<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM stack backtrace的实现</title>
    <url>/2020/03/17/arm-stack-backtrace/</url>
    <content><![CDATA[<p>介绍 arm 体系下如何实现 stack backtrace</p>
<a id="more"></a>

<h2 id="APCS"><a href="#APCS" class="headerlink" title="APCS"></a>APCS</h2><p>APCS (ARM Procedure Call Standard)，ARM 过程调用标准规范了 arm 寄存器的使用、过程调用时出栈和入栈的约定。如下图示意：</p>
<p><img src="/images/linux/apcs_t.png" alt=""></p>
<p>函数的栈帧由 <code>fp</code> 和 <code>sp</code> 标记边界。如果编译器遵循APCS，形成结构化的函数调用栈，就可以解析当前栈(callee)结构，从而得到调用栈(caller)的结构，这样就输出了整个回溯栈。</p>
<p>编译器选项 <code>-g</code> 生成栈帧信息 <code>.debug_frame</code></p>
<pre><code class="shell">$ readelf -S output/out.elf
There are 18 section headers, starting at offset 0x1bb0fd0:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        90000000 001000 6c132c 04  AX  0   0 1024
  [ 2] .devtab           PROGBITS        906c132c 6c232c 000c8c 00  WA  0   0  8
  [ 3] .bss              NOBITS          906c1fb8 6c2fb8 16a568 00  WA  0   0  8
  [ 4] .debug_abbrev     PROGBITS        00000000 6c2fb8 0b82a7 00      0   0  1
  [ 5] .debug_info       PROGBITS        00000000 77b25f a37035 00      0   0  1
  [ 6] .debug_line       PROGBITS        00000000 11b2294 3bb5fc 00      0   0  1
  [ 7] .debug_pubnames   PROGBITS        00000000 156d890 04911e 00      0   0  1
  [ 8] .debug_pubtypes   PROGBITS        00000000 15b69ae 166807 00      0   0  1
  [ 9] .debug_aranges    PROGBITS        00000000 171d1b5 018900 00      0   0  1
  [10] .debug_str        PROGBITS        00000000 1735ab5 0c4732 01  MS  0   0  1
  [11] .comment          PROGBITS        00000000 17fa1e7 0000cf 01  MS  0   0  1
  [12] .debug_frame      PROGBITS        00000000 17fa2b8 08c8b0 00      0   0  4
  [13] .debug_ranges     PROGBITS        00000000 1886b68 056380 00      0   0  1
  [14] .debug_loc        PROGBITS        00000000 18dcee8 2d402b 00      0   0  1
  [15] .shstrtab         STRTAB          00000000 1bb0f13 0000bd 00      0   0  1
  [16] .symtab           SYMTAB          00000000 1bb12a0 071130 10     17 14593  4
  [17] .strtab           STRTAB          00000000 1c223d0 086411 00      0   0  1</code></pre>
<p>内核编译选项</p>
<pre><code class="makefile">ifeq ($(CONFIG_FRAME_POINTER),y)
KBUILD_CFLAGS   +=-fno-omit-frame-pointer -mapcs -mno-sched-prolog
endif</code></pre>
<h2 id="unwind"><a href="#unwind" class="headerlink" title="unwind"></a>unwind</h2><p>APCS的缺陷是，维护栈框的指令过多，栈消耗大，占用的寄存器也过多，比如每次调用都必须将 <code>r11,r12,lr,pc</code> 入栈。使用unwind就能避免这些问题，生产指令的效率要有用的多。它的原理是记录每个函数的入栈指令(一般比APCS的入栈要少的多)到特殊的段 <code>.ARM.unwind_idx</code> <code>.ARM.unwind_tab</code>。</p>
<pre><code class="shell">$ readelf -S vmlinux
There are 33 section headers, starting at offset 0xa33ba8:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .head.text        PROGBITS        c0008000 008000 00026c 00  AX  0   0  4
  [ 2] .text             PROGBITS        c0100000 010000 55e3dc 00  AX  0   0 64
  [ 3] .fixup            PROGBITS        c065e3dc 56e3dc 00001c 00  AX  0   0  4
  [ 4] .rodata           PROGBITS        c0700000 570000 105fc8 00  WA  0   0 4096
  [ 5] __bug_table       PROGBITS        c0805fc8 675fc8 0057a8 00   A  0   0  4
  [ 6] __ksymtab         PROGBITS        c080b770 67b770 006e28 00   A  0   0  4
  [ 7] __ksymtab_gpl     PROGBITS        c0812598 682598 005d10 00   A  0   0  4
  [ 8] __ksymtab_strings PROGBITS        c08182a8 6882a8 01e235 00   A  0   0  1
  [ 9] __param           PROGBITS        c08364e0 6a64e0 000d34 00   A  0   0  4
  [10] __modver          PROGBITS        c0837214 6a7214 000dec 00   A  0   0  4
  [11] __ex_table        PROGBITS        c0838000 6a8000 001038 00   A  0   0  8
  [12] .ARM.unwind_idx   ARM_EXIDX       c0839038 6a9038 0273d8 00  AL 17   0  4
  [13] .ARM.unwind_tab   PROGBITS        c0860410 6d0410 003630 00   A  0   0  4
  [14] .notes            NOTE            c0863a40 6d3a40 000024 00  AX  0   0  4
  [15] .vectors          PROGBITS        ffff0000 6e0000 000020 00  AX  0   0  4
  [16] .stubs            PROGBITS        ffff1000 6e1000 0002ac 00  AX  0   0 32
  [17] .init.text        PROGBITS        c09002e0 6f02e0 0440d0 00  AX  0   0 32
  [18] .exit.text        PROGBITS        c09443b0 7343b0 000ee4 00  AX  0   0  4
  [19] .init.arch.info   PROGBITS        c0945294 735294 0000d0 00   A  0   0  4
  [20] .init.tagtable    PROGBITS        c0945364 735364 000048 00   A  0   0  4
  [21] .init.smpalt      PROGBITS        c09453ac 7353ac 00bd10 00   A  0   0  4
  [22] .init.pv_table    PROGBITS        c09510bc 7410bc 00064c 00   A  0   0  1
  [23] .init.data        PROGBITS        c0952000 742000 00a194 00  WA  0   0 4096
  [24] .data..percpu     PROGBITS        c095d000 74d000 0067cc 00  WA  0   0 64
  [25] .data             PROGBITS        c0a00000 760000 0609ac 00  WA  0   0 64
  [26] .data..page_align PROGBITS        c0a61000 7c1000 001000 00  WA  0   0 4096
  [27] .bss              NOBITS          c0a62000 7c2000 03260c 00  WA  0   0 64
  [28] .comment          PROGBITS        00000000 7c2000 00004e 01  MS  0   0  1
  [29] .ARM.attributes   ARM_ATTRIBUTES  00000000 7c204e 00002f 00      0   0  1
  [30] .symtab           SYMTAB          00000000 7c2080 167560 10     31 77680  4
  [31] .strtab           STRTAB          00000000 9295e0 10a46c 00      0   0  1
  [32] .shstrtab         STRTAB          00000000 a33a4c 00015a 00      0   0  1

$ objdump -D vmlinu
c04ee72c &lt;__skb_recv_datagram&gt;:
c04ee72c:       e3110040        tst     r1, #64 ; 0x40
c04ee730:       e92d43f0        push    {r4, r5, r6, r7, r8, r9, lr}
c04ee734:       e1a09003        mov     r9, r3
c04ee738:       05903144        ldreq   r3, [r0, #324]  ; 0x144
c04ee73c:       e24dd014        sub     sp, sp, #20

$ readelf -u .ARM.unwind_idx vmlinux
0xc04ee72c &lt;__skb_recv_datagram&gt;: 0x8004adb0
  Compact model index: 0
  0x04      vsp = vsp + 20
  0xad      pop {r4, r5, r6, r7, r8, r9, r14}
  0xb0      finish</code></pre>
<p>输出了函数的地址和对应的编码。接下输出的是编码对应的出栈伪指令，这些伪指令正好是函数栈操作的逆过程，用于回溯。</p>
<p>内核编译选项</p>
<pre><code class="makefile">ifeq ($(CONFIG_ARM_UNWIND),y)
CFLAGS_ABI  +=-funwind-tables
endif</code></pre>
<h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>APCS会产生更多的代码指令，对性能有影响，使用unwind的方式会生成额外的段，但不影响性能。</p>
<p>文件 <code>arch/arm/kernel/traps.c</code></p>
<pre><code class="c">#ifdef CONFIG_ARM_UNWIND
static inline void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)
{
    unwind_backtrace(regs, tsk);
}
#else
static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)
{
    unsigned int fp, mode;
    int ok = 1;

    printk(&quot;Backtrace: &quot;);

    if (!tsk)
        tsk = current;

    if (regs) {
        fp = frame_pointer(regs);
        mode = processor_mode(regs);
    } else if (tsk != current) {
        fp = thread_saved_fp(tsk);
        mode = 0x10;
    } else {
        asm(&quot;mov %0, fp&quot; : &quot;=r&quot; (fp) : : &quot;cc&quot;);
        mode = 0x10;
    }

    if (!fp) {
        pr_cont(&quot;no frame pointer&quot;);
        ok = 0;
    } else if (verify_stack(fp)) {
        pr_cont(&quot;invalid frame pointer 0x%08x&quot;, fp);
        ok = 0;
    } else if (fp &lt; (unsigned long)end_of_stack(tsk))
        pr_cont(&quot;frame pointer underflow&quot;);
    pr_cont(&quot;\n&quot;);

    if (ok)
        c_backtrace(fp, mode);
}
#endif</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/itismine/article/details/4752489" target="_blank" rel="noopener">APCS，ARM 过程调用标准(ARM Procedure Call Standard) </a></li>
<li><a href="https://www.linuxidc.com/Linux/2013-03/81247.htm" target="_blank" rel="noopener">ARM FP寄存器及frame pointer介绍</a></li>
<li><a href="https://www.alivepea.me/prog/how-backtrace-work/" target="_blank" rel="noopener">Stack backtrace 的实现</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>C</category>
        <category>Debug</category>
        <category>BackTrace</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>backtrace</tag>
        <tag>unwind</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核符号表的生成和查找</title>
    <url>/2020/03/11/linux-kernel-all-syms/</url>
    <content><![CDATA[<p><code>printk</code> 可以根据地址打印函数名/符号名，记录内核符号表生成及使用过程</p>
<a id="more"></a>

<h2 id="System-map"><a href="#System-map" class="headerlink" title="System.map"></a>System.map</h2><p>System.map 文件是编译内核时生成的，它记录了内核中的符号列表，以及符号在内存中的虚拟地址，由脚本 <code>scripts/mksysmap</code> 生成</p>
<h2 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h2><p>内核必须打开 <code>CONFIG_KALLSYMS</code> 编译选项，和 System.map 的区别是<strong>它同时包含了内核模块的符号列表</strong>，是在内核启动后生成的，位于文件系统的 /proc 目录下，实现代码见 <code>kernel/kallsyms.c</code></p>
<h2 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h2><p><strong>System.map 和内核启动后的 /proc/kallsyms 文件中的符号表只是给我们看的，内核不会使用它们</strong>，而是在编译内核时，向 vmlinux 嵌入了一个符号表</p>
<p>内核符号表如何嵌入内核查看文件 <code>scripts/link-vmlinux.sh</code></p>
<h3 id="内核符号表结构"><a href="#内核符号表结构" class="headerlink" title="内核符号表结构"></a>内核符号表结构</h3><p>由工具 <code>scripts/kallsyms</code> 生成，工具源码在同目录，用法如下</p>
<pre><code>nm -n vmlinux | scripts/kallsyms [--all-symbols] &gt; symbols.S</code></pre><p>使用 nm 工具获得符号表之后进行整理得到汇编文件，包括 6 个全局变量</p>
<ul>
<li><code>kallsyms_addresses</code> 数组，存放所有符号的地址列表，按地址升序排列</li>
<li><code>kallsyms_num_syms</code> 符号的数量</li>
<li><code>kallsyms_names</code> 数组，存放所有符号的名称，和 <code>kallsyms_addresses</code> 一一对应</li>
<li><code>kallsyms_markers</code> 存储索引用于加速搜索</li>
<li><code>kallsyms_token_table</code> 数组，存储压缩字符串</li>
<li><code>kallsyms_token_index</code> 记录每个 token 首字符在 <code>kallsyms_token_table</code> 中的偏移</li>
</ul>
<h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><pre><code>c0008000 T _text
c0008000 T stext
c000808c t __create_page_tables</code></pre><p>计算符号 <code>c000808c t __create_page_tables</code> 偏移为 <code>0x8c</code>，从 <code>kallsyms_addresses</code> 中得到索引为 <code>2</code></p>
<pre><code>kallsyms_addresses:
     PTR _text + 0
     PTR _text + 0
     PTR _text + 0x8c

kallsyms_names:
    .byte 0x04, 0x9b, 0xef, 0x78, 0x74
    .byte 0x05, 0x54, 0x5f, 0xef, 0x78, 0x74
    .byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73

kallsyms_markers:
    PTR 0
    PTR 2917
    PTR 5993</code></pre><p>根据 <code>2 &gt;&gt; 8</code> 计算出在 <code>kallsyms_markers</code> 第一组 <code>PTR 0</code>，指出起始字符的偏移在 <code>kallsyms_names[0]</code>，同时根据 <code>2 &amp;&amp; 0xFF</code> 找到具体位置</p>
<p><code>.byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73</code> 为压缩字符，需要根据 <code>kallsyms_token_table</code> 解析</p>
<ul>
<li>0x0a 长度</li>
<li>0xff <code>t_</code></li>
<li>0xe1 <code>_c</code></li>
<li>0xf5 <code>re</code></li>
<li>0x8b <code>ate_</code></li>
<li>0xa7 <code>pa</code></li>
<li>0x18 <code>get_</code></li>
<li>0xfd <code>ta</code></li>
<li>0x62 <code>b</code></li>
<li>0xd2 <code>le</code></li>
<li>0x73 <code>s</code></li>
</ul>
<p><code>t__create_page_tables</code> 其中 <code>t</code> 为符号类型，去除之后为 <code>__create_page_tables</code></p>
<h3 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h3><p>内核文件参照 <code>kernel/kallsyms.c</code> 提供接口用于内核符号表查找</p>
<ul>
<li><code>get_symbol_pos</code> 根据地址查找索引及偏移</li>
<li><code>module_address_lookup</code> 内核模块符号查找</li>
<li><code>get_symbol_offset</code> 根据 <code>kallsyms_markers</code> 获取偏移</li>
<li><code>kallsyms_expand_symbol</code> 获取符号名</li>
<li><code>kallsyms_get_symbol_type</code> 获取符号类型</li>
</ul>
<p>例如函数 <code>kallsyms_lookup</code></p>
<pre><code class="c">if (is_ksym_addr(addr)) {
    unsigned long pos;

    pos = get_symbol_pos(addr, symbolsize, offset);
    /* Grab name */
    kallsyms_expand_symbol(get_symbol_offset(pos),
                   namebuf, KSYM_NAME_LEN);
    if (modname)
        *modname = NULL;
    return namebuf;
}

/* See if it&#39;s in a module. */
return module_address_lookup(addr, symbolsize, offset, modname,
                 namebuf);</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kallsyms</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核栈溢出检测</title>
    <url>/2020/03/09/linux-kernel-stack/</url>
    <content><![CDATA[<p>监测内核栈使用情况，分析 crash 问题</p>
<a id="more"></a>

<p><code>thread_info</code> 位于内核栈底部，一旦溢出会破坏相关信息，有时会报错，但更多的是不直接报错，而是各种奇怪的panic</p>
<p><img src="/images/linux/kstack-smash.png" alt="kernel stack"></p>
<h2 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h2><p>开启 <code>debugfs</code> 使用如下方法监控内核栈的大小和深度</p>
<pre><code># mount -t debugfs nodev /sys/kernel/debug
# echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled
# cat /sys/kernel/debug/tracing/stack_max_size
# cat /sys/kernel/debug/tracing/stack_trace</code></pre><h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><h3 id="CONFIG-DEBUG-STACK-USAGE"><a href="#CONFIG-DEBUG-STACK-USAGE" class="headerlink" title="CONFIG_DEBUG_STACK_USAGE"></a>CONFIG_DEBUG_STACK_USAGE</h3><pre><code>Symbol: DEBUG_STACK_USAGE [=y]
Type  : boolean
Prompt: Stack utilization instrumentation
  Location:
    -&gt; Kernel hacking
(1)   -&gt; Memory Debugging
  Defined at lib/Kconfig.debug:562
  Depends on: DEBUG_KERNEL [=y] &amp;&amp; !IA64</code></pre><p>用于跟踪内核栈的溢出错误，一个内核栈溢出错误的明显的现象是产生 oops 错误却没有列出系统的调用栈信息。该选项将使内核进行栈溢出检查，并使内核进行栈使用的统计</p>
<h3 id="DEBUG-STACK-OVERFLOW"><a href="#DEBUG-STACK-OVERFLOW" class="headerlink" title="DEBUG_STACK_OVERFLOW"></a>DEBUG_STACK_OVERFLOW</h3><p>内核未提供 arm 配置选项，可以参照 <a href="https://www.alivepea.me/kernel/kernel-overflow/" target="_blank" rel="noopener">patch 检测内核的堆栈溢出</a></p>
<h3 id="CONFIG-STACK-TRACER"><a href="#CONFIG-STACK-TRACER" class="headerlink" title="CONFIG_STACK_TRACER"></a>CONFIG_STACK_TRACER</h3><pre><code>Symbol: STACK_TRACER [=n]
   Type  : boolean
   Prompt: Trace max stack
     Location:
       -&gt; Kernel hacking
         -&gt; Tracers (FTRACE [=y])
     Defined at kernel/trace/Kconfig:381
     Depends on: TRACING_SUPPORT [=y] &amp;&amp; FTRACE [=y] &amp;&amp; HAVE_FUNCTION_TRACER [=y]
     Selects: FUNCTION_TRACER [=n] &amp;&amp; STACKTRACE [=y] &amp;&amp; KALLSYMS [=y]</code></pre><p>参照文档 <code>Documentation/trace/ftrace.txt</code> 使用如下</p>
<pre><code># echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled

# cat stack_max_size
2928

# cat stack_trace
       Depth    Size   Location    (18 entries)
       -----    ----   --------
 0)     2928     224   update_sd_lb_stats+0xbc/0x4ac
 1)     2704     160   find_busiest_group+0x31/0x1f1
 2)     2544     256   load_balance+0xd9/0x662
 3)     2288      80   idle_balance+0xbb/0x130
 4)     2208     128   __schedule+0x26e/0x5b9
 5)     2080      16   schedule+0x64/0x66
 6)     2064     128   schedule_timeout+0x34/0xe0
 7)     1936     112   wait_for_common+0x97/0xf1
 8)     1824      16   wait_for_completion+0x1d/0x1f
 9)     1808     128   flush_work+0xfe/0x119
10)     1680      16   tty_flush_to_ldisc+0x1e/0x20
11)     1664      48   input_available_p+0x1d/0x5c
12)     1616      48   n_tty_poll+0x6d/0x134
13)     1568      64   tty_poll+0x64/0x7f
14)     1504     880   do_select+0x31e/0x511
15)      624     400   core_sys_select+0x177/0x216
16)      224      96   sys_select+0x91/0xb9
17)      128     128   system_call_fastpath+0x16/0x1b</code></pre>]]></content>
      <categories>
        <category>Linux</category>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>stack</tag>
        <tag>debugfs</tag>
        <tag>crash</tag>
      </tags>
  </entry>
  <entry>
    <title>打印用户态段错误信息</title>
    <url>/2020/03/05/linux-user-debug/</url>
    <content><![CDATA[<p>使用 <code>user_debug</code> 打印由用户态引起的 oops 信息</p>
<a id="more"></a>

<p><a href="https://www.cnblogs.com/lifexy/p/8045191.html" target="_blank" rel="noopener">Linux应用调试-修改内核来打印用户态的oops</a></p>
<ul>
<li>Linux 4.9</li>
<li>arm arch</li>
</ul>
<h2 id="Linux-内核错误处理"><a href="#Linux-内核错误处理" class="headerlink" title="Linux 内核错误处理"></a>Linux 内核错误处理</h2><p>文件 <code>arch/arm/mm/fsr-2level.c</code></p>
<pre><code class="c">{ do_bad,       SIGSEGV, 0,     &quot;vector exception&quot;         },
{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },
{ do_bad,       SIGKILL, 0,     &quot;terminal exception&quot;           },
{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },
{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },
{ do_translation_fault, SIGSEGV, SEGV_MAPERR,   &quot;section translation fault&quot;    },
{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },
{ do_page_fault,    SIGSEGV, SEGV_MAPERR,   &quot;page translation fault&quot;       },
{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },
{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;section domain fault&quot;         },
{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },
{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;page domain fault&quot;        },
{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },
{ do_sect_fault,    SIGSEGV, SEGV_ACCERR,   &quot;section permission fault&quot;     },
{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },
{ do_page_fault,    SIGSEGV, SEGV_ACCERR,   &quot;page permission fault&quot;        },</code></pre>
<ul>
<li><code>do_translation_fault</code> 调用 <code>do_bad_area</code></li>
<li><code>do_page_fault</code> 调用 <code>__do_user_fault</code> 或 <code>__do_kernel_fault</code></li>
<li><code>do_sect_fault</code> 调用 <code>do_bad_area</code></li>
</ul>
<pre><code class="c">/*                                                                              
 * Oops.  The kernel tried to access some page that wasn&#39;t present.             
 */                                                                             
static void                                                                     
__do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,   
          struct pt_regs *regs)                                                 
{                                                                               
    /*                                                                          
     * Are we prepared to handle this kernel fault?                             
     */                                                                         
    if (fixup_exception(regs))                                                  
        return;                                                                 

    /*                                                                          
     * No handler, we&#39;ll have to terminate things with extreme prejudice.       
     */                                                                         
    bust_spinlocks(1);                                                          
    pr_alert(&quot;Unable to handle kernel %s at virtual address %08lx\n&quot;,           
         (addr &lt; PAGE_SIZE) ? &quot;NULL pointer dereference&quot; :                      
         &quot;paging request&quot;, addr);                                               

    show_pte(mm, addr);                                                         
    die(&quot;Oops&quot;, regs, fsr);                                                     
    bust_spinlocks(0);                                                          
    do_exit(SIGKILL);                                                           
}

/*
 * Something tried to access memory that isn&#39;t in our memory map..
 * User mode accesses just cause a SIGSEGV
 */
static void
__do_user_fault(struct task_struct *tsk, unsigned long addr,
        unsigned int fsr, unsigned int sig, int code,
        struct pt_regs *regs)
{
    struct siginfo si;

#ifdef CONFIG_DEBUG_USER
    if (((user_debug &amp; UDBG_SEGV) &amp;&amp; (sig == SIGSEGV)) ||
        ((user_debug &amp; UDBG_BUS)  &amp;&amp; (sig == SIGBUS))) {
        printk(KERN_DEBUG &quot;%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\n&quot;,
               tsk-&gt;comm, sig, addr, fsr);
        show_pte(tsk-&gt;mm, addr);
        show_regs(regs);
    }
#endif

    tsk-&gt;thread.address = addr;
    tsk-&gt;thread.error_code = fsr;
    tsk-&gt;thread.trap_no = 14;
    si.si_signo = sig;
    si.si_errno = 0;
    si.si_code = code;
    si.si_addr = (void __user *)addr;
    force_sig_info(sig, &amp;si, tsk);
}

void do_bad_area(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
{
    struct task_struct *tsk = current;
    struct mm_struct *mm = tsk-&gt;active_mm;

    /*
     * If we are in kernel mode at this point, we
     * have no context to handle this fault with.
     */
    if (user_mode(regs))
        __do_user_fault(tsk, addr, fsr, SIGSEGV, SEGV_MAPERR, regs);
    else
        __do_kernel_fault(mm, addr, fsr, regs);
}</code></pre>
<p>可以看出 <code>__do_kernel_fault</code> 为内核态 oops 输出，<code>__do_user_fault</code> 为用户态输出，同时需要满足</p>
<ol>
<li>定义 <code>CONFIG_DEBUG_USER</code></li>
<li>设置 <code>user_debug</code></li>
</ol>
<h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><ul>
<li><code>Kernel hacking</code> -&gt; <code>Verbose user fault messages</code></li>
<li><code>user_debug</code> 见文档 <code>kernel-parameters.txt</code>，在 cmdline 中增加 <code>user_debug=31</code><pre><code class="txt">  user_debug= [KNL,ARM]
          Format: &lt;int&gt;
          See arch/arm/Kconfig.debug help text.
              1 - undefined instruction events
              2 - system calls
              4 - invalid data aborts
              8 - SIGSEGV faults
              16 - SIGBUS faults
          Example: user_debug=31</code></pre>
<pre><code class="c">unsigned int user_debug;
static int __init user_debug_setup(char *str)
{
  get_option(&amp;str, &amp;user_debug);
  return 1;
}
__setup(&quot;user_debug=&quot;, user_debug_setup);</code></pre>
</li>
</ul>
<p>修改之后测试会输出调试信息，但不包括栈信息</p>
<h2 id="打印应用栈数据"><a href="#打印应用栈数据" class="headerlink" title="打印应用栈数据"></a>打印应用栈数据</h2><p>参考 <code>__do_kernel_fault</code> 中打印栈信息函数</p>
<pre><code class="c">if (!user_mode(regs) || in_interrupt()) {
    dump_mem(KERN_EMERG, &quot;Stack: &quot;, regs-&gt;ARM_sp,
         THREAD_SIZE + (unsigned long)task_stack_page(tsk));
    dump_backtrace(regs, tsk);
    dump_instr(KERN_EMERG, regs);
}</code></pre>
<p>通过sp寄存器里存的栈地址，每打印一个栈地址里的32位数据, 栈地址便加4</p>
<p>在 <code>__do_user_fault</code> 中修改如下</p>
<pre><code class="c">unsigned long ret;
unsigned long val;
int i = 0;
printk(&quot;Stack: \n&quot;);
while(i &lt; 1024){
    if(copy_from_user(&amp;val, (const void __user *)(regs-&gt;ARM_sp + i*4), 4)){
        break;
    }
    i++;
    printk(&quot;%08x &quot;, val);
    if(i%8 == 0)
        printk(&quot;\n&quot;);
}
printk(&quot;\n end of stack \n&quot;);</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>C</category>
        <category>Debug</category>
        <category>BackTrace</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>stack</tag>
        <tag>oops</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 编译选项 -fomit-frame-pointer</title>
    <url>/2020/02/26/gcc-options-fomit-frame-pointer/</url>
    <content><![CDATA[<p>编译选项 <code>-fomit-frame-pointer</code> 与 <code>-fno-omit-frame-pointer</code> 对汇编及调试影响</p>
<a id="more"></a>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>栈是向下生长的。所谓向下生长是指从 内存高地址 -&gt; 低地址 的路径延伸</li>
<li>有两个重要的指针用于维护栈信息<ul>
<li>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。  由于栈的地址大小是从上到下从大到小，所以ESP指在栈的最底端</li>
<li>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。指在栈的最顶端</li>
</ul>
</li>
</ul>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>手册中对 <code>-fomit-frame-pointer</code> 描述如下</p>
<blockquote>
<p>Don’t keep the frame pointer in a register for functions that don’t need one.  This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions.  It also makes debugging impossible on some machines.<br>Enabled at levels -O, -O2, -O3, -Os.</p>
</blockquote>
<p>当使用 <code>-O0</code> 时不会开启上述选项，编译器会在栈空间中保存额外信息用于调试，即 <code>frame pointer</code></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="c">int add(int a, int b)
{
    return a + b ;
}</code></pre>
<p>汇编对比如下</p>
<pre><code class="shell">$ gcc -fno-omit-frame-pointer test.c
$ csky-elf-objdump -dS a.out
00008934 &lt;add&gt;:
    8934:    2470          subi    r0, r0, 8
    8936:    9800          st    r8, (r0, 0)
    8938:    2470          subi    r0, r0, 8
    893a:    1208          mov    r8, r0
    893c:    9208          st    r2, (r8, 0)
    893e:    9318          st    r3, (r8, 4)
    8940:    8608          ld    r6, (r8, 0)
    8942:    8718          ld    r7, (r8, 4)
    8944:    1c67          addu    r7, r7, r6
    8946:    1272          mov    r2, r7
    8948:    1280          mov    r0, r8
    894a:    2070          addi    r0, r0, 8
    894c:    8640          ld    r6, (r0, 16)
    894e:    8800          ld    r8, (r0, 0)
    8950:    2070          addi    r0, r0, 8
    8952:    00cf          jmp    r15

$ gcc -fomit-frame-pointer test.c
$ objdump -dS a.out
00008934 &lt;add&gt;:
    8934:    2470          subi    r0, r0, 8
    8936:    9200          st    r2, (r0, 0)
    8938:    9310          st    r3, (r0, 4)
    893a:    8600          ld    r6, (r0, 0)
    893c:    8710          ld    r7, (r0, 4)
    893e:    1c67          addu    r7, r7, r6
    8940:    1272          mov    r2, r7
    8942:    2070          addi    r0, r0, 8
    8944:    8640          ld    r6, (r0, 16)
    8946:    00cf          jmp    r15</code></pre>
<p>可以看到在栈上多开辟一些空间用于存储 <code>frame pointer</code></p>
<p>不开启优化时更能反映出压栈及出栈的操作，在这个过程中不会有 <code>fp</code> 操作</p>
<pre><code class="disass">00008934 &lt;add&gt;:
    # 开辟栈空间 8B
    8934:    2470          subi    r0, r0, 8
    # 第一个参数 r2 入栈
    8936:    9200          st    r2, (r0, 0)
    # 第二个参数 r3 入栈
    8938:    9310          st    r3, (r0, 4)
    # 加载并执行子程序 a + b
    893a:    8600          ld    r6, (r0, 0)
    893c:    8710          ld    r7, (r0, 4)
    893e:    1c67          addu    r7, r7, r6
    # 赋值给 r2 作为函数返回值
    8940:    1272          mov    r2, r7
    # 释放栈
    8942:    2070          addi    r0, r0, 8
    8944:    8640          ld    r6, (r0, 16)
    # 返回调用函数栈
    8946:    00cf          jmp    r15</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/HedpatCzw/article/details/50380128" target="_blank" rel="noopener">关于-fno-omit-frame-pointer与-fomit-frame-pointer</a></li>
<li><a href="https://jijing.site/riscv/20190428_function_call.html" target="_blank" rel="noopener">C函数调用和汇编代码分析</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_a558c25a0101l9yd.html" target="_blank" rel="noopener">Linux下Call Stack追溯的实现机制</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>GCC</category>
        <category>BackTrace</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>bt</tag>
        <tag>stack frame</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Markdown 生成幻灯片</title>
    <url>/2020/02/17/pandoc-with-reveal-js/</url>
    <content><![CDATA[<p>将 Markdown 转换为幻灯片</p>
<ul>
<li><a href="https://github.com/adamzap/landslide" target="_blank" rel="noopener">landslide</a> Generate HTML5 slideshows from markdown, ReST, or textile</li>
<li><a href="https://github.com/marp-team/marp" target="_blank" rel="noopener">Marp</a> Marp is the ecosystem to write your presentation with plain Markdown.</li>
<li><a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a></li>
<li><a href="https://github.com/jacksingleton/hacker-slides" target="_blank" rel="noopener">hacker-slides</a> You can write markdown on the left, and preview your presentation on the right.</li>
</ul>
<p>使用 Pandoc 和 <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">Reveal.js</a> 幻灯片演示框架将 Markdown 转换为幻灯片</p>
<a id="more"></a>

<h2 id="Pandoc-amp-Reveal-js"><a href="#Pandoc-amp-Reveal-js" class="headerlink" title="Pandoc &amp; Reveal.js"></a>Pandoc &amp; Reveal.js</h2><ul>
<li><a href="https://github.com/hakimel/reveal.js/releases" target="_blank" rel="noopener">reveal.js release</a> 将文件夹放在同目录</li>
<li>支持<a href="https://help.github.com/en/github/writing-on-github" target="_blank" rel="noopener">GitHub Markdown</a>语法</li>
<li>支持如下主题<ul>
<li>black: Black background, white text, blue links (default theme)</li>
<li>white: White background, black text, blue links</li>
<li>league: Gray background, white text, blue links (default theme for reveal.js &lt; 3.0.0)</li>
<li>beige: Beige background, dark text, brown links</li>
<li>sky: Blue background, thin dark text, blue links</li>
<li>night: Black background, thick white text, orange links</li>
<li>serif: Cappuccino background, gray text, brown links</li>
<li>simple: White background, black text, blue links</li>
<li>solarized: Cream-colored background, dark green text, blue links</li>
</ul>
</li>
</ul>
<pre><code class="shell">$ pandoc slides.md -o slides.html -t revealjs -s -V theme=beige</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://juejin.im/entry/5b20c950f265da6e1c4aed8e" target="_blank" rel="noopener">4 种基于 Markdown 的幻灯片生成器</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>pandoc</tag>
        <tag>reveal.js</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub Actions 发布 Hexo Blog</title>
    <url>/2020/01/19/github-actions-ci-hexo/</url>
    <content><![CDATA[<p>之前使用 Travis CI 实现了自动生成并发布 Hexo 博客，现在切换到 GitHub Actions</p>
<a id="more"></a>

<h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><ul>
<li>源码仓库，私有</li>
<li>发布仓库，xxx.github.io</li>
</ul>
<p>有两种方式可以用于 GitHub Actions 发布 Blog</p>
<ul>
<li>ssh-key，分别提交 key 到两个仓库，参考 <a href="https://juejin.im/post/5da03d5e6fb9a04e046bc3a2" target="_blank" rel="noopener">用 GitHub Actions 自动化发布Hexo网站到 GitHub Pages</a></li>
<li>token，参考 <a href="https://www.jianshu.com/p/7940fe40885d" target="_blank" rel="noopener">Hexo 使用 Github Actions 自动更新</a></li>
</ul>
<h2 id="source仓库"><a href="#source仓库" class="headerlink" title="source仓库"></a>source仓库</h2><p>打开仓库设置，在 <code>Secrets</code> 选项中，点击 <code>Add a new secret</code>，新建 <code>GH_TOKEN</code></p>
<p>添加 <code>Github Actions</code> 文件</p>
<pre><code class="yaml">name: Hexo Auto-Deploy
on: [push]

jobs:
  build:
    name: Hexo Auto-Deploy by GitHub Actions
    runs-on: ubuntu-latest

    steps:
    - name: 1. git checkout...
      uses: actions/checkout@v1

    - name: 2. setup nodejs...
      uses: actions/setup-node@v1

    - name: 3. install hexo...
      run: |
        npm install hexo-cli -g
        npm install

    - name: 4. hexo generate public files...
      run: |
        hexo clean
        hexo g  

    - name: 5. deploy &#39;public files&#39; to &#39;xxx.github.io&#39; repo...
      env:
        GH_REF: https://shenbo:${{ secrets.GH_TOKEN }}@github.com/shenbo/shenbo.github.io.git
      run: |
        git config --global user.name &quot;shenbo&quot;
        git config --global user.email &quot;shenbo@hotmail.com&quot;

        git clone ${GH_REF} hexo-public
        cp -rf public/* hexo-public/        
        cd hexo-public
        git add .
        git commit -am &quot;Deployed by GitHub Actions ...&quot;
        git push origin master</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
        <category>CI</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>ci</tag>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>32/64系统支撑库导致 Bear 编译失败</title>
    <url>/2020/01/10/bear-cmake-error/</url>
    <content><![CDATA[<p>使用 Bear 生成 <code>compile_commands.json</code> 时需要编译 32位库，记录错误及解决过程</p>
<a id="more"></a>

<h2 id="Bear"><a href="#Bear" class="headerlink" title="Bear"></a>Bear</h2><p>编译命令及错误</p>
<pre><code class="shell">$ cmake .. -DCMAKE_C_COMPILER_ARG1=&quot;-m32&quot;; VERBOSE=1 make all
    Linking C executable cmTC_8b292
    /usr/local/bin/cmake -E cmake_link_script CMakeFiles/cmTC_8b292.dir/link.txt --verbose=1
    /usr/bin/cc -m32      -rdynamic CMakeFiles/cmTC_8b292.dir/testCCompiler.c.o  -o cmTC_8b292
    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc
    /usr/bin/ld: 找不到 -lgcc
    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc
    /usr/bin/ld: 找不到 -lgcc</code></pre>
<p>可以看到原因是找不到 <code>libgcc.a</code></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>系统为 <code>ubuntu18.04</code>，可以找到 <code>/usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a</code>，需要安装32位支持库</p>
<pre><code class="shell">$ sudo apt-cache search libgcc
libgcc1 - GCC 支持库
lib32gcc-7-dev - GCC support library (32 bit development files)

$ sudo apt install lib32gcc-7-dev
$ fd libgcc.a
gcc/x86_64-linux-gnu/7/32/libgcc.a
gcc/x86_64-linux-gnu/7/libgcc.a</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>cmake</tag>
        <tag>make</tag>
        <tag>bear</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式 BRE ERE PCRE 区别</title>
    <url>/2019/12/27/regular-expression/</url>
    <content><![CDATA[<p>了解正则表达式标准，各个之间存在一些差异</p>
<ul>
<li>BRE (Basic Regular Expressions)</li>
<li>ERE (Extended Regular Expressions)</li>
<li>PCRE (Perl Compatible Regular Expressions)</li>
</ul>
<a id="more"></a>

<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><table class="table table-bordered table-striped">
  <thead>
    <tr><th>What</th><th>Syntax</th><th>Comments/gotchas</th></tr>
  </thead>
  <tbody id="programs-languages" class="subgroup">
    <tr><th colspan="3">Programming languages</th></tr>
    <tr><td><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a></td><td>PCRE</td><td>PCRE is actually a separate implementation from Perl's, with <a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions#Differences_from_Perl" target="_blank" rel="noopener">slight differences</a></td></tr>
    <tr><td><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code> standard lib</a></td><td>Python's own syntax (Perl-inspired)</td><td></td></tr>
    <tr><td><a href="http://ruby-doc.org/core-2.2.0/Regexp.html" target="_blank" rel="noopener">Ruby</a></td><td>Ruby's own syntax (Perl-inspired)</td><td></td></tr>
    <tr><td><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">Java's java.util.regex</a></td><td>Almost PCRE</td><td></td></tr>
    <tr><td><a href="http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="noopener">Boost.Regex</a></td><td>PCRE</td><td></td></tr>
  </tbody>
  <tbody id="programs-editors" class="subgroup">
    <tr><th colspan="3">Text editors</th></tr>
    <tr><td><a href="http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html" target="_blank" rel="noopener">Eclipse</a></td><td>PCRE</td><td></td></tr>
    <tr><td>Emacs</td><td>?</td><td></td></tr>
    <tr><td>Netbeans</td><td>PCRE</td><td></td></tr>
    <tr><td>Notepad++</td><td>PCRE (Boost.Regex)</td><td></td></tr>
    <tr><td>PyCharm</td><td>PCRE</td><td>Perl-inspired</td></tr>
    <tr><td>Sublime Text</td><td>?</td><td></td></tr>
    <tr><td>UltraEdit</td><td>PCRE</td><td></td></tr>
    <tr><td>ViM</td><td>ViM</td><td></td></tr>
  </tbody>
  <tbody id="programs-cmdline" class="subgroup">
    <tr><th colspan="3">Command-line tools</th></tr>
    <tr><td>awk</td><td>ERE</td><td>might depend on the implementation</td></tr>
    <tr><td>grep</td><td>BRE, <code>egrep</code> for ERE, <code>grep -P</code> for PCRE (optional)</td><td></td></tr>
    <tr><td>less</td><td>ERE</td><td>usually; man page says "regular expression library supplied by your system"</td></tr>
    <tr><td>screen</td><td>plain text</td><td></td></tr>
    <tr><td>sed</td><td>BRE, <code>-E</code> switches to ERE</td><td></td></tr>
  </tbody>
</table>

<h2 id="语法差异"><a href="#语法差异" class="headerlink" title="语法差异"></a>语法差异</h2><table class="table table-bordered table-striped">
  <thead>
    <tr><th>What</th><th><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a>/PCRE</th><th><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code></a></th><th>POSIX (BRE)</th><th>POSIX extended (ERE)</th><th>ViM</th></tr>
  </thead>
  <tbody id="syntax-basics" class="subgroup">
    <tr><th colspan="6">Basics</th></tr>
    <tr><td>Custom character class</td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td></tr>
    <tr><td>Negated custom character class</td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td></tr>
    <tr><td>\ special in class?</td><td>yes</td><td>yes</td><td>no, <code>]</code> escaped if comes first</td><td>no, <code>]</code> escaped if comes first</td><td>yes</td></tr>
    <tr><td>Ranges</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td><code>[a-z]</code>, <code>-</code> escaped if first or last</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td></td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td></tr>
    <tr><td>Alternation</td><td><code>|</code></td><td><code>|</code></td><td><code>\|</code></td><td><code>|</code></td><td><code>\|</code> <code>\&amp;</code> (low precedence)</td></tr>
    <tr><td>Escaped character</td><td><code>\033</code> <code>\x1B</code> <code>\x{1234}</code> <code>\N{name}</code> <code>\N{U+263D}</code></td><td><code>\x12</code></td><td class="na"></td><td class="na"></td><td><code>\%d123</code> <code>\%x2A</code> <code>\%u1234</code> <code>\%U1234ABCD</code></td></tr>
  </tbody>
  <tbody id="syntax-characters" class="subgroup">
    <tr><th colspan="6">Character classes</th></tr>
    <tr><td>Any character (except newline)</td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td></tr>
    <tr><td>Any character (including newline)</td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\_.</code></td></tr>
    <tr><td>Match a "word" character (alphanumeric plus <code>_</code>)</td><td><code>\w</code> <code>[[:word:]]</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td></tr>
    <tr><td>Case</td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td class="na"></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>\u</code> <code>[[:upper:]]</code> / <code>\l</code> <code>[[:lower:]]</code></td></tr>
    <tr><td>Match a non-"word" character</td><td><code>\W</code></td><td><code>\W</code></td><td class="na"></td><td class="na"></td><td><code>\W</code></td></tr>
    <tr><td>Match a whitespace character (except newline)</td><td class="na"></td><td class="na"></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td></tr>
    <tr><td>Whitespace including newline</td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code></td><td class="na"></td><td class="na"></td><td><code>\_s</code></td></tr>
    <tr><td>Match a non-whitespace character</td><td><code>\S</code></td><td><code>\S</code></td><td><code>[^[:space:]]</code></td><td><code>[^[:space:]]</code></td><td><code>\S</code> <code>[^[:space:]]</code></td></tr>
    <tr><td>Match a digit character</td><td><code>\d</code> <code>[[:digit:]]</code></td><td><code>\d</code></td><td><code>[[:digit:]]</code></td><td><code>[[:digit:]]</code></td><td><code>\d</code> <code>[[:digit:]]</code></td></tr>
    <tr><td>Match a non-digit character</td><td><code>\D</code></td><td><code>\D</code></td><td><code>[^[:digit:]]</code></td><td><code>[^[:digit:]]</code></td><td><code>\D</code> <code>[^[:digit:]]</code></td></tr>
    <tr><td>Any hexadecimal digit</td><td><code>[[:xdigit:]]</code></td><td class="na"></td><td><code>[[:xdigit:]]</code></td><td><code>[[:xdigit:]]</code></td><td><code>\x</code> <code>[[:xdigit:]]</code></td></tr>
    <tr><td>Any octal digit</td><td></td><td class="na"></td><td></td><td></td><td><code>\o</code></td></tr>
    <tr><td>Any graphical character excluding "word" characters</td><td><code>[[:punct:]]</code></td><td class="na"></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td></tr>
    <tr><td>Any alphabetical character</td><td><code>[[:alpha:]]</code></td><td class="na"></td><td><code>[[:alpha:]]</code></td><td><code>[[:alpha:]]</code></td><td><code>\a</code> <code>[[:alpha:]]</code></td></tr>
    <tr><td>Non-alphabetical character</td><td></td><td class="na"></td><td><code>[^[:alpha:]]</code></td><td><code>[^[:alpha:]]</code></td><td><code>\A</code> <code>[^[:alpha:]]</code></td></tr>
    <tr><td>Any alphanumerical character</td><td><code>[[:alnum:]]</code></td><td class="na"></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td></tr>
    <tr><td>ASCII</td><td><code>[[:ascii:]]</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>
    <tr><td>Character equivalents (e = é = è) (as per locale)</td><td></td><td class="na"></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td></tr>
  </tbody>
  <tbody id="syntax-assert" class="subgroup">
    <tr><th colspan="6">Zero-width assertions</th></tr>
    <tr><td>Word boundary</td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\&lt;</code> / <code>\&gt;</code></td></tr>
    <tr><td>Anywhere but word boundary</td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td class="na"></td></tr>
    <tr><td>Beginning of line/string</td><td><code>^</code> / <code>\A</code></td><td><code>^</code> / <code>\A</code></td><td><code>^</code></td><td><code>^</code></td><td><code>^</code> (beginning of pattern ) <code>\_^</code></td></tr>
    <tr><td>End of line/string</td><td><code>$</code> / <code>\Z</code></td><td><code>$</code> / <code>\Z</code></td><td><code>$</code></td><td><code>$</code></td><td><code>$</code> (end of pattern) <code>\_$</code></td></tr>
  </tbody>
  <tbody id="syntax-groups" class="subgroup">
    <tr><th colspan="6">Captures and groups</th></tr>
    <tr><td>Capturing group</td><td><code>(...)</code> <code>(?&lt;name&gt;...)</code></td><td><code>(...)</code> <code>(?P&lt;name&gt;...)</code></td><td><code>\(...\)</code></td><td><code>(...)</code></td><td><code>\(...\)</code></td></tr>
    <tr><td>Non-capturing group</td><td><code>(?:...)</code></td><td><code>(?:...)</code></td><td class="na"></td><td class="na"></td><td><code>\%(...\)</code></td></tr>
    <tr><td>Backreference to a specific group.</td><td><code>\1</code> <code>\g1</code> <code>\g{-1}</code></td><td><code>\1</code></td><td><code>\1</code></td><td><code>\1</code> non-official</td><td><code>\1</code></td></tr>
    <tr><td>Named backreference</td><td><code>\g{name}</code> <code>\k&lt;name&gt;</code></td><td><code>(?P=name)</code></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>
  </tbody>
  <tbody id="syntax-lookaround" class="subgroup">
    <tr><th colspan="6">Look-around</th></tr>
    <tr><td>Positive look-ahead</td><td><code>(?=...)</code></td><td><code>(?=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@=</code></td></tr>
    <tr><td>Negative look-ahead</td><td><code>(?!...)</code></td><td><code>(?!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@!</code></td></tr>
    <tr><td>Positive look-behind</td><td><code>(?&lt;=...)</code></td><td><code>(?&lt;=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;=</code></td></tr>
    <tr><td>Negative look-behind</td><td><code>(?&lt;!...)</code></td><td><code>(?&lt;!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;!</code></td></tr>
  </tbody>
  <tbody id="syntax-multiplicity" class="subgroup">
    <tr><th colspan="6">Multiplicity</th></tr>
    <tr><td>0 or 1</td><td><code>?</code></td><td><code>?</code></td><td><code>\?</code></td><td><code>?</code></td><td><code>\?</code></td></tr>
    <tr><td>0 or more</td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td></tr>
    <tr><td>1 or more</td><td><code>+</code></td><td><code>+</code></td><td><code>\+</code></td><td><code>+</code></td><td><code>\+</code></td></tr>
    <tr><td>Specific number</td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n\}</code> <code>\{n,m\}</code> <code>\{n,\}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n}</code> <code>\{n,m}</code> <code>\{n,}</code></td></tr>
    <tr><td>0 or 1, non-greedy</td><td><code>??</code></td><td><code>??</code></td><td class="na"></td><td class="na"></td><td></td></tr>
    <tr><td>0 or more, non-greedy</td><td><code>*?</code></td><td><code>*?</code></td><td class="na"></td><td class="na"></td><td><code>\{-}</code></td></tr>
    <tr><td>1 or more, non-greedy</td><td><code>+?</code></td><td><code>+?</code></td><td class="na"></td><td class="na"></td><td></td></tr>
    <tr><td>Specific number, non-greedy</td><td><code>{n,m}?</code> <code>{n,}?</code></td><td><code>{n,m}?</code> <code>{n,}?</code></td><td class="na"></td><td class="na"></td><td><code>\{-n,m}</code> <code>\{-n,}</code></td></tr>
    <tr><td>0 or 1, don't give back on backtrack</td><td><code>?+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>
    <tr><td>0 or more, don't give back on backtrack</td><td><code>*+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>
    <tr><td>1 or more, don't give back on backtrack</td><td><code>++</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>
    <tr><td>Specific number, don't give back on backtrack</td><td><code>{n,m}+</code> <code>{n,}+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>
  </tbody>
  <tbody id="syntax-other" class="subgroup">
    <tr><th colspan="6">Other</th></tr>
    <tr><td>Independent non-backtracking pattern</td><td><code>(?&gt;...)</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&gt;</code></td></tr>
    <tr><td>Make case-sensitive/insensitive</td><td><code>(?i)</code> / <code>(?-i)</code></td><td><code>(?i)</code> / <code>(?-i)</code></td><td class="na"></td><td class="na"></td><td><code>\c</code> / <code>\C</code></td></tr>
  </tbody>
</table>

<p>BRE ERE 需要注意 <code>()</code> <code>{}</code> 的区别，另外都不支持 <code>\d\D</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://liujiacai.net/blog/2014/12/07/regexp-favors/" target="_blank" rel="noopener">正则表达式“派别”简述</a></li>
<li><a href="https://en.wikipedia.org/wiki/Regular_expression#Character_classes" target="_blank" rel="noopener">Regular expression</a></li>
<li><a href="https://blog.csdn.net/yufenghyc/article/details/51078107" target="_blank" rel="noopener">grep中使用”\d”匹配数字不成功的原因</a></li>
<li><a href="https://remram44.github.io/regex-cheatsheet/regex.html" target="_blank" rel="noopener">Regex cheatsheet</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>RE</category>
      </categories>
      <tags>
        <tag>grep</tag>
        <tag>sed</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>Doxygen 注释语法</title>
    <url>/2019/12/27/doxygen-syntax/</url>
    <content><![CDATA[<p>使用 Doxygen 来生成文档需要遵从的注释语法</p>
<a id="more"></a>

<h2 id="开源工程"><a href="#开源工程" class="headerlink" title="开源工程"></a>开源工程</h2><p>可以搜索参考用法</p>
<ul>
<li><a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></li>
<li><a href="https://github.com/LiamBindle/MQTT-C.git" target="_blank" rel="noopener">MQTT</a></li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>注释块<pre><code>/**
* comment text here
*/
int x = 0;</code></pre></li>
<li>行尾注释<pre><code>int x = 0; ///&lt; comment text here</code></pre></li>
<li>单行注释<pre><code>/// comment text here
int x = 0;</code></pre></li>
</ul>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>注释块中可以使用一些特殊的标记，比如 <code>brief</code> 标记，官方称为 <code>Special Commands</code></p>
<ul>
<li><a href="http://www.doxygen.nl/manual/commands.html" target="_blank" rel="noopener">Special Commands</a></li>
<li><a href="https://www.cnblogs.com/benhuan/p/3302114.html" target="_blank" rel="noopener">翻译</a></li>
</ul>
<p>例如</p>
<ul>
<li><code>\struct &lt;name&gt; [&lt;header-file&gt;] [&lt;header-name&gt;]</code></li>
<li><code>\typedef (typedef declaration)</code></li>
<li><code>\brief { brief description }</code></li>
</ul>
<p>标记可以有两种书写方式 <code>\param</code> 或者 <code>@param</code>，每个命令有一个或多个参数，每个参数都有明确的范围：</p>
<ul>
<li><code>&lt;&gt;</code> 参数是一个单独单词</li>
<li><code>()</code> 参数一直到命令所在的结束</li>
<li><code>[]</code> 参数是可选的</li>
<li><code>{}</code> 参数一直延伸到本段结束。一个段落的结束以一个空行来标识，或者是一个段落标记</li>
</ul>
<h2 id="常用标记"><a href="#常用标记" class="headerlink" title="常用标记"></a>常用标记</h2><ul>
<li><code>\brief { brief description }</code> 可以省略</li>
<li><code>\param &#39;[&#39;dir&#39;]&#39; &lt;parameter-name&gt; { parameter description }</code><pre><code>/**
* @param[out] dest The memory area to copy to.
* @param[in]  src  The memory area to copy from.
* @param[in]  n    The number of bytes to copy
*/
void memcpy(void *dest, const void *src, size_t n);</code></pre></li>
<li><code>\return { description of the return value }</code> 返回说明</li>
<li><code>\retval &lt;return value&gt; { description }</code> 返回值</li>
<li><code>\ref &lt;name&gt; [&quot;(text)&quot;]</code> 引用<pre><code>/**
* @return 程序执行成功与否
*     @retval 0 程序执行成功
*     @retval 1 程序执行失败
* @note 这里只是一个简单的例子
*/
int main(int argc, char* argv[])</code></pre></li>
<li><code>\note { text }</code> 标注需要特别注意的地方</li>
<li><code>\deprecated { description }</code></li>
<li><code>\warning { warning message }</code> 接口容易出错的地方</li>
<li><code>\sa { references }</code> <code>\see { references }</code></li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Example <a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></p>
<pre><code>**
* Initialize the AVCodecContext to use the given AVCodec. Prior to using this
* function the context has to be allocated with avcodec_alloc_context3().
*
* The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
* avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
* retrieving a codec.
*
* @warning This function is not thread safe!
*
* @note Always call this function before using decoding routines (such as
* @ref avcodec_receive_frame()).
*
* @code
* avcodec_register_all();
* av_dict_set(&amp;opts, &quot;b&quot;, &quot;2.5M&quot;, 0);
* codec = avcodec_find_decoder(AV_CODEC_ID_H264);
* if (!codec)
*     exit(1);
*
* context = avcodec_alloc_context3(codec);
*
* if (avcodec_open2(context, codec, opts) &lt; 0)
*     exit(1);
* @endcode
*
* @param avctx The context to initialize.
* @param codec The codec to open this context for. If a non-NULL codec has been
*              previously passed to avcodec_alloc_context3() or
*              for this context, then this parameter MUST be either NULL or
*              equal to the previously passed codec.
* @param options A dictionary filled with AVCodecContext and codec-private options.
*                On return this object will be filled with options that were not found.
*
* @return zero on success, a negative value on error
* @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
*      av_dict_set(), av_opt_find().
*/</code></pre><p>注释 <code>struct</code></p>
<pre><code>/**
 * @struct AC3HeaderInfo
 * Coded AC-3 header values up to the lfeon element, plus derived values.
 */
typedef struct AC3HeaderInfo {
    /** @name Coded elements
     * @{
     */
    uint16_t sync_word;
    uint16_t crc1;
    uint8_t sr_code;
    uint8_t bitstream_id;
    uint8_t bitstream_mode;
    uint8_t channel_mode;
    uint8_t lfe_on;
    uint8_t frame_type;
    int substreamid;                        ///&lt; substream identification
    int center_mix_level;                   ///&lt; Center mix level index
    int surround_mix_level;                 ///&lt; Surround mix level index
    uint16_t channel_map;
    int num_blocks;                         ///&lt; number of audio blocks
    int dolby_surround_mode;
    /** @} */

    /** @name Derived values
     * @{
     */
    uint8_t sr_shift;
    uint16_t sample_rate;
    uint32_t bit_rate;
    uint8_t channels;
    uint16_t frame_size;
    uint64_t channel_layout;
    /** @} */
} AC3HeaderInfo;

/**
 * @brief Example class的简易说明
 *
 * 本范例说明Example class。
 * 这是一个极为简单的范例。
 *
 */
class Example {
    private:
        int var1 ; ///&lt; 这是一个private的变数
    public:
        int var2 ; ///&lt; 这是一个public的变数成员。
        int var3 ; ///&lt; 这是另一个public的变数成员。
        void ExFunc1(void);
        int ExFunc2(int a, char b);
        char *ExFunc3(char *c) ;
};</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.guorongfei.com/2016/11/20/doxygen-usage/" target="_blank" rel="noopener">使用 Doxygen 生成文档注释</a></li>
<li><a href="http://www.doxygen.nl/manual/index.html" target="_blank" rel="noopener">Doxygen Manual</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Doxygen</category>
      </categories>
      <tags>
        <tag>doxygen</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 LSP 搭建代码补全环境</title>
    <url>/2019/12/25/vim-lsp/</url>
    <content><![CDATA[<p>Language Server Protocol (LSP) 用于架接编辑器与具体语言，实现各种功能。</p>
<a id="more"></a>

<h2 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h2><p><a href="https://zhuanlan.zhihu.com/p/37290578" target="_blank" rel="noopener">Vim 8 中 C/C++ 符号索引：LSP 篇</a></p>
<p>LSP 是一套通信协议，遵从 LSP 规范的客户端（各种编辑器/IDE）可以通过众多 LSP 服务端按协议标准进行通信，由客户端完成用户界面相关的事情，由服务端提编程语言相关的：补全，定义引用查找，诊断，帮助文档，重构等服务。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">coc.nvim</a><br><a href="https://segmentfault.com/a/1190000017785227" target="_blank" rel="noopener">Vim的新一代补全插件：coc.nvim</a></p>
<p>使用 <code>vim-plug</code> 安装</p>
<pre><code class="vim">&quot; Use release branch (Recommend)
Plug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}</code></pre>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>执行 <code>:CocConfig</code> 生成配置文件 <code>~/.vim/coc-settings.json</code></p>
<p>例如</p>
<pre><code>&quot;diagnostic.enable&quot;:
        Set to false to disable diagnostic display,  default: true</code></pre><p>在 <code>coc-settings.json</code> 中添加</p>
<pre><code class="json">&quot;diagnostic.enable&quot;: false,</code></pre>
<h2 id="安装内置插件"><a href="#安装内置插件" class="headerlink" title="安装内置插件"></a>安装内置插件</h2><p><a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions" target="_blank" rel="noopener">内置插件支持列表</a><br><a href="https://github.com/fannheyward/coc-marketplace" target="_blank" rel="noopener">coc-marketplace</a><br><a href="https://www.npmjs.com/search?q=keywords%3Acoc.nvim" target="_blank" rel="noopener">coc.nvim on npm</a></p>
<p>例如：</p>
<ul>
<li>coc-json for <code>json</code>.</li>
<li>coc-tsserver for <code>javascript</code> and <code>typescript</code>.</li>
<li>coc-html for <code>html</code>, <code>handlebars</code> and <code>razor</code>.</li>
<li>coc-css for <code>css</code>, <code>scss</code> and <code>less</code>.</li>
<li>coc-ember for ember projects.</li>
<li>coc-vetur for <code>vue</code>, use vetur.</li>
<li>coc-phpls for <code>php</code>, use intelephense-docs.</li>
<li>coc-java for <code>java</code>, use eclipse.jdt.ls.</li>
</ul>
<p>使用 <code>:CocInstall coc-xxx</code> 安装，位于 <code>/.config/coc/extensions/node_modules</code>，配置文件 <code>coc-settings.json</code></p>
<p>例如 <code>coc-python</code> 需要忽略特定错误，查看 <a href="https://github.com/neoclide/coc-python" target="_blank" rel="noopener">配置</a> 添加如下内容</p>
<pre><code class="json">&quot;python.linting.flake8Args&quot;: [&quot;--ignore=E501&quot;]</code></pre>
<h2 id="安装-LSP"><a href="#安装-LSP" class="headerlink" title="安装 LSP"></a>安装 LSP</h2><p><a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers" target="_blank" rel="noopener">Language servers</a></p>
<p>支持多种 LSP，例如：</p>
<ul>
<li>Python</li>
<li>C/C++</li>
<li>Lua</li>
</ul>
<p>选择 <a href="https://github.com/MaskRay/ccls" target="_blank" rel="noopener">ccls</a> 作为 C LSP</p>
<p>编译安装如下</p>
<pre><code class="shell">$ git clone --depth=1 --recursive https://github.com/MaskRay/ccls
$ wget -c http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz
$ tar xf clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz
$ cd ccls
$ cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=$PWD/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04
$ cmake --build Release</code></pre>
<p>在 <code>coc-settings.json</code> 中添加配置</p>
<pre><code class="json">&quot;ccls&quot;: {                                                               
      &quot;command&quot;: &quot;~/.vim/ccls/ccls/Release/ccls&quot;,              
      &quot;filetypes&quot;: [&quot;c&quot;, &quot;cpp&quot;, &quot;objc&quot;, &quot;objcpp&quot;],                        
      &quot;rootPatterns&quot;: [&quot;.ccls&quot;, &quot;compile_commands.json&quot;, &quot;.vim/&quot;, &quot;.git/&quot;, &quot;.hg/&quot;],
      &quot;initializationOptions&quot;: {                                          
          &quot;cache&quot;: {                                                      
              &quot;directory&quot;: &quot;/tmp/ccls&quot;                                    
          }                                                               
      }                                                                   
  }</code></pre>
<p><code>ccls</code> 运行依赖于 <code>compile_commands.json</code>，使用 <code>Bear</code> 生成此文件</p>
<pre><code class="shell">$ Bear make</code></pre>
<h2 id="vimrc-配置"><a href="#vimrc-配置" class="headerlink" title=".vimrc 配置"></a>.vimrc 配置</h2><p><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">Example vim configuration</a><br><a href="https://github.com/MaskRay/ccls/wiki/coc.nvim" target="_blank" rel="noopener">ccls coc.nvim配置</a></p>
<pre><code class="vim">nmap &lt;silent&gt; &lt;M-j&gt; &lt;Plug&gt;(coc-definition)
nmap &lt;silent&gt; &lt;C-,&gt; &lt;Plug&gt;(coc-references)
nn &lt;silent&gt; K :call CocActionAsync(&#39;doHover&#39;)&lt;cr&gt;

&quot; bases
nn &lt;silent&gt; xb :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;)&lt;cr&gt;
&quot; bases of up to 3 levels
nn &lt;silent&gt; xB :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;levels&#39;:3})&lt;cr&gt;
&quot; derived
nn &lt;silent&gt; xd :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;derived&#39;:v:true})&lt;cr&gt;
&quot; derived of up to 3 levels
nn &lt;silent&gt; xD :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;derived&#39;:v:true,&#39;levels&#39;:3})&lt;cr&gt;

&quot; caller
nn &lt;silent&gt; xc :call CocLocations(&#39;ccls&#39;,&#39;$ccls/call&#39;)&lt;cr&gt;
&quot; callee
nn &lt;silent&gt; xC :call CocLocations(&#39;ccls&#39;,&#39;$ccls/call&#39;,{&#39;callee&#39;:v:true})&lt;cr&gt;

&quot; $ccls/member
&quot; member variables / variables in a namespace
nn &lt;silent&gt; xm :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;)&lt;cr&gt;
&quot; member functions / functions in a namespace
nn &lt;silent&gt; xf :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;,{&#39;kind&#39;:3})&lt;cr&gt;
&quot; nested classes / types in a namespace
nn &lt;silent&gt; xs :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;,{&#39;kind&#39;:2})&lt;cr&gt;

nmap &lt;silent&gt; xt &lt;Plug&gt;(coc-type-definition)&lt;cr&gt;
nn &lt;silent&gt; xv :call CocLocations(&#39;ccls&#39;,&#39;$ccls/vars&#39;)&lt;cr&gt;
nn &lt;silent&gt; xV :call CocLocations(&#39;ccls&#39;,&#39;$ccls/vars&#39;,{&#39;kind&#39;:1})&lt;cr&gt;</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>lsp</tag>
        <tag>completion</tag>
      </tags>
  </entry>
  <entry>
    <title>指定运行时动态库位置</title>
    <url>/2019/12/19/gcc-run-path/</url>
    <content><![CDATA[<p>指定运行时动态库路径</p>
<ul>
<li>gcc参数指定 <code>-Wl,-rpath=${LD_PATH}</code></li>
<li>设置环境变量 <code>export LD_LIBRARY_PATH=${LD_PATH}</code></li>
<li>配置文件 <code>/etc/ld.so.conf</code></li>
</ul>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>编译 <code>mosquitto</code> 得到几个可执行文件，运行时出现错误</p>
<pre><code class="shell">$ ./mosquitto_sub --help
./mosquitto_sub: error while loading shared libraries: libmosquitto.so.1: cannot open shared object file: No such file or directory
$ ldd mosquitto_sub
    linux-vdso.so.1 (0x00007fffe178b000)
    libmosquitto.so.1 =&gt; not found
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc8c9ca5000)
    /lib64/ld-linux-x86-64.so.2 (0x00007fc8ca2a3000)</code></pre>
<p>找不到 <code>libmosquitto.so.1</code>， 需要指定路径</p>
<h2 id="GCC参数"><a href="#GCC参数" class="headerlink" title="GCC参数"></a>GCC参数</h2><pre><code class="shell">-Wl,-rpath=${LD_PATH}</code></pre>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre><code class="shell">$ export LD_LIBRARY_PATH=../lib
$ ldd mosquitto_sub
    linux-vdso.so.1 (0x00007ffd3410b000)
    libmosquitto.so.1 =&gt; ../lib/libmosquitto.so.1 (0x00007f4ecc2d5000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4ecbee4000)
    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f4ecbcdc000)
    libssl.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007f4ecba74000)
    libcrypto.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007f4ecb631000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f4ecb412000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f4ecc6fb000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4ecb20e000)</code></pre>
<p>只在当前 shell 有效</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>修改 <code>/etc/ld.so.conf</code> 文件以添加私有路径</p>
]]></content>
      <categories>
        <category>C</category>
        <category>Linker</category>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>shared</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 静态模板使用</title>
    <url>/2019/12/18/makefile-static-pattern-rule/</url>
    <content><![CDATA[<p>Makefile 静态模板的使用</p>
<pre><code class="makefile">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;
    &lt;commands&gt;</code></pre>
<a id="more"></a>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code class="shell">$ tree -L 2
.
├── dirA
│   ├── dirA_1.c
│   ├── dirA_2.c
│   └── include
├── makefile
├── output
│   └── objects
└── dirB
    ├── include
    └── dirB.c</code></pre>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><pre><code class="makefile">SRC = $(shell find . -iname &quot;*.c&quot;)
SRC = $(wildcard dirA/*.c) \
      $(wildcard dirB/*.c)</code></pre>
<p>Makefile 规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数 <code>wildcard</code></p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><pre><code class="makefile">OBJ = $(SRC:.c=.o)
OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))</code></pre>
<ul>
<li><code>OBJ = $(SRC:.c=.o)</code> 这个表示 <code>.obj</code> 与 <code>.c</code> 位于同一个目录下</li>
<li><code>OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))</code> <code>.obj</code> 统一放到 <code>$(objects_dir)</code> 目录下</li>
</ul>
<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><pre><code class="makefile">SUBDIR = dirA
SUBDIR += dirB

CFLAGS += $(patsubst %, -I%, $(SUBDIR))</code></pre>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="静态模板"><a href="#静态模板" class="headerlink" title="静态模板"></a>静态模板</h3><pre><code class="makefile">SRC = $(wildcard dirA/*.c) \
      $(wildcard dirB/*.c)
OBJ = $(SRC:.c=.o)

$(TARGET): $(OBJ)
    @echo &quot;Generating new lib\033[1;31m: $@\033[0m&quot;
    @$(AR) -rcs $@ $^

$(OBJ): %.o: %.c
    @echo &quot;compiling \033[032m[$(CC)]\033[0m&quot;: $&lt;
    @$(CC) -c $(CFLAGS) $&lt; -o $@</code></pre>
<h3 id="obj-文件制定路径"><a href="#obj-文件制定路径" class="headerlink" title="obj 文件制定路径"></a>obj 文件制定路径</h3><pre><code class="makefile">SRC = $(wildcard dirA/*.c) \
      $(wildcard dirB/*.c)
OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))

$(TARGET): $(OBJ)
    @echo &quot;Generating new lib\033[1;31m: $@\033[0m&quot;
    @$(AR) -rcs $@ $^

$(objects_dir)/%.o: %.c dirmake
    @echo &quot;compiling \033[032m[$(CC)]\033[0m&quot;: $&lt;
    @$(CC) -c $(CFLAGS) $&lt; -o $@</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://seisman.github.io/how-to-write-makefile/rules.html#id8" target="_blank" rel="noopener">静态模式</a></li>
<li><a href="https://seisman.github.io/how-to-write-makefile/rules.html#id3" target="_blank" rel="noopener">规则的语法</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>Tools</category>
        <category>Make</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Linker 及 ld 脚本分析</title>
    <url>/2019/12/11/linker-and-lds-file/</url>
    <content><![CDATA[<p>链接器工作过程及链接脚本文件 <code>.lds</code> 分析</p>
<a id="more"></a>

<h2 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h2><p>链接器将多目标文件生成最终可执行文件，示意图如下</p>
<p><img src="/images/gnu/linker.png" alt="Linker Role"></p>
<p>在链接过程中执行如下操作</p>
<ol>
<li>Symbol Resolution - 符号解析<ul>
<li>多文件声明与调用</li>
<li>调用替换为具体函数入口</li>
</ul>
</li>
<li>Relocation - 重定位<ul>
<li>相同段合并，例如 <code>.text</code></li>
<li>Section Placement, 各段在内存中的位置</li>
</ul>
</li>
</ol>
<p>详细解释见 <a href="https://www.bravegnu.org/gnu-eprog/linker.html" target="_blank" rel="noopener">Linker</a></p>
<h2 id="Linker-Script-File"><a href="#Linker-Script-File" class="headerlink" title="Linker Script File"></a>Linker Script File</h2><p>控制链接器行为的脚本文件，一般后缀为 <code>.lds</code>。如果不指定，存在默认脚本，使用 <code>ld --verbose</code> 查看</p>
<p><a href="https://www.bravegnu.org/gnu-eprog/lds.html" target="_blank" rel="noopener">Linker Script File</a></p>
<pre><code class="lds">SECTIONS { ❶
        . = 0x00000000; ❷
        .text : { ❸
                abc.o (.text);
                def.o (.text);
        }
}</code></pre>
<ol>
<li><code>SECTIONS</code> 脚本各段组成及位置</li>
<li><code>.</code> 定位器符号</li>
<li><code>.text</code> 由 <code>abc.o</code> 和 <code>def.o</code> 中的 <code>.text</code> 组成</li>
</ol>
<h2 id="LMA-vs-VMA"><a href="#LMA-vs-VMA" class="headerlink" title="LMA vs VMA"></a>LMA vs VMA</h2><ul>
<li><code>LMA</code> (load memory address 加载内存地址或进程地址空间地址）</li>
<li><code>VMA</code> (virtual memory address 虚拟内存地址或程序地址空间地址）</li>
</ul>
<blockquote>
<p>VMA 是执行输出文件时 section 所在的地址，而 LMA 是加载输出文件时 section 所在的地址。一般而言，某 section 的 VMA == LMA. 但在嵌入式系统中，经常存在加载地址和执行地址不同的情况：比如将输出文件加载到开发板的 flash 中（由 LMA 指定）, 而在运行时将位于 flash 中的输出文件复制到 SDRAM 中（由 VMA 指定）。</p>
</blockquote>
<h2 id="SECTIONS-命令"><a href="#SECTIONS-命令" class="headerlink" title="SECTIONS 命令"></a>SECTIONS 命令</h2><p><code>SECTIONS</code> 命令告诉 ld 如何把输入文件的 sections 映射到输出文件的各个 section: 如何将输入 section 合为输出 section; 如何把输出 section 放入 VMA 和 LMA</p>
<pre><code>SECTIONS
{
    SECTIONS-COMMAND
    SECTIONS-COMMAND
    ...
}</code></pre><p>SECTION-COMMAND 有四种：</p>
<ol>
<li>ENTRY 命令</li>
<li>符号赋值语句</li>
<li>一个输出 section 的描述 (output section description)</li>
<li>一个 section 叠加描述 (overlay description)</li>
</ol>
<h3 id="ENTRY-命令"><a href="#ENTRY-命令" class="headerlink" title="ENTRY 命令"></a>ENTRY 命令</h3><p>将符号 <code>SYMBOL</code> 的值设置成入口地址</p>
<pre><code>ENTRY(SYMBOL)</code></pre><h3 id="符号赋值"><a href="#符号赋值" class="headerlink" title="符号赋值"></a>符号赋值</h3><ul>
<li>对符号的赋值只对全局变量起作用</li>
<li>赋值语句包含 4 个语法元素：符号名、操作符、表达式、分号；一个也不能少</li>
<li><code>.</code> 是一个特殊的符号，它是定位器，一个位置指针，指向程序地址空间内的某位置。该符号只能在 SECTIONS 命令内使用</li>
</ul>
<h3 id="叠加描述"><a href="#叠加描述" class="headerlink" title="叠加描述"></a>叠加描述</h3><p>覆盖图描述使两个或多个不同的 section 占用同一块程序地址空间。覆盖图管理代码负责将 section 的拷入和拷出。</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>格式如下</p>
<pre><code>SECTION-NAME [ADDRESS] [(TYPE)] : [AT(LMA)]
{
    OUTPUT-SECTION-COMMAND
    OUTPUT-SECTION-COMMAND
    …
} [&gt;REGION] [AT&gt;LMA_REGION] [:PHDR HDR ...] [=FILLEXP]</code></pre><ul>
<li><code>ALIGN</code> 地址对齐</li>
<li>文件通配符</li>
<li><code>.</code> 定位符</li>
<li><code>KEEP</code></li>
<li><code>AT</code> 修改 LMA</li>
<li><code>&gt;REGION</code> 修改 VMA</li>
</ul>
<h2 id="MEMORY-命令"><a href="#MEMORY-命令" class="headerlink" title="MEMORY 命令"></a>MEMORY 命令</h2><p>在默认情形下，连接器可以为 section 在程序地址空间内分配任意位置的存储区域。并通过输出 section 描述的 <code>&gt;REGION</code> 属性显示地将该输出 section 限定于在程序地址空间内的某块存储区域，当存储区域大小不能满足要求时，连接器会报告该错误。</p>
<pre><code>MEMORY
{
    NAME1 [(ATTR)] : ORIGIN = ORIGIN1, LENGTH = LEN2
    NAME2 [(ATTR)] : ORIGIN = ORIGIN2, LENGTH = LEN2
    ...
}</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="lds">MEMORY
{
    sram  :   ORIGIN = 0x00100000,    LENGTH = 0x8000
    ddram :   ORIGIN = 0x80000000,    LENGTH = 0x100000
}

ENTRY(ResetEntry)
SECTIONS {
    . = ALIGN(4);
    .text :
    {
        sram/*(.text*)
        sram/*(.data*)
        sram/*(.rodata*)
        *(.reset_patch)
        *(.sram_text)
        *(.sram)
    } &gt; sram

    . = ALIGN(0x8000);
    .data :
    {
        *(.text*)
        . = ALIGN(4);
        *(.data*)
        *(.rodata*)
        . = ALIGN(16);
    } &gt; ddram

    . = ALIGN(4);
    .bss :
    {
        . = ALIGN(4);
        __bss_start__ = .;
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        __bss_end__ = .;
    } &gt; ddram
}</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.cnblogs.com/li-hao/p/4107964.html" target="_blank" rel="noopener">Linux 下的 lds 链接脚本详解</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>Linker</category>
      </categories>
      <tags>
        <tag>ld</tag>
        <tag>c</tag>
        <tag>lds</tag>
        <tag>linker</tag>
      </tags>
  </entry>
  <entry>
    <title>objdump 解析目标文件各个段</title>
    <url>/2019/12/10/nm-code-segment/</url>
    <content><![CDATA[<p>目标文件 <code>.o</code> 中 <code>text</code>、 <code>bss</code>、 <code>data</code> 和 <code>rodata</code> 区别和联系</p>
<a id="more"></a>

<p>目标文件只是ELF文件的<strong>可重定位文件(Relocatable file)</strong>，常用分析ELF文件工具如下</p>
<ol>
<li>objdump</li>
<li>readelf</li>
<li>nm</li>
</ol>
<h2 id="text"><a href="#text" class="headerlink" title=".text"></a>.text</h2><p>代码段，也有可能包含一些只读的常数变量，例如字符串常量等。只读。</p>
<h2 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h2><p>没有初始化的和初始化为0的全局变量和静态变量，并不给该段的数据分配空间，只是记录数据所需空间的大小，运行时在栈上分配。</p>
<h2 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h2><p>已初始化非0全局变量和静态变量，需要分配空间用于存储数据。</p>
<h2 id="rodata"><a href="#rodata" class="headerlink" title=".rodata"></a>.rodata</h2><p><code>ro</code> 表示为只读数据段，存放C中的字符串和常量，优化后会只存储一份。常量并不一定在此段，有可能存放在代码段。</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre><code class="c">static int x1 = 0;
static int x2 = 1234;

int main()
{
    return 0;
}</code></pre>
<p>使用 <code>objdump -x -s -d a.out</code> 查找如下</p>
<pre><code>00000000006bb330 l     O .bss   0000000000000004 x1
00000000006b90f0 l     O .data  0000000000000004 x2
.
Contents of section .data:
 6b90e0 00000000 00000000 00000000 00000000  ................
 6b90f0 34120000 00000000 00080000 00000000  4...............</code></pre><p><code>x1</code> 放入 <code>.bss</code> 段；<code>x2</code> 放入 <code>.data</code> 段。</p>
<h2 id="nm-vs-objdump"><a href="#nm-vs-objdump" class="headerlink" title="nm vs objdump"></a>nm vs objdump</h2><p><code>nm</code> 与 <code>objdump</code> 标志不统一，需要注意区分</p>
<h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h3><a href="/2015/04/05/nm-symbols/" title="nm symbols 类型及程序组成">nm symbols 类型及程序组成</a>

<p>查看详细信息 <code>man nm</code></p>
<h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>查看详细信息 <code>man objdump</code></p>
<ul>
<li><code>l</code> local</li>
<li><code>g</code> global</li>
<li><code>u</code> unique global</li>
<li><code>!</code> both global and local</li>
<li><code>w</code> weak</li>
<li><code>C</code> The symbol denotes a constructor</li>
<li><code>W</code> warning</li>
<li><code>I</code> The symbol is an indirect reference to another symbol</li>
<li><code>i</code> a function to be evaluated during reloc processing</li>
<li><code>d</code> a debugging symbol</li>
<li><code>D</code> a dynamic symbol</li>
<li><code>F</code> function</li>
<li><code>f</code> file</li>
<li><code>O</code> object</li>
</ul>
<h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><pre><code class="shell">$ tree
.
├── a.out
├── one.c   // extern unsigned long start_time;
├── two.c   // unsigned long start_time = 0;
└── main.c  // start_time = _get_time();

$ nm one.o | grep start_time
00000004 C start_time
$ nm two.o | grep start_time
00000000 B start_time
$ nm main.o | grep start_time
00000004 C start_time
$ nm a.out | grep start_time
97d6c6c4 B start_time

$ objdump -x -s a.out | grep start_time
97d6c6c4 g     O .bss    00000004 start_time
 0640 0e000067 5f737461 72745f74 696d6500  ...start_time.
 1ae0 675f7374 6172745f 74696d65 00df0e00  start_time....
$ objdump -x -s one.o | grep start_time
00000004       O *COM*    00000004 start_time
00000ef5 ADDR32   start_time
0000003c ADDR32   start_time
$ objdump -x -s main.o | grep start_time
00000004       O *COM*    00000004 start_time
00000262 ADDR32   start_time
000000e4 ADDR32   start_time
$ objdump -x -s two.o | grep start_time
 32 .bss.start_time 00000004  00000000  00000000  000015c8  2**2
00000000 l    d  .bss.start_time    00000000 .bss.start_time
00000000 g     O .bss.start_time    00000004 start_time
000006d7 ADDR32   .bss.start_time</code></pre>
<p>注意变量 <code>start_time</code> 在各个文件中的标志</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.51cto.com/12810168/2321531" target="_blank" rel="noopener">程序的结构体系（十）</a></li>
<li><a href="https://www.jianshu.com/p/863b279c941e" target="_blank" rel="noopener">使用readelf和objdump解析目标文件</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>Linker</category>
      </categories>
      <tags>
        <tag>ld</tag>
        <tag>nm</tag>
        <tag>objdump</tag>
        <tag>readelf</tag>
      </tags>
  </entry>
  <entry>
    <title>抓取 JS 动态生成网页数据</title>
    <url>/2019/12/06/python-requests-dynamic-webpages/</url>
    <content><![CDATA[<p>静态网页使用 <code>bs4</code> + <code>requests</code> 进行抓取<br>动态网页数据不在 HTML 中，需要分析之后设计程序</p>
<a id="more"></a>

<blockquote>
<p>转载 <a href="https://www.jianshu.com/p/9de3be54abc1" target="_blank" rel="noopener">网络数据抓取-JS动态生成数据-Python-requests爬虫</a></p>
</blockquote>
<h2 id="理解页面"><a href="#理解页面" class="headerlink" title="理解页面"></a>理解页面</h2><p><img src="/images/spider/4324074-6bc9881ca058cf06.webp" alt="动态填充数据页面流程"></p>
<blockquote>
<p>能够动态请求数据和填充数据的代码就是 Html 网页内运行的 JavaScript 脚本代码，它们可以做各种事情，尤其善于玩弄数据。</p>
</blockquote>
<h2 id="理解数据请求Request"><a href="#理解数据请求Request" class="headerlink" title="理解数据请求Request"></a>理解数据请求Request</h2><p>使用 <code>chrome</code> 开发者工具分析 <code>Network</code></p>
<h2 id="发送数据请求"><a href="#发送数据请求" class="headerlink" title="发送数据请求"></a>发送数据请求</h2><p>复制请求地址</p>
<pre><code class="python">requests.get(url, headers=User_Agents[0], timeout=50)</code></pre>
]]></content>
      <categories>
        <category>Python</category>
        <category>Spider</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>bs4</tag>
        <tag>requests</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>提高 github 下载速度</title>
    <url>/2019/12/03/improve-github-download-speed/</url>
    <content><![CDATA[<p>修改 <code>hosts</code> 提高 github 下载速度</p>
<a id="more"></a>

<h2 id="提供速度"><a href="#提供速度" class="headerlink" title="提供速度"></a>提供速度</h2><p>在 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 使用 IP Lookup 查询下面三个域名地址</p>
<ul>
<li>140.82.113.4 github.com</li>
<li>199.232.5.194 github.global.ssl.fastly.net</li>
<li>140.82.113.10 codeload.github.com</li>
</ul>
<p>将上述信息添加到 <code>/etc/hosts</code> 中并重启网络服务</p>
<pre><code class="shell">$ sudo /etc/init.d/networking restart</code></pre>
<h2 id="减少下载量"><a href="#减少下载量" class="headerlink" title="减少下载量"></a>减少下载量</h2><pre><code class="shell">$ git clone repo_url --depth=1</code></pre>
<p>只下载最新版本，而不是带有全部历史版本的仓库</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 网桥 172.17 导致本地无法访问</title>
    <url>/2019/11/26/docker-destination-host-unreachable/</url>
    <content><![CDATA[<p>Docker 安装几个容器后导致本地无法访问，记录解决过程</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>本地网站无法访问，显示<code>Destination Host Unreachable</code>错误</p>
<pre><code class="shell">$ ping xxx.com
PING xxx.com (172.18.0.10) 56(84) bytes of data.
From (172.18.0.1) icmp_seq=1 Destination Host Unreachable
From (172.18.0.1) icmp_seq=2 Destination Host Unreachable
From (172.18.0.1) icmp_seq=3 Destination Host Unreachable

$ route
内核 IP 路由表
目标            网关            子网掩码        标志  跃点   引用  使用 接口
default         _gateway        0.0.0.0         UG    100    0        0 enp0s25
link-local      0.0.0.0         255.255.0.0     U     1000   0        0 enp0s25
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-cfc9270b15f3
172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-f5c5f0da48a2
192.168.110.0   0.0.0.0         255.255.254.0   U     100    0        0 enp0s25

$ ifconfig
br-cfc9270b15f3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255
        inet6 fe80::42:1aff:fec6:7043  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 02:42:1a:c6:70:43  txqueuelen 0  (以太网)
        RX packets 14  bytes 9546 (9.5 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 797  bytes 91465 (91.4 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:13:03:9a:6c  txqueuelen 0  (以太网)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.110.55  netmask 255.255.254.0  broadcast 192.168.111.255
        inet6 fe80::3615:4135:d778:298  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 54:ee:75:40:ea:67  txqueuelen 1000  (以太网)
        RX packets 407891  bytes 60596095 (60.5 MB)
        RX errors 0  dropped 15691  overruns 0  frame 0
        TX packets 31293  bytes 3769383 (3.7 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 20  memory 0xf1600000-f1620000  

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;
        loop  txqueuelen 1000  (本地环回)
        RX packets 33484889  bytes 2454937345 (2.4 GB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 33484889  bytes 2454937345 (2.4 GB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre>
<p>问题在于 br-cfc9270b15f3</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h3><pre><code class="shell">$ docker stop $(docker ps -aq)
$ docker rm $(docker ps -aq)</code></pre>
<h3 id="删除network"><a href="#删除network" class="headerlink" title="删除network"></a>删除network</h3><pre><code class="shell">$ docker network prune
$ ifconfig
docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:13:03:9a:6c  txqueuelen 0  (以太网)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.110.55  netmask 255.255.254.0  broadcast 192.168.111.255
        inet6 fe80::3615:4135:d778:298  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 54:ee:75:40:ea:67  txqueuelen 1000  (以太网)
        RX packets 419408  bytes 72317482 (72.3 MB)
        RX errors 0  dropped 15691  overruns 0  frame 0
        TX packets 39576  bytes 4970401 (4.9 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 20  memory 0xf1600000-f1620000  

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;
        loop  txqueuelen 1000  (本地环回)
        RX packets 34240204  bytes 2501217904 (2.5 GB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 34240204  bytes 2501217904 (2.5 GB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre>
<h3 id="修改-docker-网段"><a href="#修改-docker-网段" class="headerlink" title="修改 docker 网段"></a>修改 docker 网段</h3><pre><code class="shell">$ sudo service docker stop
$ sudo ifconfig docker0 down
$ sudo vim /etc/docker/daemon.json
$ sudo service docker restart
$ ifconfig
docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 175.168.0.1  netmask 255.255.0.0  broadcast 175.168.255.255
        ether 02:42:13:03:9a:6c  txqueuelen 0  (以太网)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre>
<p>在 <code>daemon.json</code> 添加 <code>&quot;bip&quot;: &quot;175.168.0.1/16&quot;</code></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>hosts</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git 覆盖分支</title>
    <url>/2019/11/25/git-push-force/</url>
    <content><![CDATA[<p>使用 <code>git push -f</code> 用一个分支覆盖另一个分支</p>
<a id="more"></a>

<h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><ol>
<li>同步 develop 分支<pre><code class="shell">$ git checkout develop
$ git pull</code></pre>
</li>
<li>如果是 gerrit 控制权限，需要允许 <code>git push -f</code></li>
</ol>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><pre><code class="shell">$ git push origin develop:master -f</code></pre>
<p>将本地 develop 分支推送到远程 master 分支</p>
<h2 id="II"><a href="#II" class="headerlink" title="II"></a>II</h2><pre><code class="shell">$ git checkout master
$ git reset –hard develop</code></pre>
<p>将本地 master 分支重置成 develop 分支</p>
<pre><code class="shell">$ git push origin master –force</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git push</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA 数字签名与加解密</title>
    <url>/2019/11/25/rsa-encrypt-and-signature/</url>
    <content><![CDATA[<ul>
<li>非对称加密算法 RSA 生成一对密钥：公钥和私钥。公钥和私钥都可以用来加解密，取决于应用场景</li>
<li>加密是公钥加密、私钥解密，用于保证数据安全</li>
<li>签名是私钥加密、公钥解密，用于验证身份</li>
</ul>
<a id="more"></a>

<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>将明文转换为密文，用于保护敏感数据</p>
<p><img src="/images/ssl/OpenPGPEncrypt.jpg" alt="Encrypting"></p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名有助于确保以下各项：</p>
<ol>
<li>数据完整性–消息未更改其原始形式。</li>
<li>消息身份验证（来源证明）–消息实际上来自声称的发件人。</li>
</ol>
<p><img src="/images/ssl/OpenPGPSign.jpg" alt="Signing"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/liwei16611/article/details/83686674" target="_blank" rel="noopener">加密与安全：图解非对称加密算法 RSA 数字签名与数字证书</a></li>
<li><a href="https://blog.csdn.net/sfdev/article/details/2174305" target="_blank" rel="noopener">RSA 数字签名与加密、解密间的关系</a></li>
<li><a href="http://blogs.mdaemon.com/index.php/2018/05/29/encrypting-vs-signing-with-openpgp-whats-the-difference-2/" target="_blank" rel="noopener">Encrypting vs. Signing with OpenPGP. What’s the Difference?</a></li>
</ol>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>encrypt</tag>
        <tag>rsa</tag>
        <tag>signature</tag>
        <tag>CA</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown-with-mathjax</title>
    <url>/2019/11/05/markdown-with-mathjax/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://juejin.im/post/5a6721bd518825733201c4a2" target="_blank" rel="noopener">MarkDown 插入数学公式实验大集合</a></p>
]]></content>
  </entry>
  <entry>
    <title>openssl 密钥生成与解析</title>
    <url>/2019/11/05/openssl-rsa-key/</url>
    <content><![CDATA[<p>使用 openssl 生成解析 rsa 公私钥</p>
<a id="more"></a>

<h2 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA 算法原理（一）</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA 算法原理（二）</a></p>
<p>从中可以得出如下信息：</p>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公钥 KU</td>
<td align="center">n：质数 p 和质数 q 的乘积（p 和 q 必须保密）<br>e：与 (p-1)×(q-1) 互质</td>
</tr>
<tr>
<td align="center">私钥 KR</td>
<td align="center">n：同公钥 n<br> d: \(e^{-1}(mod(p-1)(q-1))\)</td>
</tr>
<tr>
<td align="center">加密</td>
<td align="center">\(c=m^emodn\)</td>
</tr>
<tr>
<td align="center">解密</td>
<td align="center">\(m=c^dmodn\)</td>
</tr>
</tbody></table>
<p><strong>n 和 e 封装成公钥，n 和 d 封装成私钥。公钥和私钥的数据都采用 <code>ASN.1</code> 格式表达</strong></p>
<blockquote>
<p>实际应用中，e 常常选择 65537</p>
</blockquote>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>使用 openssl 来生成公钥、私钥</p>
<h3 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h3><pre><code class="shell">$ openssl genrsa -out privkey.pem 2048</code></pre>
<h3 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h3><pre><code class="shell">$ openssl rsa -in privkey.pem -pubout -out pubkey.pem</code></pre>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><pre><code class="shell">$ openssl req -new -key privkey.pem -out ca.csr</code></pre>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><a href="https://www.jianshu.com/p/78886e480bef" target="_blank" rel="noopener">openssl 密钥生成和解析</a></p>
<h3 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h3><p>openssl 的数据编码规则是基于 ans.1<br>openssl 有多种形式的密钥，openssl 提供 PEM 和 DER 两种编码方式对这些密钥进行编码，并提供相关指令可以使用户在这两种格式之间进行转换。</p>
<h4 id="DER"><a href="#DER" class="headerlink" title="DER"></a>DER</h4><p>DER 就是密钥的二进制表述格式。</p>
<h4 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h4><p>PEM 格式就是对 DER 编码转码为 base64 字符格式。通过 base64 解码可以还原 DER 格式。</p>
<h3 id="PEM-格式"><a href="#PEM-格式" class="headerlink" title="PEM 格式"></a>PEM 格式</h3><h4 id="公钥-1"><a href="#公钥-1" class="headerlink" title="公钥"></a>公钥</h4><pre><code>RSAPublicKey ::= SEQUENCE {
    modulus           INTEGER,  -- n
    publicExponent    INTEGER   -- e
}</code></pre><ul>
<li>modulus 是 RSA 的合数模 n</li>
<li>publicExponent 是 RSA 公开幂 e</li>
</ul>
<p>命令分析公钥如下</p>
<pre><code class="shell">$ cat pubkey.pem
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA04VqFIaa59Aba74p+fuL
La4I1KoZJ+40yeg3QFFagCNpqI+Krf+5qZBNuhWrBRtp0LN9IOftfDr/nC+I+04G
CXMX+4ZrPfkWRWkDZr2RC7WqC+/E2Fgx7DBSWqXx1dPog3q3j1eeO8PL/FGA2q6C
9Yy9PW5a/E/YG4ngMOGCvIc1dR2eJkqz6hBOWZB3+GnrV7VoVZZE2hNP3SXsqGZY
FXRntKhuBc1FWMIwSN9tTWC6EhR550HqZx9jogTVDvwVn5yXSNhJ/K1fg7vkQVRa
NMNuz1EX2VT00XJ1U4qd+q7p4PR1N+vDIAHUMABW8HkM0HKlYS+hl/LnZTvRCUcR
XwIDAQAB
-----END PUBLIC KEY-----
$ openssl rsa -pubin -in pubkey.pem -text -noout
RSA Public-Key: (2048 bit)
Modulus:
    00:d3:85:6a:14:86:9a:e7:d0:1b:6b:be:29:f9:fb:
    ...
Exponent: 65537 (0x10001)
$ openssl asn1parse -i -in pubkey.pem
    0:d=0  hl=4 l= 290 cons: SEQUENCE
    4:d=1  hl=2 l=  13 cons:  SEQUENCE
    6:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption
   17:d=2  hl=2 l=   0 prim:   NULL
   19:d=1  hl=4 l= 271 prim:  BIT STRING</code></pre>
<h4 id="私钥-1"><a href="#私钥-1" class="headerlink" title="私钥"></a>私钥</h4><pre><code>RSAPrivateKey ::= SEQUENCE {
  version           Version,
  modulus           INTEGER,  -- n
  publicExponent    INTEGER,  -- e
  privateExponent   INTEGER,  -- d
  prime1            INTEGER,  -- p
  prime2            INTEGER,  -- q
  exponent1         INTEGER,  -- d mod (p-1)
  exponent2         INTEGER,  -- d mod (q-1)
  coefficient       INTEGER,  -- (inverse of q) mod p
  otherPrimeInfos   OtherPrimeInfos OPTIONAL
}</code></pre><ul>
<li>modulus 是 RSA 合数模 n</li>
<li>publicExponent 是 RSA 的公开幂 e</li>
<li>privateExponent 是 RSA 的私有幂 d</li>
<li>prime1 是 n 的素数因子 p</li>
<li>prime2 是 n 的素数因子 q</li>
<li>exponent1 等于 \(d mod (p−1)\)</li>
<li>exponent2 等于 \(d mod (q−1)\)</li>
<li>coefficient 是 CRT 系数 \((q–1) mod p\)</li>
</ul>
<p>分析私钥如下</p>
<pre><code class="shell">$ cat privkey.pem
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA04VqFIaa59Aba74p+fuLLa4I1KoZJ+40yeg3QFFagCNpqI+K
...
-----END RSA PRIVATE KEY-----
$ openssl rsa -in privkey.pem -text -noout
RSA Private-Key: (2048 bit, 2 primes)
modulus:
    00:d3:85:6a:14:86:9a:e7:d0:1b:6b:be:29:f9:fb:
    ...
publicExponent: 65537 (0x10001)
privateExponent:
    3f:84:70:b6:79:35:4b:27:53:14:a7:a6:33:4b:36:
    ...
prime1:
    00:f9:d6:97:89:e0:a6:78:e4:c9:f8:70:ed:aa:6c:
    ...
prime2:
    00:d8:bc:e6:2b:25:83:48:98:d6:84:fb:90:ef:f4:
    ...
exponent1:
    00:f7:f8:64:aa:05:9e:55:49:87:a9:1d:b4:d6:bc:
    ...
exponent2:
    46:e7:85:65:18:20:9a:df:65:4e:9b:fe:0e:82:26:
    ...
coefficient:
    2c:be:89:1e:ad:1b:c7:1f:f1:72:1e:ae:6e:a8:c6:
    ...
$ openssl asn1parse -i -in privkey.pem
    0:d=0  hl=4 l=1187 cons: SEQUENCE
    4:d=1  hl=2 l=   1 prim:  INTEGER           :00
    7:d=1  hl=4 l= 257 prim:  INTEGER           :D3856A14869AE7D01B6BBE29F9FB8B2DAE08D4AA1927EE34C9E83740515A802369A88F8AADFFB9A9904DBA15AB051B69D0B37D20E7ED7C3AFF9C2F88FB4E06097317FB866B3DF91645690366BD910BB5AA0BEFC4D85831EC30525AA5F1D5D3E8837AB78F579E3BC3CBFC5180DAAE82F58CBD3D6E5AFC4FD81B89E030E182BC8735751D9E264AB3EA104E599077F869EB57B568559644DA134FDD25ECA86658157467B4A86E05CD4558C23048DF6D4D60BA121479E741EA671F63A204D50EFC159F9C9748D849FCAD5F83BBE441545A34C36ECF5117D954F4D17275538A9DFAAEE9E0F47537EBC32001D4300056F0790CD072A5612FA197F2E7653BD10947115F
  268:d=1  hl=2 l=   3 prim:  INTEGER           :010001
  273:d=1  hl=4 l= 256 prim:  INTEGER           :3F8470B679354B275314A7A6334B36202182C559CEF40EB40B6D9029E0442CF6756408B6BC496E975C9DFAA34717E1838508612AE07A9033A74E5F77E2FF2B10EB5EE849152B270169167FCEFA5DF406396A1C3620415BBC714649B24B4CCAB5A7C5D21959564ADC210543F44DB6D9DCA2C6B10BD286B1F35351B3E0F9D72885658C1B59062CDE9F71746BBC51AEAB3BF4A72093D61E186A2D241DFB6EF25F21A0F243A557E03F84BFDB67626B2C9E27E44E7865E50AF5937AA4F316D54D7D53B2666628AAF808E70775998B863D5764312E52FAD7796206312803BF685463F91662669C2D4F2B0D75F8AF5591D010C6B29B314EB3C0E0BC47410C3EBC7CF101
  533:d=1  hl=3 l= 129 prim:  INTEGER           :F9D69789E0A678E4C9F870EDAA6C1C1AA9BEE312C19E6B53129FF4F23D9CBCCCEED5DDCF6311E23A1D58741F47C6F065CF2F7A84D0FB989AD87C37B241C69AC5AA3E3E382DF603B774C6AD5CD4F0AAA40F90CCDDD69A758845213AAA0A67745E22C4FF2C703B9E0A4C6F8A73E0A3A848A20C667C8F226BAFEC8004B92CB6851B
  665:d=1  hl=3 l= 129 prim:  INTEGER           :D8BCE62B25834898D684FB90EFF468BBDE358413EA0FF9420A44F4A05636113DB2AEEAEFFECEFBA11807674612AAD21945C157EC60FB7672FC7DEC402695255AFE2FD2D55566DCAAC6FBE6231B8504765DE073F852772706BB2B7E6A7D0AA84607459F8D9EBF3AC63086B6037F626D667A8CE82EA7C96ABCD721BC4C9CEEDD0D
  797:d=1  hl=3 l= 129 prim:  INTEGER           :F7F864AA059E554987A91DB4D6BCBCDC3DF4677E9B4BF86C188548E21202FA6550FC564E5B9F4971B2E4B344C4C210A28C142CBF9C88CB7B8D392532B9143D53C95843FB10AB281F33396AA243FBA6F2753C9C09E6D1A1AC22290C07EF91A52F35C55F1BA53D96EBD3D7B58CB3BEDBED5361896B41C9C126784ECBE15B1EC157
  929:d=1  hl=3 l= 128 prim:  INTEGER           :46E7856518209ADF654E9BFE0E8226C14F30B2C4D10DE8BD721E9CE8D74B58D8965C22FFE09C56359D66CEA25DF90442C04F40345485EF7A2EA00369F93551C332E4F254585C0E54D0441845E3FAE03AD8FB54F5280552FF20BC59DEFC894003A8DD5E153699D8E07D7F948C106062E9E3ADB5478E1C968EB0D2988777CFAD01
 1060:d=1  hl=3 l= 128 prim:  INTEGER           :2CBE891EAD1BC71FF1721EAE6EA8C6091AD8C117029A9142FC4F82F04BED3855EAC22D77ACC401095AE46D6964A5CAC596513BD71554DAE296614AF352CB198C25F0213C062C93A980DAA351583C5BF354E9A39B9FE0B4EC38FFA3C8324D33062AF21FA73AAFF1CDFE6056150C724F46C689F33D132C2AB4CE6F6B79A5A9AFD8</code></pre>
<ul>
<li><code>0</code> 表示节点在整个文件中的偏移长度</li>
<li><code>d=0</code> 表示节点深度</li>
<li><code>hl=3</code> 表示节点头字节长度</li>
<li><code>l=135</code> 表示节点数据字节长度</li>
<li><code>cons</code> 表示该节点为结构节点，表示包含子节点或者子结构数据</li>
<li><code>prim</code> 表示该节点为原始节点，包含数据</li>
<li><code>SEQUENCE</code>、 <code>OCTET STRING</code> 等都是 ASN.1 中定义的数据类型</li>
</ul>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像存储原理 UnionFS</title>
    <url>/2019/10/31/docker-unionfs-aufs-vs-overlay2/</url>
    <content><![CDATA[<p>Docker 使用 <code>UnionFS</code> 以支持存储，常用的有如下文件系统</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">aufs</a></li>
<li><a href="https://zh.wikipedia.org/wiki/OverlayFS" target="_blank" rel="noopener">overlay2</a></li>
</ul>
<a id="more"></a>

<h2 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h2><p>基于 <code>ubuntu 14.04</code> 分析 <code>AUFS</code></p>
<p><a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="noopener">DOCKER基础技术：AUFS</a></p>
<h2 id="overlay2"><a href="#overlay2" class="headerlink" title="overlay2"></a>overlay2</h2><p><a href="https://www.linuxidc.com/Linux/2017-03/141579.htm" target="_blank" rel="noopener">Docker存储驱动之OverlayFS简介</a></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>官方资料</p>
<ul>
<li><a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank" rel="noopener">Use the AUFS storage driver</a></li>
<li><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">Use the OverlayFS storage driver</a></li>
<li><a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">About storage drivers</a></li>
</ul>
<p>如下信息</p>
<ul>
<li>内核 <code>4.0</code> 以上第一选择 <code>overlay2</code></li>
<li>不支持 <code>overlay2</code>，首选 <code>aufs</code></li>
<li><code>overlay2</code> 已合并到内核，不需要进行任何额外的配置</li>
<li><code>aufs</code> 未合并进内核，需要安装额外的包以支持</li>
</ul>
<p>使用命令 <code>docker info</code> 检查存储驱动</p>
<pre><code class="shell">$ docker info
Client:
 Debug Mode: false

Server:
 Containers: 4
  Running: 0
  Paused: 0
  Stopped: 4
 Images: 7
 Server Version: 19.03.4
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: true
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>unionfs</tag>
        <tag>aufs</tag>
        <tag>overlay2</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 命令总结图</title>
    <url>/2019/10/23/docker-commands/</url>
    <content><![CDATA[<p>几张关于 Docker 的命令总结图</p>
<a id="more"></a>

<h2 id="Docker-命令分布图"><a href="#Docker-命令分布图" class="headerlink" title="Docker 命令分布图"></a>Docker 命令分布图</h2><p><img src="/images/docker/20171019215328080.png" alt="Docker Commands"></p>
<h2 id="Docker-命令原理图"><a href="#Docker-命令原理图" class="headerlink" title="Docker 命令原理图"></a>Docker 命令原理图</h2><p><a href="https://blog.csdn.net/huwh_/article/details/71308119" target="_blank" rel="noopener">转载-Docker常用命令原理图</a></p>
<p>Docker 常用命令原理图，显示了 <code>Docker Layer</code></p>
<p><img src="/images/docker/20170602232245806.jpeg" alt="Docker Layer"></p>
<ul>
<li>镜像是一堆只读层在统一文件系统（union file system）整合下的统一</li>
<li>容器是镜像加顶层的读写层</li>
<li>运行中的容器在容器的资源（静态容器）上增加隔离的进程空间和其中的进程</li>
<li><code>docker create</code> 生成静态容器</li>
<li><code>docker start</code> 生成动态容器</li>
<li><code>docker run</code> 为上述两命令集合</li>
<li><code>docker commit</code> 把容器的可读写层转化成只读层</li>
</ul>
<h2 id="Docker-容器生命周期管理"><a href="#Docker-容器生命周期管理" class="headerlink" title="Docker 容器生命周期管理"></a>Docker 容器生命周期管理</h2><p>方框中显示 Docker 容器生命周期管理</p>
<p><img src="/images/docker/124167522.png" alt="Docker Container"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 中使用零宽度断言</title>
    <url>/2019/10/16/vim-regex-positive-negative/</url>
    <content><![CDATA[<p>vim 中使用零宽度断言，包括</p>
<p></style></p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">vim 表符号</th>
<th>描述</th>
<th>示例</th>
<th>vim 示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>?=</code></td>
<td align="center"><code>\@=</code></td>
<td>正先行断言 - 存在</td>
<td><code>foo(?=bar)</code></td>
<td><code>foo\(bar\)\@=</code></td>
</tr>
<tr>
<td align="center"><code>?!</code></td>
<td align="center"><code>\@!</code></td>
<td>负先行断言 - 排除</td>
<td><code>foo(?!bar)</code></td>
<td><code>foo\(bar\)\@!</code></td>
</tr>
<tr>
<td align="center"><code>?&lt;=</code></td>
<td align="center"><code>\@&lt;=</code></td>
<td>正后发断言 - 存在</td>
<td><code>(?&lt;=foo)bar</code></td>
<td><code>\(foo\) \@&lt;=bar</code></td>
</tr>
<tr>
<td align="center"><code>?&lt;!</code></td>
<td align="center"><code>\@&lt;!</code></td>
<td>负后发断言 - 排除</td>
<td><code>(?&lt;!foo)bar</code></td>
<td><code>\(foo\) \@&lt;!bar</code></td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。<br>先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p>
<p>例如，我们想要获得所有跟在 <code>$</code> 符号后的数字，我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>。<br>这个表达式匹配 <code>$</code> 开头，之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次。</p>
<h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。<br>定义一个正先行断言要使用 <code>()</code>. 在括号内部使用一个问号和等号：<code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。<br>例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> , 即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>\nfat</code>。</p>
<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。<br><code>正先行断言</code>  定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>\nfat</code>。</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<h3 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<h3 id="lt-负后发断言"><a href="#lt-负后发断言" class="headerlink" title="?&lt;!... 负后发断言"></a><code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md#4-%E9%9B%B6%E5%AE%BD%E5%BA%A6%E6%96%AD%E8%A8%80%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5" target="_blank" rel="noopener">Learn REGEX</a></li>
<li><a href="https://jbodah.github.io/blog/2016/11/01/positivenegative-lookaheadlookbehind-vim/" target="_blank" rel="noopener">Positive/Negative Lookahead/Lookbehind in Vim</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Shell</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>regex</tag>
        <tag>Lookaround</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 中文排版指南</title>
    <url>/2019/10/11/chinese-copywriting-guidelines/</url>
    <content><![CDATA[<p>中文排版指南及 Markdown + Vim 工具</p>
<a id="more"></a>

<p>整理自如下指南：<br><a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文排版指南</a><br><a href="http://lujianan.com/2017/01/20/markdown-standard/" target="_blank" rel="noopener">Markdown 中文技术文档的写作规范</a></p>
<p>工具<br><a href="https://github.com/hotoo/pangu.vim" target="_blank" rel="noopener">「盘古之白」</a></p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ul>
<li>文章标题使用<strong>一级标题</strong></li>
<li>文章顶层标题使用<strong>二级标题</strong></li>
<li>每个小节的标题使用<strong>三级标题</strong></li>
<li>进一步分层组织时使用<strong>四级标题</strong></li>
<li>尽量少用<strong>五级标题和六级标题</strong>，考虑用有序列表和无序列表代替</li>
<li>标题要避免孤立编号（即同级标题只有一个）</li>
<li>下级标题不重复上一级标题的内容</li>
</ul>
<h2 id="全角与半角"><a href="#全角与半角" class="headerlink" title="全角与半角"></a>全角与半角</h2><ul>
<li>使用全角中文标点</li>
<li>遇到完整的英文整句、特殊名词，其內容使用半角标点</li>
</ul>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul>
<li>中英文之间需要增加空格<blockquote>
<p>在 LeanCloud 上，数据存储是围绕 AVObject 进行的。</p>
</blockquote>
</li>
<li>中文与数字之间需要增加空格<blockquote>
<p>今天出去买菜花了 5000 元。</p>
</blockquote>
</li>
<li>数字与单位之间无需增加空格<blockquote>
<p>我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。<br>今天是 233° 的高温。</p>
</blockquote>
</li>
<li>全角标点与其他字符之间不加空格<blockquote>
<p>刚刚买了一部 iPhone，好开心！</p>
</blockquote>
</li>
</ul>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ul>
<li>专有名词使用正确的大小写<blockquote>
<p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p>
</blockquote>
</li>
<li>不要使用不地道的缩写<blockquote>
<p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p>
</blockquote>
</li>
<li>在提到了 <code>专有名词和特殊名词</code> 时、或者需要 <code>着重强调的词汇</code> 时，在前后添加 半角空格 分词，或者使用 <code>行内代码块</code></li>
<li>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可<blockquote>
<p>IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</p>
</blockquote>
</li>
</ul>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul>
<li>正文段落之间用一个空行来分隔</li>
<li>需要强调某处内容时使用<strong>粗体</strong></li>
<li>中文排版中不使用<em>斜体</em></li>
<li>英文排版中可用斜体表达强调，或表示书名、题目</li>
</ul>
<h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><ul>
<li>不重复使用标点符号</li>
<li>在中文输入法状态下，可使用「Shift + 6」输入省略号<blockquote>
<p>……</p>
</blockquote>
</li>
<li>在中文输入法状态下，可使用「Shift + -」输入破折号<blockquote>
<p>破折号，标示语段中某些成分的注释、补充说明或语音、意义的变化。——《标点符号用法》</p>
</blockquote>
</li>
<li>数字使用半角字符</li>
</ul>
<h2 id="写作规范"><a href="#写作规范" class="headerlink" title="写作规范"></a>写作规范</h2><ul>
<li>避免使用长句</li>
<li>尽量使用简单句和并列句</li>
<li>尽量不使用被动语态，改为使用主动语态</li>
<li>不使用非正式的语言风格</li>
<li>用对“的”、“地”、“得”<blockquote>
<p>她露出了开心的笑容。（形容词＋的＋名词）<br>她开心地笑了。（副词＋地＋动词）<br>她笑得很开心。（动词＋得＋副词）</p>
</blockquote>
</li>
<li>名词前不要使用过多的形容词</li>
<li>尽量使用肯定句表达，不使用否定句表达</li>
<li>避免使用双重否定句</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>chinese</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入门</title>
    <url>/2019/10/11/how-to-use-docker/</url>
    <content><![CDATA[<ul>
<li><code>Docker</code> 是什么</li>
<li><code>Docker</code> 核心概念</li>
<li><code>Docker</code> 怎么使用</li>
</ul>
<a id="more"></a>

<h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><ul>
<li>Docker 是 Linux 容器的一种封装，提供简单易用的容器使用接口</li>
<li>Docker 和传统虚拟化方式的不同之处在于容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现</li>
<li>相较于 VM 虚拟化方法，Docker 的好处是启动速度快，资源利用率高，性能开销小</li>
</ul>
<p><img src="/images/docker/docker.jpg" alt="Container vs VMs"></p>
<h2 id="Docker-核心概念"><a href="#Docker-核心概念" class="headerlink" title="Docker 核心概念"></a>Docker 核心概念</h2><p>Docker 技术的三大核心概念，分别是：</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>docker 是一个 client-server 的结构！先看看官网给出的架构图：</p>
<p><img src="/images/docker/three" alt="three"></p>
<h3 id="联合文件系统-UnionFS"><a href="#联合文件系统-UnionFS" class="headerlink" title="联合文件系统 - UnionFS"></a>联合文件系统 - <code>UnionFS</code></h3><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像就是一个只读的模板。一个镜像可以包含一个完整的操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。任何镜像的创建会基于其他的父镜像，也就是说镜像是一层套一层。<br>镜像不包含任何动态数据，其内容在构建之后也不会被改变。镜像（Image）就是一堆只读层（read-only layer）的统一视角：<br><img src="/images/docker/image.jpg" alt="Image"></p>
<p>统一文件系统 (Union File System) 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角。这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Docker 运行的最小单位。它是通过镜像实例化出来的一个可运行对象。容器的修改，可以提交反作用于镜像，更新这个容器的模板。Docker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<br>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件：image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<p>容器的最上面那一层是可读可写的。<br><img src="/images/docker/container.jpg" alt="Image"></p>
<h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>容器数据卷的设计目的是做<strong>数据的持久化和容器间的数据共享</strong>，数据卷完全独立于容器的生命周期，也就是说就算容器关闭或者删除，数据也不会丢失。将宿主机的目录挂在到容器，应用在容器内的数据可以同步到宿主机磁盘上，这样容器内产生的数据就可以持久化了。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>官方仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 是最重要、最常用的 image 仓库。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><code>Dockerfile</code> 是一个包含用户能够构建镜像的所有命令的文本文档，它有自己的语法以及命令，Docker 能够从 Dockerfile 中读取指令自动的构建镜像！ 可以将 Dockerfile 分为四个部分：</p>
<ol>
<li>基础镜像（父镜像）信息指令 <code>FROM</code></li>
<li>维护者信息指令 <code>MAINTAINER</code></li>
<li>镜像操作指令 <code>RUN</code>、 <code>EVN</code>、 <code>ADD</code> 和 <code>WORKDIR</code> 等</li>
<li>容器启动指令 <code>CMD</code>、 <code>ENTRYPOINT</code> 和 <code>USER</code> 等</li>
</ol>
<p>常用命令：</p>
<ul>
<li><code>FROM</code> 指定基础镜像，当前镜像是基于哪个镜像创建的， <code>FROM</code> 指令必是 Dockerfile 文件中的首条命令</li>
<li><code>ENV</code> 设置环境变量，设置的变量可供后面指令使用</li>
<li><code>WORKDIR</code> 设置工作目录，在该指令后的 <code>RUN</code>、 <code>CMD</code>、 <code>ENTRYPOINT</code>、 <code>COPY</code>、 <code>ADD</code> 指令都会在该目录执行</li>
<li><code>RUN</code> 在当前镜像的最上面创建一个新层，并且能执行任何的命令，然后对执行的结果进行提交。提交后的结果镜像在 Dockerfile 的后续步骤中可以使用</li>
<li><code>ADD</code> 从宿主机拷贝文件或者文件夹到镜像，也可以复制一个网络文件！如果拷贝的文件是一个压缩包，会自动解压缩</li>
<li><code>COPY</code> 从宿主机拷贝文件或者文件夹到镜像，不能复制网络文件也不会自动解压缩</li>
<li><code>VOLUME</code> 用于创建挂载点，一般配合 <code>run</code> 命令的 <code>-v</code> 参数使用</li>
<li><code>CMD</code> 指定容器启动时默认运行的命令，在一个 Dockerfile 文件中，如果有多个 <code>CMD</code> 命令，只有一个最后一个会生效</li>
<li><code>ENTRYPOINT</code> 与 <code>CMD</code> 指令类似，都是指定启动容器时要运行的命令，如果指定了 <code>ENTRYPOINT</code>，则 <code>CMD</code> 指定的命令不会执行</li>
<li><code>SHELL</code> 用于设置执行命令所使用的默认的 <code>shell</code> 类型</li>
<li><code>EXPOSE</code> 允许外部连接这个端口</li>
</ul>
<p>Dockerfile 执行顺序是从上到下，顺序执行！每条指令都会创建一个新的镜像层，并对镜像进行提交。编写好 Dockerfile 文件后，就需要使用 <code>docker build</code> 命令对镜像进行构建。</p>
<h2 id="Docker-怎么使用"><a href="#Docker-怎么使用" class="headerlink" title="Docker 怎么使用"></a>Docker 怎么使用</h2><p>命令图<br><img src="/images/docker/docker-diagram.jpg" alt=""></p>
<h3 id="镜像基本操作"><a href="#镜像基本操作" class="headerlink" title="镜像基本操作"></a>镜像基本操作</h3><ul>
<li>获取镜像<pre><code class="shell">$ docker search centos
$ docker pull centos
$ docker images
$ docker rmi repository:tag</code></pre>
</li>
<li>将容器改动更新到镜像<pre><code class="shell">$ docker commit container_name/container_id [REPOSITORY[:TAG]]
$ docker images</code></pre>
</li>
<li>使用 <code>Dockerfile</code> 构建镜像，使用 <code>commit</code> 生成的镜像也被称为黑箱镜像，不推荐使用<pre><code class="shell">$ docker build -t [REPOSITORY[:TAG]] .</code></pre>
</li>
<li>查看镜像详情 <code>docker inspect image_id</code></li>
<li>查看镜像、容器、数据卷所占用的空间<pre><code class="shell">$ docker system df</code></pre>
</li>
<li>删除无主数据卷<pre><code class="shell">$ docker volume prune</code></pre>
</li>
</ul>
<h3 id="容器基本操作"><a href="#容器基本操作" class="headerlink" title="容器基本操作"></a>容器基本操作</h3><ul>
<li>创建容器 <code>docker run -t -i rangalo/debian /bin/bash</code></li>
<li>查看容器 <code>docker ps -a</code></li>
<li>启动、停止、重启容器 <code>docker start/stop/restart container_name/container_id</code></li>
<li>登录后台容器 <code>docker attach container_name/container_id</code></li>
<li>删除容器 <code>docker rm container_name/container_id</code></li>
<li>停止所有容器 <code>docker stop $(docker ps -aq)</code></li>
<li>删除所有容器 <code>docker rm $(docker ps -aq)</code></li>
<li>查看容器详情 <code>docker inspect container_id</code></li>
<li>查看容器日志 <code>docker logs container_id</code></li>
</ul>
<h3 id="仓库基本操作"><a href="#仓库基本操作" class="headerlink" title="仓库基本操作"></a>仓库基本操作</h3><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 <code>Docker Hub</code>，存放了数量庞大的镜像供用户下载。当然，用户也可以在本地网络内创建一个私有仓库。</p>
<h4 id="公共仓库"><a href="#公共仓库" class="headerlink" title="公共仓库"></a>公共仓库</h4><ul>
<li>注册帐号 <code>https://hub.docker.com/</code></li>
<li>登录 <code>docker login</code></li>
<li>推出登录 <code>docker logout</code></li>
<li>标记本地镜像 <code>docker tag image_id|repository:tag user_id/image_name:tag</code><blockquote>
<p><code>docker tag fce289e99eb9 breezetemple/hello-world:test</code><br><code>docker tag hello-world:latest breezetemple/hello-world:latest</code></p>
</blockquote>
</li>
<li>推送镜像 <code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code><blockquote>
<p><code>docker push breezetemple/hello-world:test</code></p>
</blockquote>
</li>
<li>获取镜像 <code>docker push [OPTIONS] NAME[:TAG]</code></li>
</ul>
<h4 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h4><p><code>docker-registry</code> 是官方提供的工具，可以用于构建私有的镜像仓库。</p>
<ul>
<li>使用官方 <code>registry</code> 镜像<blockquote>
<p><code>docker pull registry</code><br><code>docker run -d -p 5000:5000 -v /home/workspace/registry:/var/lib/registry registry</code><br><code>-v</code> / 宿主机：/ 容器内目录</p>
</blockquote>
</li>
<li>查看镜像 <code>docker images</code></li>
<li>标记本地镜像 <code>docker tag hello-world:latest 127.0.0.1:5000/hello-world:latest</code></li>
<li>上传镜像 <code>docker push 127.0.0.1:5000/hello-world:latest</code></li>
<li>检查结果 <code>curl 127.0.0.1:5000/v2/_catalog</code></li>
<li>删除本地镜像 <code>docker image rm 127.0.0.1:5000/hello-world:latest</code></li>
<li>获取私有仓库镜像 <code>docker pull 127.0.0.1:5000/hello-world:latest</code></li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/52172321" target="_blank" rel="noopener">10 分钟带你从入门操作到实战上手</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1354393" target="_blank" rel="noopener">这可能是最为详细的 Docker 入门吐血总结</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装</title>
    <url>/2019/10/10/how-to-install-docker/</url>
    <content><![CDATA[<p>ubuntu 18.04 安装 Docker CE</p>
<a id="more"></a>

<h2 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h2><p>Linux 虚拟化技术：Linux 容器 - Linux Containers - <code>LXC</code>。<br><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，是进程级。</strong><br>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</p>
<h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><p>如安装过 Docker 先卸载，旧版本称为 docker 或 docker-engine</p>
<pre><code class="shell">$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre>
<p>目录 <code>/var/lib/docker/</code> 下的内容不会删除，其中包含 images、containers、volumes、networks 等</p>
<h2 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h2><p>存在两个版本：</p>
<ul>
<li>社区版（ <code>Community Edition</code>，缩写为 <code>CE</code> ）</li>
<li>企业版（ <code>Enterprise Edition</code>，缩写为 <code>EE</code> ）</li>
</ul>
<p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方安装指导</a></p>
<ul>
<li>更新系统<blockquote>
<p><code>sudo apt update</code></p>
</blockquote>
</li>
<li>安装软件包以允许 <code>apt</code> 通过 HTTPS 使用存储库<blockquote>
<p><code>sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</code></p>
</blockquote>
</li>
<li>添加 Docker 的官方 GPG 密钥<blockquote>
<p><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p>
</blockquote>
</li>
<li>验证密钥<blockquote>
<p><code>sudo apt-key fingerprint 0EBFCD88</code></p>
</blockquote>
</li>
<li>设定稳定存储库<blockquote>
<p><code>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</code></p>
</blockquote>
</li>
<li>安装 Docker CE<blockquote>
<p><code>sudo apt update</code><br><code>sudo apt-get install docker-ce docker-ce-cli containerd.io</code></p>
</blockquote>
</li>
<li>验证<blockquote>
<p><code>sudo docker version</code></p>
</blockquote>
</li>
</ul>
<h2 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h2><p>为了避免每次命令都输入 <code>sudo</code>，可以把用户加入 docker 用户组，<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">官方文档</a></p>
<pre><code class="shell">$ sudo groupadd docker
$ sudo usermod -aG docker $USER
$ newgrp docker
$ docker run hello-world</code></pre>
<h2 id="Docker-服务"><a href="#Docker-服务" class="headerlink" title="Docker 服务"></a>Docker 服务</h2><p>运行 Docker 时需要本机有 Docker 服务。<a href="https://docs.docker.com/config/daemon/systemd/" target="_blank" rel="noopener">官方文档</a></p>
<pre><code class="shell">$ sudo systemctl start docker
$ sudo systemctl status docker</code></pre>
<h2 id="测试-hello-world"><a href="#测试-hello-world" class="headerlink" title="测试 hello-world"></a>测试 hello-world</h2><pre><code class="shell">$ docker image pull library/hello-world
$ docker run hello-world
$ docker images</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>strftime 转换控制符</title>
    <url>/2019/10/09/strftime-options/</url>
    <content><![CDATA[<p><code>strftime</code> 按照指定格式输出时间字符串</p>
<a id="more"></a>

<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳 <code>time_t timestamp</code> 是从 <code>1970-01-01 00:00:00</code> 到目前计时时间的秒数</p>
<h2 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a>strftime</h2><p>常用选项</p>
<style>
table th:first-of-type {
    width: 200px;
}
</style>

<table>
<thead>
<tr>
<th>转换控制符</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>%a</td>
<td>星期几的简写形式</td>
</tr>
<tr>
<td>%a</td>
<td>星期几的简写形式</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的全称</td>
</tr>
<tr>
<td>%b</td>
<td>月份的简写形式</td>
</tr>
<tr>
<td>%B</td>
<td>月份的全称</td>
</tr>
<tr>
<td>%c</td>
<td>日期和时间</td>
</tr>
<tr>
<td>%d</td>
<td>月份中的日期，0-31</td>
</tr>
<tr>
<td>%H</td>
<td>小时，00-23</td>
</tr>
<tr>
<td>%I</td>
<td>12 进制小时钟点，01-12</td>
</tr>
<tr>
<td>%j</td>
<td>年份中的日期，001-366</td>
</tr>
<tr>
<td>%m</td>
<td>年份中的月份，01-12</td>
</tr>
<tr>
<td>%M</td>
<td>分，00-59</td>
</tr>
<tr>
<td>%p</td>
<td>上午或下午</td>
</tr>
<tr>
<td>%S</td>
<td>秒，00-60</td>
</tr>
<tr>
<td>%u</td>
<td>星期几，1-7</td>
</tr>
<tr>
<td>%w</td>
<td>星期几，0-6</td>
</tr>
<tr>
<td>%x</td>
<td>当地格式的日期</td>
</tr>
<tr>
<td>%X</td>
<td>当地格式的时间</td>
</tr>
<tr>
<td>%y</td>
<td>年份中的最后两位数，00-99</td>
</tr>
<tr>
<td>%Y</td>
<td>年</td>
</tr>
<tr>
<td>%Z</td>
<td>地理时区名称</td>
</tr>
</tbody></table>
<p>需要注意 <code>%Z</code> 某些 c 库未支持</p>
<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><pre><code class="c">struct tm *p = gmtime(&amp;utc_time);
strftime(data, sizeof(data), &quot;%a %b %d %H:%M:%S %Z %Y&quot;, p);
// Tue Mar 06 12:33:45 CST 2001
strftime(data, sizeof(data), &quot;%A, %b %d, %X %z %Y&quot;, p);
// Tuesday, Mar 06, 12:33:45 +0000 2001
strftime(data, sizeof(data), &quot;%A, %b %d, %X %Z %Y&quot;, p);
// Tuesday, Mar 06, 12:33:45 CST 2001</code></pre>
]]></content>
      <categories>
        <category>C</category>
        <category>Functions</category>
      </categories>
      <tags>
        <tag>time</tag>
        <tag>timezone</tag>
      </tags>
  </entry>
  <entry>
    <title>v2ray 配置 TLS</title>
    <url>/2019/10/08/v2ray-with-tls/</url>
    <content><![CDATA[<p>配置 <code>v2ray TLS</code> 工作模式</p>
<a id="more"></a>

<p>证书申请见 <a href="/2019/10/08/acme/" title="Let&#39;s Encrypt 申请 SSL 证书">Let&#39;s Encrypt 申请 SSL 证书</a></p>
<h2 id="安装证书和密钥"><a href="#安装证书和密钥" class="headerlink" title="安装证书和密钥"></a>安装证书和密钥</h2><pre><code class="shell">$ ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key --ecc
$ ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key</code></pre>
<h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p><a href="https://toutyrater.github.io/advanced/tls.html" target="_blank" rel="noopener">TLS</a></p>
<p>修改服务器</p>
<pre><code class="json">  &quot;inbounds&quot;: [
    {
      &quot;port&quot;: 443, // 建议使用 443 端口
      &quot;protocol&quot;: &quot;vmess&quot;,
      &quot;settings&quot;: {
        &quot;clients&quot;: [
          {
            &quot;id&quot;: &quot;23ad6b10-8d1a-40f7-8ad0-e3e35cd38297&quot;,
            &quot;alterId&quot;: 64
          }
        ]
      },
      &quot;streamSettings&quot;: {
        &quot;network&quot;: &quot;tcp&quot;,
        &quot;security&quot;: &quot;tls&quot;, // security 要设置为 tls 才会启用 TLS
        &quot;tlsSettings&quot;: {
          &quot;certificates&quot;: [
            {
              &quot;certificateFile&quot;: &quot;/etc/v2ray/v2ray.crt&quot;, // 证书文件
              &quot;keyFile&quot;: &quot;/etc/v2ray/v2ray.key&quot; // 密钥文件
            }
          ]
        }
      }
    }
  ]</code></pre>
<ul>
<li><code>certificateFile</code> 证书文件绝对路径</li>
<li><code>keyFile</code> 密钥文件绝对路径</li>
</ul>
<p>客户端输入</p>
<ul>
<li>域名</li>
<li>端口</li>
<li>传输协议：TCP</li>
<li>底层传输安全：TLS</li>
</ul>
<p><a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">Qualys SSL Labs’s SSL Server Test</a></p>
<blockquote>
<p>使用 Qualys SSL Labs’s SSL Server Test 要求使用 443 端口，意味着你服务器配置的 <code>inbound.port</code> 应当是 443</p>
</blockquote>
<h2 id="WebSocket-TLS"><a href="#WebSocket-TLS" class="headerlink" title="WebSocket + TLS"></a>WebSocket + TLS</h2><p><a href="https://toutyrater.github.io/advanced/websocket.html" target="_blank" rel="noopener">WebSocket 单独配置教程</a></p>
<p>修改服务端</p>
<pre><code class="json">{
  &quot;port&quot;: 443,
  &quot;protocol&quot;: &quot;vmess&quot;,
  &quot;settings&quot;: {
    &quot;clients&quot;: [{
      &quot;id&quot;: &quot;自行生成 UUID&quot;,
      &quot;alterId&quot;: 64
     }]
  },
  &quot;streamSettings&quot;: {
    &quot;network&quot;:&quot;ws&quot;,
    &quot;security&quot;: &quot;tls&quot;,
    &quot;wsSettings&quot;:{
      &quot;path&quot;:&quot;/&quot;,
      &quot;headers&quot;:{}
    },
    &quot;tlsSettings&quot;: {
      &quot;certificates&quot;: [{
        &quot;certificateFile&quot;: &quot;公钥文件绝对路径，如：/path/to/xxx.com.crt&quot;,
        &quot;keyFile&quot;: &quot;私钥文件绝对路径，如：/path/to/xxx.com.key&quot;
      }]
    }
  }
}</code></pre>
<p>增加 <code>wsSettings</code>，修改 <code>network</code> 为 <code>ws</code></p>
<p>客户端输入</p>
<ul>
<li>域名</li>
<li>端口</li>
<li>传输协议：ws</li>
<li>path：/</li>
<li>底层传输安全：TLS</li>
</ul>
<h2 id="HTTP-2-TLS"><a href="#HTTP-2-TLS" class="headerlink" title="HTTP/2 + TLS"></a>HTTP/2 + TLS</h2><p><a href="https://toutyrater.github.io/advanced/h2.html" target="_blank" rel="noopener">HTTP/2 单独配置</a></p>
<p>服务端</p>
<pre><code class="json">{
  &quot;port&quot;: 443,
  &quot;protocol&quot;: &quot;vmess&quot;,
  &quot;settings&quot;: {
    &quot;clients&quot;: [{
      &quot;id&quot;: &quot;自行生成 UUID&quot;,
      &quot;alterId&quot;: 64
     }]
  },
  &quot;streamSettings&quot;: {
    &quot;network&quot;:&quot;http&quot;,
    &quot;security&quot;: &quot;tls&quot;,
    &quot;httpSettings&quot;:{
      &quot;path&quot;: &quot;在这里填写网页路径，以 / 开头，例如 /abcde/xyz&quot;
    },
    &quot;tlsSettings&quot;: {
      &quot;certificates&quot;: [{
        &quot;certificateFile&quot;: &quot;公钥文件绝对路径，如：/path/to/xxx.com.crt&quot;,
        &quot;keyFile&quot;: &quot;私钥文件绝对路径，如：/path/to/xxx.com.key&quot;
      }]
    }
  }
}</code></pre>
<p>增加 <code>httpSettings</code>，修改 <code>network</code> 为 <code>http</code></p>
<p>客户端输入</p>
<ul>
<li>域名</li>
<li>端口</li>
<li>传输协议：<code>h2</code></li>
<li>path：<code>/</code></li>
<li>底层传输安全：TLS</li>
</ul>
<h2 id="WebSocket-TLS-Web"><a href="#WebSocket-TLS-Web" class="headerlink" title="WebSocket + TLS + Web"></a>WebSocket + TLS + Web</h2><p><a href="https://toutyrater.github.io/advanced/wss_and_web.html" target="_blank" rel="noopener">WebSocket+TLS+Web</a></p>
<ul>
<li>使用 <code>Nginx / Caddy / Apache</code> 是因为 <code>VPS</code> 已经有 <code>Nginx / Caddy / Apache</code> 可以将 <code>V2Ray</code> 稍作隐藏</li>
<li>使用 <code>WebSocket</code> 是因为搭配 <code>Nginx / Caddy / Apache</code> 只能用 <code>WebSocket</code></li>
<li>使用 <code>TLS</code> 是因为可以流量加密，看起来更像 <code>HTTPS</code></li>
</ul>
<p>一键安装脚本</p>
<ul>
<li><a href="https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC" target="_blank" rel="noopener">V2Ray 一键安装脚本</a> 集成 <code>Caddy</code></li>
<li><a href="https://github.com/wulabing/V2Ray_ws-tls_bash_onekey" target="_blank" rel="noopener">V2Ray_ws-tls_bash_onekey</a> 集成 <code>Nginx</code></li>
<li><a href="https://github.com/iMeiji/shadowsocks_install/wiki/Project-V-%E9%85%8D%E7%BD%AE-WebSocket-TLS-Web-CDN" target="_blank" rel="noopener">LNMP 1.5</a> 安装 <code>Nginx</code></li>
</ul>
<blockquote>
<p>未使用一键安装脚本，通过 <code>acme.sh</code> 手动配置</p>
</blockquote>
<p>修改服务端，删除 <code>TLS</code> 配置</p>
<pre><code class="json">  &quot;inbounds&quot;: [
    {
      &quot;port&quot;: 10000,
      &quot;listen&quot;:&quot;127.0.0.1&quot;,// 只监听 127.0.0.1，避免除本机外的机器探测到开放了 10000 端口
      &quot;protocol&quot;: &quot;vmess&quot;,
      &quot;settings&quot;: {
        &quot;clients&quot;: [
          {
            &quot;id&quot;: &quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;,
            &quot;alterId&quot;: 64
          }
        ]
      },
      &quot;streamSettings&quot;: {
        &quot;network&quot;: &quot;ws&quot;,
        &quot;wsSettings&quot;: {
        &quot;path&quot;: &quot;/ray&quot;
        }
      }
    }
  ],</code></pre>
<p><code>Nginx</code> 配置</p>
<pre><code>server {
  listen  443 ssl;
  ssl on;
  ssl_certificate       /etc/v2ray/v2ray.crt;
  ssl_certificate_key   /etc/v2ray/v2ray.key;
  ssl_protocols         TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers           HIGH:!aNULL:!MD5;
  server_name           mydomain.me;
        location /ray { # 与 V2Ray 配置中的 path 保持一致
        proxy_redirect off;
        proxy_pass http://127.0.0.1:10000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
        proxy_set_header Host $http_host;

        # Show realip in v2ray access.log
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
}</code></pre><p>客户端输入</p>
<ul>
<li>域名</li>
<li>端口 <code>443</code></li>
<li>传输协议：<code>ws</code></li>
<li>path：<code>/ray</code></li>
<li>底层传输安全：TLS</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.sprov.xyz/2019/04/27/v2ray-wstls-or-http2tls-tutorial/" target="_blank" rel="noopener">v2ray 配置 ws + tls 或 http2 + tls 教程</a></li>
<li><a href="https://toutyrater.github.io/advanced/" target="_blank" rel="noopener">高级篇</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>ssl</tag>
        <tag>tls</tag>
        <tag>vps</tag>
        <tag>Let&#39;s Encrypt</tag>
        <tag>acme.sh</tag>
        <tag>nginx</tag>
        <tag>caddy</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Encrypt 申请 SSL 证书</title>
    <url>/2019/10/08/acme/</url>
    <content><![CDATA[<p>在阿里云申请的域名，阿里云 DNS 与 <code>Let&#39;s Encrypt</code> 数字证书申请</p>
<a id="more"></a>

<h2 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title="Let’s Encrypt"></a>Let’s Encrypt</h2><p><code>Let&#39;s Encrypt</code> 申请证书的方法有很多种，详细信息 <a href="https://letsencrypt.org/zh-cn/docs/client-options/" target="_blank" rel="noopener">ACME 客户端</a></p>
<p>官方推荐客户端 <a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a>，本文使用 <a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">acme.sh</a></p>
<h2 id="域名-API"><a href="#域名-API" class="headerlink" title="域名 API"></a>域名 API</h2><p><code>Let’s Encrypt</code> 只支持 <code>DV 证书</code> 的签发，也就是通过验证域名所有权，然后签发该域名的证书。它支持两种验证方式：</p>
<ul>
<li>通过 <code>HTTP</code> 的方式验证</li>
<li>通过 <code>DNS</code> 的方式验证</li>
</ul>
<p>首先通过 <a href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" rel="noopener">manage</a> 创建 <code>API Key</code>，记录 <code>AccessKey ID</code> 与 <code>Access Key Secret</code></p>
<h2 id="acme-sh"><a href="#acme-sh" class="headerlink" title="acme.sh"></a>acme.sh</h2><p><a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">中文 Readme</a></p>
<blockquote>
<p><strong>切换为超级用户模式 <code>sudu su</code></strong></p>
</blockquote>
<pre><code class="shell">$ curl  https://get.acme.sh | sh
# 首先执行以下两行
$ export Ali_Key=&quot;AccessKey ID&quot;
$ export Ali_Secret=&quot;Access Key Secret&quot;

# 而后申请签发证书
$ ~/.acme.sh/acme.sh --issue --dns dns_ali -d xxx.com
$ ~/.acme.sh/acme.sh --issue --dns dns_ali -d xxx.club -d *.xxx.club -k ec-256</code></pre>
<ul>
<li><code>--issue</code>，签发</li>
<li><code>--dns dns_ali</code>，验证方式</li>
<li><code>-d xxx.com</code>，域名</li>
<li><code>--ecc</code>，ecc 证书</li>
</ul>
<p>成功之后文件目录如下</p>
<ul>
<li><code>ca.cer</code>：Let’s Encrypt 的中级证书</li>
<li><code>fullchain.cer</code>：包含中级证书的域名证书</li>
<li><code>xxx.com.cer</code>：无中级证书的域名证书</li>
<li><code>xxx.com.conf</code>：该域名的配置文件</li>
<li><code>xxx.com.csr</code>：该域名的 CSR 证书请求文件</li>
<li><code>xxx.com.csr.conf</code>：该域名的 CSR 请求文件的配置文件</li>
<li><code>xxx.com.key</code>：该域名证书的私钥</li>
</ul>
<p>证书更新</p>
<pre><code class="shell">$ ~/.acme.sh/acme.sh --renew -d xxx.com --force --ecc
$ ~/.acme.sh/acme.sh --renew -d xxx.com --force</code></pre>
<p>证书吊销</p>
<pre><code class="shell">acme.sh --revoke -d xxx.com --ecc</code></pre>
<p>证书安装</p>
<pre><code class="shell">$ ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key --ecc
$ ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key</code></pre>
<p>查看定时任务</p>
<pre><code class="shell">$ crontab -e</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>vps</tag>
        <tag>Let&#39;s Encrypt</tag>
        <tag>阿里云 DNS</tag>
        <tag>acme.sh</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub MarketPlace 安装 TravisCI 自动部署 gitbook</title>
    <url>/2019/10/03/GitHub-MarketPlace-and-TravisCI/</url>
    <content><![CDATA[<p><code>GitHub</code> 集成 <code>Travis CI</code> 用于自动部署 <code>GitHub Pages</code></p>
<a id="more"></a>

<h2 id="GitHub-Market-Place"><a href="#GitHub-Market-Place" class="headerlink" title="GitHub Market Place"></a>GitHub Market Place</h2><p><a href="https://github.com/marketplace" target="_blank" rel="noopener">GitHub Market Place</a> 选择 <code>Travis CI</code> 进行安装，<code>Open Source</code> 工程是免费的。</p>
<p>输入密码完成安装</p>
<h2 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h2><p><a href="https://docs.travis-ci.com/user/environment-variables" target="_blank" rel="noopener">Environment Variables</a></p>
<p>在 <code>Travis CI</code> 中定义环境变量有如下几种方式</p>
<ul>
<li>Defining Public Variables in <code>.travis.yml</code></li>
<li>Defining encrypted variables in <code>.travis.yml</code></li>
<li>Defining Variables in Repository Settings</li>
<li>Convenience Variables</li>
</ul>
<h2 id="GitHub-Token"><a href="#GitHub-Token" class="headerlink" title="GitHub Token"></a>GitHub Token</h2><p><code>Repository</code> -&gt; <code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens</code></p>
<p>Make sure to copy your new personal access token now. You won’t be able to see it again!</p>
<ul>
<li><code>https://travis-ci.com/</code> – <code>travis login --pro</code> – 付费版 – <code>GitHub</code></li>
<li><code>https://travis-ci.org/</code> – <code>travis login --org</code> – 免费版</li>
</ul>
<h3 id="在-Travis-CI-中添加环境变量"><a href="#在-Travis-CI-中添加环境变量" class="headerlink" title="在 Travis CI 中添加环境变量"></a>在 Travis CI 中添加环境变量</h3><p><a href="https://docs.travis-ci.com/user/environment-variables" target="_blank" rel="noopener">官方文档在这里</a></p>
<p>每个仓库的设置页面里，有一个 <code>Environment Variables</code> 的配置项，给我们的 <code>Token</code> 起一个名字 <code>GITHUB_TOKEN</code> 添加进去。这样以来，脚本内部就可以使用这个环境变量了。</p>
<pre><code class="shell">git push -f &quot;https://${GITHUB_TOKEN}@${GH_REF}&quot; gh-pages:gh-pages</code></pre>
<blockquote>
<p>By default, the value of these new environment variables is hidden from the export line in the logs. This corresponds to the behavior of encrypted variables in your .travis.yml. The variables are stored encrypted in our systems, and get decrypted when the build script is generated.</p>
</blockquote>
<h3 id="加密-Token"><a href="#加密-Token" class="headerlink" title="加密 Token"></a>加密 Token</h3><p><a href="https://docs.travis-ci.com/user/encryption-keys#usage" target="_blank" rel="noopener">https://travis-ci.com, see Encryption keys – Usage.</a></p>
<pre><code class="shell">$ sudo apt install ruby
$ sudo apt install gem
$ sudo apt install ruby-all-dev
$ sudo gem install travis</code></pre>
<p>输入 <code>GitHub</code> 用户名和密码？</p>
<pre><code class="shell">$ travis login --pro --github-token xxxxxxxxx
$ travis login --pro
We need your GitHub login to identify you.
This information will not be sent to Travis CI, only to api.github.com.
The password will not be displayed.

Try running with --github-token or --auto if you don&#39;t want to enter your password anyway.

Username: xxxxxxxx
Password for xxxxxxxx: **********
Successfully logged in as xxxxxxxxx!
</code></pre>
<pre><code class="shell">$ travis encrypt --pro GITHUB_TOKEN=&lt;YOUR_GITHUB_TOKEN&gt; --add</code></pre>
<blockquote>
<p><strong><code>GitHub</code> 使用 <code>https://travis-ci.org/</code>，加密时使用 <code>--pro</code> 保证正确</strong></p>
</blockquote>
<h3 id="CI-Log"><a href="#CI-Log" class="headerlink" title="CI Log"></a>CI Log</h3><p>从 <code>Settings</code> 中获取</p>
<pre><code>Setting environment variables from repository settings
$ export GITHUB_TOKEN=[secure]
Setting environment variables from .travis.yml
$ export GH_REF=github.com/breezetemple/how-to-use-gitbook.git</code></pre><p>从 <code>.travis.yml</code> 加密字符串中获取</p>
<pre><code>Setting environment variables from .travis.yml
$ export GH_REF=github.com/breezetemple/how-to-use-gitbook.git
$ export GITHUB_TOKEN=[secure]</code></pre><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p><code>Repository</code> -&gt; <code>Settings</code> -&gt; <code>Applications</code> -&gt; <code>Travis CI</code> -&gt; <code>Configure</code> -&gt; <code>Only select repositories</code></p>
<p>需要如下权限</p>
<ul>
<li>Read access to code</li>
<li>Read access to metadata and pull requests</li>
<li>Read and write access to checks, commit statuses, deployments, and repository hooks</li>
</ul>
<p><a href="https://travis-ci.com" target="_blank" rel="noopener">website</a></p>
<h3 id="使用部署"><a href="#使用部署" class="headerlink" title="使用部署"></a>使用部署</h3><p><a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">GitHub Pages Deployment</a></p>
<pre><code class="yaml">language: generic
before_install:
- npm install -g gitbook-cli
install:
- gitbook install
- gitbook build
deploy:
  provider: pages
  local_dir: _book
  skip_cleanup: true
  github_token: $GITHUB_TOKEN  # Set in the settings page of your repository, as a secure variable
  keep_history: true
  on:
    branch: master
env:
  global:
  - GH_REF: github.com/breezetemple/how-to-use-gitbook.git</code></pre>
<p>日志</p>
<pre><code>Installing deploy dependencies
Logged in as @breezetemple ()
dpl.2
Preparing deploy
dpl.3
Deploying application
cd /tmp/d20191005-4465-c01j28/work
commit f8ff418258f8f1f8dd5320c2db79c46ce628d742
Author: Deployment Bot (from Travis CI) &lt;deploy@travis-ci.org&gt;
Date:   Sat Oct 5 04:04:35 2019 +0000
    Deploy breezetemple/how-to-use-gitbook to github.com/breezetemple/how-to-use-gitbook.git:gh-pages
 .travis.yml                                   |   1 +
 README.md                                     |   5 --
 SUMMARY.md                                    |  18 ----
 _book/.gitignore                              |  16 ----
 _book/.travis.yml                             |  16 ----
 basic-usage/README.md                         | 122 --------------------------
 {_book/basic-usage =&gt; basic-usage}/index.html |   2 +-
 book.json                                     |  50 -----------
 customize/README.md                           |   4 -
 {_book/customize =&gt; customize}/book.json.html |   2 +-
 ...
 4759 files changed, 13 insertions(+), 610832 deletions(-)
cd -</code></pre><h3 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h3><pre><code class="yaml">language: generic
before_install:
- npm install -g gitbook-cli
- rm -rf _build
install:
- gitbook install
- gitbook build
script:
- git checkout --orphan gh-pages
- git rm --cached -r .
- git clean -df
- rm -rf *~
- echo &quot;*~&quot; &gt; .gitignore
- echo &quot;_book&quot; &gt;&gt; .gitignore
- echo &quot;node_modules&quot; &gt;&gt; .gitignore
- git add .gitignore
- git commit -m &quot;Ignore some files&quot;
- cp -r _book/* .
- git add .
- git commit -m &quot;Publish book&quot;
- git push --force --quiet &quot;https://${GITHUB_TOKEN}@${GH_REF}&quot; gh-pages:gh-pages
branches:
  only:
  - master
env:
  global:
  - GH_REF: github.com/breezetemple/how-to-use-gitbook.git
  - secure: encrypted data</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://neveryu.github.io/2019/02/05/travis-ci/" target="_blank" rel="noopener">使用 Travis CI 自动更新 GitHub Pages</a></li>
<li><a href="https://www.karlzhou.com/2016/05/28/travis-ci-deploy-blog/" target="_blank" rel="noopener">用 Travis CI 自动部署 Hexo 博客</a></li>
<li><a href="https://github.com/nukc/how-to-use-travis-ci" target="_blank" rel="noopener">如何简单入门使用 Travis-CI 持续集成</a></li>
<li><a href="https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/" target="_blank" rel="noopener">使用 Travis CI 自动更新 GitHub Pages</a></li>
<li><a href="https://segmentfault.com/a/1190000019067492" target="_blank" rel="noopener">用 Travis CI 自动部署 Github Pages</a></li>
<li><a href="http://blog.code4hire.com/2016/06/adding-github-token-to-travis-ci-configuration/" target="_blank" rel="noopener">Adding GitHub token to Travis CI configuration</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
        <category>CI</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>ci</tag>
        <tag>gitbook</tag>
        <tag>travis ci</tag>
      </tags>
  </entry>
  <entry>
    <title>GitBook 指南</title>
    <url>/2019/10/03/how-to-use-gitbook/</url>
    <content><![CDATA[<p><code>GitBook</code> 使用指南，升级到 <code>v3</code></p>
<ul>
<li><a href="https://docs.gitbook.com/v2-changes/important-differences" target="_blank" rel="noopener">Important differences</a></li>
</ul>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ sudo npm install -g gitbook-cli
$ gitbook --version
CLI version: 2.3.2
GitBook version: 3.2.3</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>$ gitbook init
$ gitbook install
$ gitbook build
$ gitbook server
$ gitbook serve --port 50000</code></pre><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre><code>$ gitbook init
warn: no summary file in this book
info: create README.md
info: create SUMMARY.md
info: initialization is finished
$ tree
.
├── README.md
└── SUMMARY.md</code></pre><h2 id="book-json"><a href="#book-json" class="headerlink" title="book.json"></a>book.json</h2><p>可以通过配置 <code>book.json</code> 文件来修改 <code>gitbook</code> 在编译书籍时的行为，例如：修改书籍的名称，显示效果等等。</p>
<p><a href="https://chrisniael.gitbooks.io/gitbook-documentation/content/format/configuration.html" target="_blank" rel="noopener">配置</a></p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p><a href="http://gitbook.zhangjikai.com/plugins.html#emphasize" target="_blank" rel="noopener">GitBook 插件</a></p>
<ul>
<li>Syntax highlighting (prism)</li>
<li>Image captions (image-captions)</li>
<li>Heading anchors (headings)</li>
<li>Easily selecting code snippet content (copy-code)</li>
<li>Algolia’s search (algolia, lunr)</li>
<li>Google Analytics (ga)</li>
<li>Edit on GitHub button (github, github-buttons)</li>
<li>Page’s table of content (atoc, toc)</li>
<li>Code block filename/tabs (codeblock-filename, code-tabs)</li>
</ul>
<h2 id="gitbook-com"><a href="#gitbook-com" class="headerlink" title="gitbook.com"></a>gitbook.com</h2><p><a href="https://www.gitbook.com/" target="_blank" rel="noopener">GitBook.com</a> 是一个围绕 <code>gitbook</code> 发行书籍的社区，于 <code>2014</code> 年初创，<code>GitBook.com</code> 提供免费和付费的服务</p>
<h2 id="集成-GitHub"><a href="#集成-GitHub" class="headerlink" title="集成 GitHub"></a>集成 GitHub</h2><p><code>GitBook.com</code> 还可以集成 <code>GitHub</code>，所以用户可以将书籍的源码通过 <code>GitHub</code> 上的项目来管理，这样可以使用 <code>GitHub</code> 带来的各种优点</p>
<p><code>GitBook</code> -&gt; <code>Space</code> -&gt; <code>INTEGRATIONS</code> -&gt; <code>GitHub</code> -&gt; <code>Select Repository</code></p>
<h2 id="发布到-GitHub-Pages"><a href="#发布到-GitHub-Pages" class="headerlink" title="发布到 GitHub Pages"></a>发布到 GitHub Pages</h2><p>除了能够将书籍发布到 <code>GitBook.com</code> 外，还可以将书籍发布到 <code>GitHub Pages</code>，可以通过如下地址访问书籍：<code>&lt;username&gt;.github.io/&lt;project&gt;</code></p>
<pre><code class="shell">$ gitbook build

$ git checkout --orphan gh-pages
$ git rm --cached -r .
$ git clean -df
$ rm -rf *~

$ echo &quot;*~&quot; &gt; .gitignore
$ echo &quot;_book&quot; &gt;&gt; .gitignore
$ echo &quot;node_modules&quot; &gt;&gt; .gitignore
$ git add .gitignore
$ git commit -m &quot;Ignore some files&quot;

$ cp -r _book/* .
$ git add .
$ git commit -m &quot;Publish book&quot;

$ git push -u origin gh-pages</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
        <category>GitBook</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>markdown</tag>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>pyenv 和 pipenv</title>
    <url>/2019/09/25/pyenv-and-pipenv/</url>
    <content><![CDATA[<ul>
<li><strong>pyenv</strong> <a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">github</a> - <strong>python 版本管理器</strong><blockquote>
<p>Simple Python version management</p>
</blockquote>
</li>
<li><strong>pipenv</strong> <a href="https://github.com/pypa/pipenv" target="_blank" rel="noopener">github</a> - <strong>python 包管理器，更好用的 pip</strong><blockquote>
<p>Python Development Workflow for Humans. Pipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world.</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<h2 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h2><pre><code>git clone https://github.com/yyuu/pyenv.git ~/.pyenv

echo &#39;export PATH=~/.pyenv/bin:$PATH&#39; &gt;&gt; ~/.zshrc
echo &#39;export PYENV_ROOT=~/.pyenv&#39; &gt;&gt; ~/.zshrc
echo &#39;eval &quot;$(pyenv init -)&quot;&#39; &gt;&gt; ~/.zshrc

source ~/.zshrc</code></pre><h2 id="pipenv"><a href="#pipenv" class="headerlink" title="pipenv"></a>pipenv</h2><p>其中一条特性<code>Automatically install required Pythons, if pyenv is available.</code>，配合<code>pyenv</code>可以管理<code>python</code>版本</p>
<pre><code>pip3 install pipenv</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>$ cd test
$ pipenv --two
Creating a virtualenv for this project…
$ pipenv shell</code></pre><p>新建的虚拟环境存放在<code>~/.local/share/virtualenvs/</code>下，想要删除这个环境，直接删除这个文件夹</p>
<p>常用命令</p>
<ul>
<li>pipenv install</li>
<li>pipenv install bs4</li>
<li>pipenv install django==1.11</li>
<li>pipenv install –dev django</li>
<li>pipenv install -r requirements.txt</li>
<li>pipenv uninstall –all</li>
<li>pipenv uninstall django==1.11</li>
<li>pipenv graph</li>
<li>pipenv update requests</li>
<li>pipenv update</li>
<li>pipenv shell</li>
<li>pipenv –rm</li>
<li>pipenv run pip install pip==18.0</li>
<li>pipenv run pip uninstall pip==18.0</li>
<li>pipenv run xxx.py</li>
<li>pipenv lock</li>
<li>exit</li>
</ul>
<h3 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h3><p>修改目录下的<code>Pipfile</code>文件</p>
<pre><code>阿里云：http://mirrors.aliyun.com/pypi/simple/
豆瓣：http://pypi.douban.com/simple/
清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/
中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple/</code></pre><p><strong>注意部分源访问存在问题</strong></p>
<p>修改为使用清华大学源</p>
<pre><code>$ pipenv install django==1.11
Installing django==1.11…
Adding django to Pipfile&#39;s [packages]…
✔ Installation Succeeded
Pipfile.lock not found, creating…
Locking [dev-packages] dependencies…
Locking [packages] dependencies…
✔ Success!
Updated Pipfile.lock (f9ea0f)!
Installing dependencies from Pipfile.lock (f9ea0f)…
  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 2/2 — 00:00:03
$ pipenv graph
Django==1.11
  - pytz [required: Any, installed: 2019.2]</code></pre><h2 id="zsh-增加-virtualenv-支持"><a href="#zsh-增加-virtualenv-支持" class="headerlink" title="zsh 增加 virtualenv 支持"></a>zsh 增加 virtualenv 支持</h2><pre><code class="zsh">POWERLEVEL9K_PYTHON_ICON=$&#39;\U1F40D&#39;
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(battery root_indicator dir dir_writable vcs virtualenv)</code></pre>
<p>修改<code>~/.oh-my-zsh/custom/themes/powerlevel10k/internal/p10k.zsh</code></p>
<pre><code>prompt_virtualenv() {
  [[ -n $VIRTUAL_ENV ]] || return
  local msg=&#39;&#39;
  if [[ $POWERLEVEL9K_VIRTUALENV_SHOW_PYTHON_VERSION == true ]] &amp;&amp; _p9k_python_version; then
    msg=&quot;$_P9K_RETVAL &quot;
  fi
  fullname=${${VIRTUAL_ENV:t}//\%/%%}
  msg+=${fullname%%-*}
  &quot;$1_prompt_segment&quot; &quot;$0&quot; &quot;$2&quot; &quot;blue&quot; &quot;$DEFAULT_COLOR&quot; &#39;PYTHON_ICON&#39; 0 &#39;&#39; &quot;$msg&quot;
}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.zhihu.com/question/65283716" target="_blank" rel="noopener">Pipenv 和 Pyenv 区别？</a></li>
<li><a href="https://juejin.im/entry/5c4ae2ef518825259312657d" target="_blank" rel="noopener">为什么你应该在项目中使用 pyenv+Pipenv：为项目设置超棒的本地开发工作流之秘籍</a></li>
<li><a href="https://segmentfault.com/a/1190000012837890" target="_blank" rel="noopener">pipenv 更优雅的管理你的 python 开发环境</a></li>
<li><a href="https://www.v2ex.com/t/451681" target="_blank" rel="noopener">使用 pipenv 代替 virtualenv 管理 Python 包</a></li>
<li><a href="http://www.liujiangblog.com/blog/18/" target="_blank" rel="noopener">pipenv 新款 Python 虚拟环境工具详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
        <category>Env</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyenv</tag>
        <tag>pipenv</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>电信 IPTV Vlan 及相关原理</title>
    <url>/2019/09/19/iptv-and-802-1q-vlan/</url>
    <content><![CDATA[<p>不增加交换机前提下的 IPTV 单线复用，涉及</p>
<ul>
<li>VLAN</li>
<li>路由 -Padavan</li>
<li>光猫</li>
<li>IPoE</li>
</ul>
<a id="more"></a>

<p><code>K2P</code>刷<code>Merlin</code>固件未搞定，最终刷入<code>Padavan</code>固件搞定</p>
<h2 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h2><h3 id="无线"><a href="#无线" class="headerlink" title="无线"></a>无线</h3><p>可以接受<code>IPTV</code>使用无线，未尝试</p>
<p><a href="https://zhuanlan.zhihu.com/p/27008904" target="_blank" rel="noopener">改造“电信天翼 E 家”有线 IPTV 为无线 IPTV</a><br><a href="https://www.zhihu.com/question/22701366" target="_blank" rel="noopener">怎样实现无线上网和无线看 IPTV 并存？</a><br><a href="https://www.jianshu.com/p/e1a6cc637007" target="_blank" rel="noopener">IPTV 突破限制使用 Wi-Fi 连接</a></p>
<h3 id="单线服用"><a href="#单线服用" class="headerlink" title="单线服用"></a>单线服用</h3><p><a href="https://koolshare.cn/thread-133393-1-1.html" target="_blank" rel="noopener">单线复用详细教程，完美解决弱电箱到电视墙一条网线的</a><br><a href="https://www.jianshu.com/p/52a5317744a1" target="_blank" rel="noopener">利用 VLAN 单线复用 Internet 与 IPTV</a></p>
<ol>
<li>修改<code>xx_Other_B_VID_xxx</code>, 取消<code>LAN 端口</code>绑定，记下<code>VlanID</code></li>
<li>修改<code>xx_INTERNET_R_VID_XX</code>, 取消<code>LAN 端口</code>绑定， 记下<code>VlanID</code></li>
<li>在<code>VLAN 绑定</code>中将上述两个绑定到<code>网口 1</code></li>
</ol>
<h2 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h2><h3 id="Merlin"><a href="#Merlin" class="headerlink" title="Merlin"></a>Merlin</h3><p>失败</p>
<h3 id="Padavan"><a href="#Padavan" class="headerlink" title="Padavan"></a>Padavan</h3><ol>
<li>启动<code>IGMP/MLD 侦听</code></li>
<li><code>M2U- 以太网交换机</code>设置为<code>M2U</code></li>
<li><code>无线 2.4G</code>和<code>无线 5G</code>设置为<code>禁用</code></li>
<li><code>外部网络</code>中<code>端口隔离和 VLAN 过滤</code>设置如下</li>
</ol>
<p><img src="/images/router/2116010118.jpg" alt="setting"></p>
<h2 id="高级方案"><a href="#高级方案" class="headerlink" title="高级方案"></a>高级方案</h2><p><a href="https://bbs.ui.com.cn/t/iptv/48689" target="_blank" rel="noopener">IPTV 终极组网方案（单线、无线、多终端）</a></p>
<ul>
<li>udpxy</li>
<li>mac clone</li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>交换机方案未使用</p>
<p><a href="https://koolshare.cn/thread-147680-1-1.html" target="_blank" rel="noopener">GS108E/GS105E/GT-AC5300 单线复用教程</a><br><a href="https://www.right.com.cn/forum/thread-254465-1-1.html" target="_blank" rel="noopener">IPTV 的单线复用详细设置（天邑 tewa 系列）</a><br><a href="https://koolshare.cn/thread-147076-1-1.html" target="_blank" rel="noopener">梅林自启脚本实现 VLAN 单线复用 + 任意房间 web 管理</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.zhihu.com/question/35749997" target="_blank" rel="noopener">IPOE 到底是什么？</a></li>
<li><a href="https://blog.51cto.com/86484/154523" target="_blank" rel="noopener">IPoE 方式提供 IPTV 业务解决方案</a></li>
<li><a href="https://www.jianshu.com/p/be829575b490" target="_blank" rel="noopener"><strong>VLAN 技术</strong></a></li>
<li><a href="https://shaozhuangfeng.github.io/2017/02/13/IPTV%E6%9C%BA%E9%A1%B6%E7%9B%92%E5%AE%B6%E5%BA%AD%E7%BB%84%E7%BD%91%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9/" target="_blank" rel="noopener">为何推荐 IPTV 机顶盒采用 PPPoE/IPoE 拨号方式观看视频</a></li>
<li><a href="https://post.smzdm.com/p/471548/" target="_blank" rel="noopener">使用梅林路由，丢掉 IPTV 盒子，实现局域网内任意终端观看直播</a></li>
<li><a href="https://blog.csdn.net/shanzhizi/article/details/8176992" target="_blank" rel="noopener">802.1Q Vlan 原理简介</a></li>
<li><a href="https://blog.51cto.com/enchen/154173" target="_blank" rel="noopener">基于端口的 vlan 介绍</a></li>
<li><a href="https://guihet.com/padavan-pppoe-lan-iptv.html" target="_blank" rel="noopener">Padavan 固件单线复用 PPPOE、LAN 局域网、IPTV 网络电视</a></li>
</ol>
]]></content>
      <categories>
        <category>Hacker</category>
        <category>K2P</category>
      </categories>
      <tags>
        <tag>pppoe</tag>
        <tag>k2p</tag>
        <tag>padavan</tag>
        <tag>iptv</tag>
        <tag>ipoe</tag>
        <tag>802.1q</tag>
        <tag>vlan</tag>
        <tag>switch</tag>
        <tag>untagging</tag>
        <tag>tagging</tag>
        <tag>udpxy</tag>
        <tag>iptv 分享</tag>
      </tags>
  </entry>
  <entry>
    <title>移除 sshkey 记录</title>
    <url>/2019/09/18/remove-sshkey/</url>
    <content><![CDATA[<p>vps 重装之后需要清除之前的记录</p>
<a id="more"></a>

<pre><code class="shell">$ ssh-keygen -f &quot;~/.ssh/known_hosts&quot; -R &quot;x.x.x.x&quot;</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>sshkey</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>重装 vps 之后 ping 不通</title>
    <url>/2019/09/18/vps-unreachable/</url>
    <content><![CDATA[<p>重装<code>vps</code>之后<code>ping</code>不通记录原因及解决方案</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><code>vps</code>重装为<code>centos7</code>后出现如下问题</p>
<pre><code>From x.x.x.x icmp_seq=150 Destination Host Unreachable
From x.x.x.x icmp_seq=151 Destination Host Unreachable
From x.x.x.x icmp_seq=152 Destination Host Unreachable
From x.x.x.x icmp_seq=153 Destination Host Unreachable
From x.x.x.x icmp_seq=154 Destination Host Unreachable
From x.x.x.x icmp_seq=155 Destination Host Unreachable
From x.x.x.x icmp_seq=156 Destination Host Unreachable</code></pre><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>通过<code>VNC</code>进入后台发现网卡未启动，并且相关工具未安装</p>
<pre><code class="shell">yum install net-tools</code></pre>
<p>修改<code>/etc/sysconfig/network-scipts/ifcfg-eth0</code>中<code>onboot=yes</code>，开机启动网卡</p>
<p>修改之后重启网卡<code>service network restart</code></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>centos7</tag>
        <tag>net-tools</tag>
        <tag>ping</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 markdown 编辑器 typora 绘制流程图</title>
    <url>/2019/09/17/flowchart-in-markdown/</url>
    <content><![CDATA[<p>使用插件<code>mermaid</code>支持在<code>typora</code>中绘制流程图</p>
<a id="more"></a>

<h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><p><a href="http://knsv.github.io/mermaid/#/" target="_blank" rel="noopener">mermaid</a></p>
<p><code>nodejs</code>安装<code>sudo npm install -g mermaid</code></p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>在<code>Typora</code>中启用<code>mermaid</code>如下</p>
<pre><code class="markdown">\```mermaid
graph LR
A[Hard edge] --&gt;B(Round edge)
    B --&gt; C{Decision}
    C --&gt;|One| D[Result one]
    C --&gt;|Two| E[Result two]
\```</code></pre>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><a href="https://blog.csdn.net/Subson/article/details/78054689" target="_blank" rel="noopener">Markdown 里面使用 mermaid 画流程图</a><br><a href="https://www.jianshu.com/p/af48cc77b57a" target="_blank" rel="noopener">typora 中使用流程图</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>mermaid</tag>
        <tag>flowchart</tag>
      </tags>
  </entry>
  <entry>
    <title>k2p 刷机</title>
    <url>/2019/09/13/k2p/</url>
    <content><![CDATA[<p><code>K2P</code>刷机，包括<code>A2/B2</code></p>
<a id="more"></a>

<h2 id="k2p-型号"><a href="#k2p-型号" class="headerlink" title="k2p 型号"></a>k2p 型号</h2><ul>
<li>k2p A: MTK</li>
<li>k2p B: BCM</li>
</ul>
<h2 id="刷机方式"><a href="#刷机方式" class="headerlink" title="刷机方式"></a>刷机方式</h2><p><a href="https://www.right.com.cn/forum/thread-486659-1-1.html" target="_blank" rel="noopener">给想刷 K2P 官改的朋友们提供的的刷机教程 A1A2B1</a></p>
<ul>
<li>Broadcom - CFE miniWeb Server / Tftpd</li>
<li>BREED</li>
<li>Opboot</li>
</ul>
<p>Breed、opboot、CFE、官方 boot 我们统一称做 Bootloader，相当于计算机的 BIOS，用于路由器的启动和引导。<br>K2、K2P MTK 官方出厂的叫 uboot，K3、K2P BCM、AC9 等博通系出厂是 CFE<br>K2 可以用 breed 来替换官方 uboot，K2P 可以选 breed 或 opboot 来替换官方 uboot，替换后，就可以在 breed 或 opboot 中刷写第三方固件或官方固件。所谓不死，就是会自动去掉固件中的 BootLoader 部分，防止被覆盖，即使刷写固件失败，也还是可以重新进行 breed 或 opboot。</p>
<h3 id="CFE"><a href="#CFE" class="headerlink" title="CFE"></a>CFE</h3><p><a href="https://www.right.com.cn/forum/thread-575973-1-1.html" target="_blank" rel="noopener">k2p 2019/5/10 K2P B1 华硕 382.51610 固件</a><br><a href="http://www.ittel.cn/archives/798.html" target="_blank" rel="noopener">K3 V21.5.37.246 刷官改图文教程</a><br><a href="https://www.right.com.cn/forum/thread-254919-1-1.html" target="_blank" rel="noopener">k2p 斐讯 K2P 金色博通版本开启 telnet、固件备份、恢复的方法</a></p>
<p>电脑打开浏览器（浏览器建议使用 chrome，在无痕窗口下工作，以免自动填充功能造成副作用），并下载一个 ftp 服务器程序</p>
<ol>
<li>使用网线将电脑有线网卡连接到路由器 LAN 口，断开无线连接。下文将连接到路由器上的电脑有线网卡简称为网卡。</li>
<li>确定好路由器的 LAN IP 地址。比如运行的是官方 / 官改，那 LAN IP 就是 192.168.2.1；运行的是梅林 / 华硕，就是 192.168.1.1，其他情况或者不确定的话可以在【控制面板、网络和 Internet\ 网络连接】里查看网卡的网关地址。下文以 192.168.x.1 表示路由器 LAN IP。</li>
<li>如果运行的是官方 / 官改固件，那还需要多一步操作：将网卡的 IP 地址设置为和路由器 LAN IP 在同一个网段的静态地址。比如路由器 LAN IP 是 192.168.2.1，那就需要手动将网卡 IP 设置为 192.168.2.2 - 192.168.2.254 中的一个，因为官方 / 官改进入 CFE 后路由器是不会自动分配 IP 地址的。华硕 / 梅林会给网卡分配一个 192.168.1.17 的 IP，如果没有分配，也是一样的操作。下文以 192.168.x.y 表示进入 CFE 后网卡的 IP 地址。<strong>同时网络类型必须为专用网络</strong></li>
<li>在电脑上打开 cmd 或者 powershell 命令行窗口，输入命令 ping 192.168.x.1 -t 后回车，放在一边供观察，将路由器断电，按住路由器的 RESET 按键不放，再次通电，观察 ping 命令输出的结果，当出现【来自 192.168.x.1 的回复：字节 =32 时间&lt;1ms TTL=100】时，就意味着路由器已经进入 CFE，此时可以松开 RESET 按钮了。</li>
<li>浏览器打开 192.168.x.1，看看是不是一个含有 CFE miniWeb Server 字样的页面，如果没有，多刷新几下，或者检查之前的操作是不是有疏漏错误。</li>
<li>打开 tftpd 程序，点击 Browse 按钮将 Current Directory 选成固件所在的目录，下拉 Server Interfaces 选中 IP 地址为 192.168.x.y 的网卡选项。</li>
<li>以固件 K2P_B1_ASUSWRT_382_51610_20190510.trx 为例，在浏览器中打开 <a href="http://192.168.x.1/do.htm?cmd=flash+-noheader+192.168.x.y:K2P_B1_ASUSWRT_382_51610_20190510.trx+flash0.trx，当看到" target="_blank" rel="noopener">http://192.168.x.1/do.htm?cmd=flash+-noheader+192.168.x.y:K2P_B1_ASUSWRT_382_51610_20190510.trx+flash0.trx，当看到</a> tftpd 程序弹出传输进度条的时候，请关闭这个浏览器页面，以免发生二次传输。</li>
<li>固件文件传输完成之后，路由器会对 ping 命令失去响应。当 ping 重新输出 【来自 192.168.x.1 的回复：字节 =32 时间&lt;1ms TTL=100】时，就表示刷写完成。</li>
<li>此时用浏览器打开 192.168.x.1（有时需要多刷新几次才能打开），点击页面下方 reboot 将路由器重启，同时将网卡改为自动获得 IP 地址，并关闭命令行窗口和 tftpd 程序。</li>
<li>路由器重启完成之后，网卡会自动获得 IP 地址，浏览器打开 192.168.x.1（并不一定是上面的 192.168.x.1，要看网卡的网关地址），进入路由器后台，依次找到【系统管理 - 恢复 / 导出 / 上传设置 - 原厂默认值】，点击【恢复】按钮进行初始化。</li>
<li>初始化完成之后，浏览器打开 192.168.1.1 进入后台进行配置，配置完成后重启一次路由器，到此全部步骤完成。</li>
</ol>
<h3 id="BREED"><a href="#BREED" class="headerlink" title="BREED"></a>BREED</h3><p><a href="https://ericclose.github.io/phicomm-k2p-Padavan.html" target="_blank" rel="noopener">斐讯 K2P 刷 BREED 和 Padavan</a><br><a href="https://opt.cn2qq.com/padavan/" target="_blank" rel="noopener">Padavan 下载地址</a></p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="刷入官改-k2p-bcm-v17-bin"><a href="#刷入官改-k2p-bcm-v17-bin" class="headerlink" title="刷入官改 k2p_bcm_v17.bin"></a>刷入官改 k2p_bcm_v17.bin</h3><pre><code># 计算机设置为固定 IP：192.168.2.2
# 计算机接路由器 LAN，按住复位键开电，按 10 秒左右松开
# 访问 http://192.168.2.1，确认可以打开 CFE 的 miniweb

# 开启系统自带 tftp 服务器，重启一次。
# 打开 tftpd，将固件解压后放入 tftpd 同一目录
# tftpd 中选择 192.168.2.2 的网卡

# 在计算机浏览器上输入
http://192.168.2.1/do.htm?cmd=flash+-noheader+192.168.2.2:k2p_bcm_v17.bin+flash0.trx
# 上传固件完成之后，至少等待 5 分钟，断电复位

# 重新将 IP 设置为自动 IP</code></pre><h3 id="备份编程器固件以及-8-个分区"><a href="#备份编程器固件以及-8-个分区" class="headerlink" title="备份编程器固件以及 8 个分区"></a>备份编程器固件以及 8 个分区</h3><pre><code># 启动系统自带的 telnet
# K2P 高级设置中，打开 ssh 和 telnet
# telnet 登陆 K2P
telnet 192.168.2.1
# 生成编程器固件
cat /dev/mtd0 /dev/mtd1 /dev/mtd3 /dev/mtd4 /dev/mtd5 /dev/mtd6 /dev/mtd7 &gt; /tmp/all.bin
# 查看生成的固件大小是否为 16777216 字节
ls -l /tmp/all.bin
# 挂载到 web 上
mount --bind /tmp/all.bin /www/web-static/fonts/icofont.eot
# 浏览器下载编程器固件
http://192.168.2.1/web-static/fonts/icofont.eot
# 下载后将 icofont.eot 改名为 all.bin
# 确认固件大小为 16777216 字节

# 依次备份 mtd0-mtd7 这 8 个分区
# 生成分区备份文件
dd if=/dev/mtd0 of=/tmp/mtd0
# 挂载到 web 上
mount --bind /tmp/mtd0 /www/web-static/fonts/icofont.eot
# 下载后改名 mtd0.bin
http://192.168.2.1/web-static/fonts/icofont.eot</code></pre><h3 id="刷入梅林-K2P-Merlin-V12-trx"><a href="#刷入梅林-K2P-Merlin-V12-trx" class="headerlink" title="刷入梅林 K2P_Merlin_V12.trx"></a>刷入梅林 K2P_Merlin_V12.trx</h3><pre><code># 前面几步与刷入官改相似
# 在计算机浏览器上输入
http://192.168.2.1/do.htm?cmd=flash+-noheader+192.168.2.2:K2P_Merlin_V12.trx+flash0.trx
# 上传固件完成之后，至少等待 5 分钟，断电复位
# 重新将 IP 设置为自动 IP

# 恢复出厂设置，固件的缺省地址变更为 http://192.168.1.1
http://192.168.2.1/do.htm?cmd=nvram+erase

# 在 web 的“系统管理”-“系统设置”页面打开 ssh
# ssh 登陆
ssh -p 22 admin@192.168.1.1
# 设置 WAN 口地址
nvram set wan0_hwaddr=FC:7C:02:9E:9F:35
# 设置 LAN 口地址
nvram set lan_hwaddr=FC:7C:02:9E:9F:36
nvram set et0macaddr=FC:7C:02:9E:9F:36
# 设置 2.4G 地址
nvram set wl_hwaddr=FC:7C:02:9E:9F:37
nvram set wl0_hwaddr=FC:7C:02:9E:9F:37
nvram set 0:macaddr=FC:7C:02:9E:9F:37
# 设置 5G 地址
nvram set wl1_hwaddr=FC:7C:02:9E:9F:38
nvram set sb/1/macaddr=FC:7C:02:9E:9F:38

# 保存上述设置
nvram commit</code></pre><h3 id="K2P-B2-Merlin-刷回官改"><a href="#K2P-B2-Merlin-刷回官改" class="headerlink" title="K2P B2 Merlin 刷回官改"></a>K2P B2 Merlin 刷回官改</h3><p><a href="http://www.upantool.com/sense/luyouqi/13424.html" target="_blank" rel="noopener">斐讯 K2P 金色博通版开启 telnet+ 固件备份 / 恢复教程</a></p>
<p>刷会分区 1、4、5 即可</p>
]]></content>
      <categories>
        <category>Hacker</category>
        <category>K2P</category>
      </categories>
      <tags>
        <tag>k2p</tag>
        <tag>padavan</tag>
        <tag>merlin</tag>
        <tag>breed</tag>
      </tags>
  </entry>
  <entry>
    <title>私有化部署 wiki 文档</title>
    <url>/2019/08/30/wiki-and-gitbook/</url>
    <content><![CDATA[<p>使用 <code>gitbook</code> 开源框架私有化部署 <code>wiki</code></p>
<a id="more"></a>

<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><ul>
<li>git repository - github 或 private</li>
<li>gitbook</li>
<li>travisCI</li>
<li>wiki</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.zhihu.com/question/19677718" target="_blank" rel="noopener">哪个开源的 wiki 系统比较好用？</a></li>
<li><a href="http://zitiao.org/deploy/" target="_blank" rel="noopener">通过 GitBook 开源框架和 GitHub 私有化部署 Wiki 文档</a></li>
<li><a href="https://segmentfault.com/q/1010000000585030" target="_blank" rel="noopener">有没有这样的团队 wiki: git+markdown 可视化编辑</a></li>
<li><a href="https://www.zhihu.com/question/21029766" target="_blank" rel="noopener">有没有基于 Markdown 的 wiki 开源项目？</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>gitbook</tag>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>gerrit draft and topic</title>
    <url>/2019/08/30/gerrit-draft-and-topic/</url>
    <content><![CDATA[<p>介绍<code>draft</code>和<code>topic</code>两个功能</p>
<a id="more"></a>

<h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><p><code>Gerrit</code>相对<code>Git</code>提供了一个特有的命名空间<code>refs/for/</code>用来定义我们的提交上传到哪个<code>branch</code>，且可以用来区分我们的<code>commit</code>是提交到<code>Gerrit</code>进行审核还是直接提交到<code>Git</code>仓库，格式如下：</p>
<p><code>refs/for/&lt;target-branch&gt;</code></p>
<ul>
<li>Push 一个 Commit 到 Gerrit: <code>git push origin HEAD:refs/for/master</code></li>
<li>直接 Push 一个 commit 到 Git 仓库：（默认配置成不允许） <code>git push origin HEAD:master</code></li>
</ul>
<p>当<code>commit Push</code>到<code>Gerrit</code>等待<code>review</code>时，<code>Gerrit</code>会将此<code>commit</code>保存在一个名为<code>refs/changes/xx/yy/zz</code>的一个暂存<code>branch</code>中。</p>
<ul>
<li><code>zz</code>为这个<code>commit</code>的<code>patch set</code>号</li>
<li><code>yy</code>是<code>change</code>号</li>
<li><code>xx</code>是<code>change</code>号的后两位</li>
</ul>
<h2 id="Draft"><a href="#Draft" class="headerlink" title="Draft"></a>Draft</h2><p><code>refs/drafts/&lt;target branch&gt;</code></p>
<pre><code class="shell">$ git push origin HEAD:refs/drafts/xxx</code></pre>
<p>在<code>Gerrit</code>中点击<code>Publish</code>按钮转换为正式<code>Change</code></p>
<h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><p><code>refs/for/&lt;target branch&gt;</code><br><code>refs/for/&lt;target branch&gt;/&lt;topic name&gt;</code></p>
<pre><code class="shell">$ git push origin HEAD:refs/for/xxx%topic=123
$ git push origin HEAD:refs/for/xxx/123</code></pre>
<p><code>Topic</code>用于归类相关的提交，可以用上述的命令，同时可以在<code>Gerrit</code>中编辑<code>Topic</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://nofluffjuststuff.com/magazine/2016/04/understanding_and_applying_gerrit_part_3_gerrit_submit_types_and_git_review" target="_blank" rel="noopener">Understanding and Applying Gerrit, Part 3: Gerrit Submit Types and Git-Review</a></li>
<li><a href="https://stackoverflow.com/questions/18106064/how-to-push-drafts-to-gerrit" target="_blank" rel="noopener">How to push Drafts to Gerrit?</a></li>
<li><a href="https://www.jianshu.com/p/b77fd16894b6" target="_blank" rel="noopener">代码检视工具 Gerrit 的日常使用</a></li>
<li><a href="https://wiki.qt.io/Gerrit_Introduction" target="_blank" rel="noopener">Gerrit Introduction</a></li>
<li><a href="https://git.eclipse.org/r/Documentation/user-upload.html" target="_blank" rel="noopener">Gerrit Code Review - Uploading Changes</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>repo</tag>
        <tag>gerrit</tag>
        <tag>draft</tag>
        <tag>topic</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins 使用 repo 管理代码出现错误</title>
    <url>/2019/08/29/jenkins-cannot-run-program-repo/</url>
    <content><![CDATA[<p><code>Jenkins</code>中<code>repo</code>环境变量设置</p>
<a id="more"></a>

<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><pre><code>[EnvInject] - Loading node environment variables.
Building remotely on mini-slave in workspace /Users/build/jenkins/workspace/job-64
[Destination_Directory] $ repo init -u ssh://source.company.local/git/product-manifest -b feature_branch
java.io.IOException: Cannot run program &quot;repo&quot; (in directory &quot;/Users/build/jenkins/workspace/job-64/Destination_Directory&quot;): error=2, No such file or directory
at java.lang.ProcessBuilder.processException(ProcessBuilder.java:478)</code></pre><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><p><code>jenkins</code> -&gt; <code>manage</code> -&gt; <code>configure</code> -&gt; <code>Repo</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://issues.jenkins-ci.org/browse/JENKINS-20309" target="_blank" rel="noopener">Repo(Gerrit) is behaving differently than from the command line.</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>CI</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>repo</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>源码中移除注释</title>
    <url>/2019/08/28/remove-comments-from-C/</url>
    <content><![CDATA[<p>怎样从<code>C</code>工程中移除注释以及<code>#if 0</code>代码</p>
<ol>
<li>GCC</li>
<li>unifdef</li>
<li>sunifdef</li>
<li>scc-snapshots</li>
</ol>
<a id="more"></a>

<h2 id="GCC-preprocesse"><a href="#GCC-preprocesse" class="headerlink" title="GCC preprocesse"></a>GCC preprocesse</h2><pre><code class="gcc">gcc -fpreprocessed -dD -E app_test.c</code></pre>
<ul>
<li><code>-fpreprocessed</code> Indicate to the preprocessor that the input file has already been preprocessed.</li>
<li><code>-dD</code> Dump all macro definitions, at the end of preprocessing, in addition to normal output.</li>
<li><code>-E</code> the linker is not run</li>
</ul>
<h2 id="scc-snapshots"><a href="#scc-snapshots" class="headerlink" title="scc-snapshots"></a>scc-snapshots</h2><p><a href="https://github.com/jleffler/scc-snapshots" target="_blank" rel="noopener">scc-snapshots</a></p>
<pre><code class="shell">$ sunifdef -DDEFINED -ned &lt; app_test.c &gt; 2.c</code></pre>
<h2 id="unifdef"><a href="#unifdef" class="headerlink" title="unifdef"></a>unifdef</h2><p><a href="https://github.com/fanf2/unifdef" target="_blank" rel="noopener">unifdef</a></p>
<h2 id="sunifdef"><a href="#sunifdef" class="headerlink" title="sunifdef"></a>sunifdef</h2><p><a href="https://github.com/rwy0717/sunifdef" target="_blank" rel="noopener">sunifdef</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.cnblogs.com/cnland/archive/2013/02/08/2909248.html" target="_blank" rel="noopener">GCC几个选项学习</a></li>
<li><a href="https://stackoverflow.com/questions/2394017/remove-comments-from-c-c-code" target="_blank" rel="noopener">Remove comments from C/C++ code</a></li>
<li><a href="https://github.com/jleffler/scc-snapshots" target="_blank" rel="noopener">scc-snapshots</a></li>
<li><a href="https://stackoverflow.com/questions/52248143/remove-code-between-if-0-and-endif-when-exporting-a-c-file-to-a-new-one" target="_blank" rel="noopener">Remove code between #if 0 and #endif when exporting a C file to a new one</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>c</tag>
        <tag>preprocesse</tag>
        <tag>unifdef</tag>
        <tag>sunifdef</tag>
      </tags>
  </entry>
  <entry>
    <title>hashmap 时间复杂度</title>
    <url>/2019/08/28/hashtable/</url>
    <content><![CDATA[<p>理解时间复杂度以及Hash</p>
<a id="more"></a>

<h2 id="常用数据结构时间复杂度"><a href="#常用数据结构时间复杂度" class="headerlink" title="常用数据结构时间复杂度"></a>常用数据结构时间复杂度</h2><table>
<thead>
<tr>
<th>数据结构</th>
<th>根据关键字查找</th>
<th>根据索引查找</th>
<th>插入</th>
<th>删除</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>有序数组</td>
<td>O(logn)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>有序链表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉树（一般情况）</td>
<td>O(logn)</td>
<td></td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>二叉树（最坏情况）</td>
<td>O(n)</td>
<td></td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>平衡树</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>排序二叉树</td>
<td>O(logn)~O(n)</td>
<td>O(logn)~O(n)</td>
<td>O(logn)~O(n)</td>
<td>O(logn)~O(n)</td>
</tr>
<tr>
<td>哈希表</td>
<td>O(1)</td>
<td></td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash 是将数据离散的一种算法，根据 key 来获取 value，核心在与 hash 函数的实现：</p>
<pre><code class="c">index = f(key, array_size)</code></pre>
<p>常用方法：</p>
<ul>
<li>除留余数法 <code>h(k) = k mod p</code></li>
<li>平方散列法 <code>h(k) = k*k &gt;&gt; 28</code></li>
<li>斐波那契（Fibonacci）散列法 <code>h(k) = (value * 2654435769) &gt;&gt; 28</code></li>
</ul>
<h2 id="hash-collision-resolution"><a href="#hash-collision-resolution" class="headerlink" title="hash collision resolution"></a>hash collision resolution</h2><p>hash 为了达成 O(1) 的时间复杂度，需要保证数据完全离散，当 hash 时根据选择的方法会产生碰撞，这是需要解决碰撞以保证离散散列</p>
<ul>
<li>Separate chaining<br><img src="/images/hash/separate_chaining.png" alt=""></li>
<li>Open addressing<br><img src="/images/hash/open_addressing.png" alt=""><ul>
<li><a href="https://en.wikipedia.org/wiki/Linear_probing" target="_blank" rel="noopener">Linear probing - 线性探查</a></li>
<li><a href="https://en.wikipedia.org/wiki/Quadratic_probing" target="_blank" rel="noopener">Quadratic probing - 二次探查</a></li>
<li><a href="https://en.wikipedia.org/wiki/Double_hashing" target="_blank" rel="noopener">Double hashing - 再散列</a></li>
</ul>
</li>
</ul>
<p>关于以上几种解决碰撞的优缺点比较见 <a href="https://www.geeksforgeeks.org/hashing-set-3-open-addressing/" target="_blank" rel="noopener">Hashing | Set 3 (Open Addressing)</a></p>
<ul>
<li>链表法计算简单，计算量少</li>
<li>链表法不会填满</li>
<li>链表易于删除插入</li>
<li>链表法对散列函数和装载因子不敏感，开地址法为避免聚类和性能下降<blockquote>
<p>Open addressing requires extra care for to avoid clustering and load factor.</p>
</blockquote>
</li>
<li>当数据量以及插入删除频率不确定时使用链表法，反之使用开地址法</li>
<li>链表法需要额外的存储空间</li>
<li>链表法可能浪费空间，部分hash项未使用</li>
<li>链表的缓存性能不佳</li>
</ul>
<h2 id="hash-load-factor"><a href="#hash-load-factor" class="headerlink" title="hash load factor"></a>hash load factor</h2><p>泊松分布选择 0.75</p>
<ul>
<li>数据量固定时也可以选择开地址法构建 hashmap</li>
<li>当数据量固定时选择 <code>4/3倍</code> 以使数据离散减少碰撞</li>
<li>当数据量不固定时达到装载因子时进行扩容</li>
</ul>
<h2 id="separate-chaining"><a href="#separate-chaining" class="headerlink" title="separate chaining"></a>separate chaining</h2><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node {
    int key;
    int val;
    struct node *next;
};

struct table {
    int size;
    struct node **list;
};

struct table *createTable(int size)
{
    struct table *t = (struct table *)malloc(sizeof(struct table));
    t-&gt;size = size;
    t-&gt;list = (struct node **)malloc(sizeof(struct node *)*size);
    int i;
    for (i = 0; i &lt; size; i++)
        t-&gt;list[i] = NULL;
    return t;
}

int hashCode(struct table *t, int key)
{
    if (key &lt; 0)
        return -(key % t-&gt;size);
    return key % t-&gt;size;
}

void insert(struct table *t, int key, int val)
{
    int pos = hashCode(t, key);
    struct node *list = t-&gt;list[pos];
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    struct node *temp = list;
    while (temp) {
        if (temp-&gt;key == key) {
            temp-&gt;val = val;
            return;
        }
        temp = temp-&gt;next;
    }
    newNode-&gt;key = key;
    newNode-&gt;val = val;
    newNode-&gt;next = list;
    t-&gt;list[pos] = newNode;
}

int lookup(struct table *t, int key)
{
    printf(&quot;lookup key %d\n&quot;, key);
    int pos = hashCode(t, key);
    struct node *list = t-&gt;list[pos];
    struct node *temp = list;
    while (temp) {
        if (temp-&gt;key == key) {
            printf(&quot;(%d, %d)\n&quot;, temp-&gt;key, temp-&gt;val);
            return temp-&gt;val;
        }
        printf(&quot;(%d, %d) -&gt; &quot;, temp-&gt;key, temp-&gt;val);
        temp = temp-&gt;next;
    }
    return -1;
}

void display(struct table *t, int size)
{
    int i = 0;
    for (i = 0; i &lt; size; i++) {
        printf(&quot;[%d]&quot;, i);
        struct node *temp = t-&gt;list[i];
        while(temp) {
            printf(&quot;(%d, %d)&quot;, temp-&gt;key, temp-&gt;val);
            temp = temp-&gt;next;
        }
        printf(&quot;\n&quot;);
    }
}

int main()
{
    struct table *t = createTable(10);
    insert(t, 2, 3);
    insert(t, 1, 20);
    insert(t, 22, 70);
    insert(t, 42, 80);
    insert(t, 4, 25);
    insert(t, 12, 44);
    insert(t, 14, 32);
    insert(t, 17, 11);
    insert(t, 13, 78);
    insert(t, 37, 97);
    display(t, 10);
    lookup(t, 2);
    return 0;
}</code></pre>
<p>hashmap如下</p>
<pre><code class="shell">$ ./a.out
[0]
[1](1, 20)
[2](12, 44)(42, 80)(22, 70)(2, 3)
[3](13, 78)
[4](14, 32)(4, 25)
[5]
[6]
[7](37, 97)(17, 11)
[8]
[9]
lookup key 2
(12, 44) -&gt; (42, 80) -&gt; (22, 70) -&gt; (2, 3)</code></pre>
<h2 id="open-addressing"><a href="#open-addressing" class="headerlink" title="open addressing"></a>open addressing</h2><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node {
    int key;
    int val;
};

struct table {
    int size;
    struct node **list;
};

struct table *createTable(int size)
{
    struct table *t = (struct table *)malloc(sizeof(struct table));
    t-&gt;size = size;
    t-&gt;list = (struct node **)malloc(sizeof(struct node *)*size);
    int i;
    for (i = 0; i &lt; size; i++)
        t-&gt;list[i] = NULL;
    return t;
}

int hashCode(struct table *t, int key)
{
    if (key &lt; 0)
        return -(key % t-&gt;size);
    return key % t-&gt;size;
}

void insert(struct table *t, int key, int val)
{
    int pos = hashCode(t, key);
    int n = 0;

    printf(&quot;\033[1;32mInsert (%d, %d) in %d\n\033[0m&quot;, key, val, pos);
    while(t-&gt;list[pos]) {
        printf(&quot;(%d, %d) -&gt; &quot;, t-&gt;list[pos]-&gt;key, t-&gt;list[pos]-&gt;val);
        pos = hashCode(t, pos + 1);
        n++;
        if (n == t-&gt;size)
            break;
    }

    if (n == t-&gt;size)
        printf(&quot;Hash table was full of elements\nNo Place to insert this element\n\n&quot;);
    else {
        struct node *newNode = (struct node *)malloc(sizeof(struct node));
        newNode-&gt;key = key;
        newNode-&gt;val = val;
        t-&gt;list[pos] = newNode;
        printf(&quot;(%d, %d)\n&quot;, key, val);
    }

    struct node *list = t-&gt;list[pos];
}

int lookup(struct table *t, int key)
{
    int pos = hashCode(t, key);
    int n = 0;

    printf(&quot;lookup key %d\n&quot;, key);
    while (n != t-&gt;size) {
        if (t-&gt;list[pos] &amp;&amp; t-&gt;list[pos]-&gt;key == key) {
            printf(&quot;(%d, %d)\n&quot;, t-&gt;list[pos]-&gt;key, t-&gt;list[pos]-&gt;val);
            printf(&quot;Element found at index %d\n&quot;,pos);
            break;
        }
        else {
            if (t-&gt;list[pos])
                printf(&quot;(%d, %d) -&gt; &quot;, t-&gt;list[pos]-&gt;key, t-&gt;list[pos]-&gt;val);
            pos = hashCode(t, pos + 1);
        }
    }

    return -1;
}

void display(struct table *t, int size)
{
    int i = 0;
    for (i = 0; i &lt; size; i++) {
        printf(&quot;[%d]&quot;, i);
        struct node *temp = t-&gt;list[i];
        printf(&quot;(%d, %d)&quot;, temp-&gt;key, temp-&gt;val);
        printf(&quot;\n&quot;);
    }
}

int main()
{
    struct table *t = createTable(10);
    insert(t, 2, 3);
    insert(t, 1, 20);
    insert(t, 22, 70);
    insert(t, 42, 80);
    insert(t, 4, 25);
    insert(t, 12, 44);
    insert(t, 14, 32);
    insert(t, 17, 11);
    insert(t, 13, 78);
    insert(t, 37, 97);
    display(t, 10);
    printf(&quot;%d\n&quot;, lookup(t, 13));
    return 0;
}</code></pre>
<p>hashmap如下</p>
<pre><code class="shell">$ ./a.out
[0](37, 97)
[1](1, 20)
[2](2, 3)
[3](22, 70)
[4](42, 80)
[5](4, 25)
[6](12, 44)
[7](14, 32)
[8](17, 11)
[9](13, 78)
lookup key 13
(22, 70) -&gt; (42, 80) -&gt; (4, 25) -&gt; (12, 44) -&gt; (14, 32) -&gt; (17, 11) -&gt; (13, 78)</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/2ff96b2e20fb" target="_blank" rel="noopener">数据结构与算法：hashtable</a></li>
<li><a href="https://www.jianshu.com/p/bf1d7eee28d0" target="_blank" rel="noopener">Hash 算法总结</a></li>
<li><a href="https://blog.csdn.net/v_JULY_v/article/details/6256463" target="_blank" rel="noopener">从头到尾解析 Hash 表算法</a></li>
<li><a href="https://blog.csdn.net/MOMONGA/article/details/51578602" target="_blank" rel="noopener">常用数据结构增删查时间复杂度</a></li>
<li><a href="https://runestone.academy/runestone/books/published/pythonds/SortSearch/Hashing.html" target="_blank" rel="noopener">Hashing</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hash_table#Collision_resolution" target="_blank" rel="noopener">Hash table</a></li>
<li><a href="https://www.geeksforgeeks.org/hashing-set-1-introduction/" target="_blank" rel="noopener">Hashing</a></li>
<li><a href="https://www.hollischuang.com/archives/2091" target="_blank" rel="noopener">全网把Map中的hash()分析的最透彻的文章，别无二家</a></li>
<li><a href="https://www.cnblogs.com/aspirant/p/8902285.html" target="_blank" rel="noopener">HashMap, HashTable，HashSet,TreeMap 的时间复杂度 注意数组链表 增删改查的时间复杂度都不相同</a></li>
<li><a href="https://www.cnblogs.com/aspirant/p/11470928.html" target="_blank" rel="noopener">HashMap默认加载因子为什么选择0.75？</a></li>
<li><a href="https://blog.csdn.net/donggua3694857/article/details/64127131" target="_blank" rel="noopener">关于HashMap的时间复杂度O(1)的思考</a></li>
<li><a href="https://blog.csdn.net/MrH929/article/details/52039781" target="_blank" rel="noopener">离散hash优化总结</a></li>
<li><a href="https://www.jianshu.com/p/281137bdc223" target="_blank" rel="noopener">HashMap三两事</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>Hash</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>hashtable</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins-multi-configuration</title>
    <url>/2019/08/28/jenkins-multi-configuration/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/32f6c2e08161" target="_blank" rel="noopener">Jenkins Multi-configuration Project 使用体验</a></li>
<li><a href="https://www.howtoing.com/how-to-install-jenkins-on-ubuntu-18-04" target="_blank" rel="noopener">如何在 Ubuntu 18.04 上安装 Jenkins</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>iso8601 时间格式以及转换</title>
    <url>/2019/08/20/iso8601-and-utc/</url>
    <content><![CDATA[<p><code>iso8601</code>与时间戳之间的转换</p>
<a id="more"></a>

<h2 id="ISO8601"><a href="#ISO8601" class="headerlink" title="ISO8601"></a><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO8601</a></h2><p><code>ISO8601</code>是国际标准化组织的日期和时间的表示方法，常见如下</p>
<ul>
<li>日期<ul>
<li><code>2019-09-11</code></li>
</ul>
</li>
<li>UTC 日期与时间<ul>
<li><code>2019-09-11T01:54:23+00:00</code></li>
<li><code>2019-09-11T01:54:23Z</code></li>
<li><code>20190911T015423Z</code></li>
</ul>
</li>
<li>周数<ul>
<li><code>2019-W37</code></li>
</ul>
</li>
<li>日期与周数<ul>
<li><code>2019-W37-3</code></li>
</ul>
</li>
<li>无年份标示之日期<ul>
<li><code>--09-11[1]</code></li>
</ul>
</li>
<li>当年度累积日数<ul>
<li><code>2019-254</code></li>
</ul>
</li>
</ul>
<p>其中日期与时间合并表达时，需要在时间前加<code>T</code>。<br>如果时间在零时区，并恰好与协调世界时相同，那么在时间最后加一个大写字母<code>Z</code>。<code>Z</code>是相对协调世界时时间<code>0</code>偏移的代号。</p>
<h2 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="noopener">UTC</a></h2><p><code>UTC</code>协调世界时是最主要的世界时间标准</p>
<h2 id="影响时间转换的环境变量TZ"><a href="#影响时间转换的环境变量TZ" class="headerlink" title="影响时间转换的环境变量TZ"></a>影响时间转换的环境变量<code>TZ</code></h2><p>时间函数除了<code>gmttime</code>、<code>asctime</code>不受环境变量<code>TZ</code>的影响外，大部分函数都受到环境变量<code>TZ</code>的影响，这几个函数是：<code>localtime</code>、<code>mktime</code>、<code>ctime</code>和<code>strftime</code>。如果定义了<code>TZ</code>，则这些函数将使用其值以代替系统默认时区。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="ISO8601-to-timestamp"><a href="#ISO8601-to-timestamp" class="headerlink" title="ISO8601 to timestamp"></a><code>ISO8601</code> to <code>timestamp</code></h3><p><code>char *strptime(const char *s, const char *format, struct tm *tm)</code>将时间格式字符串<code>S</code>按指定格式<code>foramt</code>解析成<code>tm</code>；再用<code>time_t mktime(struct tm *tm)</code>函数将<code>tm</code>生成时间戳。</p>
<pre><code class="c">static time_t _iso8601_to_timestamp(const char *str)
{
    struct tm ttime = {0};

    if (!str) {
        return 0;
    }
    strptime(str, &quot;%Y-%m-%dT%H:%M:%SZ&quot;, &amp;ttime);
    return mktime(&amp;ttime);
}</code></pre>
<p>或者获取当前时间戳</p>
<pre><code class="c">time_t now;
time(&amp;now);
printf(&quot;now:%ld&quot;,now);</code></pre>
<h3 id="timestamp-to-STRING"><a href="#timestamp-to-STRING" class="headerlink" title="timestamp to STRING"></a><code>timestamp</code> to <code>STRING</code></h3><p>和时间操作相关的关键数据结构是<code>struc tm</code>，其定义如下：</p>
<pre><code class="c">struct tm {
    int tm_sec;    /* Seconds (0-60) */
    int tm_min;    /* Minutes (0-59) */
    int tm_hour;   /* Hours (0-23) */
    int tm_mday;   /* Day of the month (1-31) */
    int tm_mon;    /* Month (0-11) */
    int tm_year;   /* Year - 1900 */
    int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
    int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
    int tm_isdst;  /* Daylight saving time */
};</code></pre>
<p>在将时间戳表示成指定格式前，我们需要将时间戳转换成 tm 数据结构。</p>
<ol>
<li><code>struct tm *gmtime(const time_t *timep)</code></li>
<li><code>struct tm *localtime(const time_t *timep)</code></li>
</ol>
<p><code>gtime</code>转换后的<code>tm</code>是基于时区<code>0</code>的，而<code>localtime</code>转换后的是基于当地时区</p>
<p>利用接口 <code>size_t strftime(char *s, size_t max, const char *format,const struct tm *tm)</code> 来定制我们的时间格式</p>
<pre><code class="c">time_t t;
time(&amp;t);
struct tm *tmp_time = localtime(&amp;t);
char s[100];
strftime(s, sizeof(s), &quot;%04Y%02m%02d %H:%M:%S&quot;, tmp_time);
printf(&quot;%d: %s\n&quot;, (int)t, s);</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://segmentfault.com/q/1010000004333145/a-1020000004333940" target="_blank" rel="noopener">UTC 和 ISO 8601 时间格式的一些疑问</a></li>
<li><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO 8601</a></li>
<li><a href="https://blog.csdn.net/u013457167/article/details/79021913" target="_blank" rel="noopener">时间日期与时间戳转换</a></li>
<li><a href="https://www.jianshu.com/p/8ff0ec67e34b" target="_blank" rel="noopener">c 语言中的时间戳和时间格式</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>Functions</category>
      </categories>
      <tags>
        <tag>iso8601</tag>
        <tag>utc</tag>
        <tag>timezone</tag>
        <tag>timestamp</tag>
      </tags>
  </entry>
  <entry>
    <title>理解编程语言中的数据类型</title>
    <url>/2019/07/18/type-of-data/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2009/05/data_types_and_json.html" target="_blank" rel="noopener">数据类型和 Json 格式</a></p>
<a id="more"></a>

<p>从结构上看，所有的数据<code>data</code>最终都可以分解成三种类型：</p>
<ol>
<li>第一种类型是<strong>标量</strong><code>scalar</code>，也就是一个单独的字符串<code>string</code>或数字<code>numbers</code>，比如<code>北京</code>这个单独的词</li>
<li>第二种类型是<strong>序列</strong><code>sequence</code>，也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组<code>array</code>或列表<code>List</code>，比如<code>北京，上海</code></li>
<li>第三种类型是<strong>映射</strong><code>mapping</code>，也就是一个名 / 值对<code>Name/value</code>，即数据有一个名称，还有一个与之相对应的值，这又称作散列<code>hash</code>或字典<code>dictionary</code>，比如<code>首都：北京</code></li>
</ol>
<p><strong>在编程语言中，只要有了数组<code>array</code>和对象<code>object</code>就能够储存一切数据了</strong></p>
<ol>
<li><a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">json</a></li>
<li><a href="https://yaml.org/" target="_blank" rel="noopener">yaml</a></li>
</ol>
<p>其中<code>json</code>介绍如下</p>
<p>JSON 建构于两种结构：</p>
<ul>
<li><code>名称 / 值</code>对的集合<code>A collection of name/value pairs</code>。不同的语言中，它被理解为对象<code>object</code>，纪录<code>record</code>，结构<code>struct</code>，字典<code>dictionary</code>，哈希表<code>hash table</code>，有键列表<code>keyed list</code>，或者关联数组 <code>associative array</code></li>
<li>值的有序列表<code>An ordered list of values</code>。在大部分语言中，它被理解为数组<code>array</code></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 定时器</title>
    <url>/2019/07/15/linux-timer/</url>
    <content><![CDATA[<p><code>time api</code>使用，定时器管理</p>
<ul>
<li><code>clock_gettime</code></li>
<li><code>timespec_to_timeval</code></li>
<li><code>timeradd</code></li>
<li><code>timersub</code></li>
<li><code>timercmp</code></li>
</ul>
<a id="more"></a>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><pre><code class="c">enum
{
    DSMCC_TIMEOUT_DSI,
    DSMCC_TIMEOUT_DII,
    DSMCC_TIMEOUT_MODULE,
    DSMCC_TIMEOUT_NEXTBLOCK
};

struct dsmcc_timeout
{
    struct dsmcc_object_carousel *carousel;  /*&lt; carousel this timeout applies to */
    int                           type;      /*&lt; type of timeout */
    uint16_t                      module_id; /*&lt; module ID, for type == DSMCC_TIMEOUT_MODULE or DSMCC_TIMEOUT_NEXTBLOCK */
    struct timeval                abstime;   /*&lt; absolute time */

    struct dsmcc_timeout *next;
};</code></pre>
<h2 id="add-remove"><a href="#add-remove" class="headerlink" title="add/remove"></a>add/remove</h2><pre><code class="c">void dsmcc_timeout_remove(struct dsmcc_object_carousel *carousel, int type, uint16_t module_id)
{
    struct dsmcc_timeout *current, *prev;

    current = carousel-&gt;state-&gt;timeouts;
    prev = NULL;
    while (current)
    {
        int match = current-&gt;carousel == carousel &amp;&amp; current-&gt;type == type;
        if (type == DSMCC_TIMEOUT_MODULE || type == DSMCC_TIMEOUT_NEXTBLOCK)
            match &amp;= current-&gt;module_id == module_id;
        if (match)
        {
            if (prev)
                prev-&gt;next = current-&gt;next;
            else
                carousel-&gt;state-&gt;timeouts = current-&gt;next;
            free(current);
            return;
        }
        prev = current;
        current = current-&gt;next;
    }
}

void dsmcc_timeout_set(struct dsmcc_object_carousel *carousel, int type, uint16_t module_id, uint32_t delay_us)
{
    struct dsmcc_timeout *timeout;
    struct dsmcc_timeout *current, *next;
    struct timeval now, delay;
    struct timespec ts;

    dsmcc_timeout_remove(carousel, type, module_id);

    if (!delay_us)
        return;

    DSMCC_DEBUG(&quot;Adding timeout for carousel 0x%08x type %d module id 0x%04hhx delay %uus&quot;, carousel-&gt;cid, type, module_id, delay_us);

    timeout = malloc(sizeof(struct dsmcc_timeout));
    timeout-&gt;carousel = carousel;
    timeout-&gt;type = type;
    timeout-&gt;module_id = module_id;

    clock_gettime(CLOCK_REALTIME, &amp;ts);
    timespec_to_timeval(&amp;ts, &amp;now);

    delay.tv_sec = delay_us / 1000000;
    delay.tv_usec = delay_us - delay.tv_sec * 1000000;
    timeradd(&amp;now, &amp;delay, &amp;timeout-&gt;abstime);

    current = NULL;
    next = carousel-&gt;state-&gt;timeouts;
    while (next &amp;&amp; timercmp(&amp;next-&gt;abstime, &amp;timeout-&gt;abstime, &lt;))
    {
        current = next;
        next = current-&gt;next;
    }
    timeout-&gt;next = next;
    if (current)
        current-&gt;next = timeout;
    else
        carousel-&gt;state-&gt;timeouts = timeout;
}</code></pre>
<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><pre><code class="c">struct dsmcc_timeout *prevtimeout, *timeout, *nexttimeout;

DSMCC_DEBUG(&quot;Current timeouts:&quot;);
timeout = state-&gt;timeouts;
prevtimeout = NULL;
while (timeout)
{
    struct timeval curtime;

    clock_gettime(CLOCK_REALTIME, &amp;ts);
    timespec_to_timeval(&amp;ts, &amp;curtime);

    if (dsmcc_log_enabled(DSMCC_LOG_DEBUG))
    {
        struct timeval waittime;
        timersub(&amp;timeout-&gt;abstime, &amp;curtime, &amp;waittime);
        DSMCC_DEBUG(&quot;CID 0x%08x DELAY %d.%06d TYPE %d MODULE_ID 0x%04hhx&quot;, timeout-&gt;carousel-&gt;cid, waittime.tv_sec, waittime.tv_usec,&gt;
    }

    nexttimeout = timeout-&gt;next;
    if (timercmp(&amp;timeout-&gt;abstime, &amp;curtime, &lt;))
    {
        dsmcc_object_carousel_set_status(timeout-&gt;carousel, DSMCC_STATUS_TIMEDOUT);
        dsmcc_filecache_notify_status(timeout-&gt;carousel, NULL);

        /* remove timeout */
        if (prevtimeout)
            prevtimeout-&gt;next = timeout-&gt;next;
        else
            state-&gt;timeouts = timeout-&gt;next;
        free(timeout);
    }
    timeout = nexttimeout;
}</code></pre>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>头文件<code>sys/time.h</code>定义</p>
<p><strong><code>Unix/Linux</code>都是采用<code>UTC（Universal Coordinated Time）</code>，<code>1970.1.1</code>到现在的秒数，采用<code>time_t（long int）</code>存储。</strong></p>
<p>时间结构体包括<code>time_t</code>, <code>timeval</code>, <code>time_spec</code>，精度越来越高</p>
<pre><code class="c">typedef long time_t</code></pre>
<p>表示为从<code>UTC(coordinated universal time)</code>时间<code>1970 年 1 月 1 日 00 时 00 分 00 秒</code>( 也称为 Linux 系统的 Epoch 时间 ) 到当前时刻的秒数，<strong>只是精确到秒</strong></p>
<pre><code class="c">struct timeval
{
    time_t  tv_sec; // 秒 s
    long    tv_usec;// 微秒 us
};</code></pre>
<p><strong>精确到微秒</strong></p>
<pre><code class="c">struct timespec
{
    long int tv_sec;    // 秒 s
    long int tv_nsec;   // 纳秒 ns
};</code></pre>
<p><strong>精确到纳秒</strong></p>
<h3 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime"></a>clock_gettime</h3><pre><code class="c">#include &lt;time.h&gt;

struct timespec {
    time_t   tv_sec;        /* seconds */
    long     tv_nsec;       /* nanoseconds */
};

int clock_gettime(clockid_t clk_id, struct timespec *tp);</code></pre>
<p><code>clk_id</code>常用：</p>
<ol>
<li><code>CLOCK_REALTIME</code>, 系统实时时间，随系统实时时间改变而改变，即从<code>UTC1970-1-1 0:0:0</code>开始计时，中间时刻如果系统时间被用户改成其他，则对应的时间相应改变</li>
<li><code>CLOCK_MONOTONIC</code>, 从系统启动这一刻起开始计时，不受系统时间被用户改变的影响</li>
</ol>
<h3 id="timespec-to-timeval"><a href="#timespec-to-timeval" class="headerlink" title="timespec_to_timeval"></a>timespec_to_timeval</h3><p><code>struct timespec</code>与<code>struct timespec</code>之间的转换</p>
<pre><code class="c">/* Macros for converting between `struct timeval&#39; and `struct timespec&#39;.  */
# define TIMEVAL_TO_TIMESPEC(tv, ts) {                                   \
        (ts)-&gt;tv_sec = (tv)-&gt;tv_sec;                                    \
        (ts)-&gt;tv_nsec = (tv)-&gt;tv_usec * 1000;                           \
}
# define TIMESPEC_TO_TIMEVAL(tv, ts) {                                   \
        (tv)-&gt;tv_sec = (ts)-&gt;tv_sec;                                    \
        (tv)-&gt;tv_usec = (ts)-&gt;tv_nsec / 1000;                           \
}</code></pre>
<h3 id="timeval-运算"><a href="#timeval-运算" class="headerlink" title="timeval 运算"></a>timeval 运算</h3><p>在<code>sys/time.h</code>中定义了如下运算</p>
<pre><code class="c">/* Convenience macros for operations on timevals.
   NOTE: `timercmp&#39; does not work for &gt;= or &lt;=.  */
# define timerisset(tvp)    ((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)
# define timerclear(tvp)    ((tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0)
# define timercmp(a, b, CMP)                              \
  (((a)-&gt;tv_sec == (b)-&gt;tv_sec) ?                         \
   ((a)-&gt;tv_usec CMP (b)-&gt;tv_usec) :                          \
   ((a)-&gt;tv_sec CMP (b)-&gt;tv_sec))
# define timeradd(a, b, result)                           \
  do {                                        \
    (result)-&gt;tv_sec = (a)-&gt;tv_sec + (b)-&gt;tv_sec;                 \
    (result)-&gt;tv_usec = (a)-&gt;tv_usec + (b)-&gt;tv_usec;                  \
    if ((result)-&gt;tv_usec &gt;= 1000000)                         \
      {                                       \
    ++(result)-&gt;tv_sec;                           \
    (result)-&gt;tv_usec -= 1000000;                         \
      }                                       \
  } while (0)
# define timersub(a, b, result)                           \
  do {                                        \
    (result)-&gt;tv_sec = (a)-&gt;tv_sec - (b)-&gt;tv_sec;                 \
    (result)-&gt;tv_usec = (a)-&gt;tv_usec - (b)-&gt;tv_usec;                  \
    if ((result)-&gt;tv_usec &lt; 0) {                          \
      --(result)-&gt;tv_sec;                             \
      (result)-&gt;tv_usec += 1000000;                       \
    }                                         \
  } while (0)</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Time</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>timer</tag>
        <tag>time</tag>
        <tag>dsmcc</tag>
      </tags>
  </entry>
  <entry>
    <title>ecos 文件系统</title>
    <url>/2019/07/11/ecos-fstab/</url>
    <content><![CDATA[<p>工作中遇到<code>/tmp/tmp_file</code>打开保存失败，记录原因以及解决方案</p>
<a id="more"></a>

<h2 id="1"><a href="#1" class="headerlink" title="#1"></a>#1</h2><p>开发过程中需要保存一些临时文件在内存中，一般路径为<code>/tmp/xxx</code>，在<code>Linux</code>下测试正常，而在<code>Ecos</code>系统下执行<code>open</code>出现异常</p>
<p>测试代码</p>
<pre><code class="c">const char * tmp_file = &quot;/tmp/cache&quot;;
int dst = -1, wsize = 0;
char buf[128] = {0};
dst = open(tmp_file, &quot;w+&quot;);
printf(&quot;dst:%d\n&quot;, dst);
wsize = write(dst, buf, sizeof(buf));
printf(&quot;wsize:%d\n&quot;, wsize);</code></pre>
<p>出现错误</p>
<pre><code>cramfs_open() error:cramfs is readonly filesystem
dst:-1
wsize:-1</code></pre><p>检查<code>ecos/fs</code>发现存在多个文件系统</p>
<ul>
<li>cramfs</li>
<li>ramfs</li>
<li>romfs</li>
<li>minifs</li>
<li>fat</li>
<li>ntfs</li>
</ul>
<p>应用中注册如下</p>
<pre><code>MOD_FAT
MOD_NTFS
//MOD_JFFS2
MOD_CAMFS
MOD_MINIFS
MOD_ROMFS
MOD_RAMFS</code></pre><p>已经支持<code>ramfs</code>内存文件系统，继续检查<code>mount point</code>，<code>fstab</code>如下</p>
<pre><code>/dev/flash/0/5  /home/gx  minifs
NONE  /mnt  ramfs</code></pre><p>可以看到内存文件系统<code>ramfs</code>挂载点为<code>/mnt</code>，修改之后解决问题</p>
<h2 id="ramfs-与-tmpfs"><a href="#ramfs-与-tmpfs" class="headerlink" title="ramfs 与 tmpfs"></a>ramfs 与 tmpfs</h2><p><code>ramfs</code>是下一种基于<code>RAM</code>做存储的文件系统，不会用<code>swap</code>，会因为数据的写入自动增长空间，所以可能导致最后系统所有的内存耗完</p>
<p><code>tmpfs</code>是<code>Linux</code>下的一个文件系统，它将所有的文件都保存在虚拟内存中，<code>umount tmpfs</code>后所有的数据也会丢失，<code>tmpfs</code>就是<code>ramfs</code>的衍生品。<code>tmpfs</code>使用了虚拟内存的机制，它会进行<code>swap</code>，但是它有一个相比<code>ramfs</code>的好处：<code>mount</code>时指定的<code>size</code>参数是起作用的，这样就能保证系统的安全，而不是像<code>ramfs</code>那样，一不留心因为写入数据太大吃光系统所有内存导致系统被<code>hang</code>住。</p>
]]></content>
      <categories>
        <category>Ecos</category>
      </categories>
      <tags>
        <tag>ecos</tag>
        <tag>romfs</tag>
        <tag>ramfs</tag>
        <tag>fstab</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp 选项 SO_LINGER</title>
    <url>/2019/07/04/tcp-option-SO-LINGER/</url>
    <content><![CDATA[<p><code>SO_LINGER</code>选项用于调整<code>close</code>行为，可以设置为强制关闭<code>socket</code>以回收资源</p>
<a id="more"></a>

<p>缺省<code>close</code>的行为是，如果有数据残留在<code>socket</code>发送缓冲区中则系统将继续发送这些数据给对方，等待被确认，然后返回。</p>
<p>利用此选项，可以将此缺省行为设置为以下两种：</p>
<ol>
<li>立即关闭该连接，<strong>通过发送 RST 分组（而不是用正常的 FIN|ACK|FIN|ACK 四个分组）来关闭该连接</strong>。至于发送缓冲区中如果有未发送完的数据，则丢弃。主动关闭一方的 TCP 状态则跳过 TIMEWAIT，直接进入 CLOSED。网上很多人想利用这一点来解决服务器上出现大量的 TIMEWAIT 状态的 socket 的问题，但是，这并不是一个好主意，这种关闭方式的用途并不在这儿，实际用途在于服务器在应用层的需求</li>
<li>将连接的关闭设置一个超时。如果 socket 发送缓冲区中仍残留数据，进程进入睡眠，内核进入定时状态去尽量去发送这些数据。在超时之前，如果所有数据都发送完且被对方确认，内核用正常的 FIN|ACK|FIN|ACK 四个分组来关闭该连接，<code>close</code>成功返回。如果超时之时，数据仍然未能成功发送及被确认，用上述<code>方式 1</code>来关闭此连接。<code>close</code>返回<code>EWOULDBLOCK</code></li>
</ol>
<p>使用如下结构</p>
<pre><code class="c">struct linger {
     int l_onoff; /* 0 = off, nozero = on */
     int l_linger; /* linger time */
};</code></pre>
<ul>
<li><code>l_onoff == 0</code>，则该选项关闭，<code>l_linger</code>的值被忽略，<code>close</code>用上述缺省方式关闭连接</li>
<li><code>l_onoff != 0 &amp;&amp; l_linger == 0</code>，<code>close</code>用上述<code>方式 1</code>关闭连接</li>
<li><code>l_onoff != 0 &amp;&amp; l_linger != 0</code>，<code>close</code>用上述<code>方式 2</code>关闭连接</li>
</ul>
<pre><code class="c">int z; /* Status code */
int s;       /* Socket s */
struct linger so_linger;
...
so_linger.l_onoff = 1;
so_linger.l_linger = 0;
z = setsockopt(s,
    SOL_SOCKET,
    SO_LINGER,
    &amp;so_linger,
    sizeof so_linger);
if ( z )
    perror(&quot;setsockopt(2)&quot;);
close(s); /* Abort connection */</code></pre>
<p>表</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">间隔</th>
<th align="left">关闭方式</th>
<th align="left">等待关闭与否</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SO_DONTLINGER</td>
<td align="left">不关心</td>
<td align="left">优雅</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">SO_LINGER</td>
<td align="left">零</td>
<td align="left">强制</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">SO_LINGER</td>
<td align="left">非零</td>
<td align="left">优雅</td>
<td align="left">是</td>
</tr>
</tbody></table>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/factor2000/article/details/3929816" target="_blank" rel="noopener">setsockopt ：SO_LINGER 选项设置</a></li>
<li><a href="http://www.lenky.info/archives/2013/02/2220" target="_blank" rel="noopener"><strong>Socket 选项系列之 SO_LINGER</strong></a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>network</tag>
        <tag>setsockopt</tag>
        <tag>linger</tag>
      </tags>
  </entry>
  <entry>
    <title>understand-got-and-plt</title>
    <url>/2019/07/02/understand-got-and-plt/</url>
    <content><![CDATA[<p>理解动态链接<code>elf</code>以及实现，重要的两个表</p>
<ol>
<li><code>GOT</code> - <code>Global Offset Table</code> 全局偏移表用于记录在 ELF 文件中所用到的共享库中符号的绝对地址</li>
<li><code>PLT</code> - <code>Procedure Linkage Table</code> 过程链接表的作用是将位置无关的符号转移到绝对地址</li>
</ol>
<a id="more"></a>

<h3 id="libc-so"><a href="#libc-so" class="headerlink" title="libc.so"></a>libc.so</h3><p>在 Linux 中，常用的 C 语言库运行库 glibc 动态链接形式保存在”/lib”目录下，文件名叫做“libc.so”, 整个系统只保留一份 C 语言库的动态链接文件“libc.so”，而所有的 C 语言编写的、动态链接的程序都可以在运行时使用它。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>为了解决静态链接空间浪费和更新困难的问题，设计了动态链接，也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接的基本思想。</p>
<p>动态链接是把链接的过程从本来的程序被装载前推迟到了装载的时候。</p>
<p>这样做虽然很灵活，但是性能受到影响。</p>
<p>这就引出了动态链接的优化方法。</p>
<ul>
<li>装载时重定向</li>
<li>地址无关代码</li>
</ul>
<p>常用命令</p>
<pre><code class="shell">readelf -S test.so
readelf -r test.so
objdump -R test.so
objdump -h test,so</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/" target="_blank" rel="noopener">通过 GDB 调试理解 GOT/PLT</a></li>
<li><a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html" target="_blank" rel="noopener">深入了解 GOT,PLT 和动态链接</a></li>
<li><a href="https://blog.csdn.net/u011987514/article/details/67716639" target="_blank" rel="noopener">浅析 ELF 中的 GOT 与 PLT</a></li>
<li><a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf" target="_blank" rel="noopener">ELF_Format</a></li>
<li><a href="https://www.jianshu.com/p/0ac63c3744dd" target="_blank" rel="noopener">GOT 表和 PLT 表</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>Tools</category>
        <category>Linker</category>
        <category>GCC</category>
        <category>ELF</category>
      </categories>
      <tags>
        <tag>shared</tag>
        <tag>-fpic</tag>
        <tag>got</tag>
        <tag>plt</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 编译参数 -fpic</title>
    <url>/2019/07/02/gcc-fpic/</url>
    <content><![CDATA[<p>记录<code>-fpic</code>参数作用及对执行效率的影响<br>动态链接执行很复杂，比静态链接执行时间长<br>但是，极大的节省了<code>size</code>，<code>PIC</code>和动态链接技术是计算机发展史上非常重要的一个里程碑</p>
<a id="more"></a>

<h2 id="gcc-参数"><a href="#gcc-参数" class="headerlink" title="gcc 参数"></a>gcc 参数</h2><p>相关参数可以使用<code>man gcc</code>查看具体解释</p>
<ul>
<li><code>-fpic</code>，该选项用于生成位置无关代码 (Position-Independent Code)，尤其被用于共享库的创建。使用该选项编译出的代码在访问所有常量地址时，会通过全局偏移表<code>GOT</code>进行计算得到。动态加载器将会在目标程序启动的时候解析<code>GOT</code>的入口（动态加载器不是<code>GCC</code>的一部分，其属于操作系统的一部分）。如果对于需要进行链接的可执行程序来说， 使用的<code>GOT</code>大小超过了<code>machine-specific</code>值指定的最大大小，你将会得到一条来自链接器的错误信息，以表明<code>-fpic</code>无法正常工作；在这种情况下，会使用<code>-fPIC</code>选项再重新编译一次。（这个最大大小限制在<code>SPARC</code>上为<code>8k</code>，在<code>m68k</code>和<code>RS/6000</code>上为<code>32k</code>，而在<code>x86</code>上没有限制）</li>
<li><code>-fPIC</code>，可以避免全局偏移表大小限制的问题外，其它方面和上面的一样</li>
<li><code>-shared</code>，从<code>GCC</code>来看，<code>shared</code>应该是包含<code>-fPIC</code>选项的，但似乎不是所以系统都支持，所以最好显式加上<code>-fPIC</code>选项</li>
</ul>
<p><strong>产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行</strong></p>
<p><strong>如果不加<code>-fPIC</code>, 则加载<code>.so</code>文件的代码段时，代码段引用的数据对象需要重定位，重定位会修改代码段的内容，这就造成每个使用这个<code>.so</code>文件代码段的进程在内核里都会生成这个<code>.so</code>文件代码段的<code>copy</code>. 每个<code>copy</code>都不一样，取决于这个<code>.so</code>文件代码段和数据段内存映射的位置</strong></p>
<p><strong>不加<code>-fPIC</code>编译出来的<code>so</code>, 是要再加载时根据加载到的位置再次重定位的。（因为它里面的代码并不是位置无关代码）</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong><code>non-PIC</code>与<code>PIC</code>代码的区别主要在于<code>access global data</code>, <code>jump label</code> 的不同</strong></p>
<ul>
<li><code>GOT</code>是<code>data section</code>, 是一个<code>table</code>, 除专用的几个<code>entry</code>，每个`entry 的内容可以再执行的时候修改</li>
<li><code>PLT</code>是<code>text section</code>, 是一段一段的<code>code</code>，执行中不需要修改</li>
</ul>
<h3 id="access-global-data"><a href="#access-global-data" class="headerlink" title="access global data"></a>access global data</h3><ul>
<li><code>non-pic</code>: <code>ld r3, var1</code></li>
<li><code>pic</code>: <code>ld r3, var1-offset@GOT</code>.<br>  从<code>GOT</code>表的<code>index</code>为<code>var1-offset</code>的地方处指示的地址处装载一个值，即<code>var1-offset@GOT</code>处的 4 个<code>byte</code>其实就是<code>var1</code>的地址。这个地址只有在运行的时候才知道，是由<code>dynamic-loader(ld-linux.so)</code>填进去的</li>
</ul>
<h3 id="jump-label"><a href="#jump-label" class="headerlink" title="jump label"></a>jump label</h3><ul>
<li><code>non-pic</code>: <code>jump printf</code>. 调用<code>printf</code></li>
<li><code>pic</code>: <code>jump printf-offset@GOT</code>.<br>  跳到<code>GOT</code>表的<code>index</code>为<code>printf-offset</code>的地方处指示的地址去执行。这个地址处的代码摆放在<code>.plt section</code></li>
</ul>
<p>每个外部函数对应一段这样的代码，其功能是呼叫<code>dynamic-loader(ld-linux.so)</code>来查找函数的地址（本例中是<code>printf</code>)，然后将其地址写到<code>GOT</code>表的<code>index</code>为<code>printf-offset</code>的地方，同时执行这个函数。这样，第 2 次呼叫<code>printf</code>的时候，就会直接跳到<code>printf</code>的地址，而不必再查找了。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>$ objdump -xa airkiss

airkiss：     文件格式 elf64-x86-64
airkiss
体系结构：i386:x86-64， 标志 0x00000150：
HAS_SYMS, DYNAMIC, D_PAGED
起始地址 0x0000000000001b80

程序头：
    PHDR off    0x0000000000000040 vaddr 0x0000000000000040 paddr 0x0000000000000040 align 2**3
         filesz 0x00000000000001f8 memsz 0x00000000000001f8 flags r--
  INTERP off    0x0000000000000238 vaddr 0x0000000000000238 paddr 0x0000000000000238 align 2**0
         filesz 0x000000000000001c memsz 0x000000000000001c flags r--
    LOAD off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**21
         filesz 0x000000000000bc70 memsz 0x000000000000bc70 flags r-x
    LOAD off    0x000000000000cb70 vaddr 0x000000000020cb70 paddr 0x000000000020cb70 align 2**21
         filesz 0x00000000000008c8 memsz 0x0000000000000cf8 flags rw-
 DYNAMIC off    0x000000000000cba0 vaddr 0x000000000020cba0 paddr 0x000000000020cba0 align 2**3
         filesz 0x0000000000000200 memsz 0x0000000000000200 flags rw-
    NOTE off    0x0000000000000254 vaddr 0x0000000000000254 paddr 0x0000000000000254 align 2**2
         filesz 0x0000000000000044 memsz 0x0000000000000044 flags r--
EH_FRAME off    0x000000000000accc vaddr 0x000000000000accc paddr 0x000000000000accc align 2**2
         filesz 0x000000000000031c memsz 0x000000000000031c flags r--
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
   RELRO off    0x000000000000cb70 vaddr 0x000000000020cb70 paddr 0x000000000020cb70 align 2**0
         filesz 0x0000000000000490 memsz 0x0000000000000490 flags r--

动态节：
  NEEDED               libiw.so.30
  NEEDED               libc.so.6
  INIT                 0x0000000000001738
  FINI                 0x0000000000009390
  INIT_ARRAY           0x000000000020cb70
  INIT_ARRAYSZ         0x0000000000000008
  FINI_ARRAY           0x000000000020cb78
  FINI_ARRAYSZ         0x0000000000000008
  GNU_HASH             0x0000000000000298
  STRTAB               0x0000000000000a28
  SYMTAB               0x00000000000002d8
  STRSZ                0x00000000000002f2
  SYMENT               0x0000000000000018
  DEBUG                0x0000000000000000
  PLTGOT               0x000000000020cda0
  PLTRELSZ             0x0000000000000618
  PLTREL               0x0000000000000007
  JMPREL               0x0000000000001120
  RELA                 0x0000000000000e08
  RELASZ               0x0000000000000318
  RELAENT              0x0000000000000018
  FLAGS                0x0000000000000008
  FLAGS_1              0x0000000008000001
  VERNEED              0x0000000000000db8
  VERNEEDNUM           0x0000000000000001
  VERSYM               0x0000000000000d1a
  RELACOUNT            0x0000000000000016

版本引用：
  required from libc.so.6:
    0x0d696917 0x00 05 GLIBC_2.7
    0x06969194 0x00 04 GLIBC_2.14
    0x0d696914 0x00 03 GLIBC_2.4
    0x09691a75 0x00 02 GLIBC_2.2.5

节：
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  0000000000000238  0000000000000238  00000238  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.ABI-tag 00000020  0000000000000254  0000000000000254  00000254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.gnu.build-id 00000024  0000000000000274  0000000000000274  00000274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .gnu.hash     00000040  0000000000000298  0000000000000298  00000298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynsym       00000750  00000000000002d8  00000000000002d8  000002d8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dynstr       000002f2  0000000000000a28  0000000000000a28  00000a28  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .gnu.version  0000009c  0000000000000d1a  0000000000000d1a  00000d1a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .gnu.version_r 00000050  0000000000000db8  0000000000000db8  00000db8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rela.dyn     00000318  0000000000000e08  0000000000000e08  00000e08  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rela.plt     00000618  0000000000001120  0000000000001120  00001120  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .init         00000017  0000000000001738  0000000000001738  00001738  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          00000420  0000000000001750  0000000000001750  00001750  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt.got      00000008  0000000000001b70  0000000000001b70  00001b70  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text         00007810  0000000000001b80  0000000000001b80  00001b80  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini         00000009  0000000000009390  0000000000009390  00009390  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata       0000192a  00000000000093a0  00000000000093a0  000093a0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .eh_frame_hdr 0000031c  000000000000accc  000000000000accc  0000accc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 17 .eh_frame     00000c88  000000000000afe8  000000000000afe8  0000afe8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 18 .init_array   00000008  000000000020cb70  000000000020cb70  0000cb70  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 19 .fini_array   00000008  000000000020cb78  000000000020cb78  0000cb78  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 20 .data.rel.ro  00000020  000000000020cb80  000000000020cb80  0000cb80  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 21 .dynamic      00000200  000000000020cba0  000000000020cba0  0000cba0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 22 .got          00000248  000000000020cda0  000000000020cda0  0000cda0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 23 .data         00000438  000000000020d000  000000000020d000  0000d000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 24 .bss          00000428  000000000020d440  000000000020d440  0000d438  2**5
                  ALLOC
 25 .comment      0000002b  0000000000000000  0000000000000000  0000d438  2**0
                  CONTENTS, READONLY
 26 .debug_aranges 00000150  0000000000000000  0000000000000000  0000d463  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_info   00006926  0000000000000000  0000000000000000  0000d5b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_abbrev 00000ec3  0000000000000000  0000000000000000  00013ed9  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_line   000018d1  0000000000000000  0000000000000000  00014d9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_str    00001e7a  0000000000000000  0000000000000000  0001666d  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .debug_ranges 00000030  0000000000000000  0000000000000000  000184e7  2**0
                  CONTENTS, READONLY, DEBUGGING</code></pre>]]></content>
      <categories>
        <category>C</category>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>static</tag>
        <tag>shared</tag>
        <tag>-fpic</tag>
        <tag>-fPIC</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 调试带参数程序</title>
    <url>/2019/06/27/gdb-debug-elf-with-args/</url>
    <content><![CDATA[<p>使用 <code>set args</code> 调试带参数的程序</p>
<a id="more"></a>

<p>例如 <code>a.out</code> 执行命令如下</p>
<pre><code>$ ./a.out -i file -o out.file
$ gdb a.out
(gdb) set args -i file -o out.file
(gdb) r</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>编译只有 configure.ac 文件和 Makefile.am 文件的工程</title>
    <url>/2019/06/20/how-to-compile-project-with-configure-ac-and-Makefile-am/</url>
    <content><![CDATA[<p>使用 <code>configure.ac</code> 和 <code>Makefile.am</code> 生成 <code>configure</code> 用于编译工程</p>
<a id="more"></a>

<h2 id="生成-configure-各文件关系"><a href="#生成-configure-各文件关系" class="headerlink" title="生成 configure 各文件关系"></a>生成 configure 各文件关系</h2><p><img src="/images/autotools/1560997098402.png" alt="1560997098402"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li><code>libtoolize</code> 链接一些脚本，包括 <code>ltmain.sh</code></li>
<li><code>aclocal</code> 扫描所有 <code>m4 macros</code> 生成 <code>aclocal.m4</code></li>
<li><code>autoheader</code> 生成了 configure.h.in 如果在 <code>configure.ac</code> 中定义了 <code>AC_CONFIG_HEADER</code>，那么此文件就需要</li>
<li><code>autoconf</code> expand all the macros used by <code>configure.ac</code> into the <code>configure</code> script</li>
<li><code>automake --add-missing</code> convert all the <code>Makefile.am</code> into <code>Makefile.in</code> templates. 此步主要是为了生成 <code>Makefile.in</code>，加上 <code>--add-missing</code> 参数后，会补全缺少的脚本</li>
<li><code>./configure --prefix=$PWD</code></li>
<li><code>make</code></li>
<li><code>make install</code></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>automake</tag>
        <tag>autoconf</tag>
        <tag>configure</tag>
      </tags>
  </entry>
  <entry>
    <title>gnome 终端和 vim 配色</title>
    <url>/2019/06/03/gnome-terminal-and-vim-color-theme/</url>
    <content><![CDATA[<p><code>gnome terminal</code>和<code>vim</code>配色，以及<code>solarized</code>的使用</p>
<a id="more"></a>


<h2 id="gnome-terminal"><a href="#gnome-terminal" class="headerlink" title="gnome terminal"></a>gnome terminal</h2><ol>
<li>使用<code>bash -c  &quot;$(wget -qO- https://git.io/vQgMr)&quot;</code>安装</li>
<li><code>git clone</code>之后本地安装</li>
</ol>
<h2 id="dircolors"><a href="#dircolors" class="headerlink" title="dircolors"></a>dircolors</h2><p><a href="https://github.com/seebi/dircolors-solarized.git" target="_blank" rel="noopener">dircolors-solarized</a></p>
<pre><code>git clone https://github.com/seebi/dircolors-solarized.git
cp dircolors.256dark ~/.dircolors</code></pre><p>然后在<code>.zshrc</code>中添加如下代码</p>
<pre><code>export TERM=xterm-256color
eval `dircolors ~/.dir_colors`</code></pre><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><pre><code>set background=dark
set termguicolors
colorscheme solarized</code></pre><p>同时修改<code>solarized: L243</code>支持<code>termguicolors</code>，否则会发现蒙了一层灰色</p>
<pre><code>-if (has(&quot;gui_running&quot;) &amp;&amp; g:solarized_degrade == 0)
+if (has(&quot;gui_running&quot;) &amp;&amp; g:solarized_degrade == 0) || has(&#39;termguicolors&#39;)</code></pre><p>可以在<code>~/.vim/plugged/vim-colors-solarized/colors/solarized.vim</code>修改以定制</p>
<p>可以在<code>http://vimdoc.sourceforge.net/htmldoc/syntax.html</code>查找各项定义，例如</p>
<ol>
<li><code>String</code>: a string constant: “this is a string”</li>
<li><code>Number</code>: a number constant: 234, 0xff</li>
<li><code>Function</code>: function name (also: methods for classes)</li>
</ol>
<p>同时可以使用插件<code>fogine/vim-syntaxattr</code>来查询各种颜色定义</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol>
<li><code>terminal</code>需要和<code>vim</code>配色方案保持一定的统一，例如<code>solarized</code>提供全套解决方案</li>
<li>需要检查<code>gnome terminal</code>颜色支持</li>
<li>需要检查<code>vim color theme</code>对终端的颜色支持</li>
</ol>
<h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><ul>
<li><code>gnome terminal</code> - <code>Gogh: solarized dark high contrast</code></li>
<li><code>dircolor</code> - <code>dircolors-solarized: dircolors.256dark</code></li>
<li><code>vim</code> - <code>vim-colors-solarized: solarized dark</code> 修改<code>termguicolors</code></li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.zhihu.com/question/51713545" target="_blank" rel="noopener">为什么 ubuntu vim 中 solarized 配色完全失败？</a></li>
<li><a href="https://www.cnblogs.com/chen-farsight/p/6098219.html" target="_blank" rel="noopener">让 Terminal/vim 使用 Solarized 配色</a></li>
<li><a href="https://github.com/wklken/k-vim/issues/104" target="_blank" rel="noopener">终端不能正常显示问题</a></li>
<li><a href="https://ethanschoonover.com/solarized/" target="_blank" rel="noopener">Solarized</a></li>
<li><a href="https://github.com/ciembor/4bit" target="_blank" rel="noopener">ciembor/4bit - Terminal Color Scheme Designer</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
        <category>Terminal</category>
      </categories>
      <tags>
        <tag>color</tag>
        <tag>vim</tag>
        <tag>gnome</tag>
        <tag>solarized</tag>
      </tags>
  </entry>
  <entry>
    <title>git 免密操作</title>
    <url>/2019/06/03/how-to-avoid-typing-password-repeatedly/</url>
    <content><![CDATA[<p><code>git</code> 免密操作，包括 <code>ssh</code> 和 <code>https</code></p>
<a id="more"></a>

<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>使用 <code>ssh</code> 协议，需要注册公钥到 <code>git</code> 服务器，不再赘述</p>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>使用 <code>credential.helper</code></p>
<ol>
<li>执行 <code>git config --global credential.helper store</code></li>
<li>执行 <code>touch ~/.git-credentials</code>，添加如下内容<pre><code>https://{username}:{password}@github.com</code></pre></li>
</ol>
<p>这个方式存在一个缺点， <code>username</code> 和 <code>password</code> 明文保存</p>
<p>可以使用如下设置保存到 <code>cache</code> 来增加安全性</p>
<p><code>git config --global credential.helper &#39;cache --timeout=3600&#39;</code></p>
<p>另外，可以使用命令将协议从 <code>https</code> 切换到 <code>ssh</code></p>
<p><code>git remote set-url origin git@github.com:yourusername/yourrepositoryname.git</code></p>
<h3 id="加密存储"><a href="#加密存储" class="headerlink" title="加密存储"></a>加密存储</h3><p>** <code>git</code> 也提供了加密存储，可以稍稍增加安全性**</p>
<pre><code class="shell">sudo apt-get install libsecret-1-0 libsecret-1-dev
cd /usr/share/doc/git/contrib/credential/libsecret
sudo make
git config --global credential.helper /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret</code></pre>
<ol>
<li>删除 <code>.git-credentials</code></li>
<li><code>git pull</code>，输入 <code>username</code> 和 <code>password</code></li>
<li>密文保存</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 git 显示中文乱码</title>
    <url>/2019/06/03/git-add-or-st-support-zh/</url>
    <content><![CDATA[<p><code>git st</code> 或 <code>git add</code> 中文显示为乱码，添加如下设置解决此问题</p>
<pre><code>git config --global core.quotepath false</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 GitHub 不能访问的问题</title>
    <url>/2019/06/03/github-error/</url>
    <content><![CDATA[<p>修改 <code>hosts</code> 解决网络正常情况下 <code>github</code> 不能访问的问题</p>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>网络正常的情况下，<code>google</code> 可以访问，<code>github</code> 不能访问</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>通过 <a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS 查询</a> 来查找 <code>A 记录</code></p>
<ol>
<li>通过 <code>http://www.github.com.ipaddress.com/</code> 查询 <code>github</code> 地址</li>
<li>修改 <code>/etc/hosts</code> 文件，增加如下记录<br>```<h1 id="GITHUB-Start"><a href="#GITHUB-Start" class="headerlink" title="GITHUB Start"></a>GITHUB Start</h1></li>
<li>30.253.113 github.com</li>
<li>30.253.113 <a href="http://www.github.com" target="_blank" rel="noopener">www.github.com</a><br>```</li>
<li>重启网络服务 <code>sudo service networking restart</code> 解决此问题</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>github</tag>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title>decryption-ssl-with-wireshark</title>
    <url>/2019/05/31/decryption-ssl-with-wireshark/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://support.citrix.com/article/CTX116557" target="_blank" rel="noopener">How to Decrypt SSL and TLS Traffic Using Wireshark</a></li>
<li><a href="https://serverfault.com/questions/783214/using-wireshark-to-determine-which-rsa-private-key-ssl-conversation" target="_blank" rel="noopener">Using wireshark to determine which RSA PRIVATE KEY SSL conversation?</a></li>
<li><a href="https://blog.csdn.net/u010726042/article/details/53408077" target="_blank" rel="noopener">https（ssl）协议以及 wireshark 抓包分析与解密</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36669377" target="_blank" rel="noopener">Wireshark 对 HTTPS 数据的解密</a></li>
<li><a href="https://support.citrix.com/article/CTX135121" target="_blank" rel="noopener">如何利用 Wireshark 解密 SSL 和 TLS 流量</a></li>
<li><a href="https://www.jianshu.com/p/cf8c2f2cd18a" target="_blank" rel="noopener">Wireshark 抓包理解 HTTPS 请求流程</a></li>
<li><a href="https://github.com/hallelujah-shih/start-learn/tree/master/debug_tls" target="_blank" rel="noopener">关于一些 TLS 的 DEBUG 技巧和工具集介绍</a></li>
<li><a href="https://www.jianshu.com/p/9b34d2bbcb9f" target="_blank" rel="noopener">使用 Wireshark 解密 TLS 1.3 流量</a></li>
<li><a href="https://juejin.im/post/5c71113951882562c85ae36a" target="_blank" rel="noopener">Wireshark 解密 TLS 数据包</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24872509" target="_blank" rel="noopener">HTTPS 报文抓包流程笔记</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>解密 802.11 加密数据包</title>
    <url>/2019/05/31/decryption-802-11-with-wireshark/</url>
    <content><![CDATA[<p>使用 <code>wireshark</code> 分析加密 <code>802.11</code> 数据</p>
<a id="more"></a>

<p>基于 <code>monitor</code> 模式，使用 <code>wireshark</code> 抓取空中包时，只能分析到 <code>802.11</code> 协议层，更底层被加密，此时可以使用 <code>wireshark</code> 来完成解密</p>
<p>设置如下</p>
<p><code>编辑</code> -&gt; <code>首选项</code> -&gt; <code>protocols</code> -&gt; <code>IEEE 802.11</code></p>
<ol>
<li>勾选 <code>Enable decryption</code></li>
<li>编辑 <code>Decryption keys</code><ol>
<li>加密 <code>wep</code> 时，格式为十六进制 ASCII，例如 <code>123456</code> 为 <code>31:32:33:34:35:36</code></li>
<li>加密 <code>WPA</code> 时<ul>
<li><code>WPA-PWD</code> 格式为 <code>PWD:BSSID</code>，例如 <code>123456</code> 为 <code>123456:test</code></li>
<li><code>WPA-PSK</code> 格式为 <code>PSK</code>， <code>PSK</code> 可以在 <a href="https://www.wireshark.org/tools/wpa-psk.html" target="_blank" rel="noopener">wpa-psk</a> 计算出来</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>设置之后，可以看到被 <code>802.11</code> 封装的协议</p>
<ul>
<li><code>os</code> : <code>ubuntu18.04</code></li>
<li><code>wireshark</code> : <code>2.6.8</code></li>
</ul>
<p><del>貌似不是很稳定，重新打开 wireshark 有时不能解密</del><br><del>删除 ~/.config/wireshark 之后重新来过才行</del></p>
<p>使用 <code>WPA-PSK</code> 解密</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/sinat_21455985/article/details/50772659" target="_blank" rel="noopener">解密 WEP 和 WPA-PSK/WPA-PSK 加密的数据包</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>wireshark</tag>
        <tag>802.11</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 下定制 zsh</title>
    <url>/2019/05/27/zsh-Customization/</url>
    <content><![CDATA[<p><code>ubuntu 18.04</code>下定制<code>zsh</code>，包括</p>
<ul>
<li><code>zsh</code></li>
<li><code>oh-my-zsh</code></li>
<li><code>z.lua</code></li>
<li><code>fzf</code></li>
<li><code>syntax-highlighting</code></li>
<li><code>autosuggestions</code></li>
<li><code>powerlevel9k</code></li>
</ul>
<a id="more"></a>

<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><pre><code class="shell"># install zsh
$ sudo apt install zsh

# change default sh to zsh
$ chsh -s /bin/zsh

# change bash to zsh
$ sudo vim /etc/passwd</code></pre>
<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><pre><code class="shell">$ sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre>
<h2 id="z-lua"><a href="#z-lua" class="headerlink" title="z.lua"></a>z.lua</h2><pre><code class="shell">$ cd ~/.oh-my-zsh/custom/plugins
$ git clone https://github.com/skywind3000/z.lua.git</code></pre>
<p>在<code>.zshrc</code>中添加如下配置</p>
<pre><code>eval &quot;$(lua5.3 ~/.oh-my-zsh/custom/plugins/z.lua/z.lua  --init zsh once enhanced)&quot;
export _ZL_ROOT_MARKERS=&quot;.repo,.svn,.hg,.git&quot;
alias zz=&#39;z -c&#39; # 严格匹配当前路径的子路径
alias zi=&#39;z -i&#39; # 使用交互式选择模式
alias zf=&#39;z -I&#39; # 使用 fzf 对多个结果进行选择
alias zb=&#39;z -b&#39; # 快速回到父目录
alias zh=&#39;z -I -t .&#39; # 回到历史路径</code></pre><p>注意<code>lua5.3</code>根据当前系统来选择</p>
<h2 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h2><pre><code class="shell">$ cd ~/.oh-my-zsh/custom/plugins
$ git clone git://github.com/zsh-users/zsh-syntax-highlighting.git</code></pre>
<p>在<code>.zshrc plugins</code>中增加<code>zsh-syntax-highlighting</code></p>
<h2 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h2><pre><code class="shell">$ git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code></pre>
<p>在<code>.zshrc plugins</code>中增加<code>zsh-autosuggestions</code></p>
<p>可以使用<code>ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=5&#39;</code>来改变颜色</p>
<h2 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h2><p>如果<code>vim</code>中已安装<code>junegunn/fzf</code>，例如</p>
<pre><code>Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }</code></pre><p>另外一种方式</p>
<pre><code class="shell">$ git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
$ ~/.fzf/install</code></pre>
<p>最终都是执行<code>install</code>来完成安装</p>
<p>在<code>.zshrc</code>中添加</p>
<pre><code>[ -f ~/.fzf.zsh ] &amp;&amp; source ~/.fzf.zsh</code></pre><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><code>oh-my-zsh</code>内置插件<code>git</code>提供了大量<code>git</code>缩写，可以启用，也可以参考<code>git</code>插件，在<code>.zshrc</code>中添加常用缩写</p>
<h2 id="powerlevel9k"><a href="#powerlevel9k" class="headerlink" title="powerlevel9k"></a>powerlevel9k</h2><p><code>powerlevel9k</code>用于增强显示，需要<code>power line font</code></p>
<pre><code class="shell">$ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k

# powerline &amp; fonts-powerline
$ sudo apt install powerline fonts-powerline

# https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#step-2-install-a-powerline-font
# Option 3: Install Awesome-Powerline Fonts
$ git clone https://github.com/gabrielelana/awesome-terminal-fonts
$ cd awesome-terminal-fonts
$ ./install.sh</code></pre>
<p>在<code>.zshrc</code>中启用<code>powerlevel9k</code>及字体支持</p>
<pre><code>ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;
POWERLEVEL9K_MODE=&#39;awesome-fontconfig&#39;</code></pre><p><code>powerlevel9k</code>高度可定制，参考页面 <a href="https://github.com/bhilburn/powerlevel9k/wiki/Show-Off-Your-Config" target="_blank" rel="noopener">show off your config</a></p>
<p>定制如下</p>
<pre><code>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(battery root_indicator dir dir_writable)
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram time background_jobs command_execution_time)</code></pre><h2 id="dircolor"><a href="#dircolor" class="headerlink" title="dircolor"></a>dircolor</h2><p><code>dircolor</code>影响<code>ls</code>输出，使用命令<code>echo $LS_COLORS</code>可以检查</p>
<p>选择开源工程 <a href="https://github.com/seebi/dircolors-solarized.git" target="_blank" rel="noopener">dircolors-solarized</a></p>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul>
<li><a href="https://github.com/zsh-users/antigen" target="_blank" rel="noopener">antigen</a></li>
<li><a href="https://github.com/zdharma/zplugin" target="_blank" rel="noopener">zplugin</a></li>
<li><a href="https://github.com/black7375/BlaCk-Void-Zsh.git" target="_blank" rel="noopener">zplugin example - BlaCk-Void-Zsh</a></li>
<li><a href="https://github.com/zplug/zplug" target="_blank" rel="noopener">zplug</a></li>
</ul>
<p>在<code>oh-my-zsh</code>安装指南页面，存在一系列安装方式，除了<strong>本文手动方式</strong>，提供了类似<code>vim</code>的管理插件，例如</p>
<ul>
<li>Prezto Install</li>
<li>Antigen Install</li>
<li>Zplug Install</li>
<li>Zgen Install</li>
</ul>
<p>接下来选择使用<code>zplugin</code>来管理<code>.zshrc</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.cnblogs.com/zhuxiaoxi/p/7523677.html" target="_blank" rel="noopener">oh-my-zsh 的安装与基本配置</a></li>
<li><a href="https://www.jianshu.com/p/aba8e3270f65" target="_blank" rel="noopener">zsh 的安装与配置</a></li>
<li><a href="https://g2ex.github.io/2018/01/21/linux-terminal-zsh-notes/" target="_blank" rel="noopener">终端折腾记</a></li>
<li><a href="https://www.jianshu.com/p/8c3f7345aef2" target="_blank" rel="noopener">定制一款漂亮的终端</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56077546" target="_blank" rel="noopener">一个会学习你习惯的 cd 命令 - z.lua</a></li>
<li>[Shell 脚本：模糊搜索神器 fzf, bash 神器，fzf 用法，fzf 详解]([<a href="http://justcode.ikeepstudying.com/2018/03/shell%E8%84%9A%E6%9C%AC%EF%BC%9A%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%99%A8fzf-bash%E7%A5%9E%E5%99%A8-fzf%E7%94%A8%E6%B3%95-fzf%E8%AF%A6%E8%A7%A3/]" target="_blank" rel="noopener">http://justcode.ikeepstudying.com/2018/03/shell%E8%84%9A%E6%9C%AC%EF%BC%9A%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%99%A8fzf-bash%E7%A5%9E%E5%99%A8-fzf%E7%94%A8%E6%B3%95-fzf%E8%AF%A6%E8%A7%A3/]</a>(<a href="http://justcode.ikeepstudying.com/2018/03/shell" target="_blank" rel="noopener">http://justcode.ikeepstudying.com/2018/03/shell</a> 脚本：模糊搜索神器 fzf-bash 神器 -fzf 用法 -fzf 详解 /))</li>
<li><a href="https://www.zhihu.com/question/29977255" target="_blank" rel="noopener">mac 装了 oh my zsh 后比用 bash 具体好在哪儿？</a></li>
<li><a href="https://www.zhihu.com/question/59227720" target="_blank" rel="noopener">有哪些命令行的软件堪称神器？</a></li>
<li><a href="https://gist.github.com/laggardkernel/4a4c4986ccdcaf47b91e8227f9868ded" target="_blank" rel="noopener">Comparison of ZSH frameworks and plugin managers</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Terminal</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>zsh</tag>
        <tag>powerlevel9k</tag>
        <tag>gnome terminal</tag>
        <tag>autojump</tag>
        <tag>z.lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Radiotap、Prism 和 802.11 帧格式分析</title>
    <url>/2019/05/06/radiotap-header-and-802-11-frame/</url>
    <content><![CDATA[<p>在<code>monitor</code>模式下使用<code>wireshark</code>抓包分析<code>802.11</code>帧格式，用于分析<code>Airkiss</code>协议及实现</p>
<a id="more"></a>

<h2 id="802-协议及-OSI-模型"><a href="#802-协议及-OSI-模型" class="headerlink" title="802 协议及 OSI 模型"></a>802 协议及 OSI 模型</h2><ul>
<li>802.2 ：逻辑链路控制 Logical Link Control</li>
<li>802.3 ：以太网 Ethernet （CSMA/CD）</li>
<li>802.11：无线局域网 Wireless LAN</li>
</ul>
<p><code>802.11</code>是一个协议簇，包括物理层规范、增强型 MAC 层规范及高层协议规范。</p>
<p><code>802.11</code>与<code>802.3</code>一样，主要定义了<code>OSI</code>模型中物理层和数据链路层的相关规范，其中数据链路层由<code>MAC</code>子层和<code>LLC</code>子层组成，<code>802.11</code>和<code>802.3</code>的<code>LLC</code>子层统一由<code>802.2</code>描述，<code>802.2</code>是为各种媒介向上层提供一个统一的接口。可不管是有线或者无线，都是以<code>802.2</code>为标准，进行封装的。一张老图描述<code>802</code>协议簇在<code>OSI</code>模型关系</p>
<p><img src="/images/wifi/osi.jpg" alt="OSI"></p>
<h2 id="Radiotap"><a href="#Radiotap" class="headerlink" title="Radiotap"></a>Radiotap</h2><p><a href="http://www.radiotap.org/fields/defined" target="_blank" rel="noopener">Radiotap 官网</a></p>
<p><code>monitor</code>模式下<code>802.11</code>在收到帧之后还要在外边包一层称为<code>prism</code>或<code>radiotap</code>的头部，里面包含无线协议帧相关的信息，诸如信号强度、噪声强度、信道、时间戳等。<code>radiotap</code>比传统的<code>prism</code>或<code>AVS</code>头部更有灵活性，<code>radiotap</code>头已经完全取代了<code>prism</code>，两者功能一样，但前者是后者的扩展。该报头属于<code>802.11</code>的规范内容。</p>
<p><img src="/images/wifi/1557144650029.png" alt="1557144650029"></p>
<p>这个头部是在<code>802.11</code>成帧后（RX）流经内核<code>mac80211</code>层时加上去的，代码在<code>net/mac80211</code>里。所以<strong>这是一个纯软件机制</strong>，这个头部对于底层无意义，像<code>iwconfig</code>, <code>iwlist scanning</code>这些工具显示出来的数据并不依赖这个头部的信息。那么它的用途是什么？答案是供给像<code>wireshark</code>这样的协议分析工具用的，这样这些工具就不用实时从硬件获得 RF 射频信息，直接解析协议报文即可。</p>
<blockquote>
<p> 另外在<code>monitor</code>模式下发送（TX）流经<code>802.11</code>层时需要脱掉<code>radiotap</code>头部，也就是要求编写 raw 套接字程序通过<code>monitor</code>状态的网卡发送<code>802.11</code>帧时，需要手工把<code>radiotap</code>头部加上，否则内核会认为是异常帧而丢弃。</p>
</blockquote>
<h2 id="Prism"><a href="#Prism" class="headerlink" title="Prism"></a>Prism</h2><p>各个帧的头部见 <a href="https://www.tcpdump.org/linktypes.html" target="_blank" rel="noopener">LINK-LAYER HEADER TYPES</a></p>
<p>本文涉及</p>
<ol>
<li><a href="http://www.radiotap.org/" target="_blank" rel="noopener">Radiotap</a></li>
<li><a href="https://www.tcpdump.org/linktypes/LINKTYPE_IEEE802_11_PRISM.html" target="_blank" rel="noopener">Prism</a></li>
</ol>
<p>是在内核中处理，<code>Linux 4.9</code>相关代码<code>linux/if_arp.h</code>及<code>net/mac80211/iface.c</code></p>
<pre><code>#define ARPHRD_IEEE802_TR 800       /* Magic type ident for TR  */
#define ARPHRD_IEEE80211 801        /* IEEE 802.11          */
#define ARPHRD_IEEE80211_PRISM 802  /* IEEE 802.11 + Prism2 header  */
#define ARPHRD_IEEE80211_RADIOTAP 803   /* IEEE 802.11 + radiotap header */

case NL80211_IFTYPE_MONITOR:
  sdata-&gt;dev-&gt;type = ARPHRD_IEEE80211_RADIOTAP;
  sdata-&gt;dev-&gt;netdev_ops = &amp;ieee80211_monitorif_ops;
  sdata-&gt;u.mntr.flags = MONITOR_FLAG_CONTROL | MONITOR_FLAG_OTHER_BSS;
  break;</code></pre><p>因此在<code>Linux 4.9</code>下抓包格式为<code>802.11 plus Radiotap header</code></p>
<p>而在<code>Linux 2.6</code>使用的<code>wifi</code>驱动中有如下代码</p>
<pre><code class="c">#define RTMP_OS_NETDEV_SET_TYPE_MONITOR(_pNetDev)   RTMP_OS_NETDEV_SET_TYPE(_pNetDev, ARPHRD_IEEE80211_PRISM)</code></pre>
<p>因此抓包格式为<code>802.11 plus Prism header</code>，如下<br><img src="/images/wifi/1557230043892.png" alt="1557230043892"></p>
<h2 id="802-11-帧结构"><a href="#802-11-帧结构" class="headerlink" title="802.11 帧结构"></a>802.11 帧结构</h2><p>和所有其他的<code>802</code>链路层一样，<code>802.11</code>可以传输各种不同的网络层协议。<a href="https://warpproject.org/trac/wiki/802.11/MAC/Upper/MACHighFramework/EthEncap" target="_blank" rel="noopener">和以太网不同的是</a>，<code>802.11</code>是以<code>802.2</code>的逻辑链路控制封装来携带上层协议。</p>
<p><code>802.11</code>封装上层协议下图</p>
<p><img src="/images/wifi/1557148199457.png" alt="1557148199457"></p>
<p><code>RFC 1042</code>与<code>802.1H</code>均衍生自<code>802.2</code>的子网络访问协议（sub-network access protocol ，简称<code>SNAP</code> ）</p>
<p><strong>当<code>AP</code>使用加密模式时，<code>802.11 MAC payload</code>为加密状态，看不到内部封装，只有在非加密状态才能解包分析</strong></p>
<p>协议关系图，从上到下三层分别为网络层、数据链路层和物理层，截图自<code>网络协议图【科来软件 -2011】</code></p>
<p><img src="/images/wifi/1561025089882.png" alt="1561025089882"></p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>具体<code>802.11</code>帧结构见 <a href="https://www.cnblogs.com/hzl6255/p/4084173.html" target="_blank" rel="noopener">802.11 MAC 层</a>，<code>airkiss</code>是基于<code>802.11 MAC 数据帧</code>，因此后续分析全部基于数据帧</p>
<p>数据帧<code>MAC</code>头如下</p>
<p><img src="/images/wifi/1557147251762.png" alt="1557147251762"></p>
<p>其中<code>Address</code>字段由 T<code>o DS/From DS</code>位来决定</p>
<p><img src="/images/wifi/1557147333236.png" alt="1557147333236"></p>
<p>示例</p>
<p><img src="/images/wifi/1557147475086.png" alt="1557147475086"></p>
<h2 id="SNAP"><a href="#SNAP" class="headerlink" title="SNAP"></a>SNAP</h2><p><code>SNAP</code>全称<code>Subnetwork Access Protocol</code>，是<code>802.2 LLC</code>的扩展，具体见 <a href="https://en.wikipedia.org/wiki/Subnetwork_Access_Protocol" target="_blank" rel="noopener">Subnetwork Access Protocol</a></p>
<p>子网络访问协议<code>SNAP</code>规范了在<code>IEEE802</code>网络上传输<code>IP 数据报的标准方法。换句话说，</code>IP<code>数据报可以封装在</code>802.2 LLC<code>，</code>SNAP<code>数据链路层和</code>802.3<code>、</code>802.4<code>、</code>802.5<code>或</code>802.11<code>网络物理层中，然后在</code>IEEE802`网络上发送。</p>
<p><img src="/images/wifi/1557148967247.png" alt="1557148967247"></p>
<p>当<code>DASP</code>、<code>SSAP</code>为<code>0xAA</code>或<code>0XAB</code>时，<strong>在<code>802.11</code>中只有数据帧含有<code>SNAP</code></strong>，如下图</p>
<p><img src="/images/wifi/1557149262208.png" alt="1557149262208"></p>
<p>根据<code>Type</code>可以看出<code>Ethernet type</code>，可以看到继续解析层次为<code>IP</code>-&gt;<code>UDP</code>-&gt;<code>DATA</code></p>
<h3 id="加密帧结构"><a href="#加密帧结构" class="headerlink" title="加密帧结构"></a>加密帧结构</h3><p>如下图</p>
<p><img src="/images/wifi/1557191433854.png" alt="1557191433854"></p>
<p><code>wireshark</code>识别<code>protocol</code>为<code>802.11</code>，更为上层的数据因为加密的原因无法识别，详细数据如下</p>
<p><img src="/images/wifi/1557191518505.png" alt="1557191518505"></p>
<h3 id="airkiss-数据"><a href="#airkiss-数据" class="headerlink" title="airkiss 数据"></a>airkiss 数据</h3><p><img src="/images/wifi/1557191243718.png" alt="1557191243718"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>因为网卡及路由的原因，<code>header</code>长度不一定，因此采用连续发送<code>1-4</code>长度负载来确定整个链路层长度</li>
<li>因为采用<code>mudp</code>，因此会出现乱序</li>
<li>当链接加密<code>AP</code>时，只能分析到<code>802.11</code>，更高层协议因为加密原因无法拆包</li>
<li><code>airkiss</code>只关心<code>data</code>长度，不关心<code>data</code>内容</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://libtins.github.io/tutorial/802.11/" target="_blank" rel="noopener">IEEE 802.11 - libtins</a></li>
<li><a href="http://www.networksorcery.com/enp/protocol/IEEE8022.htm" target="_blank" rel="noopener">IEEE 802.2. LLC, Logical Link Control</a></li>
<li><a href="https://stackoverflow.com/questions/42834940/how-to-find-out-encapsulated-protocol-inside-ieee802-11-frame" target="_blank" rel="noopener">How to find out encapsulated protocol inside IEEE802.11 Frame?</a></li>
<li><a href="https://www.freebuf.com/articles/wireless/130194.html" target="_blank" rel="noopener">无线网络嗅探中的 Radiotap</a></li>
<li><a href="https://witestlab.poly.edu/blog/802-11-wireless-lan-2/" target="_blank" rel="noopener">Understanding the 802.11 Wireless LAN MAC frame format</a></li>
<li><a href="https://en.wikipedia.org/wiki/Subnetwork_Access_Protocol" target="_blank" rel="noopener">Subnetwork Access Protocol</a></li>
<li><a href="https://blog.51cto.com/yaotongshaonian/1725599" target="_blank" rel="noopener">以太网两种帧的格式 Ethernet_II and IEEE 802.3</a></li>
<li><a href="https://www.cnblogs.com/aixin0813/p/3255000.html" target="_blank" rel="noopener">802.11 网络协议细节</a></li>
<li><a href="https://warpproject.org/trac/wiki/802.11/MAC/Upper/MACHighFramework/EthEncap" target="_blank" rel="noopener">Ethernet Encapsulation and De-encapsulation</a></li>
<li><a href="https://blog.csdn.net/hengkong_horse/article/details/8752908" target="_blank" rel="noopener">80211 与 IEEE 802 网络技术族谱简介</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Network</category>
        <category>802.11</category>
        <category>Airkiss</category>
      </categories>
      <tags>
        <tag>802.11</tag>
        <tag>radiotap</tag>
        <tag>802.2</tag>
        <tag>802.3</tag>
        <tag>SNAP</tag>
        <tag>LLC</tag>
        <tag>MAC</tag>
        <tag>airkiss</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 升级 18.04 之后 nfs 出错</title>
    <url>/2019/05/06/nfs-error/</url>
    <content><![CDATA[<p>解决升级<code>ubuntu</code>之后<code>nfs</code>挂载失败问题</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><code>ubunut</code>升级到<code>18.04</code>，挂载<code>nfs</code>出现如下错误</p>
<pre><code>[   99.683346] VFS: Unable to mount root fs via NFS, trying floppy.
[   99.689905] VFS: Cannot open root device &quot;nfs&quot; or unknown-block(2,0): error -6
[   99.697189] Please append a correct &quot;root=&quot; boot option; here are the available partitions:</code></pre><h2 id="检查-NFS-状态"><a href="#检查-NFS-状态" class="headerlink" title="检查 NFS 状态"></a>检查 NFS 状态</h2><pre><code>$ sudo service nfs-kernel-server status
● nfs-server.service - NFS server and services
   Loaded: loaded (/lib/systemd/system/nfs-server.service; enabled; vendor preset: enabled)
   Active: failed (Result: exit-code) since Sun 2019-05-05 13:30:40 CST; 26s ago
  Process: 12103 ExecStopPost=/usr/sbin/exportfs -f (code=exited, status=0/SUCCESS)
  Process: 12102 ExecStopPost=/usr/sbin/exportfs -au (code=exited, status=0/SUCCESS)
  Process: 12091 ExecStop=/usr/sbin/rpc.nfsd 0 (code=exited, status=0/SUCCESS)
  Process: 11366 ExecStart=/usr/sbin/rpc.nfsd $RPCNFSDARGS (code=exited, status=0/SUCCESS)
  Process: 12101 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=1/FAILURE)
 Main PID: 11366 (code=exited, status=0/SUCCESS)

5 月 05 13:30:40 host-ThinkPad-T440 systemd[1]: Starting NFS server and services...
5 月 05 13:30:40 host-ThinkPad-T440 exportfs[12101]: exportfs: Failed to stat /home/host/workspace/debug/git/output: No such file or directory
5 月 05 13:30:40 host-ThinkPad-T440 systemd[1]: nfs-server.service: Control process exited, code=exited status=1
5 月 05 13:30:40 host-ThinkPad-T440 systemd[1]: Stopped NFS server and services.
5 月 05 13:30:40 host-ThinkPad-T440 systemd[1]: nfs-server.service: Unit entered failed state.
5 月 05 13:30:40 host-ThinkPad-T440 systemd[1]: nfs-server.service: Failed with result &#39;exit-code&#39;.</code></pre><h2 id="修改-NFS-配置文件-exports"><a href="#修改-NFS-配置文件-exports" class="headerlink" title="修改 NFS 配置文件 exports"></a>修改 NFS 配置文件 exports</h2><pre><code>$ cat /etc/exports

# /etc/exports: the access control list for filesystems which may be exported
#        to NFS clients.  See exports(5).
#
# Example for NFSv2 and NFSv3:
# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)
#
# Example for NFSv4:
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)
#

/opt *(rw,no_root_squash,no_subtree_check)</code></pre><p>可以看到参数发生变化，修改为<code>(rw,sync,no_subtree_check,no_root_squash)</code>，然后重启<code>NFS</code></p>
<h2 id="重启-NFS"><a href="#重启-NFS" class="headerlink" title="重启 NFS"></a>重启 NFS</h2><pre><code>$ sudo service nfs-kernel-server restart
$ sudo service nfs-kernel-server status
● nfs-server.service - NFS server and services
   Loaded: loaded (/lib/systemd/system/nfs-server.service; enabled; vendor preset: enabled)
   Active: active (exited) since Sun 2019-05-05 13:36:47 CST; 5s ago
  Process: 12103 ExecStopPost=/usr/sbin/exportfs -f (code=exited, status=0/SUCCESS)
  Process: 12102 ExecStopPost=/usr/sbin/exportfs -au (code=exited, status=0/SUCCESS)
  Process: 12091 ExecStop=/usr/sbin/rpc.nfsd 0 (code=exited, status=0/SUCCESS)
  Process: 13155 ExecStart=/usr/sbin/rpc.nfsd $RPCNFSDARGS (code=exited, status=0/SUCCESS)
  Process: 13154 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCCESS)
 Main PID: 13155 (code=exited, status=0/SUCCESS)

5 月 05 13:36:47 host-ThinkPad-T440 systemd[1]: Starting NFS server and services...
5 月 05 13:36:48 host-ThinkPad-T440 systemd[1]: Started NFS server and services.</code></pre><p>解决问题</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>nfs</tag>
        <tag>rootfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Raw Socket L2 vs L3</title>
    <url>/2019/04/28/raw-socket-L2-vs-L3/</url>
    <content><![CDATA[<p>记录<code>Raw socket</code>相关知识点，以及数据链路层数据访问</p>
<ul>
<li>Layer 2: MAC &amp; LLC</li>
<li>Layer 3: Network</li>
</ul>
<a id="more"></a>

<h2 id="OSI-Model"><a href="#OSI-Model" class="headerlink" title="OSI Model"></a>OSI Model</h2><p><code>OSI</code>七层模型如下</p>
<p><img src="/images/socket/1556452439780.png" alt="1556452439780"></p>
<ul>
<li>Layer2: <code>MAC &amp; LLC</code>，数据类型 <a href="https://en.wikipedia.org/wiki/Frame_networking" target="_blank" rel="noopener">Frame</a></li>
<li>Layer3: <code>Network</code>，数据类型 <a href="https://en.wikipedia.org/wiki/Network_packet" target="_blank" rel="noopener">Packet</a></li>
</ul>
<h2 id="Raw-Socket"><a href="#Raw-Socket" class="headerlink" title="Raw Socket"></a>Raw Socket</h2><p>每一层级网络数据都由两部分组成：<code>Header</code>和<code>Payload</code>，<code>TCP</code>报文如下</p>
<p><img src="/images/socket/1556455755725.png" alt="1556455755725"></p>
<p>通常使用的流式套接字<code>SOCK_STREAM</code>和数据包式套接字<code>SOCK_DGRAM</code>，已经由系统提供的协议栈处理过，应用只能处理<code>Payload</code>部分，<code>Header</code>部分已被处理过。而当需要处理<code>Header</code>部分时，需要使用<code>raw socket</code>，它位于系统核心，可以处理<code>Header</code>部分，而<code>raw socket</code>根据能力不同分为<code>L2</code>和<code>L3</code>，部分资料摘录如下：</p>
<ol>
<li>non-Raw socket<blockquote>
<p>you can just determine Transport Layer Payload. i.e it is OS task to create Transport,Network and Data Link layer headers.</p>
</blockquote>
</li>
<li>Raw socket<blockquote>
<p>you can determine every section of packet,either header or payload. Please note that raw socket is a general word. I categorize raw socket into: Network Socket andd Data-Link Socket (or alternativly L3 Socket and L2 Socket)</p>
</blockquote>
</li>
</ol>
<h2 id="L3-Socket-–-Network-Socket"><a href="#L3-Socket-–-Network-Socket" class="headerlink" title="L3 Socket – Network Socket"></a>L3 Socket – Network Socket</h2><blockquote>
<p>In L3 Socket you can determine header and payload of packet in network layer. For example if network layer protocol is IPv4, you can determine IPv4 header and payload. Thus you can set transport layer header/payload, ICMP header/payload, Routing Protocols headder/payload.</p>
</blockquote>
<p>创建方式</p>
<pre><code class="c">socket(AF_INET, SOCK_RAW, protocol)</code></pre>
<p>在头文件<code>netinet/in.h</code>中定义了系统中该字段目前能取的值，注意：有些系统中不一定实现了<code>netinet/in.h</code>中的所有协议。源代码的<code>linux/in.h</code>中和<code>netinet/in.h</code>中的内容一样。常用的如下</p>
<ul>
<li><code>IPPROTO_IP(0)</code>: 用于接收任何的 IP 数据包。其中的校验和和协议分析由程序自己完成</li>
<li><code>IPPROTO_RAW(255)</code>: 只能用来发送 IP 包，而不能接收任何的数据。发送的数据需要自己填充 IP 包头，并且自己计算校验和</li>
<li>其他像<code>IPPROTO_TCP(6)</code>这种非 0、非 255 的协议，当操作系统内核碰到 IP 头中 protocol 域和创建 socket 所使用参数 protocol 相同的 IP 包，就会交给这个<code>raw socket</code>来处理，因此，一般来说，要想接收什么样的数据包，就应该在参数 protocol 里来指定相应的协议。当内核向此 raw socket 交付数据包的时候，是包括整个 IP 头的，并且已经是重组好的 IP 包</li>
</ul>
<p>用这种方式可以得到原始的 IP 包，然后就可以自定义 IP 所承载的具体协议类型，如<code>TCP</code>，<code>UDP</code>或<code>ICMP</code>，并手动对每种承载在 IP 协议之上的报文进行填充。</p>
<p>注意其中一个参数<code>IP_HDRINCL</code>，允许用户构造 IP 头</p>
<pre><code class="c">const int on =1;
if (setsockopt (sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0) {
    printf(&quot;setsockopt error!\n&quot;);
}</code></pre>
<p><strong>L3 原始套接字处理的只是 IP 层及其以上的数据，可以处理<code>IP Header</code>及<code>TCP/UDP Header</code></strong>，比如实现 SYN FLOOD 攻击、处理 PING 报文等。当需要操作更底层的数据的时候，就需要采用其他的方式。</p>
<h2 id="L2-Socket-–-Data-Link-Socket"><a href="#L2-Socket-–-Data-Link-Socket" class="headerlink" title="L2 Socket – Data-Link Socket"></a>L2 Socket – Data-Link Socket</h2><blockquote>
<p>In L2 Socket you can set header and payload of packet in data link layer, i.e everything in packet. Thus you do everything done with L3 Socket + determine ARP header/payload, PPP header/payload, PPPOE header/payload , …. .</p>
</blockquote>
<p>为了实现直接从链路层收发数据帧，用到原始套接字的如下形式</p>
<pre><code class="c">socket(PF_PACKET, type, protocol)</code></pre>
<ul>
<li><code>type</code>可取<code>SOCK_RAW</code>或<code>SOCK_DGRAM</code>。它们两个都使用一种与设备无关的标准物理层地址结构<code>struct sockaddr_ll</code>，但具体操作的报文格式不同：<ul>
<li><code>SOCK_RAW</code>：直接向网络硬件驱动程序发送或接收没有任何处理的完整数据报文，<strong>包括物理帧的帧头</strong></li>
<li><code>SOCK_DGRAM</code>：这种类型的套接字对于收到的数据报文的物理帧帧头会被系统自动去掉，<strong>不包括物理帧的帧头</strong>，然后再将其往协议栈上层传递。发送时根据<code>sockaddr_ll</code>中的目的地址信息添加<code>MAC</code>头</li>
</ul>
</li>
<li><code>protocol</code>，链路层协议，<code>linux/if_ether.h</code>，常用如下：<ul>
<li><code>ETH_P_IP</code>只接收发往目的 MAC 是本机的 IP 类型的数据帧</li>
<li><code>ETH_P_ARP</code>只接收发往目的 MAC 是本机的 ARP 类型的数据帧</li>
<li><code>ETH_P_RARP</code>只接受发往目的 MAC 是本机的 RARP 类型的数据帧</li>
<li><code>ETH_P_ALL</code>接收发往目的 MAC 是本机的所有类型 (ip,arp,rarp) 的数据帧，同时还可以接收从本机发出去的所有数据帧。<strong>在混杂模式 /Monitor 打开的情况下，还会接收到发往目的 MAC 为非本地硬件地址的数据帧</strong></li>
</ul>
</li>
</ul>
<p>发送数据的时候需要自己组织整个以太网数据帧。和地址相关的结构体就不能再用前面的<code>struct sockaddr_in</code>了，而是<code>struct sockaddr_ll</code>，头文件<code>linux/if_packet.h</code>，如下：</p>
<pre><code class="c">struct sockaddr_ll{
    unsigned short sll_family; /* 总是 AF_PACKET */
    unsigned short sll_protocol; /* 物理层的协议 */
    int sll_ifindex; /* 接口号 */
    unsigned short sll_hatype; /* 报头类型 */
    unsigned char sll_pkttype; /* 分组类型 */
    unsigned char sll_halen; /* 地址长度 */
    unsigned char sll_addr[8]; /* 物理层地址 */
};</code></pre>
<ul>
<li><p><code>sll_family</code>，使用<code>AF_PACKET</code></p>
</li>
<li><p><code>sll_protocol</code>，见头文件<code>linux/if_ether.h</code>，例如<code>ETH_P_ALL</code></p>
</li>
<li><p><code>sll_ifindex</code>，设置为<code>0</code>表示处理所有<code>interface</code>，单网卡设备无所谓，示例代码如下</p>
<pre><code class="c">struct  sockaddr_ll  sll;
struct ifreq ifr;

strcpy(ifr.ifr_name, &quot;eth0&quot;);
ioctl(sockfd, SIOCGIFINDEX, &amp;ifr);
sll.sll_ifindex = ifr.ifr_ifindex;</code></pre>
</li>
<li><p><code>sll_hatype</code>，ARP 硬件地址类型，定义在<code>linux/if_arp.h</code>中，例如</p>
<ul>
<li><code>ARPHRD_ETHER</code>以太网</li>
<li><code>ARPHRD_IEEE80211</code> IEEE 802.11</li>
<li><code>ARPHRD_IEEE80211_PRISM</code> IEEE 802.11 + Prism2 header</li>
<li><code>ARPHRD_IEEE80211_RADIOTAP</code> IEEE 802.11 + radiotap header <strong>Monitor 模式抓下来的类型</strong></li>
</ul>
</li>
<li><p><code>sll_pkttype</code>，分组类型，定义在<code>linux/if_packet.h</code>，例如</p>
<pre><code class="c">  3 #define PACKET_HOST     0       /* To us        */
  4 #define PACKET_BROADCAST    1       /* To all       */
  5 #define PACKET_MULTICAST    2       /* To group     */
  6 #define PACKET_OTHERHOST    3       /* To someone else  */
  7 #define PACKET_OUTGOING     4       /* Outgoing of any type */
  8 #define PACKET_LOOPBACK     5       /* MC/BRD frame looped back */
  9 #define PACKET_USER     6       /* To user space    */
 10 #define PACKET_KERNEL       7       /* To kernel space  */</code></pre>
</li>
<li><p><code>sll_addr</code>和<code>sll_halen</code>指示物理层（如以太网，802.3，802.4 或 802.5 等）地址及其长度，<strong>严格依赖于具体的硬件设备</strong>。类似于获取接口索引<code>sll_ifindex</code>，要获取接口的物理地址，可以采用如下代码</p>
<pre><code class="c">struct ifreq ifr;

strcpy(ifr.ifr_name, &quot;eth0&quot;);
ioctl(sockfd, SIOCGIFHWADDR, &amp;ifr);</code></pre>
</li>
</ul>
<p>默认情况下，从任何接口收到的符合指定协议的所有数据报文都会被传送到原始 PACKET 套接字口，而使用<code>bind</code>系统调用并以一个<code>sochddr_ll</code>结构体对象将 PACKET 套接字与某个网络接口相绑定，就可使我们的 PACKET 原始套接字只接收指定接口的数据报文。示例代码如下</p>
<pre><code class="c">struct sockaddr_ll sll;
struct ifreq ifr;

/* find the interface index */
memset( &amp;ifr, 0, sizeof( ifr ) );
strncpy( ifr.ifr_name, iface, sizeof( ifr.ifr_name ) - 1 );

if( ioctl( fd, SIOCGIFINDEX, &amp;ifr ) &lt; 0 )
{
    printf(&quot;Interface %s: \n&quot;, iface);
    perror( &quot;ioctl(SIOCGIFINDEX) failed&quot; );
    return( 1 );
}

memset( &amp;sll, 0, sizeof( sll ) );
sll.sll_family   = AF_PACKET;
sll.sll_ifindex  = ifr.ifr_ifindex;
//sll.sll_ifindex  = if_nametoindex(iface);
sll.sll_protocol = htons( ETH_P_ALL );

/* bind the raw socket to the interface */

if( bind( fd, (struct sockaddr *) &amp;sll, sizeof( sll ) ) &lt; 0 )
{
    printf(&quot;Interface %s: \n&quot;, iface);
    perror( &quot;bind(ETH_P_ALL) failed&quot; );
    return( 1 );
}</code></pre>
<p><strong>L2 Socket 可以处理链路层数据，可以处理<code>MAC Header</code></strong>，如果创建这个原始套接字时指定了非 0 的协议参数，那么接收到的数据报协议字段必须匹配该值。如果这个套接字已由<code>bind</code>调用绑定了某个 IP 地址，那么接收到的数据报的目的地址必须匹配这个绑定地址。</p>
<h3 id="SOCK-PACKET"><a href="#SOCK-PACKET" class="headerlink" title="SOCK_PACKET"></a>SOCK_PACKET</h3><p>老的内核<code>Linux 2.0</code>接口提供的接口用于处理数据链路层数据，具体信息参看<code>libpcap/pcap-linux.c</code></p>
<pre><code class="c">socket(PF_INET, SOCK_PACKET, htons(ETH_P_ALL))</code></pre>
<p>如果系统已经提供<code>PF_PACKET</code>支持，不建议使用<code>SOCK_PACKET</code></p>
<h2 id="Programming-Example"><a href="#Programming-Example" class="headerlink" title="Programming Example"></a>Programming Example</h2><ul>
<li>socket(AF_INET,RAW_SOCKET,…) means L3 socket , Network Layer Protocol = IPv4</li>
<li>socket(AF_IPX,RAW_SOCKET,…) means L3 socket , Network Layer Protocol = IPX</li>
<li>socket(AF_INET6,RAW_SOCKET,…) means L3 socket , Network Layer Protocol=IPv6</li>
<li>socket(AF_PACKET,RAW_SOCKET,…) means L2 socket , Data-link Layer Protocol= Ethernet</li>
<li>socket(AF_PACKET,SOCK_DGRAM,…) means L2 socket , Data-link Layer Protocol= Ethernet without MAC Header</li>
<li>socket(PF_INET, SOCK_PACKET, htons(ETH_P_ALL)) means L2 socket , Data-link Layer Protocol= Ethernet</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://smallbiztrends.com/2013/09/osi-model-layer-networking.html" target="_blank" rel="noopener">Is the Extra Layer Better? Layer 2 Versus Layer 3 Networking</a></li>
<li><a href="https://stackoverflow.com/questions/14774668/what-is-raw-socket-in-socket-programming" target="_blank" rel="noopener">what is RAW socket in socket programming</a></li>
<li><a href="https://blog.csdn.net/whatday/article/details/79232598" target="_blank" rel="noopener">原始套接字 SOCK_RAW</a></li>
<li><a href="http://abcdxyzk.github.io/blog/2015/04/14/kernel-net-sock-raw/" target="_blank" rel="noopener">Linux 网络编程：原始套接字 SOCK_RAW</a></li>
<li><a href="https://blog.csdn.net/zimu2702/article/details/7185917" target="_blank" rel="noopener">IPPROTO_IP , IPPROTO_RAW</a></li>
<li><a href="https://medium.com/@qre0ct/difference-between-pf-inet-sockets-and-pf-packet-sockets-5a58ab9fe8e3" target="_blank" rel="noopener">Difference between PF_INET sockets and PF_PACKET sockets ?</a></li>
<li><a href="https://blog.csdn.net/gqtcgq/article/details/44874349" target="_blank" rel="noopener">原始套接字和数据链路层访问</a></li>
<li><a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI Model</a></li>
<li><a href="https://austinmarton.wordpress.com/2011/09/14/sending-raw-ethernet-packets-from-a-specific-interface-in-c-on-linux/" target="_blank" rel="noopener">Sending raw Ethernet packets from a specific interface in C on Linux</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/packet.7.html" target="_blank" rel="noopener">PACKET(7) Linux Programmer’s Manual</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>Airkiss</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>LLC</tag>
        <tag>MAC</tag>
        <tag>raw socket</tag>
        <tag>layer 2</tag>
        <tag>layer 3</tag>
        <tag>OSI Model</tag>
        <tag>IP</tag>
        <tag>AF_INET</tag>
        <tag>AF_PACKET</tag>
        <tag>SOCK_RAW</tag>
      </tags>
  </entry>
  <entry>
    <title>AirKiss Client 实现评估及 raw socket</title>
    <url>/2019/04/19/airkiss-client-and-raw-socket/</url>
    <content><![CDATA[<p>原始套接字、<code>wifi</code>驱动支持及<code>Airkiss Client</code>实现</p>
<a id="more"></a>

<p>源码 <a href="https://github.com/pannzh/Airkiss.git" target="_blank" rel="noopener">AirKiss</a>，依赖于<code>libiw</code>实现抓取数据链路层 packet 功能</p>
<p>常用网络协议栈</p>
<ul>
<li>Linux</li>
<li>FreeBSD</li>
</ul>
<p><code>SOCK_RAW</code>常应用于<code>packet sniffer</code>，例如<code>libpcap</code>，结合接口混杂模式，监视本地电缆上流通的所有分组</p>
<h2 id="Promiscuous-vs-Monitoring-mode"><a href="#Promiscuous-vs-Monitoring-mode" class="headerlink" title="Promiscuous vs Monitoring mode"></a>Promiscuous vs Monitoring mode</h2><p><strong>这两种模式不是所有设备都支持的！！！</strong><br>一般网卡都工作在非混杂模式下，只接受来自网络端口的目的地址指向自己的数据。<br>以下两种模式经常混淆，常用与捕捉数据，对比其特点与差异</p>
<h3 id="Promiscuous-网卡混杂模式"><a href="#Promiscuous-网卡混杂模式" class="headerlink" title="Promiscuous 网卡混杂模式"></a>Promiscuous 网卡混杂模式</h3><p>混杂模式不是<strong>数据包捕获模式</strong>，它是以太网数据包捕获的一种选择<code>option</code>。</p>
<ul>
<li>设备必须入网，可以是 wire/wireless</li>
<li>所有流经网卡的数据</li>
<li>协议 IEEE 802.3，Ethernet level</li>
<li>OSI 层次：Mac 层</li>
</ul>
<p>在此模式下监听以太网内部的流量，这个时候网卡不会区分流经其的数据包的目标地址是不是本机，一股脑儿的都将其截下供协议栈上层进行调用查看。</p>
<p>命令开启</p>
<pre><code class="shell">ifconfig wlan0 promisc  设置混杂模式
ifconfig wlan0 -promisc 取消混杂模式</code></pre>
<h3 id="Monitor-无线网卡监听模式"><a href="#Monitor-无线网卡监听模式" class="headerlink" title="Monitor 无线网卡监听模式"></a>Monitor 无线网卡监听模式</h3><p>监听模式仅用于<code>WIFI</code>，用于在<code>802.11 radio level</code>捕捉数据包，而不是在<code>Ethernet level</code>，是一种数据包捕获模式</p>
<ul>
<li>设备不能入网，不能位于任何网络中</li>
<li>仅用于 wireless</li>
<li>协议 IEEE 802.11，radio level</li>
<li>OSI 层次：Physical (PHY) Layer + Data Link Layer (Mac)</li>
</ul>
<p>在此模式下监听所有<code>802.11</code>数据包</p>
<p>命令开启</p>
<pre><code class="shell">ifconfig wlan0 down
iwconfig wlan0 mode monitor
ifconfig wlan0 up

// 或者增加虚拟监听网卡 mon0
sudo iw dev wlan0 interface add mon0 type monitor
sudo ifconfig mon0 up</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>监听模式允许网卡不用连接<code>AP</code>就可以抓取特性频道的数据，就是在空中抓取某个波段的数据。可以用在破解密码</li>
<li>混杂模式（连接 wifi）就是接收所有经过网卡的数据包，包括不是发给本机的包，即不验证 MAC 地址</li>
<li>普通模式下网卡只接收发给本机的包</li>
</ul>
<h2 id="L2-vs-L3-raw-socket"><a href="#L2-vs-L3-raw-socket" class="headerlink" title="L2 vs L3 raw socket"></a>L2 vs L3 raw socket</h2><p>见这篇文章了解原始套接字：<a href="/2019/04/28/raw-socket-L2-vs-L3/" title="Raw Socket L2 vs L3">Raw Socket L2 vs L3</a></p>
<p><code>Airkiss Client</code>除了要求硬件具有<code>Monitor</code>能力之外，还需要系统提供<code>L2 Raw Socket</code>支持</p>
<p>而现阶段<code>ecos</code>系统使用的<code>FreeBSD Network Stack</code>不支持，因此<code>ecos</code>下不能实现。而<code>Linux Network Stack</code>下使用<code>PF_PACKET</code>协议簇下的<code>SOCK_RAW</code>来实现链路层数据处理</p>
<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><pre><code class="shell">// down device
$ sudo ifconfig wlan0 down
// up device
$ sudo ifconfig wlan0 up
// check device modes
$ sudo iw list
// check device mode
$ sudo iwconfig wlan0
// set device monitor mode
$ sudo iwconfig wlan0 mode monitor
$ sudo iw wlan0 set type monitor
// kill some processes
$ sudo airmon-ng check kill
// add virtual monitor device
$ sudo iw dev wlan0 interface add mon0 type monitor
// set channel
$ sudo iw wlan0 set channel 5
$ sudo iwconfig wlan0 channel 6
// set freq
$ sudo iwconfig wlan0 freq 2.484G
$ sudo iw wlan0 set freq 2.484G
// tcpdump with special channel
$ sudo tcpdump -i mon0 -n -w file.cap
// set device managed mode for station
$ sudo ifconfig wlan0 down
$ sudo iwconfig wlan0 mode managed
$ sudo ifconfig wlan0 up
// scan APs in managed mode
$ sudo iwlist wlan0 scan</code></pre>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1"><a href="#1" class="headerlink" title="1#"></a>1#</h3><p><code>airkiss</code>首先需要在各个<code>channel</code>上切换，以获取前导数据，在开源工程中使用如下命令来完成，有如下错误</p>
<pre><code class="shell">$ iw wlan0 set channel 5
command failed: Device or resource busy (-16)
$ iwconfig wlan0 chan 2
Error for wireless request &quot;Set Frequency&quot; (8B04) :
    SET failed on device wlan0 ; Device or resource busy.</code></pre>
<p>在主机环境下做如下测试</p>
<pre><code>$ ifconfig
wlx00117f5bb7b4: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        ether 00:11:7f:5b:b7:b4  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
$ iwconfig wlx00117f5bb7b4
wlx00117f5bb7b4  IEEE 802.11  ESSID:off/any
          Mode:Managed  Access Point: Not-Associated   Tx-Power=20 dBm
          Retry short  long limit:2   RTS thr:off   Fragment thr:off
          Power Management:off
$ sudo iw wlx00117f5bb7b4 set channel 10
command failed: Device or resource busy (-16)
$ sudo ifconfig wlx00117f5bb7b4 down
$ sudo iw wlx00117f5bb7b4 set channel 10
command failed: Device or resource busy (-16)
$ sudo ifconfig wlx00117f5bb7b4 up

$ sudo iw wlx00117f5bb7b4 set type monitor
command failed: Device or resource busy (-16)
$ sudo ifconfig wlx00117f5bb7b4 down
$ sudo iw wlx00117f5bb7b4 set type monitor
$ sudo ifconfig wlx00117f5bb7b4 up
$ iwconfig wlx00117f5bb7b4
wlx00117f5bb7b4  IEEE 802.11  Mode:Monitor  Frequency:2.412 GHz  Tx-Power=20 dBm
          Retry short  long limit:2   RTS thr:off   Fragment thr:off
          Power Management:off
$ sudo iw wlx00117f5bb7b4 set channel 10
$ iwconfig wlx00117f5bb7b4
wlx00117f5bb7b4  IEEE 802.11  Mode:Monitor  Frequency:2.457 GHz  Tx-Power=20 dBm
          Retry short  long limit:2   RTS thr:off   Fragment thr:off
          Power Management:off</code></pre><p>通过以上命令系列猜想<code>set channel</code>对应<code>SIOCSIWFREQ</code>，在<code>STATION</code>下不起作用，在<code>Monitor</code>下才可以设置</p>
<p>在内核<code>4.9.x</code>中查找到如下代码，调用<code>SIOCSIWFREQ</code>会执行到文件<code>net/wireless/wext-compat.c</code>下函数<code>cfg80211_wext_siwfreq</code></p>
<pre><code class="c">  20     case NL80211_IFTYPE_STATION:
  19         return cfg80211_mgd_wext_siwfreq(dev, info, wextfreq, extra);
  18     case NL80211_IFTYPE_ADHOC:
  17         return cfg80211_ibss_wext_siwfreq(dev, info, wextfreq, extra);
  16     case NL80211_IFTYPE_MONITOR:
  15         freq = cfg80211_wext_freq(wextfreq);
  14         if (freq &lt; 0)
  13             return freq;
  12         if (freq == 0)
  11             return -EINVAL;
  10         chandef.center_freq1 = freq;
   9         chandef.chan = ieee80211_get_channel(&amp;rdev-&gt;wiphy, freq);
   8         if (!chandef.chan)
   7             return -EINVAL;
   6         return cfg80211_set_monitor_channel(rdev, &amp;chandef);</code></pre>
<p>其中<code>cfg80211_mgd_wext_siwfreq</code>最终调用<code>cfg80211_set_monitor_channel</code></p>
<pre><code class="c">857 int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
  1                  struct cfg80211_chan_def *chandef)
  2 {
  3     if (!rdev-&gt;ops-&gt;set_monitor_channel)
  4         return -EOPNOTSUPP;
  5     if (!cfg80211_has_monitors_only(rdev))
  6         return -EBUSY;
  7
  8     return rdev_set_monitor_channel(rdev, chandef);
  9 }</code></pre>
<p>得到证实，只有在<code>monitor</code>下才能执行成功</p>
<h3 id="2"><a href="#2" class="headerlink" title="2#"></a>2#</h3><p>接上面的问题，<code>set channel</code>失败是因为不是<code>monitor</code>，而<code>set mode monitor</code>遇到错误</p>
<p>原因是<code>interface down</code>之后被其他线程<code>up</code>，调整逻辑解决此问题</p>
<h2 id="Airkiss-协议"><a href="#Airkiss-协议" class="headerlink" title="Airkiss 协议"></a>Airkiss 协议</h2><h3 id="底层协议"><a href="#底层协议" class="headerlink" title="底层协议"></a>底层协议</h3><p>见这篇文章了解<code>802.11</code>帧结构：<a href="/2019/05/06/radiotap-header-and-802-11-frame/" title="Radiotap、Prism 和 802.11 帧格式分析">Radiotap、Prism 和 802.11 帧格式分析</a></p>
<p>涉及<code>802.2</code>、<code>802.11</code>以及<code>radiotap header</code></p>
<p><code>Airkiss</code>协议数据是<code>802.11 数据帧</code>，在<code>FC</code>中的<code>subtype</code>可以确认</p>
<p>通过<code>monitor</code>获取的数据为<code>802.11 plus Radiotap</code></p>
<p>因为网卡驱动及路由区别导致链路层头长度不定，因此需要使用连续前导码来确定链路层头长度</p>
<p>因为<code>mac payload</code>加密原因，只能分析到<code>802.11</code>这一层，更高层<code>SNAP/UDP/IP</code>看不到，全部在加密数据中封装</p>
<p>开源工程<code>wicap</code>，<a href="https://github.com/niym/wicap.git" target="_blank" rel="noopener">地址</a> 中将数据直接转换为如下结构</p>
<pre><code class="c">  18  struct ieee80211_hdr {
    1     unsigned short frame_control;
    2     unsigned short duration_id;
    3     unsigned char addr1[6];
    4     unsigned char addr2[6];
    5     unsigned char addr3[6];
    6     unsigned short seq_ctrl;
    7     unsigned short addr4[6];
    8 } __attribute__ ((packed));</code></pre>
<h3 id="airkiss-优化"><a href="#airkiss-优化" class="headerlink" title="airkiss 优化"></a>airkiss 优化</h3><ol>
<li>使用<code>802.11 FC</code>只过滤<code>data frame</code></li>
<li>匹配<code>mac addr</code></li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/jnu_simba/article/details/12371127" target="_blank" rel="noopener">浅谈原始套接字 SOCK_RAW 的内幕及其应用</a></li>
<li><a href="https://blog.csdn.net/nice_wen/article/details/53392918" target="_blank" rel="noopener">raw socket 的使用</a></li>
<li><a href="https://blog.csdn.net/baidu20008/article/details/10225073" target="_blank" rel="noopener">linux 数据链路访问之 ETH_P_ALL 等等</a></li>
<li><a href="https://blog.csdn.net/goodlixueyong/article/details/6541175" target="_blank" rel="noopener">网卡的混杂模式</a></li>
<li><a href="https://blog.csdn.net/youfuchen/article/details/29782191" target="_blank" rel="noopener">linux Packet socket (1) 简介</a></li>
<li><a href="https://dupengair.github.io/2016/05/28/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BEd3-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener">第二十九章 数据链路访问</a></li>
<li><a href="https://opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/" target="_blank" rel="noopener">A Guide to Using Raw Sockets</a></li>
<li><a href="https://blog.csdn.net/LiuBF1994/article/details/50506170" target="_blank" rel="noopener">链路层套接字 PF_PACKET 简介</a></li>
<li><a href="http://plasmixs.github.io/raw-sockets-programming-in-c.html" target="_blank" rel="noopener">RAW sockets programming in C</a></li>
<li><a href="https://blog.csdn.net/q623702748/article/details/52063019" target="_blank" rel="noopener">Linux 网络编程：原始套接字编程及实例分析</a></li>
<li><a href="https://medium.com/@debookee/promiscuous-vs-monitoring-mode-d603601f5fa" target="_blank" rel="noopener"><strong>Promiscuous vs Monitoring mode</strong></a></li>
<li><a href="https://www.speedguide.net/faq/what-is-wireless-monitor-and-promiscuous-mode-282" target="_blank" rel="noopener">What is wireless monitor and promiscuous mode ?</a></li>
<li><a href="https://security.stackexchange.com/questions/36997/what-is-the-difference-between-promiscuous-and-monitor-mode-in-wireless-networks" target="_blank" rel="noopener">What is the difference between Promiscuous and Monitor Mode in Wireless Networks?</a></li>
<li><a href="https://blog.csdn.net/howeverpf/article/details/14108039" target="_blank" rel="noopener">无线网卡的 4 种工作模式</a></li>
<li><a href="https://blog.csdn.net/jidushanbojueA/article/details/86478845" target="_blank" rel="noopener">linux 网卡混杂模式和监听模式</a></li>
<li><a href="https://www.cnblogs.com/LittleHann/p/3700357.html" target="_blank" rel="noopener">802.11 协议帧格式、Wi-Fi 连接交互过程、无线破解入门研究</a></li>
<li><a href="https://stackoverflow.com/questions/48271119/how-to-send-both-802-11-management-frames-and-data-frames-using-raw-sockets-in-l" target="_blank" rel="noopener">How to send both 802.11 management frames and data frames using RAW sockets in linux</a></li>
<li><a href="https://stackoverflow.com/questions/44567716/sending-raw-packets-over-wifi-on-linux-c-c" target="_blank" rel="noopener">Sending raw packets over WiFi on Linux (C/C++)</a></li>
<li><a href="https://www.binarytides.com/packet-sniffer-code-in-c-using-linux-sockets-bsd-part-2/" target="_blank" rel="noopener">Packet Sniffer Code in C using Linux Sockets (BSD) – Part 2</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>802.11</category>
        <category>Airkiss</category>
      </categories>
      <tags>
        <tag>monitor</tag>
        <tag>802.11</tag>
        <tag>airkiss</tag>
        <tag>raw socket</tag>
        <tag>raw packet</tag>
        <tag>linux network stack</tag>
        <tag>freebsd network stack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 wolfssl 替换 openssl</title>
    <url>/2019/04/15/Using-wolfSSL-instead-of-OpenSSL/</url>
    <content><![CDATA[<p>使用<code>wolfssl</code>代替<code>openssl</code>，以及部分接口介绍</p>
<a id="more"></a>

<h2 id="wolfssl"><a href="#wolfssl" class="headerlink" title="wolfssl"></a>wolfssl</h2><p>以函数<code>BIO_write</code>为例</p>
<pre><code class="shell">$ ag BIO_write
cyassl/ssl.h
297:#define CyaSSL_BIO_write    wolfSSL_BIO_write

wolfssl/ssl.h
537:WOLFSSL_API int  wolfSSL_BIO_write(WOLFSSL_BIO*, const void*, int);
581:WOLFSSL_API int  wolfSSL_BIO_write_filename(WOLFSSL_BIO *bio, char *name);

wolfssl/openssl/ssl.h
241:#define BIO_write    wolfSSL_BIO_write
550:#define BIO_write_filename  wolfSSL_BIO_write_filename

src/ssl.c
10795:    static int wolfSSL_BIO_BIO_write(WOLFSSL_BIO* bio, const void* data,
10816:    int wolfSSL_BIO_write(WOLFSSL_BIO* bio, const void* data, int len)</code></pre>
<p><code>wolfssl</code>有两个适配层，一个是给<code>cyassl</code>，一个是给<code>wolfssl</code>，等价的</p>
<h2 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h2><ul>
<li>openssl<ul>
<li>libssl.a</li>
<li>libcrypto.a</li>
</ul>
</li>
<li>wolfssl<ul>
<li>libwolfssl.a</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>SSL_CTX</code>用于 SSL 握手前的环境准备，设置 CA 文件和目录、设置 SSL 握手中的证书文件和私钥、设置协议版本以及其他一些 SSL 握手时的选项。</p>
<p><code>BIO</code>是<code>I/O abstraction</code>。openssl 抽象 IO(I/O abstraction，即 BIO) 是 openssl 对于 io 类型的抽象封装，包括：内存、文件、日志、标准输入输出、socket（TCP/UDP）、加 / 解密、摘要和 ssl 通道等。Openssl BIO 通过回调函数为用户隐藏了底层实现细节，所有类型的 bio 的调用大体上是类似的。Bio 中的数据能从一个 BIO 传送到另外一个 BIO 或者是应用程序。</p>
<h2 id="函数解读"><a href="#函数解读" class="headerlink" title="函数解读"></a>函数解读</h2><ul>
<li><code>SSL_library_init()</code>加载各种加密和 HASH 算法</li>
<li><code>SSL_load_error_strings()</code>是加载 SSL 错误信息</li>
<li><code>OpenSSL_add_all_algorithms()</code>是 SSL 初始化</li>
<li><code>SSL_CTX_new</code>是申请 SSL 会话环境</li>
<li><code>BIO_new_ssl_connect</code>是该函数创建一个包含 SSL 类型 BIO 的新 BIO 链，并在后面附加了一个连接类型的 BIO</li>
<li><code>BIO_get_ssl()</code>是该函数返回 SSL 类型 BIO 的内部的 SSL 结构指针，得到该指针后，可以使用标志的 SSL 函数对它进行操作</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/4ef363a60668" target="_blank" rel="noopener">换用 CyaSSL 库</a></li>
<li><a href="https://www.wolfssl.com/docs/wolfssl-manual/ch13/" target="_blank" rel="noopener">CHAPTER 13: OPENSSL COMPATIBILITY</a></li>
<li><a href="https://www.wolfssl.com/top-reasons-use-wolfssl-patch-mysql-instead-yassl-openssl/" target="_blank" rel="noopener">Top Reasons to use the wolfSSL patch in MySQL instead of yaSSL or OpenSSL</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>openssl</tag>
        <tag>wolfssl</tag>
        <tag>bio</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL 禁用特定密钥套件</title>
    <url>/2019/04/15/how-to-abandon-special-cipher-in-openssl/</url>
    <content><![CDATA[<p>核心 API:<code>SSL_CTX_set_cipher_list(SSL_CTX *,const char *str)</code></p>
<a id="more"></a>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><pre><code class="c">#include &lt;openssl/ssl.h&gt;

int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str);
int SSL_set_cipher_list(SSL *ssl, const char *str);</code></pre>
<p>用于在<code>Client_hello</code>中提交一份自己能够支持的加密方法的列表<em>,</em>由服务端选择一种方法后在<code>Server_Hello</code>中通知服务端<em>,</em> 从而完成加密算法的协商。</p>
<p>因此需要禁用某些指定的算法，只需要将它从列表中删除即可。</p>
<h2 id="默认密钥"><a href="#默认密钥" class="headerlink" title="默认密钥"></a>默认密钥</h2><p><code>version:openssl 1.0.2-stable</code>头文件<code>ssl.h</code>中定义<br><code># define SSL_DEFAULT_CIPHER_LIST &quot;ALL:!EXPORT:!LOW:!aNULL:!eNULL:!SSLv2&quot;</code><br>可以使用命令<code>openssl ciphers</code>查看所有密钥套件</p>
<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><pre><code class="shell">$ openssl ciphers -v
$ openssl ciphers -v &#39;ALL&#39;
$ openssl ciphers -v &#39;ALL:!NULL-MD5:!NULL-SHA!AES&#39;
$ openssl ciphers -v &#39;HIGH:!ADH:!MD5:!RC4:!SRP:!PSK:!DSS&#39;

$ openssl ciphers -v &#39;HIGH:!ADH:!MD5:!RC4:!SRP:!PSK:!DSS&#39;
ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD
ECDHE-ECDSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AESGCM(256) Mac=AEAD
ECDHE-RSA-AES256-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AES(256)  Mac=SHA384
ECDHE-ECDSA-AES256-SHA384 TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AES(256)  Mac=SHA384
ECDHE-RSA-AES256-SHA    SSLv3 Kx=ECDH     Au=RSA  Enc=AES(256)  Mac=SHA1
ECDHE-ECDSA-AES256-SHA  SSLv3 Kx=ECDH     Au=ECDSA Enc=AES(256)  Mac=SHA1
DH-DSS-AES256-GCM-SHA384 TLSv1.2 Kx=DH/DSS   Au=DH   Enc=AESGCM(256) Mac=AEAD
DH-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=DH/RSA   Au=DH   Enc=AESGCM(256) Mac=AEAD
DHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=DH       Au=RSA  Enc=AESGCM(256) Mac=AEAD
DHE-RSA-AES256-SHA256   TLSv1.2 Kx=DH       Au=RSA  Enc=AES(256)  Mac=SHA256
DH-RSA-AES256-SHA256    TLSv1.2 Kx=DH/RSA   Au=DH   Enc=AES(256)  Mac=SHA256
DH-DSS-AES256-SHA256    TLSv1.2 Kx=DH/DSS   Au=DH   Enc=AES(256)  Mac=SHA256
DHE-RSA-AES256-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(256)  Mac=SHA1
DH-RSA-AES256-SHA       SSLv3 Kx=DH/RSA   Au=DH   Enc=AES(256)  Mac=SHA1
DH-DSS-AES256-SHA       SSLv3 Kx=DH/DSS   Au=DH   Enc=AES(256)  Mac=SHA1
DHE-RSA-CAMELLIA256-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA1
DH-RSA-CAMELLIA256-SHA  SSLv3 Kx=DH/RSA   Au=DH   Enc=Camellia(256) Mac=SHA1
DH-DSS-CAMELLIA256-SHA  SSLv3 Kx=DH/DSS   Au=DH   Enc=Camellia(256) Mac=SHA1
AECDH-AES256-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(256)  Mac=SHA1
ECDH-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH/RSA Au=ECDH Enc=AESGCM(256) Mac=AEAD
ECDH-ECDSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH/ECDSA Au=ECDH Enc=AESGCM(256) Mac=AEAD
ECDH-RSA-AES256-SHA384  TLSv1.2 Kx=ECDH/RSA Au=ECDH Enc=AES(256)  Mac=SHA384
ECDH-ECDSA-AES256-SHA384 TLSv1.2 Kx=ECDH/ECDSA Au=ECDH Enc=AES(256)  Mac=SHA384
ECDH-RSA-AES256-SHA     SSLv3 Kx=ECDH/RSA Au=ECDH Enc=AES(256)  Mac=SHA1
ECDH-ECDSA-AES256-SHA   SSLv3 Kx=ECDH/ECDSA Au=ECDH Enc=AES(256)  Mac=SHA1
AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
AES256-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
CAMELLIA256-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(256) Mac=SHA1
ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(128) Mac=AEAD
ECDHE-ECDSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AESGCM(128) Mac=AEAD
ECDHE-RSA-AES128-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AES(128)  Mac=SHA256
ECDHE-ECDSA-AES128-SHA256 TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AES(128)  Mac=SHA256
ECDHE-RSA-AES128-SHA    SSLv3 Kx=ECDH     Au=RSA  Enc=AES(128)  Mac=SHA1
ECDHE-ECDSA-AES128-SHA  SSLv3 Kx=ECDH     Au=ECDSA Enc=AES(128)  Mac=SHA1
DH-DSS-AES128-GCM-SHA256 TLSv1.2 Kx=DH/DSS   Au=DH   Enc=AESGCM(128) Mac=AEAD
DH-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=DH/RSA   Au=DH   Enc=AESGCM(128) Mac=AEAD
DHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=AESGCM(128) Mac=AEAD
DHE-RSA-AES128-SHA256   TLSv1.2 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA256
DH-RSA-AES128-SHA256    TLSv1.2 Kx=DH/RSA   Au=DH   Enc=AES(128)  Mac=SHA256
DH-DSS-AES128-SHA256    TLSv1.2 Kx=DH/DSS   Au=DH   Enc=AES(128)  Mac=SHA256
DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
DH-RSA-AES128-SHA       SSLv3 Kx=DH/RSA   Au=DH   Enc=AES(128)  Mac=SHA1
DH-DSS-AES128-SHA       SSLv3 Kx=DH/DSS   Au=DH   Enc=AES(128)  Mac=SHA1
DHE-RSA-CAMELLIA128-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA1
DH-RSA-CAMELLIA128-SHA  SSLv3 Kx=DH/RSA   Au=DH   Enc=Camellia(128) Mac=SHA1
DH-DSS-CAMELLIA128-SHA  SSLv3 Kx=DH/DSS   Au=DH   Enc=Camellia(128) Mac=SHA1
AECDH-AES128-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(128)  Mac=SHA1
ECDH-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH/RSA Au=ECDH Enc=AESGCM(128) Mac=AEAD
ECDH-ECDSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH/ECDSA Au=ECDH Enc=AESGCM(128) Mac=AEAD
ECDH-RSA-AES128-SHA256  TLSv1.2 Kx=ECDH/RSA Au=ECDH Enc=AES(128)  Mac=SHA256
ECDH-ECDSA-AES128-SHA256 TLSv1.2 Kx=ECDH/ECDSA Au=ECDH Enc=AES(128)  Mac=SHA256
ECDH-RSA-AES128-SHA     SSLv3 Kx=ECDH/RSA Au=ECDH Enc=AES(128)  Mac=SHA1
ECDH-ECDSA-AES128-SHA   SSLv3 Kx=ECDH/ECDSA Au=ECDH Enc=AES(128)  Mac=SHA1
AES128-GCM-SHA256       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(128) Mac=AEAD
AES128-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256
AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
CAMELLIA128-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA1</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://oomake.com/question/876711" target="_blank" rel="noopener">在 SSL 连接中禁用弱密码</a></li>
<li><a href="https://wiki.openssl.org/index.php/Command_Line_Utilities" target="_blank" rel="noopener">Command Line Utilities</a></li>
<li><a href="https://www.openssl.org/docs/manmaster/man1/ciphers.html" target="_blank" rel="noopener">openssl ciphers</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/45158762" target="_blank" rel="noopener">Swoole 源码分析——Server OpenSSL（三）</a></li>
<li><a href="https://blog.csdn.net/turui/article/details/2048480" target="_blank" rel="noopener">用 OpenSSL 编写 SSL,TLS 程序</a></li>
<li><a href="https://ask.helplib.com/openssl/post_2035242" target="_blank" rel="noopener">openssl - 在 openssl 中，如何禁用特定的密码套件？</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>openssl</tag>
        <tag>ciphers</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL 单向与双向认证</title>
    <url>/2019/04/11/one-way-vs-two-way-ssl-authentication/</url>
    <content><![CDATA[<p>关于<code>SSL</code>认证的两种方式：单向和双向</p>
<ul>
<li>1-way “Standard” SSL Authentication</li>
<li>2-way “Mutual” SSL Authentication</li>
</ul>
<a id="more"></a>

<h2 id="SSL-TLS-流程"><a href="#SSL-TLS-流程" class="headerlink" title="SSL/TLS 流程"></a>SSL/TLS 流程</h2><p><img src="/images/ssl/ssl.png" alt=""></p>
<p><strong>CA:</strong> 证书授权中心 ( certificate authority)，用于签发证书，由于<code>ca.key</code>和<code>ca.crt</code>（含有公钥信息）是一对，于是<code>ca.crt</code>可以解密<code>server.crt</code>和<code>client.crt</code></p>
<p>如果<code>SSL Client</code>想要校验<code>SSL server</code>. 那么<code>SSL server</code>必须要将他的证书<code>server.crt</code>传给<code>client</code>. 然后 <code>client</code> 用 <code>ca.crt</code> 去校验 <code>server.crt</code> 的合法性。如果是一个钓鱼网站，那么<strong>CA</strong>是不会给他颁发合法<code>server.crt</code>证书的，这样<code>client</code> 用<code>ca.crt</code>去校验就会失败。这样就可以保证了 client 的所有 https 访问都是安全的。</p>
<h2 id="SSL-TLS-认证"><a href="#SSL-TLS-认证" class="headerlink" title="SSL/TLS 认证"></a>SSL/TLS 认证</h2><p>存在两种</p>
<ol>
<li>单向认证 – <strong>1-way “Standard” SSL Authentication</strong>，指的是只有一个对象校验对端的证书合法性。通常都是<code>client</code>来校验服务器的合法性。<code>client</code>需要一个<code>ca.crt</code>，<code>server</code>需要<code>server.crt</code>、<code>server.key</code><blockquote>
<p>The point of this type of authentication is for you (as the client) to verify the authenticity of the web site you are connecting to and form a secure channel of communication.</p>
</blockquote>
</li>
<li>双向认证 – <strong>2-way “Mutual” SSL Authentication</strong> ，指的是相互校验。<code>server</code>需要<code>server.key</code>、<code>server.crt</code>、<code>ca.crt</code>。<code>client</code>需要<code>client.key</code>、<code>client.crt</code>、<code>ca.crt</code><blockquote>
<p>Contrary to one-way SSL; in case of two-way SSL, both client and server authenticate each other to ensure that both parties involved in the communication are trusted. Both parties share their public certificates to each other and then verification/validation is performed based on that.</p>
</blockquote>
</li>
</ol>
<h2 id="SSL-TLS-握手流程"><a href="#SSL-TLS-握手流程" class="headerlink" title="SSL/TLS 握手流程"></a>SSL/TLS 握手流程</h2><p>客户与服务器通信时，首先要进行 SSL 握手，SSL 握手主要完成以下任务：</p>
<ol>
<li>协商使用的加密套件。加密套件中包括一组加密参数，这些参数指定了加密算法和密钥的长度等信息</li>
<li>验证对方的身份，此操作是可选的</li>
<li>确定使用的加密算法</li>
<li>SSL 握手过程采用非对称加密方法传递数据，由此来建立一个安全的 SSL 会话。SSL 握手完成后，通信双方将采用对称加密方法传递实际的应用数据</li>
</ol>
<p>以下是 SSL 握手的具体流程：</p>
<ol>
<li>客户将自己的 SSL 版本号、加密参数、与 SSL 会话有关的数据及其他一些必要信息发送到服务器</li>
<li>服务器将自己的 SSL 版本号、加密参数、与 SSL 会话有关的数据及其他一些必要信息发送给客户，同时发给客户的还有服务器的证书。如果服务器需要验证客户身份，服务器还会发出要求客户提供安全证书的请求</li>
<li>客户端验证服务器证书，如果验证失败，就提示不能建立 SSL 连接。如果成功，那么继续下一步骤</li>
<li>客户端为本次 SSL 会话生成预备主密码（pre-master secret），并将其用服务器公钥加密后发送给服务器</li>
<li>如果服务器要求验证客户身份，客户端还要对另外一些数据签名后，将其与客户端证书一起发送给服务器</li>
<li>如果服务器要求验证客户身份，则检查签署客户证书的 CA（Certificate Authority，证书机构）是否可信。如果不在信任列表中，结束本次会话。如果检查通过，服务器用自己的私钥解密收到的预备主密码（pre-master secret），并用它通过某些算法生成本次会话的主密码（master secret）</li>
<li>客户端与服务器端均使用此主密码（master secret）生成此次会话的会话密钥（对称密钥）。在双方 SSL 握手结束后传递任何消息均使用此会话密钥。这样做的主要原因是对称加密比非对称加密的运算量要低一个数量级以上，能够显著提高双方会话时的运算速度</li>
<li>客户端通知服务器此后发送的消息都使用这个会话密钥进行加密，并通知服务器客户端已经完成本次 SSL 握手</li>
<li>服务器通知客户端此后发送的消息都使用这个会话密钥进行加密，并通知客户端服务器已经完成本次 SSL 握手</li>
<li>本次握手过程结束，SSL 会话已经建立。在接下来的会话过程中，双方使用同一个会话密钥分别对发送和接收的信息进行加密和解密</li>
</ol>
<h2 id="证书工作流"><a href="#证书工作流" class="headerlink" title="证书工作流"></a>证书工作流</h2><p><img src="/images/ssl/1555588843545.png" alt="1555588843545"></p>
<ol>
<li><strong>申请认证</strong>：服务器需自己生成公钥私钥对<code>pub_svr</code> &amp; <code>pri_svr</code>，同时根据 pub_svr 生成请求文件 csr, 提交给 CA，csr 中含有公钥、组织信息、个人信息（域名）等信息</li>
<li><strong>审核信息</strong>：CA 通过线上、线下等多种手段验证申请者提供信息的真实性</li>
<li><strong>签发证书</strong>：如信息审核通过，CA 会向申请者签发认证文件 - 证书。 包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名</li>
<li><strong>返回证书</strong>：client 如果请求验证服务器，服务器需返回证书文件 – <code>SERVER_HELLO</code></li>
<li><strong>client 验证证书</strong>：client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法。客户端然后验证证书相关的域名信息、有效时间是否吊销等信息。 客户端会内置信任 CA 的证书信息（包含公钥），如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法</li>
<li><strong>秘钥协商</strong>：验证通过后，Server 和 Client 将进行秘钥协商。接下来 Server 和 Client 会采用对称秘钥加密<ul>
<li>pre-master</li>
<li>change_cipher_spec</li>
<li>encrypted_handshake_message</li>
</ul>
</li>
<li><strong>数据传输</strong>：Server 和 Client 采用对称秘钥加密解密数据</li>
</ol>
<h2 id="1-way-单向认证"><a href="#1-way-单向认证" class="headerlink" title="1-way 单向认证"></a>1-way 单向认证</h2><p><img src="/images/ssl/1555589285068.png" alt="1555589285068"></p>
<ol>
<li>Client requests for some protected data from the server on HTTPS protocol. This initiates SSL/TLS handshake process.  – <code>CLIENT_HELLO</code></li>
<li>Server returns its public certificate to the client along with <code>SERVER_HELLO</code> message.</li>
<li>Client validates/verifies the received certificate. Client verifies the certificate through certification authority (CA) for CA signed certificates.<blockquote>
<p>The client receives the servers certificate and it is verified against a list of known Certificate Authorities.</p>
</blockquote>
</li>
<li>SSL/TLS client sends the random byte string that enables both the client and the server to compute the secret key to be used for encrypting subsequent message data. The random byte string itself is encrypted with the server’s public key.</li>
<li>After agreeing on this secret key, client and server communicate further for actual data transfer by encryping/decrypting data using this key.</li>
</ol>
<h2 id="2-way-双向认证"><a href="#2-way-双向认证" class="headerlink" title="2-way 双向认证"></a>2-way 双向认证</h2><p><img src="/images/ssl/1555589401105.png" alt="1555589401105"></p>
<ol>
<li>Client requests a protected resource over HTTPS protocol and the SSL/TSL handshake process begins.</li>
<li>Server returns its public certificate to the client along with <code>SERVER_HELLO</code>.</li>
<li>Client validates/verifies the received certificate. Client verifies the certificate through certification authority (CA) for CA signed certificates.</li>
<li>If Server certificate was validated successfully, client will provide its public certificate to the server.</li>
<li>Server validates/verifies the received certificate. Server verifies the certificate through certification authority (CA) for CA signed certificates.</li>
<li>After completion of handshake process, client and server communicate and transfer data with each other encrypted with the secret keys shared between the two during handshake.</li>
</ol>
<h2 id="编程-API"><a href="#编程-API" class="headerlink" title="编程 API"></a>编程 API</h2><p>证书验证函数<code>SSL_CTX_set_verify</code></p>
<ul>
<li>SSL_VERIFY_NONE 表示不验证</li>
<li>SSL_VERIFY_PEER 用于客户端时要求服务器必须提供证书，用于服务器时服务器会发出证书请求消息要求客户端提供证书，但是客户端也可以不提供</li>
<li>SSL_VERIGY_FAIL_IF_NO_PEER_CERT 只适用于服务器且必须提供证书。他必须与 SSL_VERIFY_PEER 一起使用</li>
</ul>
<pre><code class="c">/* Specify that we need to verify the client as well */
SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);

/* We accept only certificates signed only by the CA himself */
SSL_CTX_set_verify_depth(ctx, 1);</code></pre>
<p>设置可信证书默认位置<code>SSL_CTX_load_verify_locations</code><br>加载自身证书，用于发送到对端<code>SSL_CTX_use_certificate_file</code><br>加载私钥<code>SSL_CTX_use_PrivateKey_file</code><br>验证私钥<code>SSL_CTX_check_private_key</code><br>加载可信 CAs<code>SSL_load_client_CA_file</code><br>设置 CAs 列表，用于发送到客户端<code>SSL_CTX_set_client_CA_list</code><br><strong>设置握手时使用的密钥套件<code>SSL_CTX_set_cipher_list</code></strong></p>
<pre><code class="c">SSLeay_add_ssl_algorithms();

// 我们使用 SSL V3,V2
ctx = SSL_CTX_new(SSLv23_server_method());
if (ctx == NULL) {
    ERR_print_errors_fp(stdout);
    exit(1);
}

// 加载 CA 的证书，加载受信任的 CA 证书
if (!SSL_CTX_load_verify_locations(ctx, &quot;../CA/ca.crt&quot;, NULL)) {
    ERR_print_errors_fp(stdout);
    exit(1);
}

/* Load the client&#39;s CA file location as well */
// load user certificate,this cert will be send to server for server verify
// 当需要客户端验证的时候，服务器把 CAfile 里面的可信任 CA 证书发往客户端
SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(&quot;../CA/ca.crt&quot;));

// 加载自己的证书
if (!SSL_CTX_use_certificate_file(ctx, &quot;./server.crt&quot;, SSL_FILETYPE_PEM)) {
    ERR_print_errors_fp(stdout);
    exit(1);
}

// 加载自己的私钥
if (!SSL_CTX_use_PrivateKey_file(ctx, &quot;./server.key&quot;, SSL_FILETYPE_PEM)) {
    ERR_print_errors_fp(stdout);
    exit(1);
}

// 判定私钥是否正确
if (!SSL_CTX_check_private_key(ctx)) {
    ERR_print_errors_fp(stdout);
    exit(1);
}

//set cipher ,when handshake client will send the cipher list to server
SSL_CTX_set_cipher_list(g_sslctx,&quot;HIGH:MEDIA:LOW:!DH&quot;);

/* We won&#39;t handle incomplete read/writes due to renegotiation */
SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);

/* Specify that we need to verify the client as well */
SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);

/* We accept only certificates signed only by the CA himself */
// 最大的验证用户证书的上级数
SSL_CTX_set_verify_depth(ctx, 1);</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/zapstar/two-way-ssl-c" target="_blank" rel="noopener">two-way-ssl-c</a></li>
<li><a href="https://gist.github.com/zapstar/4b51d7cfa74c7e709fcdaace19233443" target="_blank" rel="noopener">openssl_2way_auth.sh</a></li>
<li><a href="https://thejimmahknows.com/1-way-vs-2-way-ssl-authentication/" target="_blank" rel="noopener">1-Way vs 2-Way SSL authentication</a></li>
<li><a href="https://blog.csdn.net/sjin_1314/article/details/21043613" target="_blank" rel="noopener"><strong>SSL 握手通信详解及 linux 下 c/c++ SSL Socket（另附 SSL 双向认证客户端代码）</strong></a></li>
<li><a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener"><strong>SSL/TLS 双向认证（一） – SSL/TLS 工作原理及抓包分析</strong></a></li>
<li><a href="https://blog.csdn.net/liangyuannao/article/details/7712882" target="_blank" rel="noopener">openssl 有关 SSL 客户端认证的问题</a></li>
<li><a href="https://blog.csdn.net/duanbokan/article/details/50847612" target="_blank" rel="noopener">Https 单向认证和双向认证</a></li>
<li><a href="https://blog.cloudboost.io/implementing-mutual-ssl-authentication-fc20ab2392b3" target="_blank" rel="noopener">Implementing Mutual SSL Authentication</a></li>
<li><a href="http://cn.voidcc.com/question/p-dyyelxgp-sa.html" target="_blank" rel="noopener">相互身份验证总是成功与 OpenSSL</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/SSRMWJ_7.0.1.10/com.ibm.isim.doc/securing/cpt/cpt_ic_security_ssl_scenario.htm" target="_blank" rel="noopener">One-way and two-way SSL authentication – <strong>IBM Security Identity Manager</strong></a></li>
<li><a href="http://tutorialspedia.com/an-overview-of-one-way-ssl-and-two-way-ssl/" target="_blank" rel="noopener">An Overview of One-Way SSL and Two-Way SSL</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>ca</tag>
        <tag>openssl</tag>
        <tag>wolfssl</tag>
        <tag>1-way</tag>
        <tag>2-way</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL 编程</title>
    <url>/2019/04/09/ssl-programming/</url>
    <content><![CDATA[<p><code>openssl</code>编程框架及相关示例代码</p>
<a id="more"></a>

<h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><p>OpenSSL 是一个开放源代码的 SSL 协议的产品实现，它采用 C 语言作为开发语言，具备了跨系统的性能。调用 OpenSSL 的函数就可以实现一个 SSL 加密的安全数据传输通道，从而保护客户端和服务器之间数据的安全。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><pre><code class="c">#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/err.h&gt;</code></pre>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在使用 OpenSSL 之前，必须进行相应的协议初始化工作，这可以通过下面的函数实现：</p>
<pre><code class="c">int SSL_library_int(void);</code></pre>
<h3 id="选择会话协议"><a href="#选择会话协议" class="headerlink" title="选择会话协议"></a>选择会话协议</h3><p>在利用 OpenSSL 开始 SSL 会话之前，需要为客户端和服务器制定本次会话采用的协议，目前能够使用的协议包括<code>TLSv1.0</code>、<code>SSLv2</code>、<code>SSLv3</code>、<code>SSLv2/v3</code>。<br>需要注意的是，客户端和服务器必须使用相互兼容的协议，否则 SSL 会话将无法正常进行。</p>
<h3 id="创建会话环境"><a href="#创建会话环境" class="headerlink" title="创建会话环境"></a>创建会话环境</h3><p>在 OpenSSL 中创建的 SSL 会话环境称为 CTX，使用不同的协议会话，其环境也不一样的。</p>
<p>申请 SSL 会话环境的 OpenSSL 函数是：</p>
<pre><code class="c">SSL_CTX *SSL_CTX_new(SSL_METHOD * method);</code></pre>
<p>当 SSL 会话环境申请成功后，还要根据实际的需要设置 CTX 的属性，通常的设置是指定 SSL 握手阶段证书的验证方式和加载自己的证书。</p>
<p>指定证书验证方式的函数是：</p>
<pre><code class="c">int SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int(*verify_callback),int(X509_STORE_CTX *));</code></pre>
<ul>
<li>SSL_VERIFY_NONE 表示不验证</li>
<li>SSL_VERIFY_PEER 用于客户端时要求服务器必须提供证书，用于服务器时服务器会发出证书请求消息要求客户端提供证书，但是客户端也可以不提供</li>
<li>SSL_VERIGY_FAIL_IF_NO_PEER_CERT<strong>只适用于服务器且必须提供证书。他必须与 SSL_VERIFY_PEER 一起使用</strong></li>
</ul>
<p>为 SSL 会话环境加载 CA 证书的函数是：</p>
<pre><code class="c">SSL_CTX_load_verify_location(SSL_CTX *ctx,const char *Cafile,const char *Capath);</code></pre>
<p>从指定文件中加载 CA 证书</p>
<pre><code class="c">STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);</code></pre>
<p>发送 CAs 到客户端，客户端必须提供一个有 CAs 签名的 CA 用于服务端验证客户端</p>
<pre><code class="c"> void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *list);
 void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *list);
 int SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *cacert);
 int SSL_add_client_CA(SSL *ssl, X509 *cacert);</code></pre>
<blockquote>
<p>The SSL_CTX_set_client_CA_list function is only needed by server applications that verify the identity of remote client applications when SSL sessions are started.</p>
<p><code>SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file())</code>用于双向认证时，服务端验证客户端</p>
</blockquote>
<p>为 SSL 会话加载用户证书的函数是：</p>
<pre><code class="c">SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file,int type);</code></pre>
<p>为 SSL 会话加载用户私钥的函数是：</p>
<pre><code class="c">SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx,const char* file,int type);</code></pre>
<p>在将证书和私钥加载到 SSL 会话环境之后，就可以调用下面的函数来验证私钥和证书是否相符：</p>
<pre><code class="c">int SSL_CTX_check_private_key(SSL_CTX *ctx);</code></pre>
<h3 id="建立-SSL-套接字"><a href="#建立-SSL-套接字" class="headerlink" title="建立 SSL 套接字"></a>建立 SSL 套接字</h3><p>SSL 套接字是建立在普通的 TCP 套接字基础之上，在建立 SSL 套接字时可以使用下面的一些函数：</p>
<pre><code class="c">// 申请一个 SSL 套接字
SSL *SSl_new(SSL_CTX *ctx);
// 绑定读写套接字
int SSL_set_fd(SSL *ssl,int fd);
// 绑定只读套接字
int SSL_set_rfd(SSL *ssl,int fd);
// 绑定只写套接字
int SSL_set_wfd(SSL *ssl,int fd);</code></pre>
<h3 id="完成-SSL-握手"><a href="#完成-SSL-握手" class="headerlink" title="完成 SSL 握手"></a>完成 SSL 握手</h3><p>在成功创建 SSL 套接字后，客户端应使用函数<code>SSL_connect</code>替代传统的函数<code>connect</code>来完成握手过程：</p>
<pre><code class="c">int SSL_connect(SSL *ssl);</code></pre>
<p>而对服务器来讲，则应使用函数<code>SSL_ accept</code>替代传统的函数<code>accept</code>来完成握手过程：</p>
<pre><code class="c">int SSL_accept(SSL *ssl);</code></pre>
<p>握手过程完成之后，通常需要询问通信双方的证书信息，以便进行相应的验证，这可以借助于下面的函数来实现：</p>
<pre><code class="c">X509 *SSL_get_peer_certificate(SSL *ssl);</code></pre>
<p>该函数可以从 SSL 套接字中提取对方的证书信息，这些信息已经被 SSL 验证过了。</p>
<pre><code class="c">X509_NAME *X509_get_subject_name(X509 *a);</code></pre>
<p>该函数得到证书所用者的名字。</p>
<h3 id="进行数据传输"><a href="#进行数据传输" class="headerlink" title="进行数据传输"></a>进行数据传输</h3><p>当 SSL 握手完成之后，就可以进行安全的数据传输了，在数据传输阶段，需要使用<code>SSL_read</code>和<code>SSL_write</code>来替代传统的<code>read</code>和<code>write</code>函数，来完成对套接字的读写操作：</p>
<pre><code class="c">int SSL_read(SSL *ssl,void *buf,int num);
int SSL_write(SSL *ssl,const void *buf,int num);</code></pre>
<h3 id="结束-SSL-通信"><a href="#结束-SSL-通信" class="headerlink" title="结束 SSL 通信"></a>结束 SSL 通信</h3><p>当客户端和服务器之间的数据通信完成之后，调用下面的函数来释放已经申请的 SSL 资源：</p>
<pre><code class="c">// 关闭 SSL 套接字
int SSL_shutdown(SSL *ssl);
// 释放 SSL 套接字
void SSl_free(SSL *ssl);
// 释放 SSL 会话环境
void SSL_CTX_free(SSL_CTX *ctx);</code></pre>
<h2 id="编程框架"><a href="#编程框架" class="headerlink" title="编程框架"></a>编程框架</h2><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><pre><code class="c">meth = SSLv23_client_method();
ctx = SSL_CTX_new (meth);
ssl = SSL_new(ctx);
fd = socket();
connect();
SSL_set_fd(ssl,fd);
SSL_connect(ssl);
SSL_write(ssl,&quot;Hello world&quot;,strlen(&quot;Hello World!&quot;));</code></pre>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><pre><code class="c">meth = SSLv23_server_method();
ctx = SSL_CTX_new (meth);
ssl = SSL_new(ctx);
fd = socket();
bind();
listen();
accept();
SSL_set_fd(ssl,fd);
SSL_connect(ssl);
SSL_read (ssl, buf, sizeof(buf));</code></pre>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><code>SSL</code>有两种模式，单向和双向</p>
<ol>
<li>1-way “Standard” SSL Authentication</li>
<li>2-way “Mutual” SSL Authentication</li>
</ol>
<p>参考代码</p>
<ul>
<li><a href="https://github.com/zapstar/two-way-ssl-c" target="_blank" rel="noopener">Two-way SSL authentication example in C</a></li>
<li><a href="http://fm4dd.com/openssl/sslconnect.htm" target="_blank" rel="noopener">Example Code Listing</a></li>
</ul>
<p>server</p>
<pre><code class="c">/* Initialize OpenSSL */
SSL_load_error_strings();
OpenSSL_add_ssl_algorithms();

/* Get a default context */
if (!(ctx = SSL_CTX_new(SSLv23_server_method()))) {
    fprintf(stderr, &quot;SSL_CTX_new failed\n&quot;);
    return NULL;
}

/* Set the CA file location for the server */
if (SSL_CTX_load_verify_locations(ctx, ca_pem, NULL) != 1) {
    fprintf(stderr, &quot;Could not set the CA file location\n&quot;);
    goto fail;
}

/* Load the client&#39;s CA file location as well */
SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(ca_pem));

/* Set the server&#39;s certificate signed by the CA */
if (SSL_CTX_use_certificate_file(ctx, cert_pem, SSL_FILETYPE_PEM) != 1) {
    fprintf(stderr, &quot;Could not set the server&#39;s certificate\n&quot;);
    goto fail;
}

/* Set the server&#39;s key for the above certificate */
if (SSL_CTX_use_PrivateKey_file(ctx, key_pem, SSL_FILETYPE_PEM) != 1) {
    fprintf(stderr, &quot;Could not set the server&#39;s key\n&quot;);
    goto fail;
}

/* We&#39;ve loaded both certificate and the key, check if they match */
if (SSL_CTX_check_private_key(ctx) != 1) {
    fprintf(stderr, &quot;Server&#39;s certificate and the key don&#39;t match\n&quot;);
    goto fail;
}

/* We won&#39;t handle incomplete read/writes due to renegotiation */
SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);

/* Specify that we need to verify the client as well */
SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);

/* We accept only certificates signed only by the CA himself */
SSL_CTX_set_verify_depth(ctx, 1);</code></pre>
<p>client</p>
<pre><code class="c">/* ---------------------------------------------------------- *
 * These function calls initialize openssl for correct work.  *
 * ---------------------------------------------------------- */
OpenSSL_add_all_algorithms();
ERR_load_BIO_strings();
ERR_load_crypto_strings();
SSL_load_error_strings();

/* ---------------------------------------------------------- *
 * Create the Input/Output BIO&#39;s.                             *
 * ---------------------------------------------------------- */
certbio = BIO_new(BIO_s_file());
outbio  = BIO_new_fp(stdout, BIO_NOCLOSE);

/* ---------------------------------------------------------- *
 * initialize SSL library and register algorithms             *
 * ---------------------------------------------------------- */
if(SSL_library_init() &lt; 0)
  BIO_printf(outbio, &quot;Could not initialize the OpenSSL library !\n&quot;);

/* ---------------------------------------------------------- *
 * Set SSLv2 client hello, also announce SSLv3 and TLSv1      *
 * ---------------------------------------------------------- */
method = SSLv23_client_method();

/* ---------------------------------------------------------- *
 * Try to create a new SSL context                            *
 * ---------------------------------------------------------- */
if ( (ctx = SSL_CTX_new(method)) == NULL)
  BIO_printf(outbio, &quot;Unable to create a new SSL context structure.\n&quot;);

/* ---------------------------------------------------------- *
 * Disabling SSLv2 will leave v3 and TSLv1 for negotiation    *
 * ---------------------------------------------------------- */
SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);

/* ---------------------------------------------------------- *
 * Create new SSL connection state object                     *
 * ---------------------------------------------------------- */
ssl = SSL_new(ctx);

/* ---------------------------------------------------------- *
 * Make the underlying TCP socket connection                  *
 * ---------------------------------------------------------- */
server = create_socket(dest_url, outbio);
if(server != 0)
  BIO_printf(outbio, &quot;Successfully made the TCP connection to: %s.\n&quot;, dest_url);

/* ---------------------------------------------------------- *
 * Attach the SSL session to the socket descriptor            *
 * ---------------------------------------------------------- */
SSL_set_fd(ssl, server);

/* ---------------------------------------------------------- *
 * Try to SSL-connect here, returns 1 for success             *
 * ---------------------------------------------------------- */
if ( SSL_connect(ssl) != 1 )
  BIO_printf(outbio, &quot;Error: Could not build a SSL session to: %s.\n&quot;, dest_url);
else
  BIO_printf(outbio, &quot;Successfully enabled SSL/TLS session to: %s.\n&quot;, dest_url);

/* ---------------------------------------------------------- *
 * Get the remote certificate into the X509 structure         *
 * ---------------------------------------------------------- */
cert = SSL_get_peer_certificate(ssl);
if (cert == NULL)
  BIO_printf(outbio, &quot;Error: Could not get a certificate from: %s.\n&quot;, dest_url);
else
  BIO_printf(outbio, &quot;Retrieved the server&#39;s certificate from: %s.\n&quot;, dest_url);

/* ---------------------------------------------------------- *
 * extract various certificate information                    *
 * -----------------------------------------------------------*/
certname = X509_NAME_new();
certname = X509_get_subject_name(cert);

/* ---------------------------------------------------------- *
 * display the cert subject here                              *
 * -----------------------------------------------------------*/
BIO_printf(outbio, &quot;Displaying the certificate subject data:\n&quot;);
X509_NAME_print_ex(outbio, certname, 0, 0);
BIO_printf(outbio, &quot;\n&quot;);

/* ---------------------------------------------------------- *
 * Free the structures we don&#39;t need anymore                  *
 * -----------------------------------------------------------*/
SSL_free(ssl);
close(server);
X509_free(cert);
SSL_CTX_free(ctx);
BIO_printf(outbio, &quot;Finished SSL/TLS connection with server: %s.\n&quot;, dest_url);</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_client_CA_list.html" target="_blank" rel="noopener">SSL_CTX_set_client_CA_list</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/SSB23S_1.1.0.15/gtps7/s5sple1.html?view=kc" target="_blank" rel="noopener">Server application with SSL code</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/SSB23S_1.1.0.15/gtpc2/cpp_ssl_ctx_set_client_ca_list.html#cpp_ssl_ctx_set_client_ca_list" target="_blank" rel="noopener">SSL_CTX_set_client_CA_list</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>ca</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 OpenSSL 生成私钥和签名并自己做 CA 签名</title>
    <url>/2019/04/08/setup-your-own-CA-with-OpenSSL/</url>
    <content><![CDATA[<p>本篇记录如何使用<code>openssl</code>自签 CA 证书，以及相关概念流程</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先要有一个 CA 根证书，然后用 CA 根证书来签发用户证书。<br>用户进行证书申请：一般先生成一个私钥，然后用私钥生成证书请求（证书请求里应含有公钥信息），再利用证书服务器的 CA 根证书来签发证书。</p>
<ol>
<li>自签名证书（一般用于顶级证书、根证书）: 证书的名称和认证机构的名称相同</li>
<li>根证书：根证书是 CA 认证中心给自己颁发的证书，是信任链的起始点。任何安装 CA 根证书的服务器都意味着对这个 CA 认证中心是信任的</li>
<li>数字证书则是由证书认证机构（CA）对证书申请者真实身份验证之后，用 CA 的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机构的公章）后形成的一个数字文件。数字证书包含证书中所标识的实体的公钥（就是说你的证书里有你的公钥），由于证书将公钥与特定的个人匹配，并且该证书的真实性由颁发机构保证（就是说可以让大家相信你的证书是真的），因此，数字证书为如何找到用户的公钥并知道它是否有效这一问题提供了解决方案</li>
</ol>
<h2 id="x509-证书"><a href="#x509-证书" class="headerlink" title="x509 证书"></a>x509 证书</h2><p><a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">X.509</a> 一般会用到三类文件，<code>key</code>，<code>csr</code>，<code>crt</code></p>
<ul>
<li><code>key</code>私钥，<code>openssl</code>格式，通常是<code>rsa</code>算法</li>
<li><code>csr(Certificate Signing Request)</code>是证书请求文件，用于申请证书，含有公钥信息。在申请的时候，必须使用自己的私钥来签署申请，还可以设定一个密钥</li>
<li><code>crt</code>证书文件，是签署人用自己的 key 给你签署的凭证。<strong>可以自签署</strong></li>
<li><code>pem</code>是以上三种文件的编码方式之一，另外一种是<code>DER</code>。Base64 编码后的文本格式。可以单独存放证书或密钥，也可以同时存放证书和密钥</li>
<li><code>crl</code>证书吊销列表，Certificate Revocation List 的缩写</li>
</ul>
<h2 id="openssl-使用"><a href="#openssl-使用" class="headerlink" title="openssl 使用"></a>openssl 使用</h2><pre><code class="shell"># get Standard commands
$ openssl -h
$ man openssl
Standard commands
asn1parse         ca                ciphers           cms
crl               crl2pkcs7         dgst              dh
dhparam           dsa               dsaparam          ec
ecparam           enc               engine            errstr
gendh             gendsa            genpkey           genrsa
nseq              ocsp              passwd            pkcs12
pkcs7             pkcs8             pkey              pkeyparam
pkeyutl           prime             rand              req
rsa               rsautl            s_client          s_server
s_time            sess_id           smime             speed
spkac             srp               ts                verify
version           x509

# get openssl x509
$ man x509</code></pre>
<h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><blockquote>
<p>当然，如果我们要弄 ssl，又没有钱请 CA 给我们签署的时候（他们的验证费都好贵的），可以考虑自己给自己签署。生成一份 key，生成一个 req，然后用自己的 key 签署自己的 req。当你使用这份证书做 ssl 的时候，就会产生不受信任的证书警报。你可以在客户那里安装这张证书为根证书，就不会弹出这个警告了。当然，考究的人，签署用证书和服务器身份认证证书要分开。先做一个自签署证书作为根证书，然后用这个根证书签署一个服务器证书。这样在客户那里安装根证书后，服务器证书就会自动信任。这样的好处是，一本证书只能颁发给一个特定域名。如果你有多个域名，就要反复在客户这里安装证书。然而如果采用根证书签名，那么只要安装一张根证书，其他都是自动的。不过如果事情只要干一次，就不用讲究这么多了。</p>
</blockquote>
<p>可以得到两种处理方式</p>
<ol>
<li>不需要根证书，直接生成用户证书</li>
<li>首先需要自签署根证书，然后再签发服务器身份认证证书</li>
</ol>
<h2 id="CA-根证书的生成"><a href="#CA-根证书的生成" class="headerlink" title="CA 根证书的生成"></a>CA 根证书的生成</h2><p>生成 CA 私钥<code>key</code>–&gt;生成 CA 证书请求<code>csr</code>–&gt;自签名得到根证书<code>crt</code>（CA 给自已颁发的证书）</p>
<pre><code class="shell"># Generate CA private key
openssl genrsa -out ca.key 2048
# Generate CSR
openssl req -new -key ca.key -out ca.csr
# Generate Self Signed certificate
openssl x509 -req -days 365 -in ca.csr -signkey ca.key -out ca.crt</code></pre>
<p>或者</p>
<pre><code class="shell"># Generate CA private key
openssl genrsa -out ca.key 2048
# Generate Self Signed certificate
openssl req -new -x509 -key ca.key -out ca.crt -days 365</code></pre>
<ul>
<li><code>genrsa</code> - generate an RSA private key</li>
<li><code>req</code> - PKCS#10 certificate request and certificate generating utility</li>
<li><code>x509</code> - Certificate display and signing utility</li>
<li><code>-days</code> 证书有效期</li>
<li><code>-x509</code> 在<code>req</code>中直接生成<code>crt</code>代替<code>csr</code></li>
</ul>
<p>这是生成的<code>ca.crt</code>可以直接作为用户证书使用，也可以作为根证书，接下来继续使用<code>ca.crt</code>来签署服务器证书</p>
<h2 id="用户证书"><a href="#用户证书" class="headerlink" title="用户证书"></a>用户证书</h2><p><strong>根证书只需要生成一次，而每个用户都需要使用根证书签署自己的证书</strong></p>
<ol>
<li>生成私钥<br><code>openssl genrsa -out mydomain.com.key 2048</code></li>
<li>检查私钥<br><code>openssl rsa -in mydomain.com.key -noout -text</code></li>
<li>生成<code>CSR</code>，注意<code>Common Name</code>指向服务器地址或域名，有互动、命令行和配置文件三种方式来生成<ol>
<li>互动方式，<code>openssl</code>要求填入一下信息用于生成<code>CSR</code><br><code>openssl req -new -key mydomain.com.key -out mydomain.com.csr</code></li>
<li>命令行，直接填入信息生成<code>CSR</code><br><code>openssl req -new -sha256 -key mydomain.com.key -subj &quot;/C=US/ST=CA/O=MyOrg, Inc./CN=mydomain.com&quot; -out mydomain.com.csr</code></li>
<li>配置文件<br><code>openssl req -new -out mydomain.com.csr -config oats.conf</code></li>
</ol>
</li>
<li>检验<code>CSR</code>，可选项<br><code>openssl req -in mydomain.com.csr -noout -text</code></li>
<li>由根证书签发用户证书<br><code>openssl x509 -req -in mydomain.com.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out mydomain.com.crt -days 500 -sha256</code></li>
<li>检验用户证书，可选项<br><code>openssl x509 -in mydomain.com.crt -text -noout</code></li>
</ol>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><code>server</code>在<code>SSL/TLS</code>握手的过程中会下发自己的证书，而这个证书是经过 CA 签名的。CA 签名的时候使用的是 CA 自己的私钥，而<code>ca.crt</code>则包含了 CA 的公钥，可以用于检验这一签名，以确认是否是自己签的名。</p>
<ol>
<li>服务端需要使用的文件是：server 私钥 (key)， server 证书。</li>
<li>客户端需要使用的文件是：CA file（ca 的证书，用以验证 server 下发的证书）</li>
</ol>
<p>生成证书脚本：<a href="https://gist.github.com/zapstar/4b51d7cfa74c7e709fcdaace19233443" target="_blank" rel="noopener">openssl_2way_auth.sh</a><br>源码：<a href="https://github.com/zapstar/two-way-ssl-c" target="_blank" rel="noopener">Two-way SSL authentication example in C</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://gist.github.com/fntlnz/cf14feb5a46b2eda428e000157447309" target="_blank" rel="noopener">self-signed-certificate-with-custom-ca.md</a></li>
<li><a href="https://gist.github.com/Soarez/9688998" target="_blank" rel="noopener"><strong>How to setup your own CA with OpenSSL</strong></a></li>
<li><a href="https://blog.csdn.net/liuchunming033/article/details/48470575" target="_blank" rel="noopener">openssl 生成 SSL 证书的流程</a></li>
<li><a href="https://blog.csdn.net/zxh2075/article/details/80657336" target="_blank" rel="noopener">用 openssl 生成 SSL 使用的私钥和证书，并自己做 CA 签名</a></li>
<li><a href="https://blog.csdn.net/zxh2075/article/details/79967227" target="_blank" rel="noopener">openssl 基本原理 + 生成证书 + 使用实例</a></li>
<li><a href="https://blog.csdn.net/gengxiaoming7/article/details/78505107" target="_blank" rel="noopener">使用 openssl 生成证书</a></li>
<li><a href="https://blog.csdn.net/xs574924427/article/details/17240793" target="_blank" rel="noopener">SSL 编程</a></li>
<li><a href="http://blog.shell909090.org/blog/archives/1772/" target="_blank" rel="noopener">说说 x509 证书链</a></li>
<li><a href="https://www.zhihu.com/question/29620953" target="_blank" rel="noopener">SSL 中，公钥、私钥、证书的后缀名都是些啥？</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>Tools</category>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>ca</tag>
        <tag>self signed</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl 和 wolfssl 及交叉编译移植</title>
    <url>/2019/04/03/cros-compile-openssl-and-wolfssl/</url>
    <content><![CDATA[<p>嵌入式方案中使用<code>openssl</code>以及<code>wolfssl</code>记录</p>
<a id="more"></a>

<h1 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>转载 <a href="https://blog.csdn.net/guoliquan1/article/details/4703315" target="_blank" rel="noopener">OpenSSL 详细介绍</a></p>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>OpenSSL 一共提供了 8 种对称加密算法，其中 7 种是分组加密算法，仅有的一种流加密算法是 RC4。这 7 种分组加密算法分别是</p>
<ul>
<li><code>AES</code></li>
<li><code>DES</code></li>
<li><code>Blowfish</code></li>
<li><code>CAST</code></li>
<li><code>IDEA</code></li>
<li><code>RC2</code></li>
<li><code>RC5</code></li>
</ul>
<p>都支持<code>电子密码本模式（ECB）</code>、<code>加密分组链接模式（CBC）</code>、<code>加密反馈模式（CFB）</code>和<code>输出反馈模式（OFB）</code>四种常用的分组密码加密模式。其中，<code>AES</code> 使用的<code>加密反馈模式（CFB）</code>和<code>输出反馈模式（OFB）</code>分组长度是 128 位，其它算法使用的则是 64 位。事实上，<code>DES</code> 算法里面不仅仅是常用的<code>DES</code> 算法，还支持三个密钥和两个密钥<code>3DES</code> 算法。</p>
<p>虽然每种加密算法都定义了自己的接口函数，但是<strong><code>OpenSSL</code> 还使用<code>EVP</code> 封装了所有的对称加密算法，使得各种对成加密算法能够使用统一的 API 接口<code>EVP_Encrypt</code> 和<code>EVP_Decrypt</code> 进行数据的加密和解密，大大提供了代码的可重用性能。</strong></p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>OpenSSL 一共实现了 4 种非对称加密算法，包括</p>
<ul>
<li><code>DH</code>，一般用户密钥交换</li>
<li><code>RSA</code>，既可以用于密钥交换，也可以用于数字签名，当然，如果你能够忍受其缓慢的速度，那么也可以用于数据加密</li>
<li><code>DSA</code>，一般只用于数字签名</li>
<li><code>EC</code>，<code>crypto/ec/ ecdsa_sign.c</code> 实现了签名算法；<code>crypto/ec/ec dh_ossl.c</code> 实现了密钥交换算法</li>
</ul>
<p>** 跟对称加密算法相似，OpenSSL 也使用 EVP 技术对不同功能的非对称加密算法进行封装，提供了统一的 API 接口。如果使用非对称加密算法进行密钥交换或者密钥加密，则使用 EVP_Seal 和 EVP_Open 进行加密和解密；如果使用非对称加密算法进行数字签名，则使用<code>EVP_Sign</code> 和<code>EVP_Verify</code> 进行签名和验证。 **</p>
<h3 id="信息摘要算法"><a href="#信息摘要算法" class="headerlink" title="信息摘要算法"></a>信息摘要算法</h3><p>OpenSSL 实现了 5 种信息摘要算法，分别是 MD2、MD5、MDC2、SHA（SHA1）和 RIPEMD。SHA 算法事实上包括了 SHA 和 SHA1 两种信息摘要算法，此外，OpenSSL 还实现了 DSS 标准中规定的两种信息摘要算法 DSS 和 DSS1。</p>
<p>OpenSSL 采用 EVP_Digest 接口作为信息摘要算法统一的 EVP 接口，对所有信息摘要算法进行了封装，提供了代码的重用性。</p>
<h3 id="密钥和证书管理"><a href="#密钥和证书管理" class="headerlink" title="密钥和证书管理"></a>密钥和证书管理</h3><p>密钥和证书管理是 PKI 的一个重要组成部分，OpenSSL 为之提供了丰富的功能，支持多种标准。</p>
<p>首先，OpenSSL 实现了 ASN.1 的证书和密钥相关标准，提供了对证书、公钥、私钥、证书请求以及 CRL 等数据对象的 DER、PEM 和 BASE64 的编解码功能。OpenSSL 提供了产生各种公开密钥对和对称密钥的方法、函数和应用程序，同时提供了对公钥和私钥的 DER 编解码功能。并实现了私钥的 PKCS#12 和 PKCS#8 的编解码功能。OpenSSL 在标准中提供了对私钥的加密保护功能，使得密钥可以安全地进行存储和分发。</p>
<p>在此基础上，OpenSSL 实现了对证书的 X.509 标准编解码、PKCS#12 格式的编解码以及 PKCS#7 的编解码功能。并提供了一种文本数据库，支持证书的管理功能，包括证书密钥产生、请求产生、证书签发、吊销和验证等功能。</p>
<p>事实上，OpenSSL 提供的 CA 应用程序就是一个小型的证书管理中心（CA），实现了证书签发的整个流程和证书管理的大部分机制。</p>
<h3 id="Engine-机制"><a href="#Engine-机制" class="headerlink" title="Engine 机制"></a>Engine 机制</h3><p>Engine 机制的出现是在 OpenSSL 的 0.9.6 版的事情，开始的时候是将普通版本跟支持 Engine 的版本分开的，到了 OpenSSL 的 0.9.7 版，Engine 机制集成到了 OpenSSL 的内核中，成为了 OpenSSL 不可缺少的一部分。</p>
<p><strong>Engine 机制目的是为了使 OpenSSL 能够透明地使用第三方提供的软件加密库或者硬件加密设备进行加密。OpenSSL 的 Engine 机制成功地达到了这个目的，这使得 OpenSSL 已经不仅仅使一个加密库，而是提供了一个通用地加密接口，能够与绝大部分加密库或者加密设备协调工作。</strong>当然，要使特定加密库或加密设备更 OpenSSL 协调工作，需要写少量的接口代码，但是这样的工作量并不大，虽然还是需要一点密码学的知识。Engine 机制的功能跟 Windows 提供的 CSP 功能目标是基本相同的。</p>
<h3 id="BIO-机制"><a href="#BIO-机制" class="headerlink" title="BIO 机制"></a>BIO 机制</h3><p>BIO 机制是 OpenSSL 提供的一种高层 IO 接口，该接口封装了几乎所有类型的 IO 接口，如内存访问、文件访问以及 Socket 等。这使得代码的重用性大幅度提高，OpenSSL 提供 API 的复杂性也降低了很多。</p>
<h3 id="OpenSSL-目录及功能描述"><a href="#OpenSSL-目录及功能描述" class="headerlink" title="OpenSSL 目录及功能描述"></a>OpenSSL 目录及功能描述</h3><ul>
<li><code>Crypto</code> 存放 OpenSSL 所有加密算法源码文件和相关标注如 X.509 源码文件，是 OpenSSL 中最重要的目录，包含了 OpenSSL 密码算法库的所有内容</li>
<li><code>SSL</code> 存放 OpenSSL 中 SSL 协议各个版本和 TLS 1.0 协议源码文件，包含了 OpenSSL 协议库的所有内容</li>
<li><code>Apps</code> 存放 OpenSSL 中所有应用程序源码文件，如 CA、X509 等应用程序的源文件就存放在这里</li>
<li><code>Doc</code> 存放了 OpenSSL 中所有的使用说明文档，包含三个部分：应用程序说明文档、加密算法库 API 说明文档以及 SSL 协议 API 说明文档</li>
<li><code>Demos</code> 存放了一些基于 OpenSSL 的应用程序例子，这些例子一般都很简单，演示怎么使用 OpenSSL 其中的一个功能</li>
<li><code>Include</code> 存放了使用 OpenSSL 的库时需要的头文件</li>
<li><code>Test</code> 存放了 OpenSSL 自身功能测试程序的源码文件</li>
</ul>
<h3 id="OpenSSL-算法目录"><a href="#OpenSSL-算法目录" class="headerlink" title="OpenSSL 算法目录"></a>OpenSSL 算法目录</h3><p>openSSL 的算法目录 Crypto 目录包含了 OpenSSL 密码算法库的所有源代码文件，是 OpenSSL 中最重要的目录之一。OpenSSL 的密码算法库包含了 OpenSSL 中所有密码算法、密钥管理和证书管理相关标准的实现，在 Windows 下编译后的库文件名为 libeay32.lib，在 Linux 下编译后生产的库文件名为 libcrypto.a。Crypto 目录下包含了众多的子目录，这些目录大多数以相关的算法或标准名称的简写命名。当然，并非所有这些目录存放的源文件都是密码算法和标准，有些是 OpenSSL 本身的一些相关功能文件，如 BIO、DSO 和 EVP 等。</p>
<h4 id="Crypto-子目录列表"><a href="#Crypto-子目录列表" class="headerlink" title="Crypto 子目录列表"></a>Crypto 子目录列表</h4><ul>
<li><code>Aes</code> 对称算法，美国新的对称加密算法标准 AES 算法源码</li>
<li><code>Bf</code> 对称算法，Blowfish 对称加密算法源码</li>
<li><code>Cast</code> 对称算法，CAST 对称加密算法源码</li>
<li><code>Des</code> 对称算法，包括了 DES 和 3DES 对称加密算法源码</li>
<li><code>Idea</code> 对称算法，IDEA 对称加密算法源码</li>
<li><code>Rc2</code> 对称算法，RC2 对称加密算法源码</li>
<li><code>Rc4</code> 对称算法，RC4 对称加密算法源码</li>
<li><code>Rc5</code> 对称算法，RC5 对称加密算法源码</li>
<li><code>Dh</code> 非对称算法，DH 非对称密钥交换算法源码</li>
<li><code>Dsa</code> 非对称算法，DSA 非对称算法源码，用于数字签名</li>
<li><code>Ec</code> 非对称算法，EC 椭圆曲线算法源码</li>
<li><code>Rsa</code> 非对称算法，RSA 非对称加密算法源码，既可以用于密钥交换，也可以用于数字签名</li>
<li><code>Md2</code> 信息摘要算法，MD2 信息摘要算法源码</li>
<li><code>Md5</code> 信息摘要算法，MD5 信息摘要算法源码</li>
<li><code>Mdc2</code> 信息摘要算法，MDC2 信息摘要算法源码</li>
<li><code>Sha</code> 信息摘要算法，SHA 信息摘要算法源码，包括了 SHA1 算法</li>
<li><code>Ripemd</code> 信息摘要算法，RIPEMD-160 信息摘要算法源码</li>
<li><code>Comp</code> 数据压缩算法数据压缩算法的函数接口，目前没有压缩算法，只是定义了一些空的接口函数</li>
<li><code>Asn1 PKI</code> 相关标准 ASN.1 标准实现源码，只实现了 PKI 相关的部分，不是完全实现。包括 DER 编解码等功能</li>
<li><code>Ocsp PKI</code> 相关标准 OCSP（在线证书服务协议）实现源码</li>
<li><code>Pem PKI</code> 相关标准 PEM 标准实现源码，包括了 PEM 的编解码功能</li>
<li><code>Pkcs7 PKI</code> 相关标准 PKCS#7 标准实现源码。PKCS#7 是实现加密信息封装的标准，包括了证书封装的标准和加密数据的封装标准</li>
<li><code>Pkcs12 PKI</code> 相关标准 PKCS#12 标准实现源码。包括了 PKCS#12 文件的编解码功能。PKCS#12 是一种常用的证书和密钥封装格式</li>
<li><code>X509 PKI</code> 相关标准 X.509 标准的实现源码。包括了 X.509 的编解码功能，证书管理功能等。X509v3 PKI 相关标准 X.509 第三版扩展功能的实现源码</li>
<li><code>Krb5</code> 其它标准支持支持 Kerberos 协议的一些接口函数和结构定义</li>
<li><code>Hmac</code> 其它标准支持 HMAC 标准的支持结构和函数源源代码</li>
<li><code>Lhash</code> 其它标准支持动态 HASH 表结构和函数源代码</li>
<li><code>Bio</code> 自定义 OpenSSL 自身定义的一种抽象 IO 接口，封装了各种平台的几乎所有 IO 接口，如文件、内存、缓存、标准输入输出以及 Socket 等等</li>
<li><code>Bn</code> 自定义 OpenSSL 实现大数管理的结构及其函数</li>
<li><code>Buffer</code> 自定义 OpenSSL 自定义的缓冲区结构体</li>
<li><code>Conf</code> 自定义 OpenSSL 自定义的管理配置结构和函数</li>
<li><code>Dso</code> 自定义 OpenSSL 自定义的加载动态库的管理函数接口。如使用 Engine 机制就用到了这些函数提供的功能</li>
<li><code>Engine</code> 自定义 OpenSSL 自定义的 Engine 机制源代码。Engine 机制运行 OpenSSL 使用第三方提供的软件密码算法库或者硬件加密设备进行数据加密等运算。相当于 Windows 平台的 CSP 机制</li>
</ul>
<h4 id="Err-自定义-OpenSSL-自定义的错误信息处理机制"><a href="#Err-自定义-OpenSSL-自定义的错误信息处理机制" class="headerlink" title="Err 自定义 OpenSSL 自定义的错误信息处理机制"></a>Err 自定义 OpenSSL 自定义的错误信息处理机制</h4><ul>
<li><code>Evp</code> 自定义 OpenSSL 定义的一组高层算法封装函数，包括了对称加密算法封装、非对称加密算法封装、签名验证算法封装以及信息摘要算法封装，类似</li>
</ul>
<h4 id="PKCS-11-提供的接口标准"><a href="#PKCS-11-提供的接口标准" class="headerlink" title="PKCS#11 提供的接口标准"></a>PKCS#11 提供的接口标准</h4><ul>
<li><code>Objects</code> 自定义 OpenSSL 管理各种数据对象的定义和函数。事实上，Objects 的 OID 是根据 ASN.1 的标准进行命名的，不完全是 OpenSSL 自定义的结构</li>
</ul>
<h4 id="Rand-自定义-OpenSSL-的安全随机数产生函数和管理函数"><a href="#Rand-自定义-OpenSSL-的安全随机数产生函数和管理函数" class="headerlink" title="Rand 自定义 OpenSSL 的安全随机数产生函数和管理函数"></a>Rand 自定义 OpenSSL 的安全随机数产生函数和管理函数</h4><ul>
<li><code>Stack</code> 自定义定义了 OpenSSL 中 STACK 结构和相关管理函数</li>
<li><code>Threads</code> 自定义 OpenSSL 处理线程的一些机制</li>
<li><code>Txt_db</code> 自定义 OpenSSL 提供的文本证书库的管理机制</li>
<li><code>Ui</code> 自定义 OpenSSL 定义的一下用户接口交换函数</li>
<li><code>Perlasm</code> 自定义编译的时候需要用到的一些 Perl 辅助配置文件</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>转载 <a href="https://zhuanlan.zhihu.com/p/37739171" target="_blank" rel="noopener">OpenSSL 的编译系统</a>，主要内容</p>
<p>Make 命令是几乎大部分 Linux 下软件的编译基石，它输入的配置文件是 Makefile。但是很多开源软件为了适应各种不同的客户机配置，通常会在 Makefile 之前添加一个 automake 的过程，就是通过对机器硬件和机器上安装的库的检测来动态的确定编译的行为。</p>
<p>OpenSSL 的编译系统自成一派。虽然最后也是依赖 Makefile 文件的 make 系统，但是并不是使用 automake 的通用做法。一般的 automake 是首先执行一个叫 configure 的文件，这个文件的执行后就会生成一个 Makefile 文件，之后再调用 make 命令即可。但是 OpenSSL 调用的命令文件是 config，里面虽然的目的和 configure.sh 一致，但是实际使用的系统是差别很大的。config 这个 Shell 脚本文件里面实际是调用的 Perl 脚本。</p>
<p>实际的编译程序仍然是一个叫<code>Configure</code>的文件。这个文件支持的命令行参数远比<code>config</code>要多很多：</p>
<pre><code>./Configure -h
Configuring OpenSSL version 1.1.1-pre7-dev (0x10101007L) for
Using os-specific seed configuration
Warning! target  doesn&#39;t exist!
Usage: Configure [no-&lt;cipher&gt; ...] [enable-&lt;cipher&gt; ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [no-asm] [no-dso] [no-egd] [sctp] [386] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--config=FILE] os/compiler[:flags]</code></pre><p>整个<code>config</code>文件都在为<code>Configure</code>文件自动的生成这些命令行参数。所以我们在一台机器上编译过之后，可以手动的拿到这些命令行参数，然后后续只直接调用<code>Configure</code>文件即可。这样就可以手动的对一些参数进行修改了。</p>
<ol>
<li><a href="https://blog.csdn.net/zqj6893/article/details/8778237" target="_blank" rel="noopener">Linux 环境下 openssl 交叉编译、安装和裁剪</a></li>
<li><a href="https://www.cnblogs.com/wangliangblog/p/7772381.html" target="_blank" rel="noopener">openssl 编译参数选项</a></li>
<li><a href="https://gist.github.com/steakknife/8247726" target="_blank" rel="noopener"><strong>openssl_configure.md</strong></a></li>
<li><a href="https://www.jianshu.com/p/74f547849255" target="_blank" rel="noopener">交叉编译 openssl、gmssl 的正确方式</a></li>
<li><a href="https://blog.csdn.net/adrian169/article/details/9245303" target="_blank" rel="noopener">openssl 在 arm 下的交叉编译</a></li>
<li><a href="https://mowblog.com/%E4%BD%BF%E7%94%A8arm-gcc%E7%BC%96%E8%AF%91openssl/" target="_blank" rel="noopener">使用 ARM GCC 编译 openssl</a></li>
<li><a href="https://www.oschina.net/question/234345_47942" target="_blank" rel="noopener">openssl 简易文档</a></li>
</ol>
<p>交叉编译时，需要关注的参数</p>
<ul>
<li>CC</li>
<li>–prefix</li>
<li>–cross-compile</li>
<li>no-shared</li>
<li>no-asm</li>
</ul>
<p>例如如下命令</p>
<pre><code class="shell">./Configure --prefix=/opt/openssl --cross-compile-prefix=arm-linux-gnueabihf- no-asm shared linux-armv4
make
make install</code></pre>
<p>嵌入式裁剪</p>
<pre><code class="shell">./config --prefix=/home/zqjun/openssl5350 no-shared no-zlib no-asm no-threads no-sse2no-compno-dso no-gmp no-rfc3779 no-krb5 no-rc5 no-zlib-dynamic no-hw no-cipherno-md2 no-md4 no-mdc2 no-rc2 no-idea no-camellia no-ec no-ecdsa no-ecdhno-store no-ripemd no-des no-rc4 no-bf no-cast no-dsa no-dh no-ssl no-ssl2no-ssl3 no-tls no-perlasm
---------------------
./config --prefic=/home/zqjun/openssl5350 shared no-zlib no-asm no-threads no-sse2 no-compno-gmp no-rfc3779 no-krb5 no-rc5 no-zlib-dynamic no-hw no-cipher no-md2 no-md4 no-mdc2no-rc2 no-idea no-camellia no-ec no-ecdsa no-ecdh no-store no-ripemd no-des no-rc4no-bf no-cast no-dsa no-dh no-ssl no-ssl2 no-ssl3 no-tls no-perlasm</code></pre>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>注意事项：</p>
<ol>
<li>生成<code>libssl.a</code>和<code>libcrypto.a</code>，注意引用库的顺序为：<code>-lssl -lcrypto</code>，如果为<code>-lcrypto –lssl</code>，编译时会出现错误</li>
<li>动态编译时不能出现 no-dso 参数，因为编译过程中有些函数需要链接相应动态库</li>
<li>编译完成后使用 XXX-strip 把相应的符号去掉，安装后的库会更小一些</li>
</ol>
<p>执行配置之后会有如下输出</p>
<pre><code class="shell">./config --prefix=`pwd`/prefix no-shared no-asm no-zlib no-async
Operating system: x86_64-whatever-linux2
Configuring OpenSSL version 1.1.1-pre7-dev (0x10101007L) for linux-x86_64
Using os-specific seed configuration
Creating configdata.pm
Creating Makefile

**********************************************************************
***                                                                ***
***   If you want to report a building issue, please include the   ***
***   output from this command:                                    ***
***                                                                ***
***     perl configdata.pm --dump                                  ***
***                                                                ***
**********************************************************************</code></pre>
<p>生成的<code>Makefile</code>中</p>
<pre><code class="makefile">LIBS=apps/libapps.a libcrypto.a libssl.a test/libtestutil.a
INSTALL_LIBS=libcrypto.a libssl.a
libssl.a: ssl/bio_ssl.o ssl/d1_lib.o ssl/d1_msg.o ssl/d1_srtp.o ssl/methods.o ssl/packet.o ssl/pqueue.o ...
libcrypto.a: crypto/aes/aes_cbc.o crypto/aes/aes_cfb.o crypto/aes/aes_core.o crypto/aes/aes_ecb.o ... engines/e_afalg.o engines/e_capi.o engines/e_padlock.o</code></pre>
<ul>
<li><code>libssl.a</code>为目录<code>ssl</code>集合</li>
<li><code>libcrypto.a</code>为目录<code>crypto</code>和<code>engines</code>集合</li>
</ul>
<h1 id="wolfssl"><a href="#wolfssl" class="headerlink" title="wolfssl"></a>wolfssl</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://zh.wikipedia.org/wiki/WolfSSL" target="_blank" rel="noopener">wolfSSL</a></p>
<p><strong>wolfSSL</strong> （原名 <strong>CyaSSL</strong> 或 <strong>yet another SSL</strong>)，是一个提供<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">传输层安全协议</a>（SSL/TLS）功能的<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BA%93" target="_blank" rel="noopener">软件库</a>，主要针对<a href="https://zh.wikipedia.org/wiki/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">嵌入式系系统</a> 发展。以开放原始码及商用许可两种方式释出，提供 SSL/TLS 功能（SSL 3.0， TLS 1.0/1.1/ 1.2，DTLS 1.0/1.2），以 <a href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">C 语言</a> 写成。提供了与 <a href="https://zh.wikipedia.org/wiki/OpenSSL" target="_blank" rel="noopener">OpenSSL</a> 兼容的 API 界面，让原有使用 OpenSSL 的软件可以容易的移植过来。</p>
<h2 id="交叉编译移植"><a href="#交叉编译移植" class="headerlink" title="交叉编译移植"></a>交叉编译移植</h2><ol>
<li><a href="https://www.jarviswang.me/?p=599" target="_blank" rel="noopener">ESP32 移植 wolfssl 方法</a></li>
<li><a href="https://blog.csdn.net/u014530704/article/details/79919876" target="_blank" rel="noopener">wolfssl 移植替换 openssl</a></li>
<li><a href="https://www.wolfssl.com/docs/wolfssl-manual/ch2/" target="_blank" rel="noopener"><strong>CHAPTER 2:  BUILDING WOLFSSL</strong></a></li>
<li><a href="https://www.wolfssl.com/docs/wolfssl-manual/ch2/" target="_blank" rel="noopener"><strong>BUILD OPTIONS (**</strong>./CONFIGURE** <strong>OPTIONS)</strong></a></li>
</ol>
<p>使用<code>configure</code>完成交叉编译配置，首先修改<code>config.sub</code>添加需要移植的<code>host</code>，然后</p>
<pre><code class="shell">./configure --prefix=`pwd`/prefix --host=csky-linux --enable-sslv3 --enable-ecc --enable-tlsx --enable-stunnel --enable-opensslextra --disable-examples --enable-static

---
Configuration summary for wolfssl version 3.11.0

   * Installation prefix:        /data/OpenSourceCode/thirdparty/wolfssl/prefix
   * System type:                unknown-linux-gnu
   * Host CPU:                   csky
   * C Compiler:                 csky-linux-gcc
   * C Flags:                     -Werror -Wno-pragmas -Wall -Wno-strict-aliasing -Wextra -Wunknown-pragmas --param=ssp-buffer-size=1 -Waddress -Warray-bounds -Wbad-function-cast -Wchar-subscripts -Wcomment -Wfloat-equal -Wformat-security -Wformat=2 -Wmissing-field-initializers -Wmissing-noreturn -Wmissing-prototypes -Wnested-externs -Wnormalized=id -Woverride-init -Wpointer-arith -Wpointer-sign -Wredundant-decls -Wshadow -Wsign-compare -Wstrict-overflow=1 -Wswitch-enum -Wundef -Wunused -Wunused-result -Wunused-variable -Wwrite-strings -fwrapv
   * C++ Compiler:               csky-linux-g++
   * C++ Flags:                  -g -O2
   * CPP Flags:                   -fvisibility=hidden
   * CCAS Flags:
   * LIB Flags:                   -pie -z relro -z now -Werror
   * Debug enabled:              no
   * Warnings as failure:        yes
   * make -j:                    5
   * VCS checkout:               yes

   Features
   * Single threaded:            no
   * Filesystem:                 yes
   * OpenSSH Build:              no
   * OpenSSL Extra API:          yes
   * Max Strength Build:         no
   * Distro Build:               no
   * fastmath:                   no
   * sniffer:                    no
   * snifftest:                  no
   * ARC4:                       no
   * AES:                        yes
   * AES-NI:                     no
   * AES-GCM:                    yes
   * AES-CCM:                    no
   * AES-CTR:                    no
   * DES3:                       yes
   * IDEA:                       no
   * Camellia:                   no
   * NULL Cipher:                no
   * MD5:                        yes
   * RIPEMD:                     no
   * SHA:                        yes
   * SHA-224:                    no
   * SHA-512:                    no
   * BLAKE2:                     no
   * CMAC:                       no
   * keygen:                     no
   * certgen:                    no
   * certreq:                    no
   * certext:                    no
   * HC-128:                     no
   * RABBIT:                     no
   * CHACHA:                     yes
   * Hash DRBG:                  yes
   * PWDBASED:                   yes
   * scrypt:                     no
   * wolfCrypt Only:             no
   * HKDF:                       no
   * X9.63 KDF:                  no
   * MD4:                        yes
   * PSK:                        yes
   * Poly1305:                   yes
   * LEANPSK:                    no
   * LEANTLS:                    no
   * RSA:                        yes
   * DSA:                        no
   * DH:                         yes
   * ECC:                        yes
   * CURVE25519:                 no
   * ED25519:                    no
   * FPECC:                      no
   * ECC_ENCRYPT:                no
   * ASN:                        yes
   * Anonymous cipher:           no
   * CODING:                     yes
   * MEMORY:                     yes
   * I/O POOL:                   no
   * LIGHTY:                     no
   * HAPROXY:                    no
   * STUNNEL:                    yes
   * NGINX:                      no
   * ERROR_STRINGS:              yes
   * DTLS:                       no
   * SCTP:                       no
   * Old TLS Versions:           yes
   * SSL version 3.0:            yes
   * OCSP:                       yes
   * OCSP Stapling:              no
   * OCSP Stapling v2:           no
   * CRL:                        yes
   * CRL-MONITOR:                no
   * Persistent session cache:   no
   * Persistent cert    cache:   no
   * Atomic User Record Layer:   no
   * Public Key Callbacks:       no
   * NTRU:                       no
   * Whitewood netRandom:        no
   * Server Name Indication:     yes
   * ALPN:                       yes
   * Maximum Fragment Length:    yes
   * Truncated HMAC:             yes
   * Supported Elliptic Curves:  yes
   * Session Ticket:             no
   * Extended Master Secret:     yes
   * Renegotiation Indication:   no
   * Secure Renegotiation:       no
   * All TLS Extensions:         yes
   * PKCS#7                      no
   * wolfSCEP                    no
   * Secure Remote Password      no
   * Small Stack:                no
   * valgrind unit tests:        no
   * LIBZ:                       no
   * Examples:                   no
   * User Crypto:                no
   * Fast RSA:                   no
   * Async Crypto:               no
   * Cavium:                     no
   * ARM ASM:                    no
   * AES Key Wrap:               no
   * Write duplicate:            no
   * Intel Quick Assist:         no

---

$ tree -L 2
.
├── bin
│   └── wolfssl-config
├── include
│   ├── cyassl
│   └── wolfssl
├── lib
│   ├── libwolfssl.a
│   ├── libwolfssl.la
│   ├── libwolfssl.so -&gt; libwolfssl.so.12.0.0
│   ├── libwolfssl.so.12 -&gt; libwolfssl.so.12.0.0
│   ├── libwolfssl.so.12.0.0
│   └── pkgconfig
└── share
    └── doc

# 如果不添加`--enable-static`，结果如下，只有动态库
$ tree -L 2
.
├── bin
│   └── wolfssl-config
├── include
│   ├── cyassl
│   └── wolfssl
├── lib
│   ├── libwolfssl.la
│   ├── libwolfssl.so -&gt; libwolfssl.so.12.0.0
│   ├── libwolfssl.so.12 -&gt; libwolfssl.so.12.0.0
│   ├── libwolfssl.so.12.0.0
│   └── pkgconfig
└── share
    └── doc

# 可以使用`--dis-shared`不编译动态库
$ tree -L 2
.
├── bin
│   └── wolfssl-config
├── include
│   ├── cyassl
│   └── wolfssl
├── lib
│   ├── libwolfssl.a
│   ├── libwolfssl.la
│   └── pkgconfig
└── share
    └── doc
</code></pre>
<p><code>configure</code>之后生成的文件，需要注意<code>config.h</code>、<code>Makefile</code>、<code>options.h</code>和<code>setting.h</code></p>
<p>其中<code>Makefile</code>为编译流程控制，各个选项均可以修改以达到目的。<code>config.h</code>为<code>wolfssl</code>的配置文件，包括各种宏定义。分析<code>Makefile</code>可以得到</p>
<ul>
<li>./wolfssl — 这个文件夹是 wolfssl 的所有头文件</li>
<li>./src — 这个是 wolfssl 功能代码</li>
<li>./wolfcrypt/src — 这个是 wolfssl 的所有加密算法源码实现</li>
<li>与<code>openssl</code>不同，只存在一个库<code>libwolfssl.a</code></li>
</ul>
<h2 id="Prefix"><a href="#Prefix" class="headerlink" title="Prefix"></a>Prefix</h2><p><code>prefix</code>目录如下</p>
<pre><code class="shell">$ tree -L 3
.
├── bin
│   └── wolfssl-config
├── include
│   ├── cyassl
│   │   ├── callbacks.h
│   │   ├── certs_test.h
│   │   ├── crl.h
│   │   ├── ctaocrypt
│   │   ├── error-ssl.h
│   │   ├── ocsp.h
│   │   ├── openssl
│   │   ├── options.h
│   │   ├── sniffer_error.h
│   │   ├── sniffer.h
│   │   ├── ssl.h
│   │   ├── test.h
│   │   └── version.h
│   └── wolfssl
│       ├── callbacks.h
│       ├── certs_test.h
│       ├── crl.h
│       ├── error-ssl.h
│       ├── io.h
│       ├── ocsp.h
│       ├── openssl
│       ├── options.h
│       ├── sniffer_error.h
│       ├── sniffer.h
│       ├── ssl.h
│       ├── test.h
│       ├── version.h
│       └── wolfcrypt
├── lib
│   ├── libwolfssl.a
│   ├── libwolfssl.la
│   ├── libwolfssl.so -&gt; libwolfssl.so.12.0.0
│   ├── libwolfssl.so.12 -&gt; libwolfssl.so.12.0.0
│   ├── libwolfssl.so.12.0.0
│   └── pkgconfig
│       └── wolfssl.pc
└── share
    └── doc
        └── wolfssl</code></pre>
<p>其中<code>include</code>存在<code>cyassl</code>和<code>wolfssl</code>是为了保证与之前的版本<code>cyassl</code>兼容，同时存在<code>openssl</code>兼容性头文件</p>
<h1 id="使用-wolfssl-替换-openssl"><a href="#使用-wolfssl-替换-openssl" class="headerlink" title="使用 wolfssl 替换 openssl"></a>使用 wolfssl 替换 openssl</h1><ol>
<li><a href="https://www.wolfssl.com/docs/wolfssl-openssl/" target="_blank" rel="noopener">WOLFSSL VERSUS OPENSSL</a></li>
<li><a href="https://www.wolfssl.com/docs/wolfssl-manual/ch13/" target="_blank" rel="noopener">CHAPTER 13: OPENSSL COMPATIBILITY</a></li>
<li><a href="https://blog.csdn.net/u014530704/article/details/79919876" target="_blank" rel="noopener">wolfssl 移植替换 openssl</a></li>
<li><a href="https://www.jianshu.com/p/4ef363a60668" target="_blank" rel="noopener">换用 CyaSSL 库</a></li>
</ol>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol>
<li><p>wolfssl 比较小，适合嵌入式环境</p>
<blockquote>
<p>wolfssl 在满足基本需求的同时，又能大大减小固件的大小</p>
</blockquote>
</li>
<li><p>wolfssl 性能相对优秀</p>
<blockquote>
<p>和 openssl 对比，wolfssl 的性能更加优秀，关于 openssl 和 wolfssl 的对比，可从 wolfssl 官网得到详尽的答案：<a href="https://www.wolfssl.com/docs/wolfssl-openssl/" target="_blank" rel="noopener">openssl 和 wolfssl 的特点对比</a></p>
</blockquote>
</li>
<li><p>wolfssl 方便移植</p>
<blockquote>
<p>wolfssl 除了本地 API 之外，wolfssl 还提供了一个 openssl 兼容性头文件 wolfssl/openssl/ssl.h ，以简化转换为使用 wolfssl 或帮助将现有的 openssl 应用程序移植到 wolfssl。openssl 兼容层将最常用的 openssl 命令的子集映射到 wolfssl 的本地 API 函数。</p>
</blockquote>
</li>
</ol>
<h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p><a href="https://www.wolfssl.com/docs/wolfssl-manual/ch2/" target="_blank" rel="noopener">configure –help 说明链接</a></p>
<p>交叉编译时需要注意</p>
<ol>
<li>使用<code>prefix</code>安装库</li>
<li>使用库地方<code>export prefix/lib/pkgconfig</code></li>
<li>或者使用<code>-L -I</code>指定路径</li>
</ol>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ol>
<li><a href="https://github.com/breezetemple/Breeze-Vim/blob/master/example/ssl/server_echo.c" target="_blank" rel="noopener">server</a></li>
<li><a href="https://github.com/breezetemple/Breeze-Vim/blob/master/example/ssl/client_echo.c" target="_blank" rel="noopener">client</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>wolfssl</tag>
      </tags>
  </entry>
  <entry>
    <title>DLNA SAT2IP 以及 UPnP 总结</title>
    <url>/2019/03/28/dlna-sat2ip-and-upnp/</url>
    <content><![CDATA[<p>本文记录<code>DLNA</code>、<code>SAT2IP</code>以及<code>UPnP</code>相关协议、实现理解</p>
<p>开源代码</p>
<ul>
<li>gmediarender</li>
<li>gmrender-resurrect – DMR</li>
<li>libupnp-1.6.25 – lib</li>
<li>minidlna-1.2.1 – DMS</li>
<li>xbmc</li>
<li>vlc – DMP</li>
<li>libsatip</li>
<li>minisatip – SAT2IP</li>
<li>satip-client</li>
<li>tvheadend</li>
</ul>
<p>协议资料</p>
<ul>
<li>UPnP-arch-DeviceArchitecture-v1.1.pdf</li>
<li>UPnP-arch-DeviceArchitecture-v2.0.pdf</li>
<li>DLNA Guidelines June 2016 - Part 1-1 Architectures and Protocols.pdf</li>
<li>DLNA Guidelines June 2016 - Part 1-2 XDMR.pdf</li>
<li>DLNA Guidelines June 2016 - Part 5 Device Profiles.pdf</li>
<li>satip_specification_version_1_2_2.pdf</li>
</ul>
<a id="more"></a>

<h2 id="upnp"><a href="#upnp" class="headerlink" title="upnp"></a>upnp</h2><p>内容包含了<code>ssdp</code>、<code>soap</code>和<code>GENA</code>，主要过程包括发现、描述、控制、事件和展示</p>
<p>设备分为两类：</p>
<ul>
<li><code>device</code>,Logical device. A container. May embed other logical devices. Embeds one or more services. Advertises its presence on network(s).<ul>
<li><code>Root device</code>, A logical device that is not embedded in any other logical device.</li>
<li><code>embedded device</code></li>
</ul>
</li>
<li><code>control point</code>, Retrieves device and service descriptions, sends actions to services, polls for service state variables, and receives events<br>from services.</li>
</ul>
<p>一个<code>UPnP 设备</code>可以是多个服务的载体和多个子设备的嵌套集。而<code>控制点 CP</code>指的是可以发现并控制其它设备的设备。逻辑关系如下：</p>
<p><img src="/images/dlna/1553738244030.png" alt="1553738244030"></p>
<p>控制使用<code>SOAP</code>逻辑如下：</p>
<p><img src="/images/dlna/1553738446538.png" alt="1553738446538"></p>
<p>事件逻辑如下：</p>
<p><img src="/images/dlna/1553738767542.png" alt="1553738767542"></p>
<h2 id="DLNA-与-SAT2IP-图"><a href="#DLNA-与-SAT2IP-图" class="headerlink" title="DLNA 与 SAT2IP 图"></a>DLNA 与 SAT2IP 图</h2><p><img src="/images/dlna/1553738835036.png" alt="1553738835036"></p>
<ul>
<li><code>Discovery</code>阶段，<code>SAT2IP</code>存在<code>DEVICE ID Negotiation</code></li>
<li><code>Description</code>阶段，<code>DLNA</code>存在<code>SCPDURL</code>、<code>controlURL</code>和<code>eventSubURL</code></li>
<li><code>Media Transport</code>，<code>DLNA</code>中<code>HTTP</code>是必选，<code>RTP</code>是可选；而<code>SAT2IP</code>相反</li>
</ul>
<h2 id="DLNA"><a href="#DLNA" class="headerlink" title="DLNA"></a>DLNA</h2><p><code>UPnP AV Architecture</code> 定义了<code>UPnP AV</code>设备间媒体传送以及和<code>CP</code>间的交互。<code>UPnP AV</code>也定义了两种<code>UPnP AV</code>设备：<code>UPnP AV MediaServer Device（MSD）</code>和<code>UPnP AV MediaRenderer Device（MRD）</code>，同时定义了可以提供的四种服务：[DLNA1-1 4.4]</p>
<ol>
<li><code>AVTransport Service</code> （可控制多屏设备上的媒体 play，pause，seek，stop 等）</li>
<li><code>RenderingControl Service</code> （可调节多屏设备上的音量，声音，静音等）</li>
<li><code>ContentDirectory Service</code> （可获取多屏设备上可访问的媒体内容）</li>
<li><code>ConnectionManager Service</code> （可提供所支持的传输协议信息及多屏设备的 MIME 格式信息）</li>
</ol>
<h3 id="DMS"><a href="#DMS" class="headerlink" title="DMS"></a>DMS</h3><blockquote>
<p>A UPnP AV MediaServer shall identify in the Device Description Document the<br>ContentDirectory service and the ConnectionManager service using serviceType and serviceId<br>elements with the values given in Table 10.</p>
</blockquote>
<p><img src="/images/dlna/1553740868260.png" alt="1553740868260"></p>
<p><code>minidlna</code>通过扫描指定目录并监控变化来提供服务</p>
<h3 id="DMR"><a href="#DMR" class="headerlink" title="DMR"></a>DMR</h3><blockquote>
<p>A UPnP AV MediaRenderer shall identify in the Device Description Document the<br>AVTransport service, the RenderingControl service, and the ConnectionManager service using<br>serviceType and serviceId elements with the values given in Table 9.</p>
</blockquote>
<p><img src="/images/dlna/1553740975457.png" alt="1553740975457"></p>
<p><code>gmrender-resurrect</code>使用<code>GStream</code>来提供<code>render</code>服务</p>
<h3 id="DMP"><a href="#DMP" class="headerlink" title="DMP"></a>DMP</h3><blockquote>
<p>DLNA Device Class having home network environmental characteristics, with the role of finding<br>content exposed by a DMS or M-DMS and rendering the content locally</p>
</blockquote>
<p>相比于另外一个<code>Rendering Endpoint：DMR</code>多个主动搜索<code>DMS</code>功能，通过发送<code>M-SEARCH</code>来发现<code>DMS</code></p>
<h3 id="DMC"><a href="#DMC" class="headerlink" title="DMC"></a>DMC</h3><blockquote>
<p>A Digital Media Controller (DMC) with the role of finding content exposed by a DMS and<br>matching it to the rendering capacities of a DMR and setting up the connections between the<br>DMS and DMR.</p>
</blockquote>
<p>用于在<code>DMS</code>和<code>DMR</code>建立连接并控制</p>
<h3 id="常见系统拓扑结构"><a href="#常见系统拓扑结构" class="headerlink" title="常见系统拓扑结构"></a>常见系统拓扑结构</h3><h4 id="客户端播放软件"><a href="#客户端播放软件" class="headerlink" title="客户端播放软件"></a>客户端播放软件</h4><p><code>minidlna</code>为<code>DMS</code>，<code>VLC</code>为<code>DMP</code>，通过搜索<code>DMS</code>并浏览目录来播放文件，逻辑如下</p>
<ol>
<li>Invoke UPnP actions to browse and select content.</li>
<li>Request the content for playback.</li>
<li>Transport the content to the DMP or the M-DMP.</li>
</ol>
<p><img src="/images/dlna/1553741595183.png" alt="1553741595183"></p>
<h4 id="手机推送到-DMR"><a href="#手机推送到-DMR" class="headerlink" title="手机推送到 DMR"></a>手机推送到 DMR</h4><p><code>手机</code>为<code>DMS/DMC?</code>，<code>gmrender-resurrect</code>为<code>DMR</code>，<code>手机</code>发送<code>SOAP ACTION</code>来完成控制，然后<code>DMR</code>从<code>DMS</code>获取数据进行播放</p>
<h2 id="SAT2IP"><a href="#SAT2IP" class="headerlink" title="SAT2IP"></a>SAT2IP</h2><p>结构图</p>
<p><img src="/images/sat2ip/20190226-093309.png" alt="img"></p>
<h3 id="SAT2IP-Server"><a href="#SAT2IP-Server" class="headerlink" title="SAT2IP Server"></a>SAT2IP Server</h3><p><code>SAT&gt;IP Servers</code> 处理 <code>SAT&gt;IP Clients</code>的请求并将电视直播节目转发给 <code>SAT&gt;IP Clients</code><br><code>Server</code>将<code>Tuner</code>数据编码为<code>RTSP</code>数据进行发送，参考<code>minisatip</code></p>
<h3 id="SAT2IP-Client"><a href="#SAT2IP-Client" class="headerlink" title="SAT2IP Client"></a>SAT2IP Client</h3><p><code>vlc</code>实现了<code>SAT2IP Client</code>，同时支持<code>DMP</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章总结<code>DMS</code>、<code>DMP</code>、<code>DMR</code>、<code>SAT2IP Server</code>以及<code>SAT2IP Client</code>相同与差异点</p>
<ol>
<li><code>DMP</code> = <code>DMR</code> + <code>DMC</code>，<code>DMR</code>是被动状态，等待其他设备的控制；而<code>DMP</code>会主动搜索<code>DMS</code>进行操作。一个是推，一个是拉</li>
<li><code>DMP</code>与<code>SAT2IP Client</code>均存在交互界面，根据界面选取内容进行控制播放等。在<code>VLC</code>中整合为同一个功能<code>upnp.c</code>，区别在于发现的<code>server</code>类型不同，其中<code>SAT2IP</code>存在协商过程</li>
<li><code>DLNA</code>与<code>SAT2IP</code>，设备发现及描述一致，需要<code>upnp</code>使用各自协议中规定字段</li>
<li><code>DLNA</code>与<code>SAT2IP</code>设备控制不一样，<code>DLNA</code>使用<code>HTTP/SOAP</code>，<code>SAT2IP</code>使用<code>RTSP</code></li>
<li><code>DMS</code>与<code>SAT2IP Server</code>，<code>SAT2IP</code>仅提供大网信号，且打包为<code>RTSP</code>进行传输；而<code>DMS</code>一般会提供多种格式文件，使用<code>HTTP GET/POST</code></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>upnp</tag>
        <tag>dlna</tag>
        <tag>sat2ip</tag>
        <tag>ssdp</tag>
        <tag>soap</tag>
        <tag>dms</tag>
        <tag>dmr</tag>
        <tag>dmp</tag>
      </tags>
  </entry>
  <entry>
    <title>DLNA DMR 和 DMP 分析</title>
    <url>/2019/03/27/dlna-dmr-and-dmp/</url>
    <content><![CDATA[<p>使用<code>wireshark</code>抓包分析<code>DMR</code>和<code>DMP</code>实现，包括设备发现、控制、播放等过程</p>
<a id="more"></a>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>DMS: <a href="https://help.ubuntu.com/community/MiniDLNA" target="_blank" rel="noopener">minidlna</a></li>
<li>DMR: <a href="https://github.com/hzeller/gmrender-resurrect.git" target="_blank" rel="noopener">gmrender-resurrect</a></li>
<li>DMP: <a href="https://github.com/videolan/vlc" target="_blank" rel="noopener">VLC</a></li>
<li>抓包数据 <a href="https://github.com/breezetemple/Breeze-Vim/blob/master/data/dlna/DLNA-Render.pcapng" target="_blank" rel="noopener">DMR-Wireshark</a></li>
<li>抓包数据 <a href="https://github.com/breezetemple/Breeze-Vim/blob/master/data/dlna/DLNA-DMP.pcapng" target="_blank" rel="noopener">DMP-Wireshark</a></li>
</ul>
<h2 id="DMR-流程"><a href="#DMR-流程" class="headerlink" title="DMR 流程"></a>DMR 流程</h2><p><code>Notify</code>或应答<code>M-SEARCH</code>-&gt;应答<code>GET XML/SCPD</code>-&gt;<code>SOAP ACTION</code>-&gt;<code>GET DATA</code>-&gt;<code>PLAY</code></p>
<h3 id="DMR-设备入网广播"><a href="#DMR-设备入网广播" class="headerlink" title="DMR 设备入网广播"></a>DMR 设备入网广播</h3><p>使用<code>ssdp:alive</code>通知消息，协议<code>upnpv2.0 1.2</code>，包含三种数据包</p>
<ol>
<li>Three discovery messages for the root device.</li>
<li>Two discovery messages for each embedded device. 可选项，在本次抓包中不存在</li>
<li>Once for each service type in each device.</li>
</ol>
<p>结构如下：</p>
<p><img src="/images/dlna/1553563823157.png" alt="1553563823157"></p>
<p><img src="/images/dlna/1553563848007.png" alt="1553563848007"></p>
<p><img src="/images/dlna/1553563870264.png" alt="1553563870264"></p>
<p><code>Frame 33-35</code>为表 1 数据，<code>Frame 36-38</code>为表 3 数据，分别为三种<code>service</code></p>
<ol>
<li><code>NT: urn:schemas-upnp-org:service:AVTransport:1\r\n</code></li>
<li><code>NT: urn:schemas-upnp-org:service:ConnectionManager:1\r\n</code></li>
<li><code>NT: urn:schemas-upnp-org:service:RenderingControl:1\r\n</code></li>
</ol>
<p>相关代码：</p>
<p><code>33-35</code>为<code>libupnp:UpnpSendAdvertisement</code></p>
<p><code>36-38</code>为<code>libupnp:</code></p>
<h3 id="DMC-入网搜索设备"><a href="#DMC-入网搜索设备" class="headerlink" title="DMC 入网搜索设备"></a>DMC 入网搜索设备</h3><p>发送<code>M-SEARCH ssdp:discover</code>发现设备，协议<code>upnpv2.0: 1.3</code></p>
<p><img src="/images/dlna/1553565538242.png" alt="1553565538242"></p>
<p>应答格式</p>
<p><img src="/images/dlna/1553565566078.png" alt="1553565566078"></p>
<p>对应帧为<code>243-253</code>，对应两种<code>ST search target</code></p>
<ol>
<li><code>upnp:rootdevice</code>，Search for root devices only.</li>
<li><code>urn:schemas-upnp-org:device:deviceType:ver</code>，Search for any device of this type where <code>deviceType</code> and<code>ver</code> are defined by the UPnP Forum working committee.<ul>
<li><code>ST: urn:schemas-upnp-org:device:MediaServer:1\r\n</code></li>
<li><code>ST: urn:schemas-upnp-org:device:MediaRenderer:1\r\n</code></li>
</ul>
</li>
</ol>
<p>应答帧<code>Frame 251</code>，信息如下</p>
<pre><code class="xml">HTTP/1.1 200 OK
CACHE-CONTROL: max-age=100
DATE: Tue, 26 Mar 2019 00:57:36 GMT
EXT:
LOCATION: http://192.168.199.183:49494/description.xml
OPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=01
01-NLS: 066fa5e8-4f62-11e9-9d14-bbebc675453c
SERVER: Linux/4.13.0-45-generic, UPnP/1.0, Portable SDK for UPnP devices/1.6.22
X-User-Agent: redsonic
ST: urn:schemas-upnp-org:device:MediaRenderer:1
USN: uuid:GMediaRender-1_0-000-000-002::urn:schemas-upnp-org:device:MediaRenderer:1</code></pre>
<h3 id="DMC-获取描述文件"><a href="#DMC-获取描述文件" class="headerlink" title="DMC 获取描述文件"></a>DMC 获取描述文件</h3><p>通过<code>HTTP GET/POST</code>来完成，协议<code>upnp: 2</code></p>
<p><img src="/images/dlna/1553566959878.png" alt="1553566959878"></p>
<p><code>Frame 257</code></p>
<pre><code>GET /description.xml HTTP/1.1
HOST: 192.168.199.183:49494
DATE: Tue, 26 Mar 2019 00:57:35 GMT
CONNECTION: close
USER-AGENT: Linux/4.4.23+ UPnP/1.0 HUAWEI_iCOS/iCOS V1R1C00 DLNADOC/1.50</code></pre><p>应答帧<code>258-261</code>使用<code>TCP</code>发送数据</p>
<pre><code>HTTP/1.1 200 OK
CONTENT-LENGTH: 2073
CONTENT-TYPE: text/xml
DATE: Tue, 26 Mar 2019 00:57:36 GMT
LAST-MODIFIED: Tue, 26 Mar 2019 00:56:44 GMT
SERVER: Linux/4.13.0-45-generic, UPnP/1.0, Portable SDK for UPnP devices/1.6.22
X-User-Agent: redsonic
CONNECTION: close</code></pre><p><code>description.xml</code>如下</p>
<pre><code class="xml">&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;&gt;
&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;0&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:schemas-upnp-org:device:MediaRenderer:1&lt;/deviceType&gt;
&lt;presentationURL/&gt;
&lt;friendlyName&gt;My Renderer&lt;/friendlyName&gt;
&lt;manufacturer&gt;Ivo Clarysse, Henner Zeller&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;http://github.com/hzeller/gmrender-resurrect&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;gmediarender 0.0.7-git&lt;/modelDescription&gt;
&lt;modelName&gt;gmediarender&lt;/modelName&gt;
&lt;modelNumber&gt;2018-08-18_a7b0b1b&lt;/modelNumber&gt;
&lt;modelURL&gt;http://github.com/hzeller/gmrender-resurrect&lt;/modelURL&gt;
&lt;UDN&gt;uuid:GMediaRender-1_0-000-000-002&lt;/UDN&gt;
&lt;iconList&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;64&lt;/width&gt;
&lt;height&gt;64&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/upnp/grender-64x64.png&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;128&lt;/width&gt;
&lt;height&gt;128&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/upnp/grender-128x128.png&lt;/url&gt;
&lt;/icon&gt;
&lt;/iconList&gt;
&lt;serviceList&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:AVTransport:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:AVTransport&lt;/serviceId&gt;
&lt;SCPDURL&gt;/upnp/rendertransportSCPD.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;/upnp/control/rendertransport1&lt;/controlURL&gt;
&lt;eventSubURL&gt;/upnp/event/rendertransport1&lt;/eventSubURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:ConnectionManager:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:ConnectionManager&lt;/serviceId&gt;
&lt;SCPDURL&gt;/upnp/renderconnmgrSCPD.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;/upnp/control/renderconnmgr1&lt;/controlURL&gt;
&lt;eventSubURL&gt;/upnp/event/renderconnmgr1&lt;/eventSubURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:RenderingControl:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:RenderingControl&lt;/serviceId&gt;
&lt;SCPDURL&gt;/upnp/rendercontrolSCPD.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;/upnp/control/rendercontrol1&lt;/controlURL&gt;
&lt;eventSubURL&gt;/upnp/event/rendercontrol1&lt;/eventSubURL&gt;
&lt;/service&gt;
&lt;/serviceList&gt;
&lt;/device&gt;
&lt;URLBase&gt;http://192.168.199.183:49494/&lt;/URLBase&gt;
&lt;/root&gt;</code></pre>
<p><code>service</code>分析</p>
<pre><code>&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:RenderingControl:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:RenderingControl&lt;/serviceId&gt;
&lt;SCPDURL&gt;/upnp/rendercontrolSCPD.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;/upnp/control/rendercontrol1&lt;/controlURL&gt;
&lt;eventSubURL&gt;/upnp/event/rendercontrol1&lt;/eventSubURL&gt;
&lt;/service&gt;</code></pre><ul>
<li><code>serviceType</code>: UPnP service type</li>
<li><code>serviceId</code>: Service identifier</li>
<li><code>SCPDURL</code>: URL for service description clause 2.5</li>
<li><code>controlURL</code>: URL for control clause 3</li>
<li><code>eventSubURL</code>: URL for eventing clause 4</li>
</ul>
<p>数据包分析</p>
<ol>
<li><code>Frame 282-298</code>获取<code>/upnp/rendertransportSCPD.xml</code></li>
<li><code>Frame 309-315</code>获取<code>/upnp/renderconnmgrSCPD.xml</code></li>
<li><code>Frame 325-337</code>获取<code>/upnp/rendercontrolSCPD.xml</code></li>
</ol>
<ul>
<li><a href="https://github.com/breezetemple/Breeze-Vim/blob/master/data/dlna/rendertransportSCPD.xml" target="_blank" rel="noopener">rendertransportSCPD.xml</a></li>
<li><a href="https://github.com/breezetemple/Breeze-Vim/blob/master/data/dlna/renderconnmgrSCPD.xml" target="_blank" rel="noopener">renderconnmgrSCPD.xml</a></li>
<li><a href="https://github.com/breezetemple/Breeze-Vim/blob/master/data/dlna/rendercontrolSCPD.xml" target="_blank" rel="noopener">rendercontrolSCPD.xml</a></li>
</ul>
<p><code>353</code>订阅消息，<code>upnp2.0： 4.1</code></p>
<pre><code>SUBSCRIBE /upnp/event/rendertransport1 HTTP/1.1
HOST: 192.168.199.183:49494
CALLBACK: &lt;http://192.168.199.114:49153/&gt;
NT: upnp:event
TIMEOUT: Second-300
CONNECTION: close</code></pre><p><code>355</code>为应答</p>
<pre><code>HTTP/1.1 200 OK
DATE: Tue, 26 Mar 2019 00:57:37 GMT
SERVER: Linux/4.13.0-45-generic, UPnP/1.0, Portable SDK for UPnP devices/1.6.22
CONTENT-LENGTH: 0
X-User-Agent: redsonic
SID: uuid:263cbdde-4f62-11e9-9d14-bbebc675453c
TIMEOUT: Second-300</code></pre><p><code>366</code>发送消息<code>NOTIFY</code>，<code>upnp2.0 4.3.2 Unicast eventing: Event messages: NOTIFY</code></p>
<pre><code>NOTIFY / HTTP/1.1
HOST: 192.168.199.114:49153
CONTENT-TYPE: text/xml; charset=&quot;utf-8&quot;
CONTENT-LENGTH: 2168
NT: upnp:event
NTS: upnp:propchange
SID: uuid:263cbdde-4f62-11e9-9d14-bbebc675453c
SEQ: 0

&lt;e:propertyset xmlns:e=&quot;urn:schemas-upnp-org:event-1-0&quot;&gt;
&lt;e:property&gt;
&lt;LastChange&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;Event xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/AVT/&quot;&amp;gt;
&amp;lt;InstanceID val=&quot;0&quot;&amp;gt;
&amp;lt;TransportStatus val=&quot;OK&quot;&amp;gt;&amp;lt;/TransportStatus&amp;gt;
&amp;lt;NextAVTransportURI val=&quot;&quot;&amp;gt;&amp;lt;/NextAVTransportURI&amp;gt;
&amp;lt;NextAVTransportURIMetaData val=&quot;&quot;&amp;gt;&amp;lt;/NextAVTransportURIMetaData&amp;gt;
&amp;lt;CurrentTrackMetaData val=&quot;&quot;&amp;gt;&amp;lt;/CurrentTrackMetaData&amp;gt;
&amp;lt;RelativeCounterPosition val=&quot;2147483647&quot;&amp;gt;&amp;lt;/RelativeCounterPosition&amp;gt;
&amp;lt;PlaybackStorageMedium val=&quot;UNKNOWN&quot;&amp;gt;&amp;lt;/PlaybackStorageMedium&amp;gt;
&amp;lt;RelativeTimePosition val=&quot;0:00:00&quot;&amp;gt;&amp;lt;/RelativeTimePosition&amp;gt;
&amp;lt;PossibleRecordStorageMedia val=&quot;NOT_IMPLEMENTED&quot;&amp;gt;&amp;lt;/PossibleRecordStorageMedia&amp;gt;
&amp;lt;CurrentPlayMode val=&quot;NORMAL&quot;&amp;gt;&amp;lt;/CurrentPlayMode&amp;gt;
&amp;lt;TransportPlaySpeed val=&quot;1&quot;&amp;gt;&amp;lt;/TransportPlaySpeed&amp;gt;
&amp;lt;PossiblePlaybackStorageMedia val=&quot;NETWORK,UNKNOWN&quot;&amp;gt;&amp;lt;/PossiblePlaybackStorageMedia&amp;gt;
&amp;lt;AbsoluteTimePosition val=&quot;NOT_IMPLEMENTED&quot;&amp;gt;&amp;lt;/AbsoluteTimePosition&amp;gt;
&amp;lt;CurrentTrack val=&quot;0&quot;&amp;gt;&amp;lt;/CurrentTrack&amp;gt;
&amp;lt;CurrentTrackURI val=&quot;&quot;&amp;gt;&amp;lt;/CurrentTrackURI&amp;gt;
&amp;lt;CurrentTransportActions val=&quot;PLAY&quot;&amp;gt;&amp;lt;/CurrentTransportActions&amp;gt;
&amp;lt;NumberOfTracks val=&quot;0&quot;&amp;gt;&amp;lt;/NumberOfTracks&amp;gt;
&amp;lt;AVTransportURI val=&quot;&quot;&amp;gt;&amp;lt;/AVTransportURI&amp;gt;
&amp;lt;AbsoluteCounterPosition val=&quot;2147483647&quot;&amp;gt;&amp;lt;/AbsoluteCounterPosition&amp;gt;
&amp;lt;CurrentRecordQualityMode val=&quot;NOT_IMPLEMENTED&quot;&amp;gt;&amp;lt;/CurrentRecordQualityMode&amp;gt;
&amp;lt;CurrentMediaDuration val=&quot;&quot;&amp;gt;&amp;lt;/CurrentMediaDuration&amp;gt;
&amp;lt;AVTransportURIMetaData val=&quot;&quot;&amp;gt;&amp;lt;/AVTransportURIMetaData&amp;gt;
&amp;lt;RecordStorageMedium val=&quot;NOT_IMPLEMENTED&quot;&amp;gt;&amp;lt;/RecordStorageMedium&amp;gt;
&amp;lt;RecordMediumWriteStatus val=&quot;NOT_IMPLEMENTED&quot;&amp;gt;&amp;lt;/RecordMediumWriteStatus&amp;gt;
&amp;lt;CurrentTrackDuration val=&quot;0:00:00&quot;&amp;gt;&amp;lt;/CurrentTrackDuration&amp;gt;
&amp;lt;TransportState val=&quot;STOPPED&quot;&amp;gt;&amp;lt;/TransportState&amp;gt;
&amp;lt;PossibleRecordQualityModes val=&quot;NOT_IMPLEMENTED&quot;&amp;gt;&amp;lt;/PossibleRecordQualityModes&amp;gt;
&amp;lt;/InstanceID&amp;gt;
&amp;lt;/Event&amp;gt;
&lt;/LastChange&gt;
&lt;/e:property&gt;
&lt;/e:propertyset&gt;</code></pre><p><code>511</code>发送<code>SOAPACTION</code></p>
<pre><code>POST /upnp/control/rendertransport1 HTTP/1.1
HOST: 192.168.199.183:49494
Content-Length: 264
CONTENT-TYPE: text/xml; charset=&quot;utf-8&quot;
SOAPACTION: &quot;urn:schemas-upnp-org:service:AVTransport:1#Stop&quot;
USER-AGENT: Linux/4.4.23+ UPnP/1.0 HUAWEI_iCOS/iCOS V1R1C00 DLNADOC/1.50
CONNECTION: close

&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
&lt;s:Body&gt;&lt;u:Stop xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;
&lt;InstanceID&gt;0&lt;/InstanceID&gt;
&lt;/u:Stop&gt;
&lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><p><code>521</code></p>
<pre><code>POST /upnp/control/rendertransport1 HTTP/1.1
HOST: 192.168.199.183:49494
Content-Length: 1168
CONTENT-TYPE: text/xml; charset=&quot;utf-8&quot;
SOAPACTION: &quot;urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI&quot;
USER-AGENT: Linux/4.4.23+ UPnP/1.0 HUAWEI_iCOS/iCOS V1R1C00 DLNADOC/1.50
CONNECTION: close

&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
&lt;s:Body&gt;&lt;u:SetAVTransportURI xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;
&lt;InstanceID&gt;0&lt;/InstanceID&gt;
&lt;CurrentURI&gt;http://192.168.199.114:49152/upnp/service/local/98070551/0/0.jpg&lt;/CurrentURI&gt;
&lt;CurrentURIMetaData&gt;&amp;lt;DIDL-Lite xmlns=&amp;quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&amp;quot; xmlns:dc=&amp;quot;http://purl.org/dc/elements/1.1/&amp;quot; xmlns:upnp=&amp;quot;urn:schemas-upnp-org:metadata-1-0/upnp/&amp;quot; xmlns:dlna=&amp;quot;urn:schemas-dlna-org:metadata-1-0/&amp;quot; xmlns:huawei=&amp;quot;urn:schemas-upnp-org:metadata-1-0/upnp/huawei/&amp;quot;&amp;gt;&amp;lt;item id=&amp;quot;0&amp;quot; parentID=&amp;quot;-1&amp;quot; restricted=&amp;quot;1&amp;quot;&amp;gt;&amp;lt;dc:title&amp;gt;dlna_default_image&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res protocolInfo=&amp;quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_OP=01&amp;quot; size=&amp;quot;501872&amp;quot;&amp;gt;http://192.168.199.114:49152/upnp/service/local/98070551/0/0.jpg&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/DIDL-Lite&amp;gt;&lt;/CurrentURIMetaData&gt;
&lt;/u:SetAVTransportURI&gt;
&lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><p><code>533 EVENT NOTIFY</code></p>
<p><code>541 PLAY</code></p>
<pre><code>POST /upnp/control/rendertransport1 HTTP/1.1
HOST: 192.168.199.183:49494
Content-Length: 282
CONTENT-TYPE: text/xml; charset=&quot;utf-8&quot;
SOAPACTION: &quot;urn:schemas-upnp-org:service:AVTransport:1#Play&quot;
USER-AGENT: Linux/4.4.23+ UPnP/1.0 HUAWEI_iCOS/iCOS V1R1C00 DLNADOC/1.50
CONNECTION: close

&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
&lt;s:Body&gt;&lt;u:Play xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;
&lt;InstanceID&gt;0&lt;/InstanceID&gt;
&lt;Speed&gt;1&lt;/Speed&gt;
&lt;/u:Play&gt;
&lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><p><code>565 DMR 获取图片数据</code></p>
<pre><code>GET /upnp/service/local/98070551/0/0.jpg HTTP/1.1
Host: 192.168.199.114:49152
Connection: close
icy-metadata: 1
User-Agent: GStreamer souphttpsrc 1.12.3 libsoup/2.60.1</code></pre><h3 id="切换节目"><a href="#切换节目" class="headerlink" title="切换节目"></a>切换节目</h3><p><code>1514：STOP</code></p>
<p><code>1524：SOAPACTION: &quot;urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI&quot;\r\n</code></p>
<p><code>1544：SOAPACTION: &quot;urn:schemas-upnp-org:service:AVTransport:1#Play&quot;\r\n</code></p>
<p><code>1563 GET Video</code></p>
<h2 id="DMP-抓包分析"><a href="#DMP-抓包分析" class="headerlink" title="DMP 抓包分析"></a>DMP 抓包分析</h2><p>大致流程<code>discover</code>-&gt;<code>description</code>-&gt;<code>post soapaction</code>-&gt;<code>get Data</code>-&gt;<code>Play</code></p>
<h3 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h3><p><code>DMP</code>即<code>client</code>发送<code>M-SEARCH ssdp:discover</code>来发现<code>server</code>，<code>Frame270</code></p>
<pre><code>M-SEARCH * HTTP/1.1
HOST: 239.255.255.250:1900
MAN: &quot;ssdp:discover&quot;
MX: 5
ST: urn:schemas-upnp-org:device:MediaServer:1</code></pre><p>相关代码<code>libupnp:UpnpSearchAsync</code>，<code>vlc</code>有相关实现，应答如下，<code>Frame271</code></p>
<pre><code>HTTP/1.1 200 OK
CACHE-CONTROL: max-age=1810
DATE: Tue, 26 Mar 2019 03:25:52 GMT
ST: urn:schemas-upnp-org:device:MediaServer:1
USN: uuid:4d696e69-444c-164e-9d41-28d2446289b1::urn:schemas-upnp-org:device:MediaServer:1
EXT:
SERVER: 4.13.0-37-generic DLNADOC/1.50 UPnP/1.0 MiniDLNA/1.2.1
LOCATION: http://192.168.199.183:8200/rootDesc.xml
Content-Length: 0</code></pre><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>根据<code>LOACTION</code>获取描述文件，请求如下，<code>Frame275</code></p>
<pre><code>GET /rootDesc.xml HTTP/1.1
HOST: 192.168.199.183:8200
DATE: Tue, 26 Mar 2019 03:25:51 GMT
CONNECTION: close
USER-AGENT: Linux/4.4.23+, UPnP/1.0, Portable SDK for UPnP devices/1.6.19</code></pre><p>应答中传输描述文件，如下</p>
<pre><code class="xml">&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;&gt;
&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;0&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:schemas-upnp-org:device:MediaServer:1&lt;/deviceType&gt;
&lt;friendlyName&gt;My DLNA XXX&lt;/friendlyName&gt;
&lt;manufacturer&gt;Justin Maggard&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;http://www.netgear.com/&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;MiniDLNA on Linux&lt;/modelDescription&gt;
&lt;modelName&gt;Windows Media Connect compatible (MiniDLNA)&lt;/modelName&gt;
&lt;modelNumber&gt;1&lt;/modelNumber&gt;
&lt;modelURL&gt;http://www.netgear.com&lt;/modelURL&gt;
&lt;serialNumber&gt;12345678&lt;/serialNumber&gt;
&lt;UDN&gt;uuid:4d696e69-444c-164e-9d41-28d2446289b1&lt;/UDN&gt;
&lt;dlna:X_DLNADOC xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot;&gt;DMS-1.50&lt;/dlna:X_DLNADOC&gt;
&lt;presentationURL&gt;/&lt;/presentationURL&gt;
&lt;iconList&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;48&lt;/width&gt;
&lt;height&gt;48&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/sm.png&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;120&lt;/width&gt;
&lt;height&gt;120&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/lrg.png&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/jpeg&lt;/mimetype&gt;
&lt;width&gt;48&lt;/width&gt;
&lt;height&gt;48&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/sm.jpg&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/jpeg&lt;/mimetype&gt;
&lt;width&gt;120&lt;/width&gt;
&lt;height&gt;120&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/lrg.jpg&lt;/url&gt;
&lt;/icon&gt;
&lt;/iconList&gt;
&lt;serviceList&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:ContentDirectory:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:ContentDirectory&lt;/serviceId&gt;
&lt;controlURL&gt;/ctl/ContentDir&lt;/controlURL&gt;
&lt;eventSubURL&gt;/evt/ContentDir&lt;/eventSubURL&gt;
&lt;SCPDURL&gt;/ContentDir.xml&lt;/SCPDURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:ConnectionManager:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:ConnectionManager&lt;/serviceId&gt;
&lt;controlURL&gt;/ctl/ConnectionMgr&lt;/controlURL&gt;
&lt;eventSubURL&gt;/evt/ConnectionMgr&lt;/eventSubURL&gt;
&lt;SCPDURL&gt;/ConnectionMgr.xml&lt;/SCPDURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;
urn:microsoft.com:service:X_MS_MediaReceiverRegistrar:1
&lt;/serviceType&gt;
&lt;serviceId&gt;
urn:microsoft.com:serviceId:X_MS_MediaReceiverRegistrar
&lt;/serviceId&gt;
&lt;controlURL&gt;/ctl/X_MS_MediaReceiverRegistrar&lt;/controlURL&gt;
&lt;eventSubURL&gt;/evt/X_MS_MediaReceiverRegistrar&lt;/eventSubURL&gt;
&lt;SCPDURL&gt;/X_MS_MediaReceiverRegistrar.xml&lt;/SCPDURL&gt;
&lt;/service&gt;
&lt;/serviceList&gt;
&lt;/device&gt;
&lt;/root&gt;</code></pre>
<h3 id="POST-SOAPACTION"><a href="#POST-SOAPACTION" class="headerlink" title="POST SOAPACTION"></a>POST SOAPACTION</h3><p>根据<code>xml</code>中描述的<code>service</code>选择相关操作，例如操作文件夹请求如下，<code>Frame335</code></p>
<pre><code>POST /ctl/ContentDir HTTP/1.1
HOST: 192.168.199.183:8200
CONTENT-LENGTH: 440
CONTENT-TYPE: text/xml; charset=&quot;utf-8&quot;
SOAPACTION: &quot;urn:schemas-upnp-org:service:ContentDirectory:1#Browse&quot;
USER-AGENT: Linux/4.4.23+, UPnP/1.0, Portable SDK for UPnP devices/1.6.19

&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
&lt;s:Body&gt;&lt;u:Browse xmlns:u=&quot;urn:schemas-upnp-org:service:ContentDirectory:1&quot;&gt;
&lt;ObjectID&gt;0&lt;/ObjectID&gt;
&lt;BrowseFlag&gt;BrowseDirectChildren&lt;/BrowseFlag&gt;
&lt;Filter&gt;*&lt;/Filter&gt;
&lt;StartingIndex&gt;0&lt;/StartingIndex&gt;
&lt;RequestedCount&gt;5000&lt;/RequestedCount&gt;
&lt;SortCriteria&gt;&lt;/SortCriteria&gt;
&lt;/u:Browse&gt;
&lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><p><code>Frame 442-569</code>为翻到文件夹最底层，会传输大量图片数据上来</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;s:Body&gt;&lt;u:BrowseResponse xmlns:u=&quot;urn:schemas-upnp-org:service:ContentDirectory:1&quot;&gt;&lt;Result&gt;&amp;lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot; xmlns:dlna=&quot;urn:schemas-dlna-org:metadata-1-0/&quot;&amp;gt;
&amp;lt;item id=&quot;3$FF0$64$13$B&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$B&quot;&amp;gt;&amp;lt;dc:title&amp;gt;543161&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;532088&quot; resolution=&quot;2048x1345&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25615.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x575&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25615.jpg?width=1024,height=575&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x359&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25615.jpg?width=640,height=359&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x89&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25615.jpg?width=160,height=89&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$2B&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$2B&quot;&amp;gt;&amp;lt;dc:title&amp;gt;543159&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;461737&quot; resolution=&quot;1920x1260&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25616.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x671&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25616.jpg?width=1024,height=671&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x419&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25616.jpg?width=640,height=419&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x104&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25616.jpg?width=160,height=104&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$2D&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$2D&quot;&amp;gt;&amp;lt;dc:title&amp;gt;543117&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;674720&quot; resolution=&quot;2880x1800&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25618.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x639&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25618.jpg?width=1024,height=639&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x399&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25618.jpg?width=640,height=399&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x98&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25618.jpg?width=160,height=98&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$2F&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$2F&quot;&amp;gt;&amp;lt;dc:title&amp;gt;543019&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;753825&quot; resolution=&quot;1920x1200&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25620.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x639&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25620.jpg?width=1024,height=639&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x399&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25620.jpg?width=640,height=399&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x99&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25620.jpg?width=160,height=99&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$31&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$31&quot;&amp;gt;&amp;lt;dc:title&amp;gt;543128&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;836038&quot; resolution=&quot;2048x1325&quot;  protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25603.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x681&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25603.jpg?width=1024,height=681&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x426&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25603.jpg?width=640,height=426&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x106&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25603.jpg?width=160,height=106&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$21&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$21&quot;&amp;gt;&amp;lt;dc:title&amp;gt;542965&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;1726194&quot; resolution=&quot;1920x1200&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25606.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x639&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25606.jpg?width=1024,height=639&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x399&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25606.jpg?width=640,height=399&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x99&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25606.jpg?width=160,height=99&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$23&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$23&quot;&amp;gt;&amp;lt;dc:title&amp;gt;542998&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;2904437&quot; resolution=&quot;1920x1200&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25608.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x639&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25608.jpg?width=1024,height=639&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x399&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25608.jpg?width=640,height=399&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x99&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25608.jpg?width=160,height=99&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$2C&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$2C&quot;&amp;gt;&amp;lt;dc:title&amp;gt;542934&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;1098202&quot; resolution=&quot;2048x1360&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25617.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x680&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25617.jpg?width=1024,height=680&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x425&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25617.jpg?width=640,height=425&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x106&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25617.jpg?width=160,height=106&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;item id=&quot;3$FF0$64$13$2E&quot; parentID=&quot;3$FF0&quot; restricted=&quot;1&quot; refID=&quot;64$13$2E&quot;&amp;gt;&amp;lt;dc:title&amp;gt;542994&amp;lt;/dc:title&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.imageItem.photo&amp;lt;/upnp:class&amp;gt;&amp;lt;res size=&quot;970686&quot; resolution=&quot;1920x1200&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_LRG;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/MediaItems/25619.jpg&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;1024x639&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_MED;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25619.jpg?width=1024,height=639&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;640x399&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25619.jpg?width=640,height=399&amp;lt;/res&amp;gt;&amp;lt;res resolution=&quot;160x99&quot; protocolInfo=&quot;http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=00F00000000000000000000000000000&quot;&amp;gt;http://192.168.199.183:8200/Resized/25619.jpg?width=160,height=99&amp;lt;/res&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/DIDL-Lite&amp;gt;&lt;/Result&gt;
&lt;NumberReturned&gt;50&lt;/NumberReturned&gt;
&lt;TotalMatches&gt;50&lt;/TotalMatches&gt;
&lt;UpdateID&gt;1&lt;/UpdateID&gt;&lt;/u:BrowseResponse&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;</code></pre>
<p>播放某个具体图片请求，<code>Frame 755</code></p>
<pre><code>GET /MediaItems/25602.jpg HTTP/1.1
Host: 192.168.199.183:8200
Accept: */*
Accept-Language: en_US
User-Agent: VLC/3.0.4 LibVLC/3.0.4
Range: bytes=0-</code></pre>]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>upnp</tag>
        <tag>dlna</tag>
        <tag>ssdp</tag>
        <tag>soap</tag>
        <tag>dmr</tag>
        <tag>dmp</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark-tcp-retransmission</title>
    <url>/2019/03/20/wireshark-tcp-retransmission/</url>
    <content><![CDATA[<p>TCP 错误恢复功能（TCP 重传与重复 ACK）和流控功能说起。之后阐述如何发现网络慢速之源。最后，对网络各组成部分上的数据流进行概况分析。这几张内容将会帮助读者识别，诊断，以及排查慢速网络。</p>
<a id="more"></a>

<h2 id="wireshark-常见提示"><a href="#wireshark-常见提示" class="headerlink" title="wireshark 常见提示"></a>wireshark 常见提示</h2><a href="/2019/03/19/wireshark-tcp-info/" title="Wireshark 中常见的 TCP Info">Wireshark 中常见的 TCP Info</a>

<p>TCP 错误恢复功能：</p>
<p>TCP 的错误恢复功能是定位，诊断及修复网络延时的最佳工具。延时可以在单程也可以往返方向测量。高延时是网络管理员的头号大敌。本节我们讨论 TCP 高延时是如何导致序列号和确认号乱序的。</p>
<p>TCP 重传：</p>
<p>主机报文重传是 TCP 最基本的错误恢复功能，它的目的是防止报文丢失。</p>
<p>报文丢失的可能因素有很多种，包括应用故障，路由设备过载，或暂时的服务宕机。报文级别速度是很高的，而通常报文丢失是暂时的，因此 TCP 能够发现和恢复报文丢失显得尤为重要。</p>
<p>决定报文是否有必要重传的主要机制是重传计时器（retransmission timer），它的主要功能是维护重传超时（RTO）值。当报文使用 TCP 传输时，重传计时器启动，收到 ACK 时计时器停止。报文发送至接收到 ACK 的时间称为往返时间（RTT）。对若干次时间取平均值，该值用于确定最终 RTO 值。在最终 RTO 值确定之前，确定每一次报文传输是否有丢包发生使用重传计时器，下图说明了 TCP 重传过程。</p>
<p><img src="https://box.kancloud.cn/2015-09-09_55efb0be42972.jpg" alt="img"></p>
<p>当报文发送之后，但接收方尚未发送 TCP ACK 报文，发送方假设源报文丢失并将其重传。重传之后，RTO 值加倍；如果在 2 倍 RTO 值到达之前还是没有收到 ACK 报文，就再次重传。如果仍然没有收到 ACK，那么 RTO 值再次加倍。如此持续下去，每次重传 RTO 都翻倍，直到收到 ACK 报文或发送方达到配置的最大重传次数。</p>
<p>最大重传次数取决于发送操作系统的配置值。默认情况下，Windows 主机默认重传 5 次。大多数 Linux 系统默认最大 15 次。两种操作系统都可配置。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.kancloud.cn/digest/wireshark/62473" target="_blank" rel="noopener">网络性能排查之 TCP 重传与重复 ACK</a></li>
<li><a href="https://blog.csdn.net/chenfengdejuanlian/article/details/53761004" target="_blank" rel="noopener">TCP 报文之 -tcp dup ack 、tcp Out-of-Order</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>Tools</category>
        <category>TCP</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark 中常见的 TCP Info</title>
    <url>/2019/03/19/wireshark-tcp-info/</url>
    <content><![CDATA[<p>wireshark 抓包分析 TCP 常见信息</p>
<a id="more"></a>

<h2 id="TCP-Previous-segment-not-captured"><a href="#TCP-Previous-segment-not-captured" class="headerlink" title="TCP Previous segment not captured"></a>TCP Previous segment not captured</h2><p>前一个 TCP 分段没有抓到。 在 TCP 连接建立的时候，SYN 包里面会把彼此 TCP 最大的报文段长度，即 MSS 标志，一般都是 1460。如果发送的包比最大的报文段长度长的话就要分片了，被分片出来的包，就会被标记了<code>TCP segment of a reassembled PDU</code>，<strong>这些包分片存在同样的<code>ack number</code>，且每个分片的<code>seq number</code>不同</strong>。</p>
<p>这些分片正常应该是连续接收的，即<strong>前一个分片指示的<code>next seq number</code>即为下一个收到的分片的<code>seq number</code></strong>。假如收到的下一个分片的<code>seq number</code>与上一个比不连续的话，wireshark 就会将该分片标记为<code>TCP Previous segment not captured</code>。如下图，<code>ack number</code>为 500 的 TCP 包被分为多个分片发送，在<code>1346</code>后应该收到一个<code>seq=60817 ack number=500</code>的包，但是<code>1347</code>为<code>seq=62265 ack number=500</code></p>
<p><img src="/images/wireshark/1553073720428.png" alt="1553073720428"></p>
<p>需要注意的是，前一个分片丢失，有可能是网络中确实丢失了，或者晚到了，也有可能是 wireshark 本身并没有抓到。</p>
<h2 id="TCP-out-of-order-segment"><a href="#TCP-out-of-order-segment" class="headerlink" title="TCP out-of-order segment"></a>TCP out-of-order segment</h2><p>Wireshark 判断<code>TCP out-of-order</code>是基于 TCP 包中 SEQ number 并非期望收到的下一个 SEQ number，则判断为 out-of-order。因此，出现 TCP out-of-order 时，很大可能是 TCP 存在乱序或丢包，导致接收端的 seq number 不连续。 如上图<code>1349</code>，在客户端已经收到服务端的 TCP 包<code>seq=62265 ack number=500</code>，服务端再次发送了 TCP 包<code>seq=60817 ack number=500</code>，wireshark 将此包标记为 out-of-order。</p>
<p>如果抓包中出现大量的 out-of-order 包，则说明网络存在较大的 TCP 乱序或丢包。</p>
<h2 id="TCP-Spurious-Retransmission"><a href="#TCP-Spurious-Retransmission" class="headerlink" title="TCP Spurious Retransmission"></a>TCP Spurious Retransmission</h2><p>TCP 虚假重传。 发送端重发了一个已经收到应答的报文段。<br><strong>当抓到 2 次同一包数据时，wireshark 判断网络发生了重传，同时，wireshark 抓到初传包的反馈 ack，因此 wireshark 判断初传包实际并没有丢失，因此称为虚假重传</strong>。基于 wireshark 的判断机制，如果抓包点在客户端的话，虚假重传一般为下行包，因为这时，客户端在收到服务端的下行包后发送反馈 ack，并被 wireshark 抓到，但很有可能服务端未收到此反馈 ack，RTO 超时，触发服务端重传。如下图，红框内出现了 2 次虚假重传，其中绿色的两条为同一包数据，粉色的两条为同一包数据。</p>
<p><img src="/images/wireshark/1553135965445.png" alt="1553135965445"></p>
<h2 id="TCP-Retransmission"><a href="#TCP-Retransmission" class="headerlink" title="TCP Retransmission"></a>TCP Retransmission</h2><p>TCP 重传。<br><strong>当抓到 2 次同一包数据时，wireshark 判断发生了重传，同时 wireshark 没有抓到初传包的反馈 ack，因此，wireshark 判定重传有效，标记为 TCP Retransmission</strong>。基于软件的判定机制，如果抓包点在客户端的话，TCP 重传一般为上行包，因为这时，客户端并没有收到服务端的反馈 ack，无从知晓服务端是否收到了初传包，RTO 超时后触发客户端重传。此时存在 2 种情况：</p>
<ol>
<li>服务端收到了初传包，只是下发的反馈 ack 丢包，客户端没有收到</li>
<li>服务端没有收到初传包，因此也就没有下发反馈 ack</li>
</ol>
<p>如下图，红线的 TCP 包为重传包，wireshark 为该包添加了重传原因，是由于 TRO 超时导致，以及初传包序号 45，并给出了当前的 RTO 超时时间。</p>
<p><img src="/images/wireshark/1553138137570.png" alt="1553138137570"></p>
<h2 id="TCP-fast-Retransmission"><a href="#TCP-fast-Retransmission" class="headerlink" title="TCP fast Retransmission"></a>TCP fast Retransmission</h2><p>TCP 快速重传。<br><strong>TCP 协议设定了快速重传机制以避免过多的慢启动对传输速率的影响。快速重传通过接收到 3 个或 3 个以上重复的 ack 反馈触发。快速重传不需要等待 RTO 超时</strong>。如下图。<br>325 包，客户端向服务端反馈 ack=133251，说明下一个期望收到服务端 seq=133251 的包；<br>326 包，服务端向客户端发送了 seq=135771 的数据包，与客户端的期望不符，因此客户端在 327 包重传了 ack=133251 的包，再次申明期望收到 seq=133251 的包。Wireshark 将重复 ack 标记为 TCP Dup ACK，#后边指明为第几次重传。<br>328 包，服务端向客户端发送了 seq=137031 的数据包，仍然与客户端期望不符，客户端在 329 包再次重传 ack=133251 的包。<br>330 包，服务端收到 3 次重复 ack，触发快速重传，重传了 seq=133251 的 TCP 分片。</p>
<p><img src="/images/wireshark/1553138255811.png" alt="1553138255811"></p>
<h2 id="TCP-Dup-ACK"><a href="#TCP-Dup-ACK" class="headerlink" title="TCP Dup ACK"></a>TCP Dup ACK</h2><p>重复 ack。<br><strong>当网络中存在乱序或者丢包时，将会导致接收端接收到的 seq number 不连续。此时接收端会向发送端回复重复 ack，ack 值为期望收到的下一个 seq number。重复 ack 数大于等于 3 次将会触发快速重传</strong>。如下图，<br>315 包，客户端向服务端发送 ack=126951 的反馈，期望下一包收到 seq=126951 的 TCP 包。但下一包接收到的却是 seq=128211 的 TCP 包，由于 seq 不连续，wireshark 将该报标记为 TCP Previous segment not captured。<br>317 包，客户端向服务端重复发送 ack=126951 的包，第一次重发，#后边带 1。<br>318 包，客户端收到 seq=126951 的 TCP 包。<br>319 包，截止到 seq=129471 的所有 TCP 包全部收到，因此客户端回复了 ack=129471 的反馈。</p>
<p><img src="/images/wireshark/1553138354613.png" alt="1553138354613"></p>
<h2 id="TCP-window-update"><a href="#TCP-window-update" class="headerlink" title="TCP window update"></a>TCP window update</h2><p>TCP 窗口更新。<br>当接收方的 TCP window 发生突变时，接收方通过 TCP window update 消息告知对方当前的接收窗口大小。如下图，TCP window Update 同时携带了反馈 ack，ack 序列号与前一个反馈 ack 序列号相同，但这并不是重复 ack。</p>
<p><img src="/images/wireshark/1553138386419.png" alt="1553138386419"></p>
<h2 id="TCP-acked-unseen-segment"><a href="#TCP-acked-unseen-segment" class="headerlink" title="TCP acked unseen segment"></a>TCP acked unseen segment</h2><p>反馈 ACK 指向了一个未知的 TCP 片段。<br>这个意思是说 ACK 反馈的是一个 wireshark 上不存在的 TCP 包。很可能是 wireshark 漏抓了这个包，但却抓到了对端反馈的该报的 ack 包。如下图，标记为 ack unseen segment 的包反馈的 ack=2721，看着像是反馈的 seq=1361 的包，但其实这个 ack 还反馈了 seq=1 的包，由于 seq=1 的包没有抓到，因此 wireshark 将反馈 ack 标记为 ack unseen segment。从下面的图还可知，由于对端已经反馈了 ack=2721，说明发端发送的 seq=1 的包，对端也收到了，只不过 wireshark 可能漏抓了而已。</p>
<p><img src="/images/wireshark/1553138458034.png" alt="1553138458034"></p>
<h2 id="TCP-ZeroWindow"><a href="#TCP-ZeroWindow" class="headerlink" title="TCP ZeroWindow"></a>TCP ZeroWindow</h2><p>TCP 滑动窗口为 0。<br>当发送端发包速率大于接收端的接收速率时，会造成接收端 TCP window 越来越小，当接收端在反馈 ack 时携带的 window size=0 时，wireshark 标记 TCP Zero window。此时发送端将暂停发送数据，直到收到接收端 window size!=0 的标志。</p>
<p><img src="/images/wireshark/1553138431304.png" alt="1553138431304"></p>
<h2 id="TCP-window-full"><a href="#TCP-window-full" class="headerlink" title="TCP window full"></a>TCP window full</h2><p>TCP window 满。<br>是指的发送端发送的数据已经达到的接受窗口的上限。发送端暂停发送，等待新的接收窗口的通告。<br>如下图，客户端向服务端发送的 ack 反馈，期望下一包收到的 seq=288961，但接收窗口仅有 960，服务端在收到 ack 后发送了 960 字节的数据，TCP window full。注意，len=1004 是整个 IP 包的长度，需要减去 IP 头 44 字节，即 960 字节。</p>
<p><img src="/images/wireshark/1553138486481.png" alt="1553138486481"></p>
<h2 id="TCP-RST"><a href="#TCP-RST" class="headerlink" title="TCP RST"></a>TCP RST</h2><p>TCP 重置。<br>是 TCP 协议结束异常连接的一种方式，通过 flog 中的 reset=1 标记。当 TCP 连接无法通过正常的 4 次挥手结束时，一方可以通过发送携带 reset 标志的 TCP 包结束 TCP 连接。<br>如下图，发送方通过 2 个 TCP 流发送数据，截图中，接收方首先向发送方反馈了 TCP window=0，让发送方暂缓发送数据，之后紧接着发送了 TCP RST 标记，释放了 TCP 连接。猜测可能接收方程序突然崩溃了，导致缓存区数据没法清空，之后接收方系统发送了 TCP reset 释放 TCP 连接。</p>
<p><img src="/images/wireshark/1553145383560.png" alt="1553145383560"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://my.oschina.net/moooofly/blog/804568" target="_blank" rel="noopener">抓包分析之 “TCP Previous segment not captured”</a></li>
<li><a href="https://my.oschina.net/u/2310891/blog/611502" target="_blank" rel="noopener">Wireshark 中的”TCP Spurious Retransmission”</a></li>
<li><a href="https://blog.packet-foo.com/2013/06/spurious-retransmissions/comment-page-1/" target="_blank" rel="noopener">Spurious Retransmissions</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>Tools</category>
        <category>TCP</category>
        <category>HTTP</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark 观察网络协议</title>
    <url>/2019/03/18/wireshark-network-protocol/</url>
    <content><![CDATA[<p>使用<code>wireshark</code>抓包分析网络协议<code>TCP</code>和<code>HTTP</code></p>
<a id="more"></a>

<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ul>
<li>色彩标识，Wireshark 通过颜色让各种流量的报文一目了然。比如默认绿色是 TCP 报文，深蓝色是 DNS，浅蓝是 UDP，黑色标识出有问题的 TCP 报文——比如乱序报文</li>
<li>在 <a href="https://wiki.wireshark.org/SampleCaptures" target="_blank" rel="noopener">SampleCaptures</a> 下载样本文件</li>
</ul>
<h2 id="使用-wireshark-观察网络基本协议"><a href="#使用-wireshark-观察网络基本协议" class="headerlink" title="使用 wireshark 观察网络基本协议"></a>使用 wireshark 观察网络基本协议</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><code>TCP/IP</code>通过三次握手建立一个连接。这一过程中的三种报文是：<code>SYN</code>，<code>SYN/ACK</code>，<code>ACK</code>。第一步是找到 PC 发送到网络服务器的第一个 SYN 报文，这标识了 TCP 三次握手的开始。</p>
<p>如果你找不到第一个 SYN 报文，选择<strong>Edit -&gt; Find Packet</strong>菜单选项。选择 Display Filter，输入过滤条件：<code>tcp.flags</code>，这时会看到一个 flag 列表用于选择。选择合适的 flag，<code>tcp.flags.syn==1</code>。点击 Find，之后 trace 中的第一个 SYN 报文就会高亮出来了。</p>
<p><img src="/images/wireshark/1552876060101.png" alt="1552876060101"></p>
<p><code>Find Packet</code>也可以用于搜索十六进制字符或搜索字符串。</p>
<p>一个快速过滤 TCP 报文流的方式是在<strong>Packet List Panel</strong>中右键报文，并且选择<strong>Follow TCP Stream</strong>。这就创建了一个只显示 TCP 会话报文的自动过滤条件。</p>
<p>这一步骤会弹出一个会话显示窗口，默认情况下包含 TCP 会话的 ASCII 代码，客户端报文用红色表示服务器报文则为蓝色。窗口类似下图所示，对于读取协议有效载荷非常有帮助，比如 HTTP，SMTP，FTP。</p>
<p><img src="/images/wireshark/1552876152950.png" alt="1552876152950"></p>
<p>更改为十六进制 Dump 模式查看载荷的十六进制代码，如下图所示：</p>
<p><img src="/images/wireshark/1552876202078.png" alt="1552876202078"></p>
<p>关闭弹出窗口，Wireshark 就只显示所选 TCP 报文流。现在可以轻松分辨出 3 次握手信号。</p>
<p><img src="/images/wireshark/1552876258999.png" alt="1552876258999"></p>
<p>Wireshark 自动为此 TCP 会话创建了一个显示过滤。本例中：<code>tcp.stream eq 14</code></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>抓包如下：</p>
<p><img src="/images/wireshark/1552876838977.png" alt="1552876838977"></p>
<p><code>Follow HTTP</code>如下</p>
<p><img src="/images/wireshark/1552876904157.png" alt="1552876904157"></p>
<p>Wireshark 自动创建<code>tcp.stream eq 14</code></p>
<p><img src="/images/wireshark/1552876944966.png" alt="1552876944966"></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>应用 Wireshark 显示过滤器分析特定数据流</title>
    <url>/2019/03/16/wireshark-filter/</url>
    <content><![CDATA[<p>掌握显示过滤器对于网络分析者来说是一项必备的技能。这是一项大海捞针的技巧。学会构建，编辑，保存关键的显示过滤器能够节省数小时的时间。</p>
<p>与捕捉过滤器使用的 BPF 语法不同，显示过滤器使用的是 Wireshark 特定的格式。除了某些特例之外，Wireshark 显示过滤器和捕捉过滤器有很大的区别。</p>
<a id="more"></a>

<h2 id="最简单的过滤器语法"><a href="#最简单的过滤器语法" class="headerlink" title="最简单的过滤器语法"></a><strong>最简单的过滤器语法</strong></h2><p>最简单的显示过滤器可基于<code>协议</code>，<code>应用</code>，<code>域名</code>，或<code>字符</code>，对<strong>大小写敏感</strong>。绝大多数简单的显示过滤器由小写字母组成。</p>
<h2 id="协议过滤器"><a href="#协议过滤器" class="headerlink" title="协议过滤器"></a><strong>协议过滤器</strong></h2><ul>
<li>arp：显示所有包括 ARP 请求和回复在内的所有 ARP 数据流</li>
<li>ip：显示内含 IPv4 头的（如 ICMP 目的地址不可达报文，在 ICMP 报文头之后返回到来方向的 IPv4 头）IP 数据流</li>
<li>ipv6：显示所有 IPv6 数据流，包括内含 IPv6 报文头的 IPv4 报文，如 6to4，Teredo，以及 ISATAP 数据流</li>
<li>tcp：显示所有基于 TCP 的数据流</li>
</ul>
<h2 id="应用过滤器"><a href="#应用过滤器" class="headerlink" title="应用过滤器"></a><strong>应用过滤器</strong></h2><ul>
<li>bootp：显示所有 DHCP 数据流（基于 BOOTP）</li>
<li>dns：显示包括 TCP 区域传输以及基于标准 UDP 的 DNS 请求和回复在内的所有 DNS 数据流</li>
<li>tftp：显示所有 TFTP（Trivial File Transfer Protocol）数据流</li>
<li>http：显示所有 HTTP 命令，回复以及数据传输报文，但不显示 TCP 握手报文，TCP ACK 报文以及 TCP 结束报文</li>
<li>icmp：显示所有 ICMP 报文</li>
</ul>
<h2 id="域过滤器"><a href="#域过滤器" class="headerlink" title="域过滤器"></a><strong>域过滤器</strong></h2><ul>
<li>boot.option.hostname：显示所有包含主机名的 DHCP 数据流（DHCP 基于 BOOTP）</li>
<li>http:host：显示所有包含 HTTP 主机名字段的 HTTP 报文。此报文是客户端向网络服务器发送请求时发出的</li>
<li><a href="ftp://ftp.request.command/">ftp.request.command</a>：显示所有包含命令的 FTP 数据流，比如 USER，PASS，或 RETR 命令</li>
</ul>
<h2 id="字符过滤器"><a href="#字符过滤器" class="headerlink" title="字符过滤器"></a><strong>字符过滤器</strong></h2><ul>
<li>tcp.analysis.flags：显示所有包含 TCP 分析标识的所有报文，包括报文丢失，重传，或零窗口标识</li>
<li>tcp.analysis,zero_window：显示含有表明发送方的接收缓存用完标识的报文</li>
</ul>
<h2 id="了解字段名"><a href="#了解字段名" class="headerlink" title="了解字段名"></a><strong>了解字段名</strong></h2><p>很多显示过滤器都是基于字段名（例如 http.host）。要了解字段名，在 Packet list 面板选中字段查看 Status 条，如下图所示。</p>
<p><img src="/images/wireshark/1552618219538.png" alt="1552618219538"></p>
<p>在<strong>Packet Details</strong>面板中展开 HTTP 报文头。在 HTTP 段点击<strong>Request Method</strong>行，状态条表明这一字段称为<code>http.request.method</code>。在显示过滤器区域输入<code>http.request.method</code>以显示所有包含这一字段的报文。</p>
<h2 id="使用自动完成功能"><a href="#使用自动完成功能" class="headerlink" title="使用自动完成功能"></a><strong>使用自动完成功能</strong></h2><p>在过滤器区域输入<code>http.request.method</code>时 Wireshark 打开一个窗口让你遍历过滤器选项。当输入<code>http.</code>，会看到所有以此为开头的显示过滤条件列表。继续输入<code>http.request.</code> ，会看到以这一短语为开头的过滤条件。</p>
<p>可以使用自动完成功能查看所有可用的过滤条件。例如，输入<code>tcp.</code> ，Wireshark 会列出所有可用的 TCP 过滤条件。如果输入<code>tcp.analysis.</code>，Wireshark 会列出所有处理 TCP 问题与性能的 TCP analysis 过滤条件。</p>
<h2 id="显示过滤器比较运算符"><a href="#显示过滤器比较运算符" class="headerlink" title="显示过滤器比较运算符"></a><strong>显示过滤器比较运算符</strong></h2><p>通过扩展过滤条件可查找某一域值，Wireshark 针对此功能支持数字比较运算符。</p>
<ol>
<li><p>== 或 eq</p>
<blockquote>
<p><code>ip.src == 10.2.2.2</code> 显示所有源地址为 10.2.2.2 的 IPv4 数据流</p>
</blockquote>
</li>
<li><p>!= 或 ne</p>
<blockquote>
<p><code>tcp.srcport != 80</code> 显示源端口除了 80 以外的所有 TCP 数据流</p>
</blockquote>
</li>
<li><p>&gt;或 gt</p>
<blockquote>
<p><code>frame.time_relative &gt; 1</code> 显示距前一个报文到达时间相差 1 秒的报文</p>
</blockquote>
</li>
<li><p>《或 lt</p>
<blockquote>
<p><code>tcp.window_size &lt; 1460</code> 显示当 TCP 接收窗口小于 1460 字节时的报文</p>
</blockquote>
</li>
<li><p>&gt;= 或 ge</p>
<blockquote>
<p><code>dns.count.answers &gt;= 10</code> 显示包含 10 个以上 answer 的 DNS 响应报文</p>
</blockquote>
</li>
<li><p>&lt;= 或 le</p>
<blockquote>
<p><code>ip.ttl &lt;= 10</code> 显示 IP 报文中 Time to Live 字段小于等于 10 的报文</p>
</blockquote>
</li>
<li><p>contains</p>
<blockquote>
<p><code>http contains “GET”</code> 显示所有 HTTP 客户端发送给 HTTP 服务器的 GET 请求</p>
</blockquote>
</li>
</ol>
<p>对于 TCP 应用的过滤条件采用比较运算符。例如想看端口 80 上面的 HTTP 数据流，使用<code>HTTP.port==80</code></p>
<h2 id="使用-Expressions"><a href="#使用-Expressions" class="headerlink" title="使用 Expressions"></a><strong>使用 Expressions</strong></h2><p>当你实在不知道该过滤些什么的时候，使用显示过滤器工具栏的<code>Expression</code>按钮。在<strong>Filter Expression</strong>窗口，输入感兴趣的应用或协议名，跳转到<code>Field Name</code>列表中相应条目。<strong>Relation</strong>选项用来添加一个比较运算符，窗口右端是预先定义的值。点击<strong>Apply</strong>按钮完成。</p>
<p><img src="/images/wireshark/1552619382659.png" alt="1552619382659"></p>
<h2 id="编辑和使用默认过滤器"><a href="#编辑和使用默认过滤器" class="headerlink" title="编辑和使用默认过滤器"></a><strong>编辑和使用默认过滤器</strong></h2><p>Wireshark 提供 15 个缺省显示过滤器供创建新的显示过滤器时参考。点击<strong>Filter</strong>按钮或点击 Display Filter 按钮打开显示过滤器窗口，如下图所示：</p>
<p><img src="/images/wireshark/1552619561587.png" alt="1552619561587"></p>
<h2 id="过滤HTTP-数据流"><a href="#过滤HTTP-数据流" class="headerlink" title="过滤HTTP 数据流"></a>过滤<strong>HTTP 数据流</strong></h2><p>在排查网页浏览器会话或检查网速过慢问题时，对浏览器会话进行过滤就显得尤为重要。过滤 HTTP 数据流有两种方式：</p>
<ol>
<li>http</li>
<li>tcp.port==xx(xx 表示所使用的 HTTP 端口）</li>
</ol>
<p><strong>第二种过滤方法更加有效</strong>。让我们通过分别对网页浏览会话应用两个过滤条件来比较一下：</p>
<p>使用<code>http</code>过滤如下</p>
<p><img src="/images/wireshark/1552722099631.png" alt="1552722099631"></p>
<p>使用<code>tcp.port==80</code>的显示过滤器如下图所示</p>
<p><img src="/images/wireshark/1552722152605.png" alt="1552722152605"></p>
<p>如果想要查看 TCP 连接建立，维护以及关闭报文，就应该使用上述过滤条件</p>
<h2 id="按照某一-IP-地址或主机过滤报文"><a href="#按照某一-IP-地址或主机过滤报文" class="headerlink" title="按照某一 IP 地址或主机过滤报文"></a><strong>按照某一 IP 地址或主机过滤报文</strong></h2><p>对于<code>IPv4</code>数据流，我们使用字段名<code>ip.src</code>，<code>ip.dst</code>，<code>ip.addr</code>；</p>
<p>对于<code>IPv6</code>数据流，使用<code>ipv6.src</code>，<code>ipv6.dst</code>，<code>ipv6.host</code>以及<code>ipv6.addr</code>。在 Packet Details 面板中点击 IP 地址将会看到它们被称为：<code>ip.src</code>，<code>ip.dst</code>, <code>ipv6.src</code>或<code>ipv6.dst</code>。字段名<code>ip.host</code>和<code>ipv6.host</code>，<code>ip.addr</code>以及<code>ipv6.addr</code>不在报文里。</p>
<p><code>ip.host</code>和<code>ipv6.host</code>过滤条件在<code>IPv4/IPv6</code>源和目的地址字段查找解析为指定主机名的<code>IPv4</code>或<code>IPv6</code>地址。<code>ip.addr==[address]</code>和<code>ipv6.addr==[address]</code>过滤条件在<code>IPv4/IPv6</code>源和目的地址字段查找指定<code>IPv4/IPv6</code>地址。</p>
<ul>
<li><p>显示在 IP 源地址字段或 IP 目的地址字段包含 10.3.1.1 的帧</p>
<blockquote>
<p><code>ip.addr==10.3.1.1</code></p>
</blockquote>
</li>
<li><p>显示除了在 IP 源地址字段或 IP 目的地址字段包含 10.3.1.1 以外的帧</p>
<blockquote>
<p><code>！ip.addr==10.3.1.1</code></p>
</blockquote>
</li>
<li><p>显示以 2406:da00:ff00::6b16:f02d 为源地址或目的地址的帧</p>
<blockquote>
<p><code>ipv6.addr==2406:da00:ff00::6b16:f02d</code></p>
</blockquote>
</li>
<li><p>显示所有来自 10.3.1.1 的数据流</p>
<blockquote>
<p><code>ip.src==10.3.1.1</code></p>
</blockquote>
</li>
<li><p>显示所有发往 10.3.1.1 的数据流</p>
<blockquote>
<p><code>ip.dst==10.3.1.1</code></p>
</blockquote>
</li>
<li><p>显示所有解析为 <a href="http://www.wireshark.xn--orgip-k81m/" target="_blank" rel="noopener">www.wireshark.org 的 IP</a> 地址</p>
<blockquote>
<p><code>ip.host==www.wireshark.org</code></p>
</blockquote>
</li>
</ul>
<h2 id="按照某一-IP-地址范围过滤报文"><a href="#按照某一-IP-地址范围过滤报文" class="headerlink" title="按照某一 IP 地址范围过滤报文"></a><strong>按照某一 IP 地址范围过滤报文</strong></h2><p>可以使用<code>&gt;</code>或<code>&lt;</code>比较运算符或逻辑运算符<code>&amp;&amp;</code>查找某一地址范围内的报文。</p>
<ul>
<li><p>显示来自或发往 10.3.0.2，10.3.0.3，10.3.0.4 的数据流</p>
<blockquote>
<p><code>ip.addr&gt;10.3.0.1&amp;&amp;ip.addr&lt;10.3.0.5</code></p>
</blockquote>
</li>
<li><p>显示来自或发往 10.3.0.1，10.3.0.2，10.3.0.4，10.3.0.5，10.3.0.6 的数据流，10.3.0.3 排除在外</p>
<blockquote>
<p><code>(ip.addr&gt;=10.3.0.1&amp;&amp;ip.addr&lt;=10.3.0.6)&amp;&amp;!ip.addr==10.3.0.3</code></p>
</blockquote>
</li>
<li><p>显示 IPv6 地址从 0xfe80 到 0xfec0 开头的数据流</p>
<blockquote>
<p><code>ipv6.addr&gt;=fe80::&amp;&amp;ipv6.addr&lt;fec0::</code></p>
</blockquote>
</li>
</ul>
<h2 id="按照某一-IP-子网过滤报文"><a href="#按照某一-IP-子网过滤报文" class="headerlink" title="按照某一 IP 子网过滤报文"></a><strong>按照某一 IP 子网过滤报文</strong></h2><p>可以通过<code>ip.addr</code>字段名定义一个子网。这种格式使用 IP 地址后跟斜杠以及一个后缀，表明 IP 地址中定义的网络部分的比特数。</p>
<ul>
<li><p>显示在 IP 源地址或目的地址字段以 10.3 开头的数据流。</p>
<blockquote>
<p><code>ip.addr==10.3.0.0/16</code></p>
</blockquote>
</li>
<li><p>显示除了 10.3.1.1 以外，在 IP 源地址或目的地址字段以 10.3 开头的数据流。</p>
<blockquote>
<p><code>ip.addr==10.3.0.0/16 &amp;&amp; ！ip.addr==10.3.1.1</code></p>
</blockquote>
</li>
<li><p>显示所有数据流，除了在 IP 源地址或目的地址字段以 10.3 和 10.2 开头的数据流</p>
<blockquote>
<p><code>!ip.addr==10.3.0.0/16 &amp;&amp; !ip.addr==10.2.0.0/16</code></p>
</blockquote>
</li>
</ul>
<h2 id="使用右键作为过滤条件"><a href="#使用右键作为过滤条件" class="headerlink" title="使用右键作为过滤条件"></a><strong>使用右键作为过滤条件</strong></h2><p>如下图所示：在某一帧的 Packet Details 面板，扩展 HTTP 部分，右键 Request URI 一行，选择<strong>Apply as Filter | Selected</strong>。</p>
<p><img src="https://vjauj58549.i.lithium.com/community/s/legacyfs/online/dellemc/89710_image004.png" alt="image004.png"></p>
<p>Wireshark 会创建合适的显示过滤条件（http.request.rui==”/”）并应用于抓包文件。之后过滤得到 2 个报文，显示用户从两个不同的 IP 地址访问主页内容，如下图所示。</p>
<p><img src="https://vjauj58549.i.lithium.com/community/s/legacyfs/online/dellemc/89711_image005.png" alt="image005.png"></p>
<p>如果你想排除这类 HTTP 请求，只要在过滤条件前加<code>!</code>或<code>not</code>。可以通过右键 GET 请求并选择<strong>Apply as Filter | Not Selected。</strong><code>not http.request.uri==”/”</code></p>
<p>如果你感兴趣的是其余 HTTP GET 请求，可对上述过滤条件扩展：定位在一个 HTTP GET 请求报文，扩展 HTTP 部分，右键 GET 并选择<strong>Apply as Filter</strong>，这一次选择<strong>and Selected</strong>选项。之后，显示过滤器显示如下：</p>
<p><code>(not http.request.uri==”/”)&amp;&amp;(http.request.method==“GET”)</code></p>
<p>现在可以看到除了<code>default page request(/)</code>之外的所有<code>HTTP GET</code>请求。</p>
<h2 id="过滤单个-TCP-或-UDP-会话"><a href="#过滤单个-TCP-或-UDP-会话" class="headerlink" title="过滤单个 TCP 或 UDP 会话"></a><strong>过滤单个 TCP 或 UDP 会话</strong></h2><p>当你想要观察客户端应用于服务器进程之间的通讯，你需要查找的是一个<code>会话</code>。会话是基于客户端应用和服务器进程的 IP 地址和端口号。通常抓包文件中会包含数百个会话，了解如何快速定位及过滤无疑是很有帮助的。</p>
<p>以下两种常用方式可从抓包文件中提取单一 TCP 或 UDP 会话：</p>
<ul>
<li><p>通过在<strong>Packet List</strong>面板右键一个 TCP 或 UDP 报文并选择<strong>Conversation Filter | [TCP|UDP].</strong></p>
</li>
<li><p>通过在<strong>Packet List</strong>面板右键一个 TCP 或 UDP 报文并选择<strong>Follow [TCP|UDP] Stream</strong>。</p>
</li>
</ul>
<h2 id="右键选择-Conversation-Filter"><a href="#右键选择-Conversation-Filter" class="headerlink" title="右键选择 Conversation Filter"></a><strong>右键选择 Conversation Filter</strong></h2><p>通过在<strong>Packet List</strong>面板右键一个 TCP 或 UDP 报文并选择<strong>Conversation Filter | TCP，</strong>如下图所示：</p>
<p><img src="https://vjauj58549.i.lithium.com/community/s/legacyfs/online/dellemc/89712_image006.png" alt="image006.png"></p>
<p>Wireshark 对数据流创建并应用以下过滤条件：</p>
<p><code>(ip.addr eq 24.6.173.220 and ip.addr eq 184.84.222.48) and (tcp.port eq 19953 and tcp.port eq 80)</code></p>
<p>同样的方法可应用于基于 IP 地址，以太网地址，UDP 地址 / 端口号结合的会话。</p>
<h2 id="右键选择-Follow-a-Stream"><a href="#右键选择-Follow-a-Stream" class="headerlink" title="右键选择 Follow a Stream"></a><strong>右键选择 Follow a Stream</strong></h2><p>要查看应用命令以及会话中的交换数据，通过在<strong>Packet List</strong>面板右键一个 TCP 或 UDP 报文并选择<strong>Follow [TCP|UDP] Stream</strong>，如下图所示。如果选择<strong>Follow UDP Stream</strong>，显示过滤条件会基于 IP 地址和端口号。如果选择<strong>Follow TCP Stream</strong>, 显示过滤条件会基于 TCP Stream Index number。</p>
<p><img src="https://vjauj58549.i.lithium.com/community/s/legacyfs/online/dellemc/89713_image007.png" alt="image007.png"></p>
<h2 id="错误的用法导致不-work"><a href="#错误的用法导致不-work" class="headerlink" title="错误的用法导致不 work"></a><strong>错误的用法导致不 work</strong></h2><p><strong>错误</strong>：ip.addr != 10.2.2.2</p>
<p>显示在 IP 源地址<em>或</em>IP 目的地址不包含 10.2.2.2 的报文。只要在源或目的 IP 地址不为 10.2.2.2，报文就会被显示出来。这时隐含的<em>或</em>会导致实际上并未过滤任何报文。</p>
<p><strong>正确</strong>：！ip.addr == 10.2.2.2</p>
<p>显示 IP 源地址和 IP 目的地址都不包含 10.2.2.2 的报文。</p>
<p><strong>错误</strong>：!tcp.flags.syn==1</p>
<p>显示所有不含 TCP SYN bit 设置为 1 的报文。其他协议报文，必须 UDP 和 ARP 报文也符合这一过滤条件，因为它们的 TCP SYN bit 没有设置为 1。</p>
<p><strong>正确</strong>：tcp.flags.syn！=1</p>
<p>只显示包含 SYN 设置为 0 的 TCP 报文。</p>
<p>小贴士：</p>
<p>当你知道只有一个字段符合你的过滤字段名的时候，不要害怕使用！= 运算符。有时，这是最好用的过滤运算符。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark 图形显示分析网络数据</title>
    <url>/2019/03/13/wireshark-statistics/</url>
    <content><![CDATA[<p><code>wireshark statistics</code>常用图形工具</p>
<ul>
<li>IO Graph</li>
<li>Flow Graph</li>
<li>HTTP Packet Counter</li>
<li>HTTP Requests</li>
<li>HTTP Request Sequences</li>
<li>TCP Throughput</li>
<li>TCP Window Scaling</li>
<li>TCP Round Trip Time</li>
</ul>
<a id="more"></a>

<h2 id="IO-Graph"><a href="#IO-Graph" class="headerlink" title="IO Graph"></a>IO Graph</h2><p><code>IO Graphs</code>这个窗口可以让我们对网络上的<code>数据吞吐</code>情况进行绘图。这样就可以很容易地发现数据吞吐的峰值，找出不同协议中的性能瓶颈，并且还可以用来比较实时的数据流。</p>
<p>选中任意一个 TCP 数据包，在菜单栏选择<strong>“Statistics”</strong>-&gt;<strong>“IO Graphs”</strong>。这是一台电脑从互联网下载文件时的例子：</p>
<p><img src="/images/wireshark/1552440846433.png" alt="1552440846433"></p>
<p><img src="/images/wireshark/1552896238527.png" alt="1552896238527"></p>
<p>过滤条件为空，此图形<strong>显示所有流量</strong>。 双击<code>Y Axis</code>将 Y 轴改为<code>bits/tick</code>这样就可以看到<strong>每秒的流量</strong></p>
<p><img src="/images/wireshark/1552902520535.png" alt="1552902520535"></p>
<h3 id="常用过滤条件"><a href="#常用过滤条件" class="headerlink" title="常用过滤条件"></a>常用过滤条件</h3><ol>
<li><code>tcp.analysis.lost_segment</code>：表明已经在抓包中看到不连续的序列号。报文丢失会造成重复的 ACK，这会导致重传</li>
<li><code>tcp.analysis.duplicate_ack</code>：显示被确认过不止一次的报文。大量的重复 ACK 是 TCP 端点之间高延时的迹象</li>
<li><code>tcp.analysis.retransmission</code>：显示抓包中的所有重传。如果重传次数不多的话还是正常的，过多重传可能有问题。这通常意味着应用性能缓慢和 / 或用户报文丢失</li>
<li><code>tcp.analysis.window_update</code>：将传输过程中的 TCP window 大小图形化。如果看到窗口大小下降为零，这意味着发送方已经退出了，并等待接收方确认所有已传送数据。这可能表明接收端已经不堪重负了</li>
<li><code>tcp.analysis.bytes_in_flight</code>：某一时间点网络上未确认字节数。未确认字节数不能超过你的 TCP 窗口大小（定义于最初 3 此 TCP 握手），为了最大化吞吐量你想要获得尽可能接近 TCP 窗口大小。如果看到连续低于 TCP 窗口大小，可能意味着报文丢失或路径上其他影响吞吐量的问题</li>
<li><code>tcp.analysis.ack_rtt</code>：衡量抓取的 TCP 报文与相应的 ACK。如果这一时间间隔比较长那可能表示某种类型的网络延时（报文丢失，拥塞，等等）</li>
</ol>
<p>在抓包中应用以上一些过滤条件：</p>
<p><img src="/images/wireshark/1552959516799.png" alt="1552959516799"></p>
<p>得到如下图：</p>
<p><img src="/images/wireshark/1552959550482.png" alt="1552959550482"></p>
<ul>
<li>Line 是 HTTP 总体流量，显示形式为 packets/tick，时间间隔 1 秒</li>
<li>Red 是 TCP 丢失报文片段</li>
<li>Green 是 TCP 重复 ACK</li>
<li>Blue 重传</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>IO Graphs</code>有六个可用函数：<code>SUM</code>, <code>MIN</code>, <code>AVG</code>, <code>MAX</code>, <code>COUNT</code>, <code>LOAD</code></p>
<p><code>MIN</code>、<code>AVG</code>和<code>MAX</code>帧之间的最小，平均和最大时间，这对于查看帧 / 报文之间的延时非常有用可以将这些函数结合<code>frame.time_delta</code>过滤条件看清楚帧延时，并使得往返延时更为明显。</p>
<p><img src="/images/wireshark/1552972558253.png" alt="1552972558253"></p>
<p><code>COUNT</code>此函数计算时间间隔内事件发生的次数，在查看 TCP 分析标识符时很有用，例如重传。例图如下：</p>
<p><img src="/images/wireshark/1552972717700.png" alt="1552972717700"></p>
<p><code>SUM</code>该函数统计事件的累加值。有两种常见的用例是看在捕获 TCP 数据量，以及检查 TCP 序列号。</p>
<h2 id="Flow-Graph"><a href="#Flow-Graph" class="headerlink" title="Flow Graph"></a>Flow Graph</h2><p><code>数据流图</code>功能可以将连接可视化，并且将一段时间中的数据流显示出来。数据流图一般以<code>列</code>的方式将主机之间的连接显示出来，并将数据组织到一起，便于更加直观地解读。</p>
<p>选择菜单栏的<strong><code>Statistics</code></strong>-&gt;<strong><code>Flow Graph</code></strong>，就可以打开数据流图窗口：</p>
<p><img src="/images/wireshark/1552441053261.png" alt="1552441053261"></p>
<p>从上图中我们可以更好地看到整个连接的情况，比如 TCP 的<code>三次握手</code>，数据传输以及 HTTP 协议等的信息都一目了然。</p>
<h2 id="Packet-Counter"><a href="#Packet-Counter" class="headerlink" title="Packet Counter"></a>Packet Counter</h2><p><strong><code>Statistics</code></strong>-&gt;<strong><code>HTTP</code></strong>-&gt;<strong><code>Packet Counter</code></strong>，每一个网站的报文数量。帮助识别有多少响应和请求</p>
<p><img src="/images/wireshark/1552441081950.png" alt="1552441081950"></p>
<h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><p><strong><code>Statistics</code></strong>-&gt;<strong><code>HTTP</code></strong>-&gt;<strong><code>Requests</code></strong>，各网站的请求分布</p>
<p><img src="/images/wireshark/1552441138425.png" alt="1552441138425"></p>
<h2 id="Request-Sequences"><a href="#Request-Sequences" class="headerlink" title="Request Sequences"></a>Request Sequences</h2><p><strong><code>Statistics</code></strong>-&gt;<strong><code>HTTP</code></strong>-&gt;<strong><code>Request Sequences</code></strong></p>
<p><img src="/images/wireshark/1552441180076.png" alt="1552441180076"></p>
<h2 id="Throughput"><a href="#Throughput" class="headerlink" title="Throughput"></a>Throughput</h2><p><strong><code>Statistics</code></strong>-&gt;<strong><code>TCP</code></strong>-&gt;<strong><code>Throughput</code></strong>，显示 TCP 流吞吐量图形</p>
<p><img src="/images/wireshark/1552441779141.png" alt="1552441779141"></p>
<h2 id="Window-Scaling"><a href="#Window-Scaling" class="headerlink" title="Window Scaling"></a>Window Scaling</h2><p>显示 TCP 滑动窗口图形</p>
<p><img src="/images/wireshark/1552441808903.png" alt="1552441808903"></p>
<h2 id="Round-Trip-Time"><a href="#Round-Trip-Time" class="headerlink" title="Round Trip Time"></a>Round Trip Time</h2><p>Wireshark 的另一个绘图功能就是对所捕获的文件进行往返时间的绘图。<code>往返时间</code>（round-trip time, RTT）是指一个数据包从发出到确认被成功接收所需要的时间。或者说，往返时间就是数据包抵达目的地的时间，加上收到对方的确认信息的时间之和。通过对这个时间的分析，可以找到通信中的瓶颈，确定是否存在延迟。</p>
<p>选择<strong><code>Statistics</code></strong>-&gt;<strong><code>TCP Stram Graph</code></strong>-&gt;<strong><code>Round Trip Time Graph</code></strong>，来查看往返时间图：</p>
<p><img src="/images/wireshark/1552441901150.png" alt="1552441901150"></p>
<p>上图中的每个点代表的是一个数据包的往返时间。在默认情况下，这些值按照序号进行排序。单击图中任意一个点，就可以在<strong>Packet List</strong>面板中看到相应的数据包。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
        <tag>window scaling</tag>
      </tags>
  </entry>
  <entry>
    <title>connect-to-hidden-ap</title>
    <url>/2019/03/05/connect-to-hidden-ap/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://unix.stackexchange.com/questions/368964/connect-to-my-hidden-wifi-which-i-know-the-password-and-the-ssid-name" target="_blank" rel="noopener">Connect to my hidden wifi which I know the password and the ssid name</a></li>
<li><a href="https://blog.csdn.net/wukery/article/details/53032120" target="_blank" rel="noopener">Linux 系统 Wpa_supplicant 用法</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>源代码分析及 DLNA 和 UPnP 协议理解</title>
    <url>/2019/03/01/dlna-and-upnp-protocol/</url>
    <content><![CDATA[<ul>
<li>Protocol<ul>
<li><code>DLNA Guidelines June 2016 - Part 1-1 Architectures and Protocols.pdf</code></li>
<li><code>UPnP-arch-DeviceArchitecture-v2.0.pdf</code></li>
</ul>
</li>
<li>Open Source Project<ul>
<li><code>minidlna</code></li>
<li><code>gmediarender</code></li>
</ul>
</li>
</ul>
<a id="more"></a>


<h2 id="UPnP-AV-Audio-Video-Architecture"><a href="#UPnP-AV-Audio-Video-Architecture" class="headerlink" title="UPnP AV(Audio/Video) Architecture"></a>UPnP AV(Audio/Video) Architecture</h2><p>在 <code>UPnP</code> 网络中，服务、设备和控制点（Control Point，即 CP）是基本组件。<code>UPnP</code>网络中定义的设备具有很广泛的含义，各种各样的家电、电脑外设、智能设备、无线设备、个人电脑等等都可以成为其中一员。一个 UPnP 设备可以是多个服务的载体和多个子设备的嵌套集。而<code>控制点 CP</code>指的是可以发现并控制其它设备的设备。</p>
<p>UPnP 网络中的设备可提供四种服务（Service）：</p>
<ol>
<li><code>AVTransport Service</code> （可控制多屏设备上的媒体 play，pause，seek，stop 等）</li>
<li><code>RenderingControl Service</code> （可调节多屏设备上的音量，声音，静音等）</li>
<li><code>ContentDirectory Service</code>  （可获取多屏设备上可访问的媒体内容）</li>
<li><code>ConnectionManager Service</code> （可提供所支持的传输协议信息及多屏设备的 MIME 格式信息）</li>
</ol>
<p><code>UPnP AV Architecture</code> 定义了<code>UPnP AV</code>设备间媒体传送以及和<code>CP</code>间的交互。<code>UPnP AV</code>也定义了两种<code>UPnP AV</code>设备：<code>UPnP AV MediaServer Device（MSD）</code>和<code>UPnP AV MediaRenderer Device（MRD）</code>,</p>
<p><code>DLNA</code>协议中定义如下：</p>
<ul>
<li><code>MRD</code>使用<code>RCS</code>、<code>CDS</code>和<code>CMS</code></li>
</ul>
<p><img src="/images/dlna/1551407003451.png" alt="1551407003451"></p>
<ul>
<li><code>MSD</code>使用<code>CDS</code>和<code>CMS</code></li>
</ul>
<p><img src="/images/dlna/1551407205375.png" alt="1551407205375"></p>
<ul>
<li><code>DMP</code>需要实现<code>CDS</code>，<code>Rendering Endpoints</code>如果支持<code>DMP</code>也需要支持<code>DMR</code><blockquote>
<p>Rendering Endpoints that claim to support the DLNA DMP Device Class shall also support the DLNA DMR Device Class.</p>
</blockquote>
</li>
</ul>
<h3 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h3><p>根据上述四种<code>server</code>描述，可以判断出</p>
<ul>
<li><code>minidlna</code>是<code>MSD</code>，<code>DMS</code>项目</li>
<li><code>gmediarender</code>是<code>MRD</code>，<code>DMR</code>项目</li>
</ul>
<h2 id="UPnP-的工作过程"><a href="#UPnP-的工作过程" class="headerlink" title="UPnP 的工作过程"></a>UPnP 的工作过程</h2><ol>
<li>寻址 ( Addressing )<br> IP 寻址是整个 UPnP 网络的基础。设备或控制点必须支持 IPv4（或者是 IPv4 和 IPv6）。当设备或 CP 首次与网络建立连接时，设备或控制点会寻找 DHCP（Dynamic Host Configuration Protocol）服务器，由 DHCP 负责分配向他们分配 IP。如果局域网内没有 DHCP 服务，UPnP 设备将按照 Auto-IP 去获取一个未被使用的 IP 地址。</li>
<li>发现 ( Discovery )<br>发现是 UPnP 网络工作的第一步。 当一个设备加入到网络中，UPnP 的发现协议允许该设备向网络上的 Control Points(CPs) 通知 (advise) 自己拥有的服务。类似地，当一个控制点加入到网络中的时候，它也能够搜索到网络中存在的、感兴趣的设备。设备主动通知或者被动响应时提供的信息仅包含少量的设备信息，比如，类型、uuid 和指向更详细信息的 URL。<code>Discovery architecture</code>如下图所示：</li>
</ol>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-18211e0a9da3b30d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/663/format/webp" alt="img"></p>
<p><code>UPnP</code>检测协议是基于简单服务发现协议（SSDP，Simple Service Discovery Protocol）的。</p>
<p>按照协议的规定，当一个控制点（CP）接入网络的时候，它可以向一个特定的<strong>多播</strong>地址的 SSDP 端口 ( 比如 IPv4 环境下，多播地址是 239.255.255.250，端口号是 1900 ) 使用<code>M-SEARCH</code>方法发送<code>ssdp:discover</code>消息。当设备监听到这个保留的多播地址上由控制点发送的消息的时候，设备会分析控制点请求的服务，如果自身提供了控制点请求的服务，设备将通过<strong>单播</strong>的方式直接响应控制点的请求。类似的，当一个设备接入网络的时候，它应当向一个特定的多播地址的 SSDP 端口使用 <code>NOTIFY</code> 方法发送<code>ssdp:alive</code>消息。控制点根据自己的策略，处理监听到的消息。</p>
<p>SSDP 格式套用 HTTP1.1 的部分消息头字段，但是和 HTTP 不同，<strong>SSDP 是采用 UDP 传输的</strong>，而且 SSDP 没有 Message Body。</p>
<p>下面说明设备怎样向网络通知或者撤销自己可以提供的服务，CP 是如何搜索设备以及设备是如何回应搜索的。</p>
<h3 id="通知-设备可用"><a href="#通知-设备可用" class="headerlink" title="通知 - 设备可用"></a>通知 - 设备可用</h3><p>当一个设备加入网络时，用 <code>NOTIFY</code> 方法发送一个多播请求，并且 <code>NTS</code> 头为 <code>ssdp:alive</code> 。<code>NOTIFY</code> 方法发送的请求没有消息体，但消息与最后一个 HTTP 头之间必须空一行。<code>ssdp:alive</code> 消息格式：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-cde9f83f92ed8469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/611/format/webp" alt="img"></p>
<p><code>NOTIFY</code> 消息必须包含以下四部分：</p>
<ol>
<li>A notification type (e.g., device type), sent in an NT (Notification Type) header field.</li>
<li>A composite identifier for the advertisement, sent in a USN (Unique Service Name) header field.</li>
<li>A URL for more information about the device (or enclosing device in the case of a service), sent in a LOCATION header field.</li>
<li>A duration for which the advertisement is valid, sent in a CACHE-CONTROL header field. （单位：秒）</li>
</ol>
<h3 id="撤销-设备不可用"><a href="#撤销-设备不可用" class="headerlink" title="撤销 - 设备不可用"></a>撤销 - 设备不可用</h3><p>在设备及其服务将要从网络中退出时，设备以多播方式用 <code>NOTIFY</code> 方法发送 <code>ssdp:byebye</code> 消息 ( 对于每个未超期的<code>ssdp:alive</code>消息 )。但如果设备突然从网络退出，它可能来不及发出这个通知消息。因此，<code>discovery message</code> 必须在<code>CACHE-CONTROL</code> 中包含超时值（如上所述）；如果不重新发出通告，<code>discovery message</code> 最后也会因超时而过期的。<code>ssdp:byebye</code>消息格式如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-e893b494d82c0f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/601/format/webp" alt="img"></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>当一个控制点加入到网络中时，它应该采用以下格式的 <code>M-SEARCH</code> 方法发送多播请求来搜索自己感兴趣的设备（服务）。如果 CP 已知道设备的 IP，也可以类似的格式发送单播去了解详细信息。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-71347cf517bb99d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/598/format/webp" alt="img"></p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>当设备自身能够提供与 CP 发出的多播消息所匹配的服务时，就会以单播形式予以响应，消息格式如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-2d88c9d5a65b9b46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="img"></p>
<p>需要注意的是：设备通过主动多播方式或者是被动地响应 CP 的搜索消息，使得 CP 能够了解到它是否是自己感兴趣的设备。但是如果 CP 对某设备感兴趣，想获取更多信息的话，则需要通过已获得的<code>LOCATION- 指向更详细信息的 URL</code>来发送<code>description query message</code>，从而得到设备详细的描述信息。</p>
<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 ( Description )"></a>描述 ( Description )</h3><p>在控制点发现了一个设备之后，控制点仍然对设备知之甚少。可能仅仅知道发现消息中的相关信息，如设备（或服务）的 UPnP 类型、设备的全球唯一标识符和设备 UPnP 描述的 URL 地址。为了让控制点更多的了解设备及其功能、或者与设备交互，控制点必须从发现消息中得到设备描述的 URL，并通过 URL 取得详细的设备描述。这些信息是以 XML 的形式返回的。设备的 UPnP 描述一般分成两个逻辑部分：设备描述以及服务描述（描述设备对外暴露的能力）。</p>
<ul>
<li>设备描述<br> UPnP 设备描述包括特定厂商、制造商信息，如模块名称和编号、序列号、制造商名称、特定厂商网站 URL 等。对于设备中的每种服务，描述包含服务类型、名称、服务描述 URL、控制 URL 以及事件 URL。设备描述还包括所有嵌入式设备描述及 presentationURL.</li>
<li>服务描述<br> 关于服务的 UPnP 描述定义了 Action 及其参数，还有状态变量及其数据类型、取值范围和事件特征。<br> 每个服务必须包含 0 或多个 Action，每个 Action 必须包含 0 或多个参数，每个参数要么是输入参数要么是输出参数，每个参数对应一个状态变量，每个服务有 1 或多个状态变量。</li>
</ul>
<p>XML 格式如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-e272ff0bb34a21c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/610/format/webp" alt="img"></p>
<p>获取设备描述很简单，CP 向 discovery message 里的 URL 发一个 HTTP GET 请求，设备在 HTTP 响应的消息体中返回其描述。</p>
<h3 id="控制-Control"><a href="#控制-Control" class="headerlink" title="控制 ( Control )"></a>控制 ( Control )</h3><p>拿到 Device description 和 Service descriptions 以后，那 CP 怎么去控制这些设备呢？<br>为了控制一个设备，控制点向设备上的服务发出一个 Action 。这一般由控制点向服务的 controLURL（在设备描述的服务元素 controlURL 子元素部分提供）发送一个适当的控制消息。而服务则会对此 Action 做出响应，返回相关结果或错误。</p>
<p>UPnP 的设备控制是基于 SOAP 协议的，SOAP（Simple Object Access Protocol）即简单对象访问协议，是交换数据的一种协议规范，是一种轻量的、简单的、基于 XML（标准通用标记语言下的一个子集）的协议，它被设计成在 WEB 上交换结构化的和固化的信息。在 UPnP 中控制点会向设备的服务发出 Action，并接收结果或错误返回，该动作、结果和错误封装在 SOAP 中，通过 HTTP 请求发送，并通过 HTTP 响应接收。</p>
<h3 id="事件-Eventing"><a href="#事件-Eventing" class="headerlink" title="事件 ( Eventing )"></a>事件 ( Eventing )</h3><p>控制点可以监听设备的状态，设备的状态或信息发生了变化，只要产生一个事件广播出去，控制点就能接收到并进行响应，类似一般的订阅者模式，发布者是指事件源即设备的服务，订阅者是控制点。有两种类型的事件：单播事件和多播事件。</p>
<ul>
<li>单播事件</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-cb6f9586ec7840ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/743/format/webp" alt="img"></p>
<ul>
<li>多播事件</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-469ecae596954136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840/format/webp" alt="img"></p>
<h3 id="表示-展示-Presentation"><a href="#表示-展示-Presentation" class="headerlink" title="表示 / 展示 ( Presentation )"></a>表示 / 展示 ( Presentation )</h3><p>控制点发现设备并且获取到设备的描述信息后，如果设备有返回 “presentationURL” ，那么，控制点就可以请求（HTTP GET）该 URL，在浏览器中展示出来，用户通过该网页就能控制远端的设备，或查看设备状态等。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1837725-578bc190d36a5274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/737/format/webp" alt="img"></p>
<h2 id="DLNA-协议"><a href="#DLNA-协议" class="headerlink" title="DLNA 协议"></a>DLNA 协议</h2><p>数字生活网络联盟 Digital Living Network Alliance (DLNA)</p>
<p>DLNA 采用 upnp 协议格式。主要分为两大块，一个是发现控制器 SSDP, 它通过 udp 来实现</p>
<p>二是控制协议 SOAP , 即开始投屏后发投屏设备发送 前进，后退，暂停，调节音量等操作。</p>
<p>DLNA 各种设备术语：</p>
<ol>
<li>Digital Media Controller（DMC）数位媒体控制器：作为遥控装置使用，可寻找 DMS 上的多媒体档案，并指定可播放该多媒体档案的 DMR 进行播放或是控制多媒体档案上下传到 DMS 的装置，一般是手机。</li>
<li>Digital Media Server（DMS）数位媒体服务器：提供了媒体档案的获取、录制、储存以及作为源头的装置。一般是公网上流媒体服务器</li>
<li>Digital Media Renderer（DMR）数位媒体控制器：可接收并播放从 DMC push 过来的媒体档案。即接收投屏数据，一般是智能电视，OTT 盒子等。</li>
</ol>
<p>这三者的关系是，DMC 通过获取 DMS 上的歌曲或者视频（也可以不是 DMS 上的，而仅仅只是一个链接），把它们传送到 DMR 上，由 DMR 进行播放。</p>
<h2 id="DLNA-发现控制协议"><a href="#DLNA-发现控制协议" class="headerlink" title="DLNA 发现控制协议"></a>DLNA 发现控制协议</h2><p>即 DMC 通过 upnp 广播 发现局域网中 DMR 设备。</p>
<p>这里我们抓 iOS 咪咕视频的发现为分析例子。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1493747-cba1ed4367f69c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/728/format/webp" alt="img"></p>
<p>步骤是，DMC 首先向固定的 多播地址（239.255.255.250:1900）发送 UDP 广播包。DMR 收到数据后，会用 UDP 响应数据</p>
<h3 id="M-SEARCH-包格式"><a href="#M-SEARCH-包格式" class="headerlink" title="M-SEARCH 包格式"></a>M-SEARCH 包格式</h3><p>实际包格式</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1493747-6ddf7b365cf76dea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/701/format/webp" alt="img"></p>
<p>http 包头格式：</p>
<ul>
<li>M-SEARCH * HTTP/1.1   起始行，表明是一个 SSDP 搜索消息</li>
<li>HOST  多播地址和端口</li>
<li>MAN   协议查询类型，必须是 ssdp:discover</li>
<li>MX    设备响应最长等待时间；设备在 0 和这个值之间随机选择一个时间最为延迟，避免多个设备同时响应造成网络拥堵<br> +ST 搜索的目标，通常为 upnp:rootdevice （值域为 ssdp:all、upnp:rootdevice、uuid:device-UUID、urn:schemas-upnp-org:devices:device-Type:version、urn:schemas-upnp-org:service:service-Type ）</li>
<li>User-Agent DMC 设备名称</li>
</ul>
<pre><code>M-SEARCH * HTTP/1.1
MX: 5
ST: upnp:rootdevice
MAN: &quot;ssdp:discover&quot;
User-Agent: UPnP/1.0 DLNADOC/1.50 Platinum/1.0.5.13
Connection: close
Host: 239.255.255.250:1900</code></pre><h3 id="响应包格式"><a href="#响应包格式" class="headerlink" title="响应包格式"></a>响应包格式</h3><p><img src="https:////upload-images.jianshu.io/upload_images/1493747-bb39f18dc5a51c4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/591/format/webp" alt="img"></p>
<ul>
<li>HTTP/1.1 200 OK   起始行，表明是一个 HTTP 响应消息</li>
<li>CACHE_CONTROL 消息存活时间</li>
<li>DATE  响应生成的时间</li>
<li>EXT   N/A</li>
<li>LOCATION  设备描述的 URL</li>
<li>SERVER    包含设备上的操作系统名、版本、产品名称和产品版本信息</li>
<li>ST    与搜索消息相同<br> USN 唯一服务名称，SSDP 使用通用唯一标识符 UUID 作为某个设备 / 服务的全球唯一标识</li>
</ul>
<pre><code>HTTP/1.1 200 OK
LOCATION: http://169.254.100.156:37215/upnpdev.xml
SERVER: Linux UPnP/1.0 Huawei-ATP-IGD
CACHE-CONTROL: max-age=86500
EXT:
ST: upnp:rootdevice
USN: uuid:00e0fc37-2525-2828-2500-0034fe66fdc6::upnp:rootdevice
DATE: Fri, 20 Jul 2018 07:11:30 GMT</code></pre><p>LOCATION: <a href="http://192.168.0.108:49152/description.xml" target="_blank" rel="noopener">http://192.168.0.108:49152/description.xml</a><br>还有一种格式采用 NOTIFY, 主动向广播发送自己信息，这是小米电视主动发送通知</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1493747-de7a01bc12518d91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p>
<pre><code>NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=62
LOCATION: http://192.168.0.108:49152/description.xml
NT: urn:schemas-upnp-org:service:AVTransport:1
NTS: ssdp:alive
SERVER: Linux/3.14.29, UPnP/1.0, Portable SDK for UPnP devices/1.6.13
USN: uuid:F7CA5454-3F48-4390-8009-4c3848e24612::urn:schemas-upnp-org:service:AVTransport:1</code></pre><p>其中 LOCATION 是一个指向 xml 下载网址，里面描述设备真正的信息</p>
<p>以下是一个小米音箱的响应</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;root
    xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;&gt;
    &lt;specVersion&gt;
        &lt;major&gt;1&lt;/major&gt;
        &lt;minor&gt;1&lt;/minor&gt;
    &lt;/specVersion&gt;
    &lt;device&gt;
        &lt;deviceType&gt;urn:schemas-upnp-org:device:MediaRenderer:1&lt;/deviceType&gt;
        &lt;friendlyName&gt;灏忕背 AI 闊崇-8003&lt;/friendlyName&gt;
        &lt;manufacturer&gt;Mi, Inc.&lt;/manufacturer&gt;
        &lt;modelDescription&gt;The Mi AI SoundBox&lt;/modelDescription&gt;
        &lt;modelName&gt;S12&lt;/modelName&gt;
        &lt;modelNumber&gt;S12&lt;/modelNumber&gt;
        &lt;qq:X_QPlay_SoftwareCapability
            xmlns:qq=&quot;http://www.tencent.com&quot;&gt;QPlay:2
        &lt;/qq:X_QPlay_SoftwareCapability&gt;
        &lt;dlna:X_DLNADOC
            xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot;&gt;DMR-1.50
        &lt;/dlna:X_DLNADOC&gt;
        &lt;dlna:X_DLNACAP
            xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot;&gt;,
        &lt;/dlna:X_DLNACAP&gt;
        &lt;UDN&gt;uuid:d3b1a06a-8fb6-4f5b-b042-a15d1b956fb8&lt;/UDN&gt;
        &lt;serviceList&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:schemas-upnp-org:service:AVTransport:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:upnp-org:serviceId:AVTransport&lt;/serviceId&gt;
                &lt;SCPDURL&gt;AVTransport1.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;/AVTransport/control&lt;/controlURL&gt;
                &lt;eventSubURL&gt;/AVTransport/event&lt;/eventSubURL&gt;
            &lt;/service&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:schemas-upnp-org:service:ConnectionManager:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:upnp-org:serviceId:ConnectionManager&lt;/serviceId&gt;
                &lt;SCPDURL&gt;ConnectionManager1.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;/ConnectionManager/control&lt;/controlURL&gt;
                &lt;eventSubURL&gt;/ConnectionManager/event&lt;/eventSubURL&gt;
            &lt;/service&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:schemas-upnp-org:service:RenderingControl:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:upnp-org:serviceId:RenderingControl&lt;/serviceId&gt;
                &lt;SCPDURL&gt;RenderingControl1.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;/RenderingControl/control&lt;/controlURL&gt;
                &lt;eventSubURL&gt;/RenderingControl/event&lt;/eventSubURL&gt;
            &lt;/service&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:xiaomi-com:service:Queue:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:xiaomi-com:serviceId:Queue&lt;/serviceId&gt;
                &lt;SCPDURL&gt;Queue1.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;Queue1/control&lt;/controlURL&gt;
                &lt;eventSubURL&gt;Queue1/event&lt;/eventSubURL&gt;
            &lt;/service&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:xiaomi-com:service:Playlist:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:xiaomi-com:serviceId:Playlist&lt;/serviceId&gt;
                &lt;SCPDURL&gt;Playlist1.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;Playlist1/control&lt;/controlURL&gt;
                &lt;eventSubURL&gt;Playlist1/event&lt;/eventSubURL&gt;
            &lt;/service&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:schemas-tencent-com:service:QPlay:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:tencent-com:serviceId:QPlay&lt;/serviceId&gt;
                &lt;SCPDURL&gt;QPlay1.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;QPlay1/control&lt;/controlURL&gt;
                &lt;eventSubURL&gt;QPlay1/event&lt;/eventSubURL&gt;
            &lt;/service&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:xiaomi-com:service:Favorites:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:xiaomi-com:serviceId:Favorites&lt;/serviceId&gt;
                &lt;SCPDURL&gt;Favorites1.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;Favorites1/control&lt;/controlURL&gt;
                &lt;eventSubURL&gt;Favorites1/event&lt;/eventSubURL&gt;
            &lt;/service&gt;
        &lt;/serviceList&gt;
    &lt;/device&gt;
&lt;/root&gt;</code></pre><p>其中 friendlyName 是比较友好的显示名字，一般显示在设备上。<br> modelName 是英文名字</p>
<p>天猫盒子的设备描述</p>
<pre><code>&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;&gt;
&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;0&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:schemas-upnp-org:device:MediaRenderer:1&lt;/deviceType&gt;
&lt;UDN&gt;uuid:595d5f67-dc56-3ac7-118b-2fab9893c7b7&lt;/UDN&gt;
&lt;friendlyName/&gt;
&lt;manufacturer&gt;www.yunos.com&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;www.yunos.com&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;YunOS UPnP/DNLA DMR&lt;/modelDescription&gt;
&lt;modelName&gt;MagicBox_M17&lt;/modelName&gt;
&lt;modelNumber&gt;3.0.4-gp3.0.4&lt;/modelNumber&gt;
&lt;modelURL&gt;www.yunos.com&lt;/modelURL&gt;
&lt;yingshiVersion&gt;2120513812&lt;/yingshiVersion&gt;
&lt;rcsPort&gt;13510&lt;/rcsPort&gt;
&lt;serviceList&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:AVTransport:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:AVTransport&lt;/serviceId&gt;
&lt;controlURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/AVTransport/action
&lt;/controlURL&gt;
&lt;eventSubURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/AVTransport/event
&lt;/eventSubURL&gt;
&lt;SCPDURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/AVTransport/desc.xml
&lt;/SCPDURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:RenderingControl:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:RenderingControl&lt;/serviceId&gt;
&lt;controlURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/RenderingControl/action
&lt;/controlURL&gt;
&lt;eventSubURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/RenderingControl/event
&lt;/eventSubURL&gt;
&lt;SCPDURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/RenderingControl/desc.xml
&lt;/SCPDURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:ConnectionManager:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:ConnectionManager&lt;/serviceId&gt;
&lt;controlURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/ConnectionManager/action
&lt;/controlURL&gt;
&lt;eventSubURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/ConnectionManager/event
&lt;/eventSubURL&gt;
&lt;SCPDURL&gt;
/dev/595d5f67-dc56-3ac7-118b-2fab9893c7b7/svc/upnp-org/ConnectionManager/desc.xml
&lt;/SCPDURL&gt;
&lt;/service&gt;
&lt;/serviceList&gt;
&lt;/device&gt;
&lt;/root&gt;</code></pre><p>小米电视的通知</p>
<pre><code>&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;0&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:schemas-upnp-org:device:MediaRenderer:1&lt;/deviceType&gt;
&lt;presentationURL&gt;/&lt;/presentationURL&gt;
&lt;friendlyName&gt;客厅的小米电视&lt;/friendlyName&gt;
&lt;manufacturer&gt;Xiaomi&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;http://www.xiaomi.com/&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;Xiaomi MediaRenderer&lt;/modelDescription&gt;
&lt;modelName&gt;Xiaomi MediaRenderer&lt;/modelName&gt;
&lt;modelURL&gt;http://www.xiaomi.com/hezi&lt;/modelURL&gt;
&lt;UPC&gt;000000000017&lt;/UPC&gt;
&lt;UDN&gt;uuid:F7CA5454-3F48-4390-8009-4c3848e24612&lt;/UDN&gt;
&lt;UID&gt;-982164636&lt;/UID&gt;
&lt;serviceList&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:AVTransport:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:AVTransport&lt;/serviceId&gt;
&lt;SCPDURL&gt;/dlna/Render/AVTransport_scpd.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;_urn:schemas-upnp-org:service:AVTransport_control&lt;/controlURL&gt;
&lt;eventSubURL&gt;_urn:schemas-upnp-org:service:AVTransport_event&lt;/eventSubURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:ConnectionManager:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:ConnectionManager&lt;/serviceId&gt;
&lt;SCPDURL&gt;/dlna/Render/ConnectionManager_scpd.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;
_urn:schemas-upnp-org:service:ConnectionManager_control
&lt;/controlURL&gt;
&lt;eventSubURL&gt;
_urn:schemas-upnp-org:service:ConnectionManager_event
&lt;/eventSubURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:schemas-upnp-org:service:RenderingControl:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:RenderingControl&lt;/serviceId&gt;
&lt;SCPDURL&gt;/dlna/Render/RenderingControl_scpd.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;
_urn:schemas-upnp-org:service:RenderingControl_control
&lt;/controlURL&gt;
&lt;eventSubURL&gt;
_urn:schemas-upnp-org:service:RenderingControl_event
&lt;/eventSubURL&gt;
&lt;/service&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:mi-com:service:RController:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:upnp-org:serviceId:RController&lt;/serviceId&gt;
&lt;SCPDURL&gt;/dlna/Render/RControl_scpd.xml&lt;/SCPDURL&gt;
&lt;controlURL&gt;
_urn:schemas-upnp-org:service:RenderingControl_control
&lt;/controlURL&gt;
&lt;eventSubURL&gt;
_urn:schemas-upnp-org:service:RenderingControl_event
&lt;/eventSubURL&gt;
&lt;/service&gt;
&lt;/serviceList&gt;
&lt;av:X_RController_DeviceInfo xmlns:av=&quot;urn:mi-com:av&quot;&gt;
&lt;av:X_RController_Version&gt;1.0&lt;/av:X_RController_Version&gt;
&lt;av:X_RController_ServiceList&gt;
&lt;av:X_RController_Service&gt;
&lt;av:X_RController_ServiceType&gt;controller&lt;/av:X_RController_ServiceType&gt;
&lt;av:X_RController_ActionList_URL&gt;http://192.168.0.108:6095/&lt;/av:X_RController_ActionList_URL&gt;
&lt;/av:X_RController_Service&gt;
&lt;av:X_RController_Service&gt;
&lt;av:X_RController_ServiceType&gt;data&lt;/av:X_RController_ServiceType&gt;
&lt;av:X_RController_ActionList_URL&gt;http://api.tv.duokanbox.com/bolt/3party/&lt;/av:X_RController_ActionList_URL&gt;
&lt;/av:X_RController_Service&gt;
&lt;/av:X_RController_ServiceList&gt;
&lt;/av:X_RController_DeviceInfo&gt;
&lt;/device&gt;
&lt;URLBase&gt;http://192.168.0.108:49152/&lt;/URLBase&gt;
&lt;/root&gt;</code></pre><h3 id="投屏及控制功能"><a href="#投屏及控制功能" class="headerlink" title="投屏及控制功能"></a>投屏及控制功能</h3><p>投屏指令<code>10.1.4.30 MM control point rules for DLNA PlayContainer URI</code></p>
<blockquote>
<p>A UPnP AV MediaRenderer control point may invoke AVT:SetAVTransportURI with the CurrentURI input argument set to a DLNA PlayContainer URI.<br>这里的<code>SOAPAction</code>: <code>urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI</code> 就是播放指定 URL，在 SOAP 消息体中 CurrentURI 内容就是播放地址</p>
</blockquote>
<pre><code>POST /_urn:schemas-upnp-org:service:AVTransport_control HTTP/1.1
SOAPAction: &quot;urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI&quot;
User-Agent: UPnP/1.0 DLNADOC/1.50 Platinum/1.0.5.13
Host: 192.168.0.108:49152
Content-Length: 1535
Content-Type: text/xml; charset=&quot;utf-8&quot;


&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;s:Envelope s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;s:Body&gt;&lt;u:SetAVTransportURI xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;&lt;InstanceID&gt;0&lt;/InstanceID&gt;&lt;CurrentURI&gt;http://gslbmgsplive.miguvideo.com/wd_r1/fifa/cctv5hd/720264/encrypt/index.m3u8?msisdn=&amp;amp;mdspid=&amp;amp;spid=800033&amp;amp;netType=4&amp;amp;sid=5500511372&amp;amp;pid=2028597139&amp;amp;timestamp=20180726185704&amp;amp;Channel_ID=0116_23050003-99000-200300020100003&amp;amp;promotionId=&amp;amp;mvid=&amp;amp;mcid=&amp;amp;mpid=&amp;amp;ProgramID=641252154&amp;amp;ParentNodeID=-99&amp;amp;playbackbegin=20180715223000&amp;amp;playbackend=20180716020059&amp;amp;client_ip=223.74.148.1&amp;amp;assertID=5500511372&amp;amp;imei=3d90e97657c1de3de151910495bc22fa6c0bd18914e3b5f7f7e638a25c1bcbbf&amp;amp;chargePhone=&amp;amp;SecurityKey=20180726185704&amp;amp;encrypt=d9814b446d6b3bb25ec6d42a25e59bb0&lt;/CurrentURI&gt;&lt;CurrentURIMetaData&gt;&amp;lt;DIDL-Lite xmlns=&quot;urn:schemas - upnp - org : metadata - 1 - 0 / DIDL - Lite / &quot; xmlns:dc=&quot;http ://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot;&amp;gt;&amp;lt;item id=&quot;unknown&quot; parentID=&quot;-1&quot; restricted=&quot;1&quot;&amp;gt;&amp;lt;upnp:genre&amp;gt;Unknown&amp;lt;/upnp:genre&amp;gt;&amp;lt;upnp:storageMedium&amp;gt;UNKNOWN&amp;lt;/upnp:storageMedium&amp;gt;&amp;lt;upnp:writeStatus&amp;gt;UNKNOWN&amp;lt;/upnp:writeStatus&amp;gt;&amp;lt;upnp:class&amp;gt;object.item.videoItem.movie&amp;lt;/upnp:class&amp;gt;&amp;lt;dc:title&amp;gt;unknown&amp;lt;/dc:title&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/DIDL-Lite&amp;gt;&lt;/CurrentURIMetaData&gt;&lt;/u:SetAVTransportURI&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;</code></pre><p><img src="https:////upload-images.jianshu.io/upload_images/1493747-6d4fee37dab22785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/807/format/webp" alt="img"></p>
<p>查询播放状态指令</p>
<blockquote>
<p>UPnP MediaRenderers that respond to an AVT:GetTransportInfo request shall reflect the play/transport state in the following manner.<br>投屏指令是向设备描述的处理 IP 和端口发送 TCP http POST 指令来完成 <code>&lt;URLBase&gt;http://192.168.0.108:49152/&lt;/URLBase&gt;</code></p>
</blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/1493747-4231595e97ac2912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/820/format/webp" alt="img"></p>
<pre><code>POST /_urn:schemas-upnp-org:service:AVTransport_control HTTP/1.1
SOAPAction: &quot;urn:schemas-upnp-org:service:AVTransport:1#GetTransportInfo&quot;
User-Agent: UPnP/1.0 DLNADOC/1.50 Platinum/1.0.5.13
Host: 192.168.0.108:49152
Content-Length: 314
Content-Type: text/xml; charset=&quot;utf-8&quot;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;s:Envelope s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;s:Body&gt;&lt;u:GetTransportInfo xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;&lt;InstanceID&gt;0&lt;/InstanceID&gt;&lt;/u:GetTransportInfo&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;</code></pre><p>这是小米电视响应包</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1493747-2b3a892182d32a6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp" alt="img"></p>
<p>表示已经开始播放了</p>
<pre><code>HTTP/1.1 200 OK
CONTENT-LENGTH: 411
CONTENT-TYPE: text/xml; charset=&quot;utf-8&quot;
DATE: Thu, 26 Jul 2018 10:57:14 GMT
EXT:
SERVER: Linux/3.14.29, UPnP/1.0, Portable SDK for UPnP devices/1.6.13
X-User-Agent: redsonic

&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;s:Body&gt;
&lt;u:GetTransportInfoResponse xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;
&lt;CurrentTransportState&gt;PLAYING&lt;/CurrentTransportState&gt;
&lt;CurrentTransportStatus&gt;OK&lt;/CurrentTransportStatus&gt;
&lt;CurrentSpeed&gt;1&lt;/CurrentSpeed&gt;
&lt;/u:GetTransportInfoResponse&gt;
&lt;/s:Body&gt; &lt;/s:Envelope&gt;</code></pre>]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>upnp</tag>
        <tag>dlna</tag>
        <tag>ssdp</tag>
        <tag>soap</tag>
        <tag>minidlan</tag>
      </tags>
  </entry>
  <entry>
    <title>SAT2IP 开源工程分析</title>
    <url>/2019/02/26/open-source-project-minisatip-analysis/</url>
    <content><![CDATA[<p>开源工程</p>
<ol>
<li><a href="https://github.com/catalinii/minisatip" target="_blank" rel="noopener">minisatip</a></li>
<li><a href="https://github.com/not1337/libsatip.git" target="_blank" rel="noopener">libsatip</a></li>
<li><a href="https://github.com/tvheadend/tvheadend.git" target="_blank" rel="noopener">tvheadend</a></li>
</ol>
<a id="more"></a>

<h2 id="SAT-gt-IP-Server-Minisatip"><a href="#SAT-gt-IP-Server-Minisatip" class="headerlink" title="SAT&gt;IP Server Minisatip"></a>SAT&gt;IP Server Minisatip</h2><p><code>SAT&gt;IP Server</code>流程具体见 <a href="/2019/02/26/sat2ip-protocol/" title="SAT&gt;IP 协议简介">SAT&gt;IP 协议简介</a> 及 <a href="/2019/02/26/sat2ip-notes/" title="SAT&gt;IP 协议笔记">SAT&gt;IP 协议笔记</a></p>
<p>流程图如下：<br><img src="/images/sat2ip/20190226-093749.png" alt=""></p>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><pre><code class="c">readBootID();
if ((ssdp = udp_bind(NULL, 1900)) &lt; 1)
    FAIL(&quot;SSDP: Could not bind on udp port 1900&quot;);
if ((ssdp1 = udp_bind(opts.disc_host, 1900)) &lt; 1)
    FAIL(&quot;SSDP: Could not bind on %s udp port 1900&quot;, opts.disc_host);
if ((rtsp = tcp_listen(NULL, opts.rtsp_port)) &lt; 1)
    FAIL(&quot;RTSP: Could not listen on port %d&quot;, opts.rtsp_port);
if ((http = tcp_listen(NULL, opts.http_port)) &lt; 1)
    FAIL(&quot;Could not listen on http port %d&quot;, opts.http_port);

si = sockets_add(ssdp, NULL, -1, TYPE_UDP, (socket_action)ssdp_reply, NULL,
                 (socket_action)ssdp_discovery);
si1 = sockets_add(ssdp1, NULL, -1, TYPE_UDP, (socket_action)ssdp_reply,
                  NULL, (socket_action)ssdp_discovery);
if (si &lt; 0 || si1 &lt; 0)
    FAIL(&quot;sockets_add failed for ssdp&quot;);

sockets_timeout(si, 60 * 1000);
set_sockets_rtime(si, -60 * 1000);
if (0 &gt; sockets_add(rtsp, NULL, -1, TYPE_SERVER, (socket_action)new_rtsp,
                    NULL, (socket_action)close_http))
    FAIL(&quot;sockets_add failed for rtsp&quot;);
if (0 &gt; sockets_add(http, NULL, -1, TYPE_SERVER, (socket_action)new_http,
                    NULL, (socket_action)close_http))
    FAIL(&quot;sockets_add failed for http&quot;);

if (0 &gt; (sock_signal = sockets_add(SOCK_TIMEOUT, NULL, -1, TYPE_UDP, NULL,
                                   NULL, (socket_action)signal_thread)))
    FAIL(&quot;sockets_add failed for signal thread&quot;);

if (!opts.no_threads)
{
    set_socket_thread(sock_signal, start_new_thread(&quot;signal&quot;));
    sockets_timeout(sock_signal, 300); // 300 ms
}
else
    sockets_timeout(sock_signal, 1000); // 1 sec

if (0 &gt; (sock_bw = sockets_add(SOCK_TIMEOUT, NULL, -1, TYPE_UDP, NULL,
                               NULL, (socket_action)calculate_bw)))
    FAIL(&quot;sockets_add failed for BW calculation&quot;);</code></pre>
<h3 id="Discovery"><a href="#Discovery" class="headerlink" title="Discovery"></a>Discovery</h3><p>函数<code>ssdp_discovery</code>以及<code>ssdp_reply</code></p>
<pre><code class="c">int ssdp_discovery(sockets *s)
{
    char *reply = &quot;NOTIFY * HTTP/1.1\r\n&quot;
                  &quot;HOST: %s:1900\r\n&quot;
                  &quot;CACHE-CONTROL: max-age=1800\r\n&quot;
                  &quot;LOCATION: http://%s/%s\r\n&quot;
                  &quot;NT: %s\r\n&quot;
                  &quot;NTS: ssdp:alive\r\n&quot;
                  &quot;SERVER: Linux/1.0 UPnP/1.1 %s/%s\r\n&quot;
                  &quot;USN: uuid:%s%s\r\n&quot;
                  &quot;BOOTID.UPNP.ORG: %d\r\n&quot;
                  &quot;CONFIGID.UPNP.ORG: 0\r\n&quot;
                  &quot;DEVICEID.SES.COM: %d\r\n\r\n\0&quot;;
    char buf[500], mac[15] = &quot;00000000000000&quot;;
    char nt[3][50];

    char uuid1[] = &quot;11223344-9999-0000-b7ae&quot;;
    socklen_t salen;
    int i;
    s-&gt;wtime = getTick();
    if (uuidi == 0)
    {
        uuidi = 1;
        get_mac_address(mac);
        sprintf(uuid, &quot;%s-%s&quot;, uuid1, mac);
        fill_sockaddr(&amp;ssdp_sa, opts.disc_host, 1900);
    }
    strcpy(nt[0], &quot;::upnp:rootdevice&quot;);
    sprintf(nt[1], &quot;::uuid:%s&quot;, uuid);
    strcpy(nt[2], &quot;::urn:ses-com:device:SatIPServer:1&quot;);

    if (s-&gt;type != TYPE_UDP)
        return 0;

    LOGM(&quot;ssdp_discovery: bootid: %d deviceid: %d http: %s&quot;, opts.bootid,
         opts.device_id, opts.http_host);

    for (i = 0; i &lt; 3; i++)
    {
        sprintf(buf, reply, opts.disc_host, opts.http_host, opts.xml_path,
                nt[i] + 2, app_name, version, uuid, i == 1 ? &quot;&quot; : nt[i],
                opts.bootid, opts.device_id);
        salen = sizeof(ssdp_sa);
        LOGM(&quot;Discovery packet %d:\n%s&quot;, i + 1, buf);
        int wb = sendto(s-&gt;sock, buf, strlen(buf), MSG_NOSIGNAL, (const struct sockaddr *)&amp;ssdp_sa, salen);
        if (wb != strlen(buf))
            LOG(&quot;incomplete ssdp_discovery: wrote %d out of %d: error %d: %s&quot;, wb, strlen(buf), errno, strerror(errno));
    }
    s-&gt;rtime = getTick();
    return 0;
}

int ssdp;
int ssdp_reply(sockets *s)
{
    char *reply = &quot;HTTP/1.1 200 OK\r\n&quot;
                  &quot;CACHE-CONTROL: max-age=1800\r\n&quot;
                  &quot;DATE: %s\r\n&quot;
                  &quot;EXT:\r\n&quot;
                  &quot;LOCATION: http://%s/%s\r\n&quot;
                  &quot;SERVER: Linux/1.0 UPnP/1.1 %s/%s\r\n&quot;
                  &quot;ST: urn:ses-com:device:SatIPServer:1\r\n&quot;
                  &quot;USN: uuid:%s::urn:ses-com:device:SatIPServer:1\r\n&quot;
                  &quot;BOOTID.UPNP.ORG: %d\r\n&quot;
                  &quot;CONFIGID.UPNP.ORG: 0\r\n&quot;
                  &quot;DEVICEID.SES.COM: %d\r\n\r\n\0&quot;;
    char *device_id_conflict = &quot;M-SEARCH * HTTP/1.1\r\n&quot;
                               &quot;HOST: %s:1900\r\n&quot;
                               &quot;MAN: \&quot;ssdp:discover\&quot;\r\n&quot;
                               &quot;ST: urn:ses-com:device:SatIPServer:1\r\n&quot;
                               &quot;USER-AGENT: Linux/1.0 UPnP/1.1 %s/%s\r\n&quot;
                               &quot;DEVICEID.SES.COM: %d\r\n\r\n\0&quot;;
    socklen_t salen;
    char *man, *man_sd, *didsescom, *ruuid, *rdid;
    char buf[500];
    char ra[50];
    int did = 0;

    if (uuidi == 0)
        ssdp_discovery(s);

    s-&gt;rtime = s-&gt;wtime; // consider the timeout of the discovery operation

    salen = sizeof(s-&gt;sa);
    ruuid = strcasestr((const char *)s-&gt;buf, &quot;uuid:&quot;);
    if (ruuid &amp;&amp; strncmp(uuid, strip(ruuid + 5), strlen(uuid)) == 0)
    {
        LOGM(&quot;Dropping packet from the same UUID as mine (from %s:%d)&quot;,
             get_socket_rhost(s-&gt;id, ra, sizeof(ra)),
             get_socket_rport(s-&gt;id));
        return 0;
    }

    // not my uuid

#ifdef AXE
    axe_set_network_led(1);
#endif

    LOGM(&quot;Received SSDP packet from %s:%d -&gt; handle %d&quot;,
         get_socket_rhost(s-&gt;id, ra, sizeof(ra)), get_socket_rport(s-&gt;id),
         s-&gt;sock);
    LOGM(&quot;%s&quot;, s-&gt;buf);

    if (strncasecmp((const char *)s-&gt;buf, &quot;NOTIFY&quot;, 6) == 0)
    {
        rdid = strcasestr((const char *)s-&gt;buf, &quot;DEVICEID.SES.COM:&quot;);
        if (rdid &amp;&amp; opts.device_id == map_int(strip(rdid + 17), NULL))
        {
            snprintf(buf, sizeof(buf), device_id_conflict, getlocalip(),
                     app_name, version, opts.device_id);
            LOG(
                &quot;A new device joined the network with the same Device ID:  %s, asking to change DEVICEID.SES.COM&quot;,
                get_socket_rhost(s-&gt;id, ra, sizeof(ra)));
            int wb = sendto(ssdp, buf, strlen(buf), MSG_NOSIGNAL,
                            (const struct sockaddr *)&amp;s-&gt;sa, salen);
            if (wb != strlen(buf))
                LOG(&quot;incomplete ssdp_reply notify: wrote %d out of %d: error %d: %s&quot;, wb, strlen(buf), errno, strerror(errno));
        }

        return 0;
    }

    man = strcasestr((const char *)s-&gt;buf, &quot;MAN&quot;);
    man_sd = strcasestr((const char *)s-&gt;buf, &quot;ssdp:discover&quot;);
    if ((didsescom = strcasestr((const char *)s-&gt;buf, &quot;DEVICEID.SES.COM:&quot;)))
        did = map_int(didsescom + 17, NULL);

    if (man &amp;&amp; man_sd &amp;&amp; didsescom &amp;&amp; (s-&gt;rtime &lt; 15000) &amp;&amp; did == opts.device_id) // SSDP Device ID clash, only first 5 seconds after the announcement
    {
        opts.device_id++;
        s[si].timeout_ms = 1800 * 1000;
        s[si].rtime = -s[si].timeout_ms;
        LOG(
            &quot;Device ID conflict, changing our device id to %d, destination SAT&gt;IP server %s&quot;,
            opts.device_id, get_socket_rhost(s-&gt;id, ra, sizeof(ra)));
        readBootID();
    }
    else
        did = opts.device_id;

    if (strncmp((const char *)s-&gt;buf, &quot;HTTP/1&quot;, 6) == 0)
        LOG_AND_RETURN(0, &quot;ssdp_reply: the message is a reply, ignoring....&quot;);

    sprintf(buf, reply, get_current_timestamp(), opts.http_host, opts.xml_path,
            app_name, version, uuid, opts.bootid, did);

    LOGM(&quot;ssdp_reply fd: %d -&gt; %s:%d, bootid: %d deviceid: %d http: %s&quot;, ssdp,
         get_socket_rhost(s-&gt;id, ra, sizeof(ra)), get_socket_rport(s-&gt;id),
         opts.bootid, did, opts.http_host);
    //use ssdp (unicast) even if received to multicast address
    LOGM(&quot;%s&quot;, buf);
    int wb = sendto(ssdp, buf, strlen(buf), MSG_NOSIGNAL, (const struct sockaddr *)&amp;s-&gt;sa, salen);
    if (wb != strlen(buf))
        LOG(&quot;incomplete ssdp_reply: wrote %d out of %d: error %d: %s&quot;, wb, strlen(buf), errno, strerror(errno));
    return 0;
}</code></pre>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><code>ssdp</code>信息中的<code>LOCATION</code>字段，对于<code>minisatip</code>可以通过参数来指定</p>
<pre><code>case XML_OPT:
    while (*optarg &gt; 0 &amp;&amp; *optarg == &#39;/&#39;)
        optarg++;
    if (*optarg &gt; 0)
        opts.xml_path = optarg;
    else
        LOG(&quot;Not a valid path for the xml file&quot;);
    break;

case PLAYLIST_OPT:
{
    if (strlen(optarg) &lt; 1000)
    {
        opts.playlist = malloc1(strlen(optarg) + 200);
        if (opts.playlist)
            sprintf(opts.playlist, &quot;&lt;satip:X_SATIPM3U xmlns:satip=\&quot;urn:ses-com:satip\&quot;&gt;%s&lt;/satip:X_SATIPM3U&gt;\r\n&quot;, &gt;
    }
    else
        LOG(&quot;playlist length is too big %d bytes&quot;, strlen(optarg));
    break;
}</code></pre><p>另外从函数<code>read_http</code>也可以看到<code>xml</code>的组成成分及生成过程</p>
<p><code>minisatip</code>同时支持<code>SAT&gt;IP Client</code>，文件<code>satipc.c</code>即为相关代码，函数<code>satip_getxml</code>为获取<code>LOCATION</code>过程</p>
<h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>涉及<code>RTSP</code>和<code>HTTP</code>，忽略<code>HTTP</code>。<code>RTSP</code>函数为<code>new_rtsp</code>及<code>read_rtsp</code></p>
<p><code>read_rtsp</code>为服务端处理<code>rtsp</code></p>
<pre><code class="c">#define RTSP_SETUP 1
#define RTSP_PLAY 2
#define RTSP_OPTIONS 3
#define RTSP_TEARDOWN 4
#define RTSP_DESCRIBE 5

if ((strncasecmp(arg[0], &quot;PLAY&quot;, 4) == 0) || (strncasecmp(arg[0], &quot;GET&quot;, 3) == 0) || (strncasecmp(arg[0], &quot;SETUP&quot;, 5) == 0))
{
    char ra[100];
    int rv;

    if (!(sid = get_sid(s-&gt;sid)))
    {
        http_response(s, 454, NULL, NULL, cseq, 0);
        return 0;
    }

    if (useragent)
        strncpy(sid-&gt;useragent, useragent, sizeof(sid-&gt;useragent) - 1);

    if ((strncasecmp(arg[0], &quot;PLAY&quot;, 4) == 0) || (strncasecmp(arg[0], &quot;GET&quot;, 3) == 0))
        if ((rv = start_play(sid, s)) &lt; 0)
        {
            http_response(s, -rv, NULL, NULL, cseq, 0);
            return 0;
        }
    buf[0] = 0;
    if (transport)
    {
        int s_timeout;

        if (sid-&gt;timeout == 1)
            sid-&gt;timeout = opts.timeout_sec;

        s_timeout = ((sid-&gt;timeout &gt; 20000) ? sid-&gt;timeout : opts.timeout_sec) / 1000;
        get_stream_rhost(sid-&gt;sid, ra, sizeof(ra));

        switch (sid-&gt;type)
        {
        case STREAM_RTSP_UDP:
            if (atoi(ra) &lt; 224)
                snprintf(buf, sizeof(buf),
                            &quot;Transport: RTP/AVP;unicast;destination=%s;source=%s;client_port=%d-%d;server_port=%d-%d\r\nSession: %010d;timeout=%d\r\ncom.ses.streamID: %d&quot;,
                            ra, get_sock_shost(s-&gt;sock),
                            get_stream_rport(sid-&gt;sid),
                            get_stream_rport(sid-&gt;sid) + 1,
                            //                            opts.start_rtp, opts.start_rtp + 1,
                            get_sock_sport(sid-&gt;rsock),
                            get_sock_sport(sid-&gt;rtcp), get_session_id(s-&gt;sid),
                            s_timeout, sid-&gt;sid + 1);
            else
                snprintf(buf, sizeof(buf),
                            &quot;Transport: RTP/AVP;multicast;destination=%s;port=%d-%d\r\nSession: %010d;timeout=%d\r\ncom.ses.streamID: %d&quot;,
                            ra, get_stream_rport(sid-&gt;sid),
                            ntohs(sid-&gt;sa.sin_port) + 1,
                            get_session_id(s-&gt;sid), s_timeout, sid-&gt;sid + 1);
            break;
        case STREAM_RTSP_TCP:
            snprintf(buf, sizeof(buf),
                        &quot;Transport: RTP/AVP/TCP;interleaved=0-1\r\nSession: %010d;timeout=%d\r\ncom.ses.streamID: %d&quot;,
                        get_session_id(s-&gt;sid), s_timeout, sid-&gt;sid + 1);
            break;
        }
    }

    if (strncasecmp(arg[0], &quot;PLAY&quot;, 4) == 0)
    {
        char *qm = strchr(arg[1], &#39;?&#39;);
        if (qm)
            *qm = 0;
        if (buf[0])
            strcat(buf, &quot;\r\n&quot;);

        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf) - 1,
                    &quot;RTP-Info: url=%s;seq=%jd;rtptime=%jd\r\nRange: npt=0.000-&quot;,
                    arg[1], getTick(), (getTickUs() / 1000000));
    }
    if (buf[0] == 0 &amp;&amp; sid-&gt;type == STREAM_HTTP)
        snprintf(buf, sizeof(buf), &quot;Content-Type: video/mp2t\r\nConnection: close&quot;);
    http_response(s, 200, buf, NULL, cseq, 0);
}
else if (strncmp(arg[0], &quot;TEARDOWN&quot;, 8) == 0)
{
    buf[0] = 0;
    if (get_sid(s-&gt;sid))
        sprintf(buf, &quot;Session: %010d&quot;, get_session_id(s-&gt;sid));
    close_stream(s-&gt;sid);
    s-&gt;flush_enqued_data = 1;
    http_response(s, 200, buf, NULL, cseq, 0);
}
else
{
    if (strncmp(arg[0], &quot;DESCRIBE&quot;, 8) == 0)
    {
        char sbuf[1000];
        char *rv;
        rv = describe_streams(s, arg[1], sbuf, sizeof(sbuf));
        if (!rv)
        {
            http_response(s, 404, NULL, NULL, cseq, 0);
            return 0;
        }
        snprintf(buf, sizeof(buf),
                    &quot;Content-type: application/sdp\r\nContent-Base: rtsp://%s/&quot;,
                    get_sock_shost(s-&gt;sock));
        http_response(s, 200, buf, sbuf, cseq, 0);
    }
    else if (strncmp(arg[0], &quot;OPTIONS&quot;, 7) == 0)
    {
        //            if(!get_sid(s-&gt;sid))
        //                http_response(s, 454, public, NULL, cseq, 0);
        //            else
        http_response(s, 200, public, NULL, cseq, 0);
    }
}
</code></pre>
<p>客户端发送<code>rtsp</code>命令可以参看文件<code>satipc.c</code>函数<code>satipc_reply</code></p>
<h3 id="Media-Transport"><a href="#Media-Transport" class="headerlink" title="Media Transport"></a>Media Transport</h3><p>涉及<code>RTP</code>及<code>RTCP</code>协议</p>
<p><code>RTP</code>处理流程<code>read_dmx</code> -&gt; <code>process_dmx</code> -&gt; <code>process_packet</code> -&gt; <code>flush_streami</code> -&gt; <code>send_rtp</code></p>
<p><code>RTCP</code>处理流程<code>setup_stream</code> -&gt; <code>stream_timeout</code> -&gt; <code>send_rtcp</code></p>
<h2 id="SAT-gt-IP-Client-Vlc"><a href="#SAT-gt-IP-Client-Vlc" class="headerlink" title="SAT&gt;IP Client Vlc"></a>SAT&gt;IP Client Vlc</h2><p>主要是<code>SAT&gt;IP Client</code>怎么获取<code>Channel List</code>，以<code>vlc</code>为例</p>
<p><code>modules/services_discovery/upnp.cpp</code>函数<code>void MediaServerList::parseNewServer( IXML_Document *doc, const std::string &amp;location )</code></p>
<pre><code>if ( !strncmp( SATIP_SERVER_DEVICE_TYPE, psz_device_type,
        strlen( SATIP_SERVER_DEVICE_TYPE ) - 1 ) )
{
    SD::MediaServerDesc* p_server = NULL;

    vlc_url_t url;
    vlc_UrlParse( &amp;url, psz_base_url );

    char *psz_satip_channellist = config_GetPsz(m_sd, &quot;satip-channelist&quot;);
    if( !psz_satip_channellist ) {
        break;
    }

    /* a user may have provided a custom playlist url */
    if (strncmp(psz_satip_channellist, &quot;CustomList&quot;, 10) == 0) {
        char *psz_satip_playlist_url = config_GetPsz( m_sd, &quot;satip-channellist-url&quot; );
        if ( psz_satip_playlist_url ) {
            p_server = new(std::nothrow) SD::MediaServerDesc( psz_udn, psz_friendly_name, psz_satip_playlist_url, iconUrl );

            if( likely( p_server ) ) {
                p_server-&gt;satIpHost = url.psz_host;
                p_server-&gt;isSatIp = true;
                if( !addServer( p_server ) ) {
                    delete p_server;
                }
            }

            /* to comply with the SAT&gt;IP specification, we don&#39;t fall back on another channel list if this path failed */
            free( psz_satip_playlist_url );
            vlc_UrlClean( &amp;url );
            continue;
        }
    }

    /* If requested by the user, check for a SAT&gt;IP m3u list, which may be provided by some rare devices */
    if (strncmp(psz_satip_channellist, &quot;ServerList&quot;, 10) == 0) {
        const char* psz_m3u_url = xml_getChildElementValue( p_device_element, &quot;satip:X_SATIPM3U&quot; );
        if ( psz_m3u_url ) {
            if ( strncmp( &quot;http&quot;, psz_m3u_url, 4) )
            {
                char* psz_url = NULL;
                if ( UpnpResolveURL2( psz_base_url, psz_m3u_url, &amp;psz_url ) == UPNP_E_SUCCESS )
                {
                    p_server = new(std::nothrow) SD::MediaServerDesc( psz_udn, psz_friendly_name, psz_url, iconUrl );
                    free(psz_url);
                }
            } else {
                p_server = new(std::nothrow) SD::MediaServerDesc( psz_udn, psz_friendly_name, psz_m3u_url, iconUrl );
            }

            if ( unlikely( !p_server ) )
            {
                free( psz_satip_channellist );
                break;
            }

            p_server-&gt;satIpHost = url.psz_host;
            p_server-&gt;isSatIp = true;
            if ( !addServer( p_server ) )
                delete p_server;
        } else {
            msg_Warn( m_sd, &quot;SAT&gt;IP server &#39;%s&#39; did not provide a playlist&quot;, url.psz_host);
        }

        /* to comply with the SAT&gt;IP specifications, we don&#39;t fallback on another channel list if this path failed */
        free(psz_satip_channellist);
        vlc_UrlClean( &amp;url );
        continue;
    }

    /* Normally, fetch a playlist from the web,
        * which will be processed by a lua script a bit later */
    char *psz_url;
    if (asprintf( &amp;psz_url, &quot;http://www.satip.info/Playlists/%s.m3u&quot;,
                    psz_satip_channellist ) &lt; 0 ) {
        vlc_UrlClean( &amp;url );
        free( psz_satip_channellist );
        continue;
    }

    p_server = new(std::nothrow) SD::MediaServerDesc( psz_udn,
                                                        psz_friendly_name, psz_url, iconUrl );

    if( likely( p_server ) ) {
        p_server-&gt;satIpHost = url.psz_host;
        p_server-&gt;isSatIp = true;
        if( !addServer( p_server ) ) {
            delete p_server;
        }
    }
    free( psz_url );
    free( psz_satip_channellist );
    vlc_UrlClean( &amp;url );

    continue;
}</code></pre><ol>
<li>获取<code>CustomList</code></li>
<li>根据<code>satip:X_SATIPM3U</code>获取</li>
<li>指定<code>URL:http://www.satip.info/Playlists/%s.m3u</code>获取</li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>sat2ip</tag>
        <tag>ssdp</tag>
        <tag>soap</tag>
        <tag>rtsp</tag>
        <tag>minisatip</tag>
        <tag>vlc</tag>
        <tag>rtcp</tag>
      </tags>
  </entry>
  <entry>
    <title>SAT&gt;IP 协议笔记</title>
    <url>/2019/02/26/sat2ip-notes/</url>
    <content><![CDATA[<p>针对文档 <a href="http://www.satip.info/sites/satip/files/resource/satip_specification_version_1_2_2.pdf" target="_blank" rel="noopener">satip_specification_version_1_2_2</a> 笔记</p>
<a id="more"></a>


<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><code>SAT&gt;IP</code> 规范是一份通信协议，不是设备规范。在 <code>SAT&gt;IP</code> 规范下存在两种角色</p>
<ul>
<li><code>SAT&gt;IP</code> Server</li>
<li><code>SAT&gt;IP</code> Client</li>
</ul>
<p>一个具体的设备可以是其中一个角色，或者两者兼具。</p>
<p><code>SAT&gt;IP</code> 协议提供了一种标准化的方式，使客户端可以通过网络来访问 sat 上的实时流</p>
<p><code>SAT&gt;IP</code> 协议实现了卫星接收端与播放端分离，卫星接收端被放在远端服务器上， <code>SAT&gt;IP</code> 协议提供控制协议，Clients 可以远程控制</p>
<p>从而扩展了卫星接收端的范围</p>
<p><code>SAT&gt;IP</code> 是一种客户端驱动的架构。客户端向服务器发送请求。服务器执行这些请求和向客户转发直播电视节目。</p>
<h3 id="SAT-gt-IP-Clients"><a href="#SAT-gt-IP-Clients" class="headerlink" title="SAT&gt;IP Clients"></a><code>SAT&gt;IP Clients</code></h3><p><code>SAT&gt;IP Clients</code> 通过发送请求完成获取 channel list 和播放指定节目功能</p>
<ul>
<li>具有网络连接能力的 STB</li>
<li>NAS</li>
<li>Smartphones</li>
<li>PCs</li>
<li>etc.</li>
</ul>
<h3 id="SAT-gt-IP-Servers"><a href="#SAT-gt-IP-Servers" class="headerlink" title="SAT&gt;IP Servers"></a><code>SAT&gt;IP Servers</code></h3><p><code>SAT&gt;IP Servers</code> 处理 <code>SAT&gt;IP Clients</code> 的请求并将电视直播节目转发给 <code>SAT&gt;IP Clients</code></p>
<p>从简单到复杂</p>
<ul>
<li>IP Adapters / Multiswitches</li>
<li>Master STBs</li>
<li>IP LNBs</li>
<li>MDU(Multi Dwelling Unit) 多用户居住单元</li>
</ul>
<h3 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h3><p>以 <code>SAT&gt;IP Servers</code> 能力来完成对 Clients 的支持</p>
<p>可以是单卫星 - 单 Tuner/ 多卫星 - 多 Tuner</p>
<p>即可以是单个家庭场景中工作，也可以是宾馆等大型社区场景下工作</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>描述几种常用的场景</p>
<h3 id="IP-Adapter-IP-Multiswitch"><a href="#IP-Adapter-IP-Multiswitch" class="headerlink" title="IP Adapter / IP Multiswitch"></a>IP Adapter / IP Multiswitch</h3><p>将卫星信号转换为 IP 数据，同时可以按照 <code>SAT&gt;IP</code> 协议处理 Client 发送的控制命令</p>
<p>一般会有多个卫星信号输入用来为多客户端提供并发支持</p>
<p>例如：<a href="https://unitrongroup.com/en/products/CAT/SIP/MSW/9830.html" target="_blank" rel="noopener">Johansson SAT&gt;IP Multiswitch 9830</a></p>
<p>支持 4 路卫星信号输入，支持 2×8 信号输出，通过网口，支持 8 路独立收看电视节目</p>
<p>内部集成 multiswitch/disqec 等控制</p>
<h3 id="IP-LNB"><a href="#IP-LNB" class="headerlink" title="IP LNB"></a>IP LNB</h3><p><a href="http://www.satip.info/sites/satip/files/files/GB%20-%20Product%20info%20%5BTriax%20SAT-IP-LNB%5D%2005-2016%20-1.pdf" target="_blank" rel="noopener">Triax SAT&gt;IP LNB unit</a></p>
<p>Common features:</p>
<ul>
<li>8 x Full Band H/V DVB-S/S2 tuners</li>
<li>Unlimited number of transponders from position</li>
<li>Supports 8 x SAT&gt;IP clients (one each tuner)</li>
<li>SAT&gt;IP via Gigabit Ethernet RJ45 connector output</li>
<li>Up to 900 Mbps transport stream bandwidth</li>
<li>Separate H and V Full Band SAT-IF outputs</li>
<li>Powered via 802.3@rev 2012 PoE type 1, class 2</li>
<li>No DiSEqC, 22kHz or FSK required or supported</li>
<li>Transparently supports FTA as well as CAS services</li>
<li>Die-cast housing</li>
<li>Power consumption &lt;7.5W</li>
</ul>
<p>新的 LNA 设备，使用 <code>POE</code> 供电，可以支持作为 <code>SAT&gt;IP Server</code> 输出 IP 数据</p>
<h3 id="Master-STBs"><a href="#Master-STBs" class="headerlink" title="Master STBs"></a>Master STBs</h3><p>通过在传统 STB 上开发 <code>SAT&gt;IP Server</code> 完成扩展，主要讨论的内容</p>
<h3 id="SMATV-Satellite-Master-Antenna-Television-MDU-Multi-Dwelling-Units"><a href="#SMATV-Satellite-Master-Antenna-Television-MDU-Multi-Dwelling-Units" class="headerlink" title="SMATV(Satellite Master Antenna Television) / MDU(Multi-Dwelling Units)"></a>SMATV(Satellite Master Antenna Television) / MDU(Multi-Dwelling Units)</h3><p>是指电视程序到安装在一个公寓大楼，宾馆或其它中心位置的卫星共享天线的传输，在那里它为电视观众私人组服务。</p>
<p>组网</p>
<h2 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h2><p><code>SAT&gt;IP</code> 是在已有协议基础上的扩展，主要依赖于以下协议</p>
<ul>
<li>UPnP for Addressing, Discovery and Description</li>
<li>RTSP or HTTP for Control</li>
<li>RTP or HTTP for Media Transport</li>
</ul>
<p>协议栈组织形式：</p>
<p>与 <code>DLNA</code> 的关系</p>
<p>使用了 <code>UPnP/DLNA</code> 架构的子集和协议</p>
<ul>
<li>UPnP Device Architecture 1.1</li>
<li>DLNA Networked Device Interoperability Guidelines</li>
</ul>
<p><code>SAT&gt;IP</code> 设备可以扩展为 <code>DLNA</code> 设备，另外客户端可以通用，例如 VLC 均通过 <code>UPnP</code> 来访问</p>
<p>阶段</p>
<ul>
<li>Addressing</li>
<li>Discovery</li>
<li>Description</li>
<li>Control</li>
<li>Media Transport</li>
</ul>
<h3 id="Addressing"><a href="#Addressing" class="headerlink" title="Addressing"></a>Addressing</h3><p>先决条件，一切通信的基础，按照 <code>UPnP</code> 规范提供两个选项</p>
<ul>
<li>DHCP</li>
<li>Auto-IP</li>
</ul>
<h3 id="Discovery"><a href="#Discovery" class="headerlink" title="Discovery"></a>Discovery</h3><ul>
<li>Server 发送通知给其他的 Servers 和 Clients</li>
<li>Clients 搜索可用的 Servers</li>
</ul>
<p><code>SSDP</code> 全称是 Simple Service Discover Protocol 简单服务发现协议，这个协议是 <code>UPnP</code> 的核心，在 <code>UPnP</code> 中定义了一组协议框架，其中有控制点，根设备等概念， <code>UPnP</code> 设备通过 <code>SSDP</code> 协议与根设备（用户设备）进行交互。<br><code>SSDP</code> 是应用层协议，使用 <code>HTTPU</code> 和 <code>HTTPMU</code> 规范，基于 <code>UDP</code> 端口进行通信。</p>
<ul>
<li>SAT&gt;IP server is a UPnP Device and a UPnP Control Point</li>
<li>SAT&gt;IP client is a UPnP Control Point</li>
</ul>
<p>Unique Resource Name (URN) in UPnP:</p>
<pre><code>urn:ses-com:device:SatIPServer:1</code></pre><p>UUID</p>
<pre><code>4B-2B-2B-2B-6B
Example of a UUID string:
“2fac1234-31f8-11b4-a222-08002b34c003”</code></pre><h4 id="Server-Advertisements-服务器通知"><a href="#Server-Advertisements-服务器通知" class="headerlink" title="Server Advertisements 服务器通知"></a>Server Advertisements 服务器通知</h4><p>SSDP 使用一个固定的组播地址 <code>239.255.255.250</code> 和 UDP 端口号 1900 来监听其他设备的请求。</p>
<p>根据 <code>UPnP</code> 对 <code>UPnP root devices</code> 的要求， <code>SAT&gt;IP servers</code> 入网时会对 <code>SSDP</code> 地址 <code>239.255.255.250:1900</code> 多播三个不同的 <code>NOTIFY ssdp:alive</code> 消息</p>
<pre><code>  12     strcpy(nt[0], &quot;::upnp:rootdevice&quot;);
  11     sprintf(nt[1], &quot;::uuid:%s&quot;, uuid);
  10     strcpy(nt[2], &quot;::urn:ses-com:device:SatIPServer:1&quot;);
   9
   8     if (s-&gt;type != TYPE_UDP)
   7         return 0;
   6
   5     LOGM(&quot;ssdp_discovery: bootid: %d deviceid: %d http: %s&quot;, opts.bootid,
   4          opts.device_id, opts.http_host);
   3
   2     for (i = 0; i &lt; 3; i++)
   1     {
1494         sprintf(buf, reply, opts.disc_host, opts.http_host, opts.xml_path,
   1                 nt[i] + 2, app_name, version, uuid, i == 1 ? &quot;&quot; : nt[i],
   2                 opts.bootid, opts.device_id);
   3         salen = sizeof(ssdp_sa);
   4         LOGM(&quot;Discovery packet %d:\n%s&quot;, i + 1, buf);
   5         int wb = sendto(s-&gt;sock, buf, strlen(buf), MSG_NOSIGNAL, (const struct sockaddr *)&amp;ssdp_sa, salen);
   6         if (wb != strlen(buf))
   7             LOG(&quot;incomplete ssdp_discovery: wrote %d out of %d: error %d: %s&quot;, wb, strlen(buf), errno, strerror(errno));
   8     }</code></pre><pre><code>NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://&lt;SatIPServer_IP_Address&gt;/&lt;description&gt;.xml
NT: &lt;notification type&gt;
NTS: ssdp:alive
SERVER: OS/version UPnP/1.1 product/version
USN: &lt;unique service name&gt;
BOOTID.UPNP.ORG: &lt;bootID&gt;
CONFIGID.UPNP.ORG: &lt;configID&gt;
SEARCHPORT.UPNP.ORG: &lt;searchPort&gt;
DEVICEID.SES.COM: &lt;DEVICEID&gt;
&lt;CRLF&gt;</code></pre><ul>
<li><code>NTS</code> 为 <code>ssdp:alive</code> 或 <code>ssdp:byebye</code></li>
<li><code>NT</code> 三种，the root device, its device uuid and the urn</li>
</ul>
<p>Example Announcement of a <code>SAT&gt;IP</code> server joining the network:</p>
<pre><code>NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://192.168.178.21/desc.xml
NT: upnp:rootdevice
NTS: ssdp:alive
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c::upnp:rootdevice
BOOTID.UPNP.ORG: 2318
CONFIGID.UPNP.ORG: 0
DEVICEID.SES.COM: 1

NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://192.168.178.21/desc.xml
NT: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c
NTS: ssdp:alive
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c
BOOTID.UPNP.ORG: 2318
CONFIGID.UPNP.ORG: 0
DEVICEID.SES.COM: 1

NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://192.168.178.21/desc.xml
NT: urn:ses-com:device:SatIPServer:1
NTS: ssdp:alive
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c::urn:ses-com:device:SatIPServer:1
BOOTID.UPNP.ORG: 2318
CONFIGID.UPNP.ORG: 0
DEVICEID.SES.COM: 1</code></pre><p><code>SAT&gt;IP server</code> 离开网络时需要发送 <code>ssdp:byebye</code>，不包含 <code>CACHE-CONTROL, LOCATION, SERVER and DEVICEID.SES.COM</code> 字段</p>
<pre><code>NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
NT: upnp:rootdevice
NTS: ssdp:byebye
USN: uuid:5a0c857b-add1-42d0-8673-b5ca60df4a63::upnp:rootdevice
BOOTID.UPNP.ORG: 2
CONFIGID.UPNP.ORG: 0

NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
NT: uuid:5a0c857b-add1-42d0-8673-b5ca60df4a63
NTS: ssdp:byebye
USN: uuid:5a0c857b-add1-42d0-8673-b5ca60df4a63
BOOTID.UPNP.ORG: 2
CONFIGID.UPNP.ORG: 0

NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
NT: urn:ses-com:device:SatIPServer:1
NTS: ssdp:byebye
USN: uuid:5a0c857b-add1-42d0-8673-b5ca60df4a63::urn:ses-com:device:SatIPServer:1
BOOTID.UPNP.ORG: 2
CONFIGID.UPNP.ORG: 0</code></pre><h4 id="DEVICE-ID-Negotiation-设备-ID-协商"><a href="#DEVICE-ID-Negotiation-设备-ID-协商" class="headerlink" title="DEVICE ID Negotiation 设备 ID 协商"></a>DEVICE ID Negotiation 设备 ID 协商</h4><p>每个在网的 <code>SAT&gt;IP Server</code> 都有一个唯一不冲突的 <code>DEVICE ID</code>，这个值存储于非易失区域</p>
<p>协商流程如下：</p>
<ol>
<li>设备冷启动之后，从 <code>non-volatile memory</code> 读出 <code>DEVICE ID</code> 值，然后作为 <code>announcement NOTIFY messages ssdp:alive</code> 参数多播发送</li>
<li>其他在网的 servers 会监听这些公告，如果 <code>DEVICE ID</code> 不存在冲突，不做任何反应；如果存在冲突，需要在 1s 以内，发送单播 <code>M-SEARCH message ssdp:disvocer</code> 到冲突的 server</li>
<li>入网 server 发送 200 ok 来确认，注意 <code>EXT</code> 字段</li>
<li>入网 server 发送 <code>ssdp:byebye</code>，可选项</li>
<li>入网 server 生成新的 <code>DEVICE ID</code>，一般是 <code>+1</code>，然后发送 <code>announcement NOTIFY messages ssdp:alive</code></li>
<li>5s 超时时间内未收到 <code>ssdp:discover</code> 表示没有冲突，使用新的 <code>DEVICE ID</code> 作为新的并存储</li>
</ol>
<p>流程如下：</p>
<p>multicast 地址？??</p>
<pre><code>239. &lt;DEVICEID&gt; . &lt;0-254&gt; . &lt;0-254&gt;</code></pre><p>如果一个 <code>SAT&gt;IP server</code> <code>DEVICEID=3</code>，那么地址为 <code>239.3.x.x</code></p>
<h4 id="Client-Search-Requests"><a href="#Client-Search-Requests" class="headerlink" title="Client Search Requests"></a>Client Search Requests</h4><p><code>client</code> 多播 <code>M-SEARCH ssdp:discover</code> 来发现在网 servers，由于 <code>udp</code> 的不可靠性，建议发送三次，间隔 100ms</p>
<p>Example Search Request of a <code>SAT&gt;IP</code> Client and Server Response:</p>
<pre><code>#In order to discover servers on the network a client sends a multicast M-SEARCH ssdp:discover message to 239.255.255.250 Port 1900

M-SEARCH * HTTP/1.1
HOST: 239.255.255.250:1900
ST: urn:ses-com:device:SatIPServer:1
MAN: &quot;ssdp:discover&quot;
MX: 2

#Servers respond in unicast UDP to IP address and port where request came from

HTTP/1.1 200 OK
CACHE-CONTROL: max-age=1800
DATE: Sat Jan 1 00:01:50 2000
EXT:
LOCATION: http://192.168.178.21/desc.xml
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
ST: urn:ses-com:device:SatIPServer:1
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c::urn:ses-com:device:SatIPServer:1
BOOTID.UPNP.ORG: 2399
CONFIGID.UPNP.ORG: 0</code></pre><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>通过 <code>xml</code> 文件向网络上其他 <code>UPnP Control Points</code> 提供更多信息，这个文件的路径是在 <code>Discovery</code> 阶段获取的， <code>LOCATION</code> 字段指出</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; configId=&quot;configuration number&quot;&gt;
&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;1&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:ses-com:device:SatIPServer:1&lt;/deviceType&gt;
&lt;friendlyName&gt;short user-friendly title&lt;/friendlyName&gt;
&lt;manufacturer&gt;manufacturer name&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;URL to manufacturer site&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;long user-friendly title&lt;/modelDescription&gt;
&lt;modelName&gt;model name&lt;/modelName&gt;
&lt;modelNumber&gt;model number&lt;/modelNumber&gt;
&lt;modelURL&gt;URL to model site&lt;/modelURL&gt;
&lt;serialNumber&gt;manufacturer&#39;s serial number&lt;/serialNumber&gt;
&lt;UDN&gt;uuid:UUID&lt;/UDN&gt;
&lt;UPC&gt;Universal Product Code&lt;/UPC&gt;
&lt;iconList&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/format&lt;/mimetype&gt;
&lt;width&gt;horizontal pixels&lt;/width&gt;
&lt;height&gt;vertical pixels&lt;/height&gt;
&lt;depth&gt;color depth&lt;/depth&gt;
&lt;url&gt;URL to icon&lt;/url&gt;
&lt;/icon&gt;
&lt;/iconList&gt;
&lt;presentationURL&gt;URL for presentation&lt;/presentationURL&gt;
&lt;/device&gt;
&lt;/root&gt;</code></pre>
<p><code>configid=</code> 值必须与 <code>discovery</code> 阶段的 <code>CONFIGID.UPNP.ORG</code> 相同</p>
<p>必须提供两张 JPEG 和两张 PNG 图标，小的尺寸为 <code>48×48</code>，大的为 <code>120×120</code></p>
<p><code>&lt;satip:X_SATIPCAP&gt;</code> 用来描述支持的前端类型及数量，放在 <code>&lt;device&gt;</code> 元素的尾部</p>
<pre><code>&lt;satip:X_SATIPCAP xmlns:satip=&quot;urn:ses-com:satip&quot;&gt;DVBS2-8,DVBT-4&lt;/satip:X_SATIPCAP&gt;</code></pre><p><code>SA&gt;IP server</code> 提供 <code>channel list</code></p>
<pre><code>&lt;satip:X_SATIPM3U xmlns:satip=&quot;urn:ses-com:satip&quot;&gt;/channellist.m3u&lt;/satip:X_SATIPM3U&gt;
&lt;satip:X_SATIPM3U xmlns:satip=&quot;urn:ses-com:satip&quot;&gt;http://www.example.com/channellist.m3u&lt;/satip:X_SATIPM3U&gt;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; configId=&quot;0&quot;&gt;
&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;1&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:ses-com:device:SatIPServer:1&lt;/deviceType&gt;
&lt;friendlyName&gt;SATIPBOX&lt;/friendlyName&gt;
&lt;manufacturer&gt;Manufacturer&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;http://www.manufacturer.com&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;SATIPBOX 500 4.0&lt;/modelDescription&gt;
&lt;modelName&gt;SATIPBOX&lt;/modelName&gt;
&lt;modelNumber&gt;1.0&lt;/modelNumber&gt;
&lt;modelURL&gt;http://www.manufacturer.com/satipbox&lt;/modelURL&gt;
&lt;serialNumber&gt;1S81A31231000007&lt;/serialNumber&gt;
&lt;UDN&gt;uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c&lt;/UDN&gt;
&lt;iconList&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;48&lt;/width&gt;
&lt;height&gt;48&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/sm.png&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;120&lt;/width&gt;
&lt;height&gt;120&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/lr.png&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/jpeg&lt;/mimetype&gt;
&lt;width&gt;48&lt;/width&gt;
&lt;height&gt;48&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/sm.jpg&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/jpeg&lt;/mimetype&gt;
&lt;width&gt;120&lt;/width&gt;
&lt;height&gt;120&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/lr.jpg&lt;/url&gt;
&lt;/icon&gt;
&lt;/iconList&gt;
&lt;presentationURL&gt;/index.htm&lt;/presentationURL&gt;
&lt;satip:X_SATIPCAP xmlns:satip=&quot;urn:ses-com:satip&quot;&gt;DVBS2-8,DVBT-4&lt;/satip:X_SATIPCAP&gt;
&lt;satip:X_SATIPM3U xmlns:satip=&quot;urn:ses-com:satip&quot;&gt;/channellist.m3u&lt;/satip:X_SATIPM3U&gt;
&lt;/device&gt;
&lt;/root&gt;</code></pre>
<h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p><code>control</code> 使用协议 <code>RTSP</code> 或 <code>HTTP</code></p>
<ul>
<li>RTP(Real Time Transport Protocol)</li>
<li>RTCP(Real Time Contorl Protocol)</li>
<li>RTSP（Real Time Streaming Protocol）</li>
</ul>
<h4 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h4><p>HTTP 与 RTSP 相比，HTTP 请求由客户机发出，服务器作出响应；使用 RTSP 时，客户机和服务器都可以发出请求，即 RTSP 可以是双向的。</p>
<p>RTSP 是一个基于文本的协议，它与 HTTP 十分相似。在 RTSP 中，保留了几乎所有的 HTTP 符号以及相关定义。所以，RTSP 十分利于扩展，并且容易使用程序进行解析。</p>
<p>RTSP 虽然可以用来获取实时流，但是协议中并没有定义传输实时流的方式。它通过与其它的传输机制配合，例如 RTP，进行实时流传输。在 RTSP 中，我们可以在 SETUP 方法中设置一些参数，以选择是用 TCP 还是用 UDP 作为 RTP 的底层传输协议。</p>
<p>RTSP 通过以会话 (Session) 的方式描述一个连接的生命周期。会话 (Session) 通过 RTSP 客户端使用 RTSP 的 SETUP 方法建立，然后 RTSP 客户端可以通过 PLAY、PAUSE、RECORD 等方法 (Method) 来控制实时流的播放、暂停以及回放等。当不再需要实时流的时候，RTSP 客户端通过 TEARDOWN 方法 (Method) 来结束这个会话 (Session)。</p>
<ol>
<li><a href="https://www.jianshu.com/p/4e3925f98e84" target="_blank" rel="noopener">RTSP 协议</a></li>
<li><a href="https://blog.csdn.net/shining100/article/details/6030818" target="_blank" rel="noopener">RTSP 简介以及常用方法使用实例</a></li>
</ol>
<p><code>SAT&gt;IP Clients</code> 使用 <code>RTSP TCP</code> 与 <code>SAT&gt;IP Servers</code> 建立 <code>RTSP sessions</code> （RTSP 会话），以 <code>RTSP SETUP</code> 起始，以 <code>RTSP TEARDOWN</code> 结束， <code>session number</code> 由 <code>server</code> 分配唯一标识</p>
<p><code>SAT&gt;IP</code> 使用标准 <code>RTSP</code> 端口号 <code>554</code></p>
<p><code>RTSP</code> 与 <code>TCP</code> 关系</p>
<p>RTSP 会话通常跨越多个 TCP 连接（例如，每个 TCP 连接一个请求 - 响应）。但是，RTSP 会话也可以由单个 TCP 连接组成（持久模式）包括几个 RTSP 请求 - 响应对。</p>
<p>如图所示：</p>
<p>以下两种情况需要关闭 <code>TCP connection</code></p>
<ol>
<li>通过连接管理的所有 <code>RTSP</code> 会话都已超时</li>
<li>响应上一次 RTSP 会话的会话级 TEARDOWN 请求后 10 秒</li>
</ol>
<h4 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h4><p><code>SAT&gt;IP</code> 发送 <code>RTSP SETUP</code> 请求来建立新的会话，包括如下内容</p>
<ul>
<li><code>RTSP URI</code> 查询字符串 <code>TS 流参数</code>，位于第一行</li>
<li><code>RTSP SETUP</code> 头中携带 <code>TS</code> 传输参数（unicast/multicast, ports, etc.）</li>
</ul>
<p>如果会话建立成功，返回 <code>200 OK</code> 消息，内容如下</p>
<ul>
<li><code>RTSP session number</code></li>
<li>实际的 <code>TS</code> 传输参数，例如 <code>IP</code> 目标地址和端口</li>
<li>唯一标识 <code>TS</code> 媒体流的 <code>streamID</code></li>
</ul>
<p>服务器和客户端之间的每个 RTSP 会话由随机生成的会话号 <code>session number</code> 标识。</p>
<p><code>streamID</code> 唯一标识 <code>TS 媒体流对象</code>，客户端使用 <code>streamID</code> 来引用在 <code>SETUP</code> 设置的 <code>TS 流</code></p>
<p>新建会话并定义媒体流参数的客户端是这个流的所有者</p>
<blockquote>
<p>The client which sets up the session and defines the parameters of the media stream is the owner of the stream.</p>
</blockquote>
<p>Unicast Transport Delivery Example:</p>
<pre><code>Request  SETUP rtsp://192.168.128.5/?src=1&amp;fe=1&amp;freq=12402&amp;pol=v&amp;msys=dvbs&amp;sr=27500&amp;fec=34&amp;pids=0,16,
         50,104,166,1707 RTSP/1.0
         CSeq: 1
         Transport: RTP/AVP;unicast;client_port=1400-1401
         &lt;CRLF&gt;

Response RTSP/1.0 200 OK
         CSeq: 1
         Session: 12345678;timeout=60
         Transport: RTP/AVP;unicast;client_port=1400-1401
         com.ses.streamID: 1
         &lt;CRLF&gt;</code></pre><ul>
<li><code>Cseq</code> 每个 <code>request</code> - <code>response</code> 必须一致</li>
<li><code>Session</code> 包括 <code>session id</code> 和 <code>time out</code></li>
<li><code>com.ses.streamID</code> 为 <code>streamID</code></li>
<li><code>Transport</code> 指示使用的传输协议及参数</li>
</ul>
<pre><code>RTP/AVP;unicast;client_port=&lt;client RTP port&gt;-&lt;client RTCP port&gt;
RTP/AVP;multicast;destination=&lt;IP multicast address&gt;;port=&lt;RTP port&gt;-&lt;RTCP port&gt;;ttl=&lt;ttl&gt;
RTP/AVP;multicast
RTP/AVP;multicast;ttl=&lt;ttl&gt;
RTP/AVP;multicast;port=&lt;RTP port&gt;-&lt;RTCP port&gt;
RTP/AVP;multicast;port=&lt;RTP port&gt;-&lt;RTCP port&gt;;ttl=&lt;ttl&gt;
RTP/AVP;multicast;destination=&lt;IP multicast address&gt;
RTP/AVP;multicast;destination=&lt;IP multicast address&gt;;ttl=&lt;ttl&gt;
RTP/AVP;multicast;destination=&lt;IP multicast address&gt;;port=&lt;RTP port&gt;-&lt;RTCP port&gt;
RTP/AVP;multicast;destination=&lt;IP multicast address&gt;;port=&lt;RTP port&gt;-&lt;RTCP port&gt;;ttl=&lt;ttl&gt;</code></pre><ul>
<li><code>RTP/AVP</code>，表示流传输格式。在 <code>SAT&gt;IP</code> 中仅支持 <code>RTP/AVP</code></li>
<li><code>unicast | multicast</code>，单播 / 多播</li>
<li><code>destination</code>，多播下的选项，指示 <code>TS</code> 发送目标地址</li>
<li><code>client_port</code>，单播选项，指示 <code>RTP/RTCP</code> 端口</li>
<li><code>port</code>，多播选项，指示 <code>RTP/RTCP</code> 端口</li>
<li><code>ttl</code>，多播选项，指示 <code>time-to-live</code></li>
</ul>
<p>注意事项：</p>
<ol>
<li><code>RTP</code> 端口为偶数，而 <code>RTCP</code> 为 <code>+1</code> 的奇数</li>
<li>单播和多播端口不一样</li>
</ol>
<pre><code>For unicast:
client_port= &lt;client RTP port&gt; - &lt;client RTCP port&gt;
server_port= &lt;server RTP port&gt; - &lt;server RTCP port&gt;

For multicast:
port= &lt;RTP port&gt; - &lt;RTCP port&gt;</code></pre><p><strong>Joining an existing stream without becoming stream owner??</strong></p>
<pre><code>SETUP rtsp://192.168.178.57:554/?src=1&amp;fe=1&amp;freq=10744&amp;pol=h&amp;ro=0.35&amp;msys=dvbs&amp;mtype=qpsk&amp;plts=off&amp;sr=22000&amp;fec=56&amp;pids=0,400,401,402 RTSP/1.0
CSeq:1
Transport: RTP/AVP;multicast
Connection:close

RTSP/1.0 200 OK
Session:21dbf7c5873c9ff;timeout=30
com.ses.streamID:8
Transport:RTP/AVP;multicast;destination=239.0.0.3;port=1500-1501;ttl=2
CSeq:1</code></pre><pre><code>SETUP rtsp://192.168.178.57:554/?src=1&amp;fe=1&amp;freq=10744&amp;pol=h&amp;ro=0.35&amp;msys=dvbs&amp;mtype=qpsk&amp;plts=off&amp;sr=22000&amp;fec=56&amp;pids=0,400,401,402 RTSP/1.0
CSeq:1
Transport: RTP/AVP;multicast
Connection:close

RTSP/1.0 200 OK
Session:222626d35aa05f4;timeout=30
com.ses.streamID:17
Transport:RTP/AVP;multicast;destination=239.0.0.8;port=1500-1501;ttl=2
CSeq:1</code></pre><p><strong>Example RTSP SETUP messages</strong></p>
<h4 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h4><ul>
<li>单播，使用 <code>streamID</code> 发送 <code>RTSP PLAY</code></li>
<li>多播，两个选择，其一与单播相同；另外一个是向组播组 <code>multicast group</code> 发送 <code>IGMPv3 membership report</code></li>
</ul>
<p>发送 <code>PLAY</code> 消息后开始传输 <code>RTP/RTCP</code> 数据</p>
<ul>
<li>如果前端设置正确，TS 流正确传输</li>
<li>如果前端不正确，丢失信号或者 PID 设置不正确，每 100ms 发送一个 RTP 空包</li>
</ul>
<p><code>PLAY</code> 消息常用来切换节目</p>
<p><code>SAT&gt;IP server</code> 输出取决于服务器状态和多媒体流拥有者状态</p>
<blockquote>
<p>The SAT&gt;IP server output depends on the server state (resulting from the sequence of RTSP and/or IGMP methods invoked by a client) and the state of the media stream owner.</p>
</blockquote>
<p><strong>Server Stream Output State Machine</strong></p>
<h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><p><code>RTSP</code> 会话建立之后需要发送 <code>OPTIONS</code> 来维持会话，服务器也需要依靠 <code>OPTIONS</code> 来确认那些 <code>clients</code> 存在</p>
<p><strong>Examples</strong></p>
<pre><code>Request&gt;
OPTIONS rtsp://192.168.178.57:554/ RTSP/1.0
CSeq:5
Session:2180f601c42957d
Connection:close

Response&gt;
RTSP/1.0 200 OK
Public:OPTIONS,SETUP,PLAY,TEARDOWN,DESCRIBE
CSeq:5
Session:2180f601c42957d</code></pre><h4 id="修改媒体流"><a href="#修改媒体流" class="headerlink" title="修改媒体流"></a>修改媒体流</h4><p><code>TS</code> 流只能由它的拥有者修改，通常调用 <code>RTSP PLAY</code> 来修改。</p>
<p>某些情况下需要修改 <code>Transport</code> 参数，这时需要使用 <code>in-session SETUP</code></p>
<pre><code>Request&gt;
PLAY rtsp://192.168.178.57:554/stream=5?src=1&amp;fe=1&amp;freq=12603&amp;pol=h&amp;ro=0.35&amp;msys=dvbs&amp;mtype=qpsk&amp;plts=off&amp;sr=22000
&amp;fec=56&amp;pids=0,1290,2290,6290,7290 RTSP/1.0
CSeq:8
Session:21a15c02c1ee244
Connection:close

Response&gt;
RTSP/1.0 200 OK
RTP-Info:url=rtsp://192.168.178.57/stream=5;seq=22857
CSeq:8
Session:21a15c02c1ee244</code></pre><h4 id="加入一个存在的流"><a href="#加入一个存在的流" class="headerlink" title="加入一个存在的流"></a>加入一个存在的流</h4><p><code>clients</code> 可以加入一个其他 <code>client</code> 拥有的 ts 流</p>
<ul>
<li>使用指定 <code>streamID</code> 调用 <code>SETUP</code> 和 <code>PLAY</code> 来建立新会话</li>
<li>发送 <code>IGMPv3 membership report</code></li>
</ul>
<p>使用多播 / 单播取决于 <code>owner</code> 初始化选择的 <code>transport</code> 类型</p>
<pre><code>Request&gt;
SETUP rtsp://192.168.128.192:554/stream=27 RTSP/1.0
CSeq:1
Transport: RTP/AVP;unicast;client_port=42494-42495
Connection:close

Response&gt;
RTSP/1.0 200 OK
Session:43ae7c353e77bc;timeout=60
com.ses.streamID:27
Transport:RTP/AVP;unicast;destination=192.168.128.100;client_port=42494-42495
CSeq:1</code></pre><h4 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h4><p><code>RTSP DESCRIBE</code> 为了获取 <code>SDP</code> (Session Description Protocol)</p>
<p>会话描述信息，提供 <code>server</code> 上多媒体描述，必须有至少一个 <code>session</code> 已经建立，否则返回 <code>404</code> 错误</p>
<pre><code>Request&gt;
DESCRIBE rtsp://192.168.128.5/
CSeq: 5
Accept: application/sdp
&lt;CRLF&gt;

Response&gt;
RTSP/1.0 200 OK
CSeq: 5
Content-Type: application/sdp
Content-Base: rtsp://192.168.128.5/
Content-Length: 724
&lt;CRLF&gt;
v=0
o=- 5678901234 7890123456 IN IP4 192.168.128.5
s=SatIPServer:1 4
t=0 0
m=video 5004 RTP/AVP 33
c=IN IP4 239.0.0.8/5
a=control:stream=0
a=fmtp:33 ver=1.0;src=1;tuner=1,240,1,7,12402,v,dvbs,,,,27500,34;pids=0,16,56,112,168,1709
a=inactive
m=video 5006 RTP/AVP 33
c=IN IP4 239.0.0.9/5
a=control:stream=1
a=fmtp:33 ver=1.0;src=1;tuner=1,240,1,7,12402,v,dvbs,,,,27500,34;pids=0,16,50,104,166,1707
a=sendonly
m=video 0 RTP/AVP 33
c=IN IP4 0.0.0.0
a=control:stream=2
a=fmtp:33 ver=1.0;src=1;tuner=1,240,1,7,12402,v,dvbs,,,,27500,34;pids=all
a=sendonly
m=video 5010 RTP/AVP 33
c=IN IP4 239.0.0.11/5
a=control:stream=3
a=fmtp:33 ver=1.0;src=2;tuner=2,221,1,6,11758,h,dvbs2,8psk,off,25,27500,56;pids=all
a=sendonly</code></pre><ul>
<li>v = （协议版本）</li>
<li>o = （所有者 / 创建者和会话标识符）<session-id> <session-version> IN for internet and the IP address of the server.</li>
<li>s = （会话名称）SatIPServer:1 <frontends></li>
<li>i = * （会话信息）</li>
<li>u = * （URI 描述）</li>
<li>e = * （Email 地址）</li>
<li>p = * （电话号码）</li>
<li>c = * （连接信息）多播地址 /TTL 单播设置为 0.0.0.0</li>
<li>b = * （带宽信息）</li>
<li>z = * （时间区域调整）</li>
<li>k = * （加密密钥）</li>
<li>a = * （0 个或多个会话属性行）control:stream=<streamID></li>
<li>t = （会话活动时间）</li>
<li>r = * （0 或多次重复次数）</li>
<li>m = （媒体名称和传输地址）the media type, port, protocol 33: SAT&gt;IP 类型</li>
<li>i = * （媒体标题）</li>
<li>c = * （连接信息 — 如果包含在会话层则该字段可选）</li>
<li>b = * （带宽信息）</li>
<li>k = * （加密密钥）</li>
<li>a = * （0 个或多个媒体属性行）</li>
</ul>
<pre><code>Session Level:
s=SatIPServer:1 &lt;frontends&gt;

Media level:
a=control:stream=&lt;streamID&gt;
a=fmtp:33 ver=&lt;major&gt;.&lt;minor&gt;;src=&lt;srcID&gt;;tuner=&lt;feID&gt;,&lt;level&gt;,&lt;lock&gt;,&lt;quality&gt;,&lt;frequency&gt;,&lt;pol
arisation&gt;,&lt;system&gt;,&lt;type&gt;,&lt;pilots&gt;,&lt;roll_off&gt;,&lt;symbol_rate&gt;,&lt;fec_inner&gt;;pids=&lt;pid0&gt;,...,&lt;pidn&gt;</code></pre><h4 id="TEARDOWN"><a href="#TEARDOWN" class="headerlink" title="TEARDOWN"></a>TEARDOWN</h4><p>关闭会话</p>
<pre><code>Request&gt;
TEARDOWN rtsp://192.168.178.57:554/stream=2 RTSP/1.0
CSeq:5
Session:2166e663b4be550
Connection: close

Response&gt;
RTSP/1.0 200 OK
Content-Length:0
CSeq:5
Session:2166e663b4be550</code></pre><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><pre><code></code></pre><p><code>RTSP 状态机</code></p>
<h4 id="Uniform-Resource-Identifier-URI"><a href="#Uniform-Resource-Identifier-URI" class="headerlink" title="Uniform Resource Identifier URI"></a>Uniform Resource Identifier URI</h4><h4 id="信号选择"><a href="#信号选择" class="headerlink" title="信号选择"></a>信号选择</h4><h4 id="RTSP-序列图"><a href="#RTSP-序列图" class="headerlink" title="RTSP 序列图"></a>RTSP 序列图</h4><h4 id="RTCP-Announcements"><a href="#RTCP-Announcements" class="headerlink" title="RTCP Announcements"></a>RTCP Announcements</h4><p><code>RTP</code> 传送的多媒体流都伴随着 <code>RTCP</code> 通知流，携带关于该特定 TS 媒体流的 SAT&gt;IP 配置的信息以及实时信息。</p>
<p>实时信息包括以下信息，更新速度 5/s。当信号不可用是需要发送空包</p>
<ul>
<li>信号锁定</li>
<li>信号强度</li>
<li>信号质量</li>
</ul>
<p>负载格式如下</p>
<pre><code>ver=&lt;major&gt;.&lt;minor&gt;;src=&lt;srcID&gt;;tuner=&lt;feID&gt;,&lt;level&gt;,&lt;lock&gt;,&lt;quality&gt;,&lt;frequency&gt;,&lt;polarisation&gt;,
&lt;system&gt;,&lt;type&gt;,&lt;pilots&gt;,&lt;roll_off&gt;,&lt;symbol_rate&gt;,&lt;fec_inner&gt;;pids=&lt;pid0&gt;,...,&lt;pidn&gt;

ver=1.0;src=1;tuner=1,240,1,7,12402,v,dvbs,,,,27500,34;pids=0,16,56,112,168,1709</code></pre><h3 id="Media-Transport"><a href="#Media-Transport" class="headerlink" title="Media Transport"></a>Media Transport</h3><h4 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h4><p><code>RTP</code> 一个包可以封装 7 个 <code>TS</code> 包</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h3 id="Dynamic-vs-Static-Server-Operation"><a href="#Dynamic-vs-Static-Server-Operation" class="headerlink" title="Dynamic vs Static Server Operation"></a>Dynamic vs Static Server Operation</h3><h4 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h4><h4 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h4><h3 id="Client-指南"><a href="#Client-指南" class="headerlink" title="Client 指南"></a>Client 指南</h3><p>包括 <code>RTSP Client</code> 和 <code>IGMP Client</code></p>
<h4 id="Client-Setup-and-Configuration-Settings"><a href="#Client-Setup-and-Configuration-Settings" class="headerlink" title="Client Setup and Configuration Settings"></a>Client Setup and Configuration Settings</h4><ol>
<li><code>SAT&gt;IP clients</code> 自动检测 <code>SAT&gt;IP servers</code><ol>
<li>监听 <code>SSDP NOTIFY</code></li>
<li>发送 <code>SSDP M-SEARCH</code></li>
</ol>
</li>
<li>自动绑定 <code>SAT&gt;IP servers</code></li>
<li>手动绑定到指定 <code>SAT&gt;IP servers</code></li>
<li>手动配置 <code>SAT&gt;IP servers</code> 地址</li>
<li>指定前端</li>
<li>配置天线</li>
</ol>
<h4 id="Service-Discovery"><a href="#Service-Discovery" class="headerlink" title="Service Discovery"></a>Service Discovery</h4><p><code>SAT&gt;IP</code> 规范不要求特定的服务发现机制，有两种</p>
<ol>
<li>Standard DVB Service Discovery，解析标准 DVB PSI/SI 表，解析慢，建议预置 service list</li>
<li>Discovery based on Service Lists</li>
</ol>
<p>第二种方式称为 <code>thin clients</code>，离线或在线服务器获取某一颗或几颗卫星的 services</p>
<p>客户端中应该添加选项以指定 <code>m3u list</code> 位置</p>
<pre><code>http://sat-ip_server/channel_file.m3u</code></pre><h4 id="切换节目"><a href="#切换节目" class="headerlink" title="切换节目"></a>切换节目</h4><p><code>channel list</code> 获取参照 <code>vlc</code> 代码 <code>upnp.cpp:int MediaServerList::Callback( Upnp_EventType event_type, UpnpEventPtr p_event )</code></p>
<p><strong>M3U playlist format (Unicast Streams)</strong></p>
<pre><code>#EXTM3U
#EXTINF:0,13. BBC World
rtsp://192.168.1.202/?src=1&amp;freq=11597&amp;pol=v&amp;msys=dvbs&amp;mtype=qpsk&amp;sr=22000&amp;fec=56&amp;pids=0,16,17,92,163,1858
#EXTINF:0,14. Sky News
rtsp://192.168.1.202/?src=1&amp;freq=12604&amp;pol=h&amp;msys=dvbs&amp;mtype=qpsk&amp;sr=22000&amp;fec=56&amp;pids=0,1290,2290,7290,6290,5290
#EXTINF:0,15. France24
rtsp://192.168.1.202/stream=18</code></pre><p><strong>M3U playlist format (Multicast Streams)</strong></p>
<pre><code>#EXTM3U
#EXTINF:0,1. TF1
rtp://232.0.1.17:8200
#EXTINF:0,2. France 2
rtp://232.0.1.1:8200
#EXTINF:0,3. France 3
rtp://232.0.1.2:8200</code></pre><h3 id="STB-作为-simpler-SAT-gt-IP-Servers"><a href="#STB-作为-simpler-SAT-gt-IP-Servers" class="headerlink" title="STB 作为 simpler SAT&gt;IP Servers"></a>STB 作为 simpler SAT&gt;IP Servers</h3><p>省略 <code>IGMP</code>、 <code>HTTP</code> 等</p>
]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>upnp</tag>
        <tag>sat2ip</tag>
        <tag>ssdp</tag>
        <tag>rtsp</tag>
      </tags>
  </entry>
  <entry>
    <title>SAT&gt;IP 协议简介</title>
    <url>/2019/02/26/sat2ip-protocol/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>SAT&gt;IP</code>规范是一份通信协议，不是设备规范。<code>在 SAT&gt;IP</code>规范下存在两种角色：</p>
<ul>
<li><code>SAT&gt;IP Server</code></li>
<li><code>SAT&gt;IP Client</code></li>
</ul>
<p>一个具体的设备可以是其中一个角色，或者两者兼具。</p>
<p><img src="/images/sat2ip/20190226-093309.png" alt=""></p>
<a id="more"></a>

<p><code>SAT&gt;IP</code>协议提供了一种标准化的方式，使客户端可以通过网络来访问<code>sat</code>上的实时流。<code>SAT&gt;IP</code>协议实现了卫星接收端与播放端分离，卫星接收端被放在远端服务器上，<code>SAT&gt;IP</code>协议提供控制协议，<code>Clients</code>可以远程控制，从而扩展了卫星接收端的范围。</p>
<p><code>SAT&gt;IP</code>是一种客户端驱动的架构。<br>客户端向服务器发送请求。服务器执行这些请求和向客户转发直播电视节目。</p>
<h3 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h3><p><img src="/images/sat2ip/20190226-093424.png" alt=""></p>
<h3 id="clients"><a href="#clients" class="headerlink" title="clients"></a>clients</h3><p><code>SAT&gt;IP Clients</code> 通过发送请求完成获取 channel list 和播放指定节目功能，类型：</p>
<ul>
<li>具有网络连接能力的 STB</li>
<li>NAS</li>
<li>Smartphones</li>
<li>PCs</li>
</ul>
<h3 id="servers"><a href="#servers" class="headerlink" title="servers"></a>servers</h3><p><code>SAT&gt;IP Servers</code> 处理<code>SAT&gt;IP Clients</code>的请求并将电视直播节目转发给<code>Clients</code>，类型如下：</p>
<ul>
<li>IP Adapters / Multiswitches</li>
<li>Master STBs</li>
<li>IP LNBs</li>
<li>MDU(Multi Dwelling Unit) 多用户居住单元</li>
</ul>
<p>我们要关心的是<code>Master STBs</code>，<strong>不需要多播</strong>，具体技术需求表如下：<br><img src="/images/sat2ip/20190226-093038.png" alt=""></p>
<p><code>Master Stb</code>网络拓扑结构如下：<br><img src="/images/sat2ip/20190226-093545.png" alt=""></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><code>SAT&gt;IP</code>是在已有协议基础上的扩展，主要依赖于以下协议</p>
<ul>
<li>UPnP for Addressing, Discovery and Description</li>
<li>RTSP or HTTP for Control</li>
<li>RTP or HTTP for Media Transport</li>
</ul>
<p>协议栈组织形式：<br><img src="/images/sat2ip/20190226-093728.png" alt=""></p>
<p>与<code>DLNA</code>关系：<br><img src="/images/sat2ip/20190226-093749.png" alt=""></p>
<p>使用了<code>UPnP/DLNA</code>架构的子集和协议</p>
<ul>
<li>UPnP Device Architecture 1.1</li>
<li>DLNA Networked Device Interoperability Guidelines</li>
</ul>
<p><code>SAT&gt;IP</code>设备可以扩展为 <code>DLNA</code>设备，另外客户端可以通用，例如<code>VLC</code>均通过<code>UPnP</code>来访问</p>
<p>协议分为以下阶段：</p>
<ul>
<li>寻址</li>
<li>设备发现</li>
<li>设备描述</li>
<li>控制</li>
<li>流传输</li>
</ul>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><ul>
<li>DHCP</li>
<li>Auto-IP</li>
</ul>
<p><code>STB</code>已支持<code>DHCP</code>，这部分不讨论</p>
<h3 id="设备发现"><a href="#设备发现" class="headerlink" title="设备发现"></a>设备发现</h3><p>使用<code>SSDP(Simple Service Discover Protocol)</code>简单服务发现协议，这个协议是 <code>UPnP</code> 的核心，在 <code>UPnP</code> 中定义了一组协议框架，其中有控制点，根设备等概念，<code>UPnP</code> 设备通过 <code>SSDP</code> 协议与根设备（用户设备）进行交互。<code>SSDP</code> 是应用层协议，使用 <code>HTTPU</code> 和 <code>HTTPMU</code> 规范，基于 <code>UDP</code> 端口进行通信。</p>
<p>每个设备会有一个特定的设备类型，<code>SAT&gt;IP</code>为<code>urn:ses-com:device:SatIPServer:1</code></p>
<p><code>UUID</code>格式为<code>4B-2B-2B-2B-6B</code>，示例<code>2fac1234-31f8-11b4-a222-08002b34c003</code></p>
<p>通过以下两种方式进行设备发现：</p>
<ul>
<li>Server 发送通知给其他的 Servers 和 Clients</li>
<li>Clients 搜索可用的 Servers</li>
</ul>
<h4 id="server-通告"><a href="#server-通告" class="headerlink" title="server 通告"></a>server 通告</h4><p><code>SAT&gt;IP Server</code>入网之后，会向<strong>多播地址 239.255.255.250:1900 发送三次不同</strong>的<code>NOTIFY ssdp:alive</code>消息，<code>SAT&gt;IP Server</code>离网时需要发送<code>NOTIFY ssdp:byebye</code>，消息格式如下：</p>
<p><img src="/images/sat2ip/20190226-100703.png" alt=""></p>
<p><code>NT</code>三种：</p>
<ol>
<li>the root device</li>
<li>its device uuid</li>
<li>the urn</li>
</ol>
<p>还需要注意<code>LOCATION</code>、<code>DEVICEID.SES.COM</code>，前者是描述文件路径，后者是<code>DeviceID</code>，具体作用后续章节介绍</p>
<p><strong>Example Announcement of a SAT&gt;IP server joining the network:</strong></p>
<pre><code>NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://192.168.178.21/desc.xml
NT: upnp:rootdevice
NTS: ssdp:alive
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c::upnp:rootdevice
BOOTID.UPNP.ORG: 2318
CONFIGID.UPNP.ORG: 0
DEVICEID.SES.COM: 1

NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://192.168.178.21/desc.xml
NT: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c
NTS: ssdp:alive
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c
BOOTID.UPNP.ORG: 2318
CONFIGID.UPNP.ORG: 0
DEVICEID.SES.COM: 1

NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://192.168.178.21/desc.xml
NT: urn:ses-com:device:SatIPServer:1
NTS: ssdp:alive
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c::urn:ses-com:device:SatIPServer:1
BOOTID.UPNP.ORG: 2318
CONFIGID.UPNP.ORG: 0
DEVICEID.SES.COM: 1</code></pre><h4 id="DEVICE-ID-协商"><a href="#DEVICE-ID-协商" class="headerlink" title="DEVICE ID 协商"></a>DEVICE ID 协商</h4><p><code>DEVICE ID</code>是<code>SAT&gt;IP Server</code>入网时声明的唯一不冲突的<code>ID</code>，这个值存储于非易失区域。协商流程如下：</p>
<ol>
<li>设备冷启动之后，从<code>non-volatile memory</code>读出<code>DEVICE ID</code>值，然后作为<code>announcement NOTIFY messages ssdp:alive</code>参数多播发送</li>
<li>其他在网的<code>servers</code>会监听这些公告，如果<code>DEVICE ID</code>不存在冲突，不做任何反应；如果存在冲突，需要在<code>1s</code>以内，发送单播<code>M-SEARCH message ssdp:disvocer</code>到冲突的<code>server</code></li>
<li>入网<code>server</code>发送 <code>200 ok</code>来确认，注意<code>EXT</code>字段</li>
<li>入网<code>server</code>发送<code>ssdp:byebye</code>，可选项</li>
<li>入网<code>server</code>生成新的<code>DEVICE ID</code>，一般是<code>+1</code>，然后发送<code>announcement NOTIFY messages ssdp:alive</code></li>
<li><code>5s</code>超时时间内未收到<code>ssdp:discover</code>表示没有冲突，使用新的<code>DEVICE ID</code>作为新的并存储</li>
</ol>
<p>流程图：<br><img src="/images/sat2ip/20190226-105236.png" alt=""></p>
<h4 id="Client-Search-Requests"><a href="#Client-Search-Requests" class="headerlink" title="Client Search Requests"></a>Client Search Requests</h4><p><code>client</code>多播<code>M-SEARCH ssdp:discover</code>来发现在网<code>servers</code>，由于<code>udp</code>的不可靠性，建议发送三次，间隔<code>100ms</code>，格式如下：</p>
<p><img src="/images/sat2ip/20190226-105453.png" alt=""></p>
<pre><code>Requests&gt;
M-SEARCH * HTTP/1.1
HOST: 239.255.255.250:1900
ST: urn:ses-com:device:SatIPServer:1
MAN: &quot;ssdp:discover&quot;
MX: 2

respond&gt;
HTTP/1.1 200 OK
CACHE-CONTROL: max-age=1800
DATE: Sat Jan 1 00:01:50 2000
EXT:
LOCATION: http://192.168.178.21/desc.xml
SERVER: Linux/1.0 UPnP/1.1 IDL4K/1.0
ST: urn:ses-com:device:SatIPServer:1
USN: uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c::urn:ses-com:device:SatIPServer:1
BOOTID.UPNP.ORG: 2399
CONFIGID.UPNP.ORG: 0</code></pre><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>通过<code>xml</code>文件向网络上其他<code>UPnP Control Points</code>提供更多信息，这个文件的路径是在<code>Discovery</code>阶段获取的<code>LOCATION</code>字段，示例如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; configId=&quot;0&quot;&gt;
&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;1&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:ses-com:device:SatIPServer:1&lt;/deviceType&gt;
&lt;friendlyName&gt;SATIPBOX&lt;/friendlyName&gt;
&lt;manufacturer&gt;Manufacturer&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;http://www.manufacturer.com&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;SATIPBOX 500 4.0&lt;/modelDescription&gt;
&lt;modelName&gt;SATIPBOX&lt;/modelName&gt;
&lt;modelNumber&gt;1.0&lt;/modelNumber&gt;
&lt;modelURL&gt;http://www.manufacturer.com/satipbox&lt;/modelURL&gt;
&lt;serialNumber&gt;1S81A31231000007&lt;/serialNumber&gt;
&lt;UDN&gt;uuid:50c958a8-e839-4b96-b7ae-8f9d989e136c&lt;/UDN&gt;
&lt;iconList&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;48&lt;/width&gt;
&lt;height&gt;48&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/sm.png&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/png&lt;/mimetype&gt;
&lt;width&gt;120&lt;/width&gt;
&lt;height&gt;120&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/lr.png&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/jpeg&lt;/mimetype&gt;
&lt;width&gt;48&lt;/width&gt;
&lt;height&gt;48&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/sm.jpg&lt;/url&gt;
&lt;/icon&gt;
&lt;icon&gt;
&lt;mimetype&gt;image/jpeg&lt;/mimetype&gt;
&lt;width&gt;120&lt;/width&gt;
&lt;height&gt;120&lt;/height&gt;
&lt;depth&gt;24&lt;/depth&gt;
&lt;url&gt;/icons/lr.jpg&lt;/url&gt;
&lt;/icon&gt;
&lt;/iconList&gt;
&lt;presentationURL&gt;/index.htm&lt;/presentationURL&gt;
&lt;satip:X_SATIPCAP xmlns:satip=&quot;urn:ses-com:satip&quot;&gt;DVBS2-8,DVBT-4&lt;/satip:X_SATIPCAP&gt;
&lt;satip:X_SATIPM3U xmlns:satip=&quot;urn:ses-com:satip&quot;&gt;/channellist.m3u&lt;/satip:X_SATIPM3U&gt;
&lt;/device&gt;
&lt;/root&gt;</code></pre>
<p>关注点：</p>
<ol>
<li><code>config=</code>必须与<code>discovery</code>阶段的<code>CONFIGID.UPNP.ORG</code>相同</li>
<li>提供两张 JPEG 和两张 PNG 图标，小的尺寸为<code>48×48</code>，大的为<code>120×120</code></li>
<li><code>&lt;satip:X_SATIPCAP&gt;</code>用来描述支持的前端类型及数量，放在<code>&lt;device&gt;</code>元素的尾部</li>
<li><code>SA&gt;IP server</code>提供<code>channel list</code></li>
</ol>
<h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>涉及如下协议</p>
<ul>
<li><code>RTSP</code></li>
<li><code>RTCP</code></li>
<li><code>RTP</code></li>
<li><code>HTTP</code></li>
<li><code>IGMP</code></li>
</ul>
<p><code>HTTP</code>和<code>IGMP</code>暂不考虑</p>
<h4 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h4><p><code>SAT&gt;IP Servers</code>和<code>SAT&gt;IP Clients</code>应该支持如下<code>RTSP</code>方法：</p>
<p><img src="/images/sat2ip/20190226-111505.png" alt=""></p>
<p><code>RTSP</code>状态机如下：</p>
<p><img src="/images/sat2ip/20190226-111538.png" alt=""></p>
<h4 id="Uniform-Resource-Identifier-URI"><a href="#Uniform-Resource-Identifier-URI" class="headerlink" title="Uniform Resource Identifier URI"></a>Uniform Resource Identifier URI</h4><p><img src="/images/sat2ip/20190226-132143.png" alt=""></p>
<h4 id="Query-Syntax"><a href="#Query-Syntax" class="headerlink" title="Query Syntax"></a>Query Syntax</h4><p>格式<code>&lt;attribute1&gt;=&lt;value1&gt;&amp;&lt;attribute2&gt;=&lt;value2&gt;&amp;&lt;attribute3&gt;=&lt;value3&gt;...</code></p>
<p><img src="/images/sat2ip/20190226-132248.png" alt=""></p>
<p><strong>Example</strong></p>
<pre><code>rtsp://192.168.128.1/?src=1&amp;freq=12402&amp;pol=v&amp;ro=0.35&amp;msys=dvbs&amp;mtype=qpsk&amp;plts=off&amp;sr=27500&amp;fec=34&amp;pids=0,16,50,104,166,1707
rtsp://192.168.128.1/stream=0?freq=12402&amp;pol=v&amp;ro=0.35&amp;msys=dvbs&amp;mtype=qpsk&amp;plts=off&amp;sr=27500&amp;fec=34&amp;pids=0,16,50,104,166,1707
rtsp://192.168.128.1/stream=1?addpids=17,51&amp;delpids=166,1707
rtsp://192.168.128.5/?src=1&amp;fe=1&amp;freq=12720&amp;pol=v&amp;msys=dvbs2&amp;mtype=8psk&amp;ro=0.35&amp;plts=on&amp;sr=30000&amp;fec=910&amp;pids=0,16,50,104,166,1707</code></pre><h4 id="Example-RTSP-Sequence-Diagram"><a href="#Example-RTSP-Sequence-Diagram" class="headerlink" title="Example RTSP Sequence Diagram"></a>Example RTSP Sequence Diagram</h4><p>TODO:</p>
<h4 id="RTCP-Announcements"><a href="#RTCP-Announcements" class="headerlink" title="RTCP Announcements"></a>RTCP Announcements</h4><p>当以<code>RTP</code>传输实时流时会伴随发送<code>RTCP</code>通知流，包含了关于流的实时信息，例如信号质量、信号强度、锁定状态。当前端失锁时需要发送空包。更新频率 5/s</p>
<p>格式如下：<br><img src="/images/sat2ip/20190226-133048.png" alt=""></p>
<p>其中<code>string</code>格式如下：<br><img src="/images/sat2ip/20190226-133118.png" alt=""></p>
<p><strong>Example：</strong></p>
<pre><code>ver=1.0;src=1;tuner=1,240,1,7,12402,v,dvbs,,,,27500,34;pids=0,16,56,112,168,1709</code></pre><h3 id="Media-Transport"><a href="#Media-Transport" class="headerlink" title="Media Transport"></a>Media Transport</h3><p><code>SAT&gt;IP</code>使用<code>RTP</code>来传输实时流，一般 MTU 长度为 1500bytes，一个 IP 包可以携带 7 个 ts 数据包，<code>RTP</code>编码如下：<br><img src="/images/sat2ip/20190226-133535.png" alt=""></p>
]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>upnp</tag>
        <tag>sat2ip</tag>
        <tag>ssdp</tag>
        <tag>rtsp</tag>
      </tags>
  </entry>
  <entry>
    <title>rtsp 协议</title>
    <url>/2019/02/26/rtsp-protocol/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/4e3925f98e84" target="_blank" rel="noopener">RTSP 协议</a></p>
<a id="more"></a>


<h2 id="RTSP-简介"><a href="#RTSP-简介" class="headerlink" title="RTSP 简介"></a>RTSP 简介</h2><p><strong>RTSP</strong>（Real Time Streaming Protocol）是由 Real Network 和 Netscape 共同提出的如何有效地在 IP 网络上传输流媒体数据的应用层协议。RTSP 对流媒体提供了诸如暂停，快进等控制，而它本身并不传输数据，RTSP 的作用相当于流媒体服务器的<strong>远程控制</strong>。服务器端可以自行选择使用 TCP 或 UDP 来传送串流内容，它的语法和运作跟 HTTP 1.1 类似，但并不特别强调时间同步，所以比较能容忍网络延迟。</p>
<h2 id="RTSP-和-HTTP-RTP-RTCP-的关系"><a href="#RTSP-和-HTTP-RTP-RTCP-的关系" class="headerlink" title="RTSP 和 HTTP RTP(RTCP) 的关系"></a>RTSP 和 HTTP RTP(RTCP) 的关系</h2><h3 id="RTSP-和-HTTP"><a href="#RTSP-和-HTTP" class="headerlink" title="RTSP 和 HTTP"></a>RTSP 和 HTTP</h3><ul>
<li><strong>联系</strong>：两者都用纯文本来发送消息，且 rtsp 协议的语法也和 HTTP 类似。Rtsp 一开始这样设计，也是为了能够兼容使用以前写的 HTTP 协议分析代码 。</li>
<li><strong>区别</strong>：rtsp 是有状态的，不同的是 RTSP 的命令需要知道现在正处于一个什么状态，也就是说 rtsp 的命令总是<strong>按照顺序来发送</strong>，某个命令总在另外一个命令之前要发送。Rtsp 不管处于什么状态都<strong>不会断掉连接</strong>。而 http 则不保存状态，协议在发送一个命令以后，<strong>连接就会断开</strong>，且命令之间是<strong>没有依赖性</strong>。rtsp 协议使用 554 端口，http 使用 80 端口。</li>
</ul>
<h3 id="RTSP-和-RTP-RTCP"><a href="#RTSP-和-RTP-RTCP" class="headerlink" title="RTSP 和 RTP(RTCP)"></a>RTSP 和 RTP(RTCP)</h3><ul>
<li><strong>RTP</strong>：Realtime Transport Potocol 实时传输协议<br>RTP 提供时间标志，序列号以及其他能够保证在实时数据传输时处理时间的方法。</li>
<li><strong>RTCP</strong>：Realtime Transport Control Potocol 实时传输控制协议<br>RTCP 是 RTP 的控制部分，用来保证服务质量和成员管理。RTP 和 RTCP 是一起使用的。</li>
<li><strong>RTSP</strong>：RealTime Streaming Potocol 实时流协议<br>RTSP 具体数据传输交给 RTP, 提供对流的远程控制</li>
</ul>
<p>RTP 是基于 UDP 协议的， UDP 不用建立连接，效率更高；但允许丢包， 这就要求在重新组装媒体的时候多做些工作<br>RTP 只是包裹内容信息，而 RTCP 是交换控制信息的，Qos 是通过 RTCP 实现的<br>应用程序对应的是 play, seek, pause, stop 等命令，RTSP 则是处理这些命令，在 UDP 传输时并使用 RTP(RTCP) 来完成。如果是 TCP 连接则不会使用 RTP(RTCP)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5031276-092df4f7341d4b37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/404/format/webp" alt="img"></p>
<p>RTSP structure</p>
<p>RTSP 的 client 连接 server 通过 SDP（<a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-24372973-id-293651.html" target="_blank" rel="noopener">会话描述协议</a>）传递信息，详细请见：<a href="https://www.jianshu.com/p/4e3925f98e84#rtsp_msg" target="_blank" rel="noopener">RTSP 消息</a></p>
<h2 id="RTSP-消息"><a href="#RTSP-消息" class="headerlink" title="RTSP 消息"></a>RTSP 消息</h2><p>RTSP 的消息有两大类，一是请求消息 (request)，一是回应消息 (response)，两种消息的格式不同。<br><strong>请求消息格式</strong>：</p>
<blockquote>
<p>方法 URI RTSP 版本 CR LF<br>消息头 CR LF CR LF<br>消息体 CR LF</p>
</blockquote>
<p>方法包括：OPTIONS、SETUP、PLAY、TEARDOWN DESCRIBE<br>URI 是接收方（服务端）的地址，例如：<a href="https://link.jianshu.com/?t=rtsp://192.168.22.136:5000/v0" target="_blank" rel="noopener">rtsp://192.168.22.136:5000/v0</a><br>每行后面的 CR LF 表示回车换行，需要接收端有相应的解析，消息头需要有两个 CR LF。</p>
<pre><code>DESCRIBE rtsp://192.168.1.211 RTSP/1.0
CSeq: 1
Accept: application/sdp
User-Agent: magnus-fc</code></pre><p><strong>回应消息格式</strong>：</p>
<blockquote>
<p>RTSP 版本 状态码 解释 CR LF<br>消息头 CR LF CR LF<br>消息体 CR LF</p>
</blockquote>
<p>其中 RTSP 版本一般都是 RTSP/1.0，状态码是一个数值，200 表示成功，解释是与状态码对应的文本解释，详细请见：<a href="https://www.jianshu.com/p/4e3925f98e84#sdp_intro" target="_blank" rel="noopener">SDP 协议介绍。</a></p>
<pre><code>RTSP/1.0 200 OK
CSeq: 1
Server: GrandStream Rtsp Server V100R001
Content-Type: application/sdp
Content-length: 256
Content-Base: rtsp://192.168.1.211/0

v=0
o=StreamingServer 3331435948 1116907222000 IN IP4 192.168.1.211
s=h264.mp4
c=IN IP4 0.0.0.0
t=0 0
a=control:*
m=video 0 RTP/AVP 96
a=control:trackID=0
a=rtpmap:96 H264/90000
m=audio 0 RTP/AVP 97
a=control:trackID=1
a=rtpmap:97 G726-16/8000</code></pre><h2 id="简单的-rtsp-交互过程："><a href="#简单的-rtsp-交互过程：" class="headerlink" title="简单的 rtsp 交互过程："></a>简单的 rtsp 交互过程：</h2><p>C 表示 rtsp 客户端，S 表示 rtsp 服务端</p>
<blockquote>
<p>step1:<br>C-&gt;S:OPTION request // 询问 S 有哪些方法可用<br>S-&gt;C:OPTION response //S 回应信息中包括提供的所有可用方法</p>
</blockquote>
<blockquote>
<p>step2:<br>C-&gt;S:DESCRIBE request // 要求得到 S 提供的媒体初始化描述信息<br>S-&gt;C:DESCRIBE response //S 回应媒体初始化描述信息，主要是 sdp</p>
</blockquote>
<blockquote>
<p>step3:<br>C-&gt;S:SETUP request // 设置会话的属性，以及传输模式，提醒 S 建立会话<br>S-&gt;C:SETUP response //S 建立会话，返回会话标识符，以及会话相关信息</p>
</blockquote>
<blockquote>
<p>step4:<br>C-&gt;S:PLAY request //C 请求播放<br>S-&gt;C:PLAY response //S 回应该请求的信息</p>
</blockquote>
<blockquote>
<p>S-&gt;C: 发送流媒体数据</p>
</blockquote>
<blockquote>
<p>step5:<br>C-&gt;S:TEARDOWN request //C 请求关闭会话<br>S-&gt;C:TEARDOWN response //S 回应该请求</p>
</blockquote>
<h2 id="RTSP-中常用方法"><a href="#RTSP-中常用方法" class="headerlink" title="RTSP 中常用方法"></a>RTSP 中常用方法</h2><h3 id="OPTION"><a href="#OPTION" class="headerlink" title="OPTION"></a>OPTION</h3><p>得到服务器提供的可用方法</p>
<pre><code>OPTIONS rtsp://192.168.20.136:5000/xxx666 RTSP/1.0
CSeq: 1 // 每个消息都有序号来标记，第一个包通常是 option 请求消息
User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</code></pre><p>服务器的回应信息包括提供的一些方法，例如：</p>
<pre><code>RTSP/1.0 200 OK
Server: UServer 0.9.7_rc1
Cseq: 1 // 每个回应消息的 cseq 数值和请求消息的 cseq 相对应
Public: OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, SCALE,GET_PARAMETER // 服务器提供的可用的方法</code></pre><h3 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h3><p>C 向 S 发起 DESCRIBE 请求，为了得到会话描述信息 (SDP):</p>
<pre><code>DESCRIBE rtsp://192.168.20.136:5000/xxx666 RTSP/1.0
CSeq: 2
token:
Accept: application/sdp
User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</code></pre><p>服务器回应一些对此会话的描述信息 (<a href="https://www.jianshu.com/p/4e3925f98e84#sdp_intro" target="_blank" rel="noopener">sdp</a>):</p>
<pre><code>RTSP/1.0 200 OK
Server: UServer 0.9.7_rc1
Cseq: 2
x-prev-url: rtsp://192.168.20.136:5000
x-next-url: rtsp://192.168.20.136:5000
x-Accept-Retransmit: our-retransmit
x-Accept-Dynamic-Rate: 1
Cache-Control: must-revalidate
Last-Modified: Fri, 10 Nov 2006 12:34:38 GMT
Date: Fri, 10 Nov 2006 12:34:38 GMT
Expires: Fri, 10 Nov 2006 12:34:38 GMT
Content-Base: rtsp://192.168.20.136:5000/xxx666/
Content-Length: 344
Content-Type: application/sdp

v=0 // 以下都是 sdp 信息
o=OnewaveUServerNG 1451516402 1025358037 IN IP4 192.168.20.136
s=/xxx666
u=http:///
e=admin@
c=IN IP4 0.0.0.0
t=0 0
a=isma-compliance:1,1.0,1

a=range:npt=0-
m=video 0 RTP/AVP 96 //m 表示媒体描述，下面是对会话中视频通道的媒体描述
a=rtpmap:96 MP4V-ES/90000
a=fmtp:96 profile-level-id=245;config=000001B0F5000001B509000001000000012000C888B0E0E0FA62D089028307 a=control:trackID=0 //trackID＝0 表示视频流用的是通道 0</code></pre><h3 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h3><p>客户端提醒服务器建立会话，并确定传输模式：</p>
<pre><code>SETUP rtsp://192.168.20.136:5000/xxx666/trackID=0 RTSP/1.0
CSeq: 3
Transport: RTP/AVP/TCP;unicast;interleaved=0-1
User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)
 //uri 中 带有 trackID＝0，表示对该通道进行设置。Transport 参数设置了传输模式，包的结构。接下来的数据包头部第二个字节位置就是 interleaved，它的值是每个通道都不同的，trackID＝0 的 interleaved 值有两个 0 或 1，0 表示 rtp 包，1 表示 rtcp 包，接收端根据 interleaved 的值来区别是哪种数据包。</code></pre><p>服务器回应信息：</p>
<pre><code>RTSP/1.0 200 OK
Server: UServer 0.9.7_rc1
Cseq: 3
Session: 6310936469860791894 // 服务器回应的会话标识符
Cache-Control: no-cache
Transport: RTP/AVP/TCP;unicast;interleaved=0-1;ssrc=6B8B4567</code></pre><h3 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h3><p>客户端发送播放请求：</p>
<pre><code>PLAY rtsp://192.168.20.136:5000/xxx666 RTSP/1.0
CSeq: 4
Session: 6310936469860791894
Range: npt=0.000- // 设置播放时间的范围
User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</code></pre><p>服务器回应信息：</p>
<pre><code>RTSP/1.0 200 OK
Server: UServer 0.9.7_rc1
Cseq: 4
Session: 6310936469860791894
Range: npt=0.000000-
RTP-Info: url=trackID=0;seq=17040;rtptime=1467265309
 //seq 和 rtptime 都是 rtp 包中的信息</code></pre><h3 id="TEARDOWN"><a href="#TEARDOWN" class="headerlink" title="TEARDOWN"></a>TEARDOWN</h3><p>客户端发起关闭请求：</p>
<pre><code>TEARDOWN rtsp://192.168.20.136:5000/xxx666 RTSP/1.0
CSeq: 5
Session: 6310936469860791894
User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</code></pre><p>服务器回应：</p>
<pre><code>RTSP/1.0 200 OK
Server: UServer 0.9.7_rc1
Cseq: 5
Session: 6310936469860791894</code></pre><h2 id="SDP-协议"><a href="#SDP-协议" class="headerlink" title="SDP 协议"></a>SDP 协议</h2><p>sdp 的格式：</p>
<pre><code>v=&lt;version&gt;
o=&lt;username&gt; &lt;session id&gt; &lt;version&gt; &lt;network type&gt; &lt;address type&gt; &lt;address&gt;
s=&lt;session name&gt;
i=&lt;session description&gt;
u=&lt;URI&gt;
e=&lt;email address&gt;
p=&lt;phone number&gt;
c=&lt;network type&gt; &lt;address type&gt; &lt;connection address&gt;
b=&lt;modifier&gt;:&lt;bandwidth-value&gt;
t=&lt;start time&gt; &lt;stop time&gt;
r=&lt;repeat interval&gt; &lt;active duration&gt; &lt;list of offsets from start-time&gt;
z=&lt;adjustment time&gt; &lt;offset&gt; &lt;adjustment time&gt; &lt;offset&gt; ....
k=&lt;method&gt;
k=&lt;method&gt;:&lt;encryption key&gt;
a=&lt;attribute&gt;
a=&lt;attribute&gt;:&lt;value&gt;
m=&lt;media&gt; &lt;port&gt; &lt;transport&gt; &lt;fmt list&gt;</code></pre><blockquote>
<p>v = （协议版本）<br>o = （所有者 / 创建者和会话标识符）<br>s = （会话名称）<br>i = * （会话信息）<br>u = * （URI 描述）<br>e = * （Email 地址）<br>p = * （电话号码）<br>c = * （连接信息）<br>b = * （带宽信息）<br>z = * （时间区域调整）<br>k = * （加密密钥）<br>a = * （0 个或多个会话属性行）</p>
</blockquote>
<ul>
<li>时间描述：<br>t = （会话活动时间）<br>r = * （0 或多次重复次数）</li>
<li>媒体描述：<br>m = （媒体名称和传输地址）<br>i = * （媒体标题）<br>c = * （连接信息 — 如果包含在会话层则该字段可选）<br>b = * （带宽信息）<br>k = * （加密密钥）<br>a = * （0 个或多个媒体属性行）</li>
</ul>
<p>SDP 一会话描述协议一描述 SAP、SIP 和 RTSR 会话的协议，是一种文件描述协议，是由服务器生成的描述媒体文件编码信息以及所在服务器的链接等的信息。在多媒体会话 中 sDP 传送有关媒体流的信息，使会话描述的参人方加人会话。SDP 主要用于 Intemet 网中，但也可以在其它网络环境下使用。SDP 十分通用，可描述其它网络环境中的会话，但主要用 于 Intemet 中。在 Intemet 环境下，SDP 有两个主要目的：一是表明会话存在，二是传送足够信息给接收方，以便能加人、参加该会话。SDP 所传达的信息包括：会话名称和目的，会话 活动时间，组成会话媒体种类，接收这些媒体的控制信息（如地址、端口、格式、带宽和会议管理人员资料等）。</p>
<p>总结：在 RTSP 交互过程中，只要在客户端发出 Describe 请求的时候，服务端回应的时候会有 SDP 消息发出，用 SDP 来描述会话情况和内容，方便客户端能够加入该会话。</p>
<h2 id="RTSP-基于-libcurl-代码实现"><a href="#RTSP-基于-libcurl-代码实现" class="headerlink" title="RTSP 基于 libcurl 代码实现"></a>RTSP 基于 libcurl 代码实现</h2><pre><code>/*
 * Copyright (c) 2011, Jim Hollinger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Jim Hollinger nor the names of its contributors
 *     may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/* &lt;DESC&gt;
 * A basic RTSP transfer
 * &lt;/DESC&gt;
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;curl/curl.h&gt;

#if defined (WIN32)
#include &lt;conio.h&gt;  /* _getch() */
#else
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

#define VERSION_STR  &quot;V1.0&quot;

/* error handling macros */
#define my_curl_easy_setopt(A, B, C)                             \
  res = curl_easy_setopt((A), (B), (C));                         \
  if(!res)                                                       \
    fprintf(stderr, &quot;curl_easy_setopt(%s, %s, %s) failed: %d\n&quot;, \
            #A, #B, #C, res);

#define my_curl_easy_perform(A)                                     \
  res = curl_easy_perform(A);                                       \
  if(!res)                                                          \
    fprintf(stderr, &quot;curl_easy_perform(%s) failed: %d\n&quot;, #A, res);

static int _getch(void)
{
  struct termios oldt, newt;
  int ch;
  tcgetattr(STDIN_FILENO, &amp;oldt);
  newt = oldt;
  newt.c_lflag &amp;= ~( ICANON | ECHO);
  tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt);
  ch = getchar();
  tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt);
  return ch;
}
#endif

/* send RTSP OPTIONS request */
static void rtsp_options(CURL *curl, const char *uri)
{
  CURLcode res = CURLE_OK;
  printf(&quot;\nRTSP: OPTIONS %s\n&quot;, uri);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_STREAM_URI, uri);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_REQUEST, (long)CURL_RTSPREQ_OPTIONS);
  my_curl_easy_perform(curl);
}

/* send RTSP DESCRIBE request and write sdp response to a file */
static void rtsp_describe(CURL *curl, const char *uri,
                          const char *sdp_filename)
{
  CURLcode res = CURLE_OK;
  FILE *sdp_fp = fopen(sdp_filename, &quot;wb&quot;);
  printf(&quot;\nRTSP: DESCRIBE %s\n&quot;, uri);
  if(sdp_fp == NULL) {
    fprintf(stderr, &quot;Could not open &#39;%s&#39; for writing\n&quot;, sdp_filename);
    sdp_fp = stdout;
  }
  else {
    printf(&quot;Writing SDP to &#39;%s&#39;\n&quot;, sdp_filename);
  }
  my_curl_easy_setopt(curl, CURLOPT_WRITEDATA, sdp_fp);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_REQUEST, (long)CURL_RTSPREQ_DESCRIBE);
  my_curl_easy_perform(curl);
  my_curl_easy_setopt(curl, CURLOPT_WRITEDATA, stdout);
  if(sdp_fp != stdout) {
    fclose(sdp_fp);
  }
}

/* send RTSP SETUP request */
static void rtsp_setup(CURL *curl, const char *uri, const char *transport)
{
  CURLcode res = CURLE_OK;
  printf(&quot;\nRTSP: SETUP %s\n&quot;, uri);
  printf(&quot;      TRANSPORT %s\n&quot;, transport);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_STREAM_URI, uri);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_TRANSPORT, transport);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_REQUEST, (long)CURL_RTSPREQ_SETUP);
  my_curl_easy_perform(curl);
}

/* send RTSP PLAY request */
static void rtsp_play(CURL *curl, const char *uri, const char *range)
{
  CURLcode res = CURLE_OK;
  printf(&quot;\nRTSP: PLAY %s\n&quot;, uri);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_STREAM_URI, uri);
  my_curl_easy_setopt(curl, CURLOPT_RANGE, range);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_REQUEST, (long)CURL_RTSPREQ_PLAY);
  my_curl_easy_perform(curl);
}

/* send RTSP TEARDOWN request */
static void rtsp_teardown(CURL *curl, const char *uri)
{
  CURLcode res = CURLE_OK;
  printf(&quot;\nRTSP: TEARDOWN %s\n&quot;, uri);
  my_curl_easy_setopt(curl, CURLOPT_RTSP_REQUEST, (long)CURL_RTSPREQ_TEARDOWN);
  my_curl_easy_perform(curl);
}

/* convert url into an sdp filename */
static void get_sdp_filename(const char *url, char *sdp_filename,
                             size_t namelen)
{
  const char *s = strrchr(url, &#39;/&#39;);
  strcpy(sdp_filename, &quot;video.sdp&quot;);
  if(s != NULL) {
    s++;
    if(s[0] != &#39;\0&#39;) {
      snprintf(sdp_filename, namelen, &quot;%s.sdp&quot;, s);
    }
  }
}

/* scan sdp file for media control attribute */
static void get_media_control_attribute(const char *sdp_filename,
                                        char *control)
{
  int max_len = 256;
  char *s = malloc(max_len);
  FILE *sdp_fp = fopen(sdp_filename, &quot;rb&quot;);
  control[0] = &#39;\0&#39;;
  if(sdp_fp != NULL) {
    while(fgets(s, max_len - 2, sdp_fp) != NULL) {
      sscanf(s, &quot; a = control: %s&quot;, control);
    }
    fclose(sdp_fp);
  }
  free(s);
}

/* main app */
int main(int argc, char * const argv[])
{
#if 1
  const char *transport = &quot;RTP/AVP;unicast;client_port=1234-1235&quot;;  /* UDP */
#else
  /* TCP */
  const char *transport = &quot;RTP/AVP/TCP;unicast;client_port=1234-1235&quot;;
#endif
  const char *range = &quot;0.000-&quot;;
  int rc = EXIT_SUCCESS;
  char *base_name = NULL;

  printf(&quot;\nRTSP request %s\n&quot;, VERSION_STR);
  printf(&quot;    Project web site: http://code.google.com/p/rtsprequest/\n&quot;);
  printf(&quot;    Requires curl V7.20 or greater\n\n&quot;);

  /* check command line */
  if((argc != 2) &amp;&amp; (argc != 3)) {
    base_name = strrchr(argv[0], &#39;/&#39;);
    if(base_name == NULL) {
      base_name = strrchr(argv[0], &#39;\\&#39;);
    }
    if(base_name == NULL) {
      base_name = argv[0];
    }
    else {
      base_name++;
    }
    printf(&quot;Usage:   %s url [transport]\n&quot;, base_name);
    printf(&quot;         url of video server\n&quot;);
    printf(&quot;         transport (optional) specifier for media stream&quot;
           &quot; protocol\n&quot;);
    printf(&quot;         default transport: %s\n&quot;, transport);
    printf(&quot;Example: %s rtsp://192.168.0.2/media/video1\n\n&quot;, base_name);
    rc = EXIT_FAILURE;
  }
  else {
    const char *url = argv[1];
    char *uri = malloc(strlen(url) + 32);
    char *sdp_filename = malloc(strlen(url) + 32);
    char *control = malloc(strlen(url) + 32);
    CURLcode res;
    get_sdp_filename(url, sdp_filename, strlen(url) + 32);
    if(argc == 3) {
      transport = argv[2];
    }

    /* initialize curl */
    res = curl_global_init(CURL_GLOBAL_ALL);
    if(res == CURLE_OK) {
      curl_version_info_data *data = curl_version_info(CURLVERSION_NOW);
      CURL *curl;
      fprintf(stderr, &quot;    curl V%s loaded\n&quot;, data-&gt;version);

      /* initialize this curl session */
      curl = curl_easy_init();
      if(curl != NULL) {
        my_curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);
        my_curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
        my_curl_easy_setopt(curl, CURLOPT_HEADERDATA, stdout);
        my_curl_easy_setopt(curl, CURLOPT_URL, url);

        /* request server options */
        snprintf(uri, strlen(url) + 32, &quot;%s&quot;, url);
        rtsp_options(curl, uri);

        /* request session description and write response to sdp file */
        rtsp_describe(curl, uri, sdp_filename);

        /* get media control attribute from sdp file */
        get_media_control_attribute(sdp_filename, control);

        /* setup media stream */
        snprintf(uri, strlen(url) + 32, &quot;%s/%s&quot;, url, control);
        rtsp_setup(curl, uri, transport);

        /* start playing media stream */
        snprintf(uri, strlen(url) + 32, &quot;%s/&quot;, url);
        rtsp_play(curl, uri, range);
        printf(&quot;Playing video, press any key to stop ...&quot;);
        _getch();
        printf(&quot;\n&quot;);

        /* teardown session */
        rtsp_teardown(curl, uri);

        /* cleanup */
        curl_easy_cleanup(curl);
        curl = NULL;
      }
      else {
        fprintf(stderr, &quot;curl_easy_init() failed\n&quot;);
      }
      curl_global_cleanup();
    }
    else {
      fprintf(stderr, &quot;curl_global_init(%s) failed: %d\n&quot;,
              &quot;CURL_GLOBAL_ALL&quot;, res);
    }
    free(control);
    free(sdp_filename);
    free(uri);
  }

  return rc;
}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/4e3925f98e84" target="_blank" rel="noopener">RTSP 协议</a></li>
<li><a href="https://blog.csdn.net/bytxl/article/details/50400987" target="_blank" rel="noopener">RTCP 协议详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>RTSP</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>http</tag>
        <tag>rtsp</tag>
      </tags>
  </entry>
  <entry>
    <title>DLNA 协议分析及应用</title>
    <url>/2019/02/25/dlan-introduction/</url>
    <content><![CDATA[<p><code>DLNA</code>及相关协议简介</p>
<ul>
<li>DLNA 简介</li>
<li>DLNA 架构</li>
<li>DLNA 原理</li>
<li>UPnP 组件</li>
<li>UPnP 工作流程</li>
<li>UPnP 消息描述</li>
<li>UPnP 设备描述</li>
</ul>
<a id="more"></a>

<h2 id="DLNA-简介"><a href="#DLNA-简介" class="headerlink" title="DLNA 简介"></a>DLNA 简介</h2><p>DLNA 的全称是<code>DIGITAL LIVING NETWORK ALLIANCE</code>（数字生活网络联盟）， 旨在解决个人 PC，消费电器，移动设备在内的无线网络和有线网络的互联互通，使得数字媒体和内容服务的无限制的共享和增长成为可能，目前成员公司已达 280 多家。</p>
<h2 id="DLNA-架构"><a href="#DLNA-架构" class="headerlink" title="DLNA 架构"></a>DLNA 架构</h2><p>DLNA 将其整个应用规定成 5 个功能组件，从下到上依次为：</p>
<ol>
<li>网络互连：802.3 以太网，802.11WiFi，802.15 蓝牙</li>
<li>网络协议：IPV4</li>
<li>设备的发现控制和管理：UPnP</li>
<li>媒体传输：HTTP/RTP</li>
<li>媒体格式</li>
</ol>
<p><img src="https://liuweiqiang.win/images/dlna/dlna_overview.png" alt="DLNA ARCHITECTURE"></p>
<p><code>DLNA</code>不是一种协议，但包括了实现相关标准所需要的一系列协议栈，<code>UPnP</code>是其中的关键协议</p>
<p><code>DLNA</code>是基于<code>UPnP</code>协议，<code>DLNA</code>整个发现，控制，事件订阅部分都是由<code>Upnp Device Architecture</code>协议所定义，因此有必要了解下<code>UPnP</code>协议。</p>
<p><img src="https://liuweiqiang.win/images/dlna/upnp_overview.png" alt="img"></p>
<p><code>UPnP</code>协议结构最底层的<code>TCP/IP</code>协议是<code>UPnP</code>协议结构的基础。<code>IP</code>层用于数据的发送与接收。对于需要可靠传送的信息，使用<code>TCP</code>进行传送，反之则使用<code>UDP</code>。<code>UPnP</code>对网络物理设备没有要求，可以使用以太网、无线网、<code>IEEE1394</code>、红外进行连接，只要支持<code>IP</code>协议即可。</p>
<p>构建在<code>TCP/IP</code>协议之上的是<code>HTTP</code>协议及其变种，这一部分是<code>UPnP</code>协议的核心部分，所有<code>UPnP</code>消息都被封装在<code>HTTP</code>协议及其变种之中。<code>HTTP</code>协议的变种是<code>HTTPU</code>和<code>HTTPMU</code>, 这些协议的格式沿袭了<code>HTTP</code>协议，只不过与<code>HTTP</code>协议不同的是它们通过<code>UDP</code>而不是<code>TCP</code>来发送消息，并且可以用于多播通信。</p>
<p><code>UPnP</code>包含以下协议：</p>
<ul>
<li><code>SSDP</code>协议<br>简单服务发现协议 (Simple Service Discovery Protocol：SSDP)，内建在 HTTPU/HTTPMU 里，定义如何让网络上有的服务被发现的协议。包括控制点如何发现网络上有哪些服务，并取得这些服务的资讯，还有装置本身宣告他提供哪些服务。该协议运用在 UPnP 工作流程的设备发现部分。</li>
<li><code>SOAP</code>协议<br>简单对象访问协议 ( Simple Object Access Protocol) 定义了可扩展标记语言 (XML) 和 HTTP 的使用来执行远程调用，包括控制点如何发送命令消息给设备，及设备接收到命令消息后如何发送响应消息给控制点。该协议运用在 UPnP 工作流程的设备控制部分。</li>
<li><code>GENA</code>协议<br>一般事件通知架构 (Generic Event Notification Architecture：GENA) 定义在控制点想要监听设备的某个服务状态变量的状况时，控制点如何传送订阅讯息并如何接收通知讯息用的。该协议运用在 UPnP 工作流程的事件订阅部分。</li>
</ul>
<h2 id="DLNA-原理"><a href="#DLNA-原理" class="headerlink" title="DLNA 原理"></a>DLNA 原理</h2><p>参考 <a href="http://www.jianshu.com/p/fbc7c700cdb5" target="_blank" rel="noopener"> 《基于 DLNA 的移动端网络视频投屏技术初探》</a></p>
<p>要实现从移动端将网络视频投放至智能电视或机顶盒，首先要保证这些设备在同一个局域网的相同网段下，即共享同一个网关，这样所有设备都能够拥有独立的 IP，从而具备相互通信的基础</p>
<h3 id="设备发现"><a href="#设备发现" class="headerlink" title="设备发现"></a>设备发现</h3><p>当一个新的<code>Control Point</code>加入一个局域网时，为了获取当前网段里都有哪些智能设备，需要遵循<code>SSDP</code>向默认多播 IP 和端口发送获取信息的请求，这是一个 UDP 消息，所以建议在设备搜索过程多做几次发现请求，以免丢包带来的遗漏</p>
<p>控制点可以获得的信息是：有一台设备，它的 IP 和端口号，设备描述文档 (<code>DDD</code>) 在什么位置、UUID 是什么</p>
<h3 id="请求设备描述文档"><a href="#请求设备描述文档" class="headerlink" title="请求设备描述文档"></a>请求设备描述文档</h3><p><code>DDD</code>以及后面要说到的服务描述文档 (<code>SDD, Service Description Document</code>) 都是以 XML 格式返回给请求端的，这一步的通信则是基于 TCP/HTTP 进行可靠传输的。我们请求<code>Location</code>字段的内容即</p>
<pre><code>http://10.2.9.152:49152/TxMediaRenderer_desc.xml</code></pre><p>响应</p>
<pre><code>&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot; configId=&quot;499354&quot;&gt;
    &lt;specVersion&gt;
        &lt;major&gt;1&lt;/major&gt;
        &lt;minor&gt;1&lt;/minor&gt;
    &lt;/specVersion&gt;
    &lt;device&gt;
        &lt;deviceType&gt;urn:schemas-upnp-org:device:MediaRenderer:1&lt;/deviceType&gt;
        &lt;friendlyName&gt;我的设备&lt;/friendlyName&gt;
        &lt;manufacturer&gt;Plutinosoft LLC&lt;/manufacturer&gt;
        &lt;manufacturerURL&gt;http://www.plutinosoft.com&lt;/manufacturerURL&gt;
        &lt;modelDescription&gt;Plutinosoft AV Media Renderer Device&lt;/modelDescription&gt;
        &lt;modelName&gt;AV Renderer Device&lt;/modelName&gt;
        &lt;modelURL&gt;http://www.plutinosoft.com/platinum&lt;/modelURL&gt;
        &lt;UDN&gt;uuid:9c443d47158b-dmr&lt;/UDN&gt;
        &lt;dlna:X_DLNADOC xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot;&gt;DMR-1.50&lt;/dlna:X_DLNADOC&gt;
        &lt;serviceList&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:schemas-upnp-org:service:AVTransport:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:upnp-org:serviceId:AVTransport&lt;/serviceId&gt;
                &lt;SCPDURL&gt;/AVTransport/9c443d47158b-dmr/scpd.xml&lt;/SCPDURL&gt;
                &lt;controlURL&gt;/AVTransport/9c443d47158b-dmr/control.xml&lt;/controlURL&gt;
                &lt;eventSubURL&gt;/AVTransport/9c443d47158b-dmr/event.xml&lt;/eventSubURL&gt;
            &lt;/service&gt;
            ...
        &lt;/serviceList&gt;
    &lt;/device&gt;
&lt;/root&gt;</code></pre><p>返回设备的详细信息：设备名称、设备类型、UUID、服务列表，每个服务都有<code>serviceType</code>，<code>SCPDURL</code>，<code>serviceId</code>，<code>controlURL</code>和<code>eventSubURL</code></p>
<h3 id="请求服务描述文档"><a href="#请求服务描述文档" class="headerlink" title="请求服务描述文档"></a>请求服务描述文档</h3><p>如何使用这个服务需要参考该服务的<code>SDD</code>。<code>SCPDURL</code>这个字段的内容就是请求<code>SDD</code>的路径地址，我们将其与之前在发现设备阶段获取到的响应消息中的 Location 字段内容中设备的 IP 和端口号拿过来，拼接成完整 URL 字符串</p>
<pre><code>http://10.2.9.152:49152/AVTransport/9c443d47158b-dmr/scpd.xml</code></pre><p>返回一个动作列表，一个服务会包含一个或多个功能请求动作</p>
<pre><code>&lt;scpd xmlns=&quot;urn:schemas-upnp-org:service-1-0&quot;&gt;
    &lt;specVersion&gt;
        &lt;major&gt;1&lt;/major&gt;
        &lt;minor&gt;0&lt;/minor&gt;
    &lt;/specVersion&gt;
    &lt;actionList&gt;
        &lt;action&gt;
            &lt;name&gt;SetAVTransportURI&lt;/name&gt;
            &lt;argumentList&gt;
                &lt;argument&gt;
                    &lt;name&gt;InstanceID&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;A_ARG_TYPE_InstanceID&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
                &lt;argument&gt;
                    &lt;name&gt;CurrentURI&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;AVTransportURI&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
                &lt;argument&gt;
                    &lt;name&gt;CurrentURIMetaData&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;AVTransportURIMetaData&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
            &lt;/argumentList&gt;
        &lt;/action&gt;
        ...
    &lt;/actionList&gt;
    &lt;serviceStateTable&gt;
        &lt;stateVariable sendEvents=&quot;no&quot;&gt;
            &lt;name&gt;AVTransportURI&lt;/name&gt;
            &lt;dataType&gt;string&lt;/dataType&gt;
        &lt;/stateVariable&gt;
        ...
    &lt;/serviceStateTable&gt;
&lt;/scpd&gt;</code></pre><p>如<code>SetAVTransportURI</code>这个请求的功能是将一个音视频资源的 URI 发送给渲染端。一个<code>Action</code>就好比一个 API 请求，你还需要传递一些要求的参数，这时就会用到该 Action 后面参数列表里规定的参数</p>
<h3 id="服务动作请求"><a href="#服务动作请求" class="headerlink" title="服务动作请求"></a>服务动作请求</h3><p>有了动作所需要的全部信息，就可以按照 DLNA 规定的方式发给设备请求服务</p>
<pre><code>POST /AVTransport/9c443d47158b-dmr/control.xml HTTP/1.1
HOST: 10.2.9.152
Content-Type: text/xml; charset=&quot;utf-8&quot;
SOAPAction: &quot;urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI&quot;
&lt;?xml version=&quot;1.0&quot;?&gt;
    &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
    &lt;s:Body&gt;
        &lt;u:SetAVTransportURI xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;
            &lt;InstanceID&gt;0&lt;/InstanceID&gt;
            &lt;CurrentURI&gt;yourAVURI&lt;/CurrentURI&gt;
        &lt;/u:SetAVTransportURI&gt;
    &lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><p>响应</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/xml; charset=&quot;utf-8&quot;
Date: Thu, 16 Feb 2017 09:09:45 GMT
Server: OS/version UPnP/1.1 product/version
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
    &lt;s:Body&gt;
        &lt;u:SetAVTransportURI xmlns:u=&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&gt;
            &lt;u:SetAVTransportURIResponse&gt;
                &lt;_xmlns:u&gt;&quot;urn:schemas-upnp-org:service:AVTransport:1&quot;&lt;/_xmlns:u&gt;
            &lt;/u:SetAVTransportURIResponse&gt;
        &lt;/u:SetAVTransportURI&gt;
    &lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><h2 id="UPnP-组件"><a href="#UPnP-组件" class="headerlink" title="UPnP 组件"></a>UPnP 组件</h2><p>图为组件之间的关系：</p>
<p><img src="https://liuweiqiang.win/images/dlna/device_overview.png" alt="img"></p>
<ul>
<li>服务 (Service)<br>在<code>UPnP</code>网络中，最新的控制控制单元就是服务，服务描述的设备在不同的情况下的活动和设备的状态。例如，时钟服务可以表述为时间变化（状态变化），当前的时间（时间状态）以及设置时间和读取时间两个活动，通过这两个活动，你就可以控制服务。</li>
<li>设备 (Device)<br><code>UPnP</code>网络中定义的设备具有很广泛的含义，各种各样的家电、电脑外设、智能设备、无线设备、个人电脑等等都可以成为其中一员。一个<code>UPnP</code>设备可以是多个服务的载体和多个子设备的嵌套集。例如一台印表机有提供列印这样的服务；一台电视有提供收讯的服务，这些都属于设备。</li>
<li>控制点 (ControlPoint)<br>在<code>UPnP</code>网络中，控制点指的是可以发现并控制其它设备的控制设备。在<code>UPnP</code>网络中，设备可以和控制点合并。也就是说，同一个设备，可以同时具有设备的功能和控制点的功能，即可以作为设备提供服务，也可以作为控制点发现和控制其它设备。</li>
</ul>
<h2 id="UPnP-工作流程"><a href="#UPnP-工作流程" class="headerlink" title="UPnP 工作流程"></a>UPnP 工作流程</h2><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>UPnP 网络互连的基础是 IP 协议，因此必须先获取一个有效的 IP 地址。当设备首次与网络建立连接后，利用 DHCP 服务，使设备得到一个 IP 地址。这个 IP 地址可以是 DHCP 系统指定的，也可以是由设备选择的。设备还可以使用 Friendly Name，这就需要 DNS 来转换得到 IP</p>
<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>当一个设备被添加到网络后，UPnP 的发现协议允许该设备向网络上的控制点 (Control Point, CP) 通知自己拥有的服务。同样，当一个 CP 被添加到网络后，UPnP 发现协议允许该 CP 搜索网络上可用的设备。这两种情况下的组播消息一般是设备和服务的基本信息，如设备类型，唯一标识符，状态参数和指向更详细信息的一个指针等等。要注意设备信息和服务信息都是要组播出去的</p>
<p>发现过程使用的协议是 SSDP(Simple Service Discovery Protocol，简单服务发现协议），采用 UDP 传输</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>描述分为两部分：</p>
<ul>
<li>一个是设备描述</li>
<li>另一个是服务描述</li>
</ul>
<p>控制点在发现一个设备之后仍然对其知之甚少。为了使控制点了解到更多关于设备及其能力的信息或与设备进行交互，则控制点必须取得来自该设备在发现消息中所提供之 URL 的设备描述。设备可能包含其它逻辑设备，以及功能单元或服务 。对于设备的 UPnP 描述通过 XML 来表达，并包括诸如模型名称和号码、序列号、制造商名称和厂商专门网站 URL 等专门针对厂商的制造商信息。该描述还包括一列任意的嵌入式设备或服务，以及用于控制、事件触发和展示的 URL。对于每项服务，此描述均包括一列命令或动作，而服务（参数或变量）对于每个动作做出响应；针对服务的描述还包括一系列变量；这些变量模型化服务在运行时的状态，并通过数据类型、范围和事件特征进行描述。以下关于描述的部分说明了设备如何被描述，以及这些描述如何被 控制点取得。</p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>在设备描述部分，还有关于如何控制设备的描述，会给出一个 Control URL，CP 可以向这个 URL 发送不同的控制信息就可以控制了，然后设备也可以返回一个信息反馈。</p>
<p>这种 CP 和设备之间沟通信息按照<code>SOAP</code>(Simple Object Access Protocol) 的格式来写。消息体里面就可以写想调用的动作了，叫做 Action Invocation，可能还要传参数，比如想播放一个视频，要把视频的 URL 传过去，设备收到后会响应，表示能不能执行调用，出错的话会返回一个错误代码</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在服务进行的整个时间内，只要变量值发生了变化或者模式的状态发生了改变，就产生了一个事件，该事件服务提供者（某设备的某个服务）会把该事件向整个网络进行多播。而且，CP 也可以事先向事件服务器订阅事件信息，保证将该 CP 感兴趣的事件及时准确地单播传送过来</p>
<p>事件的订阅和推送这块用的通信协议是<code>General Event Notification Architecture(GENA)</code>，通过 HTTP/TCP/IP 传送。订阅过程如下：</p>
<ol>
<li>订阅。Subscriber 发送订阅消息主要包含事件 URL，服务 ID 号，这两个可以在设备服务描述信息中找到，以及寄送 URL，还会包含一个订阅期限 Duration</li>
<li>成功订阅。Publisher 收到订阅信息，如果同意订阅的话就会为每个新 Subscriber 生成一个唯一的 ID 并记录 Subscriber 的 Duration 和 Delivery URL。还会记录一个顺序增长 EventKey 用来保证事件确实推送到 Subscriber 那里</li>
<li>首次推送。订阅同意订阅之后还会向 Subscriber 发送一组初始变量或状态值，进行首次同步</li>
<li>续订。Subscriber 必须在订阅到期前发送 Renewal 续订</li>
<li>订阅到期。订阅到期后 Publisher 会把 Subscriber 的信息删除，Subscriber 又回到订阅前的状态。</li>
<li>退订。Subscriber 发送 Cancel 信息将会取消订阅。Subscriber 因非正常退出网络的话，则不会退订直到订阅到期</li>
<li>订阅操作失败信息。当订阅、续订和退订不能被 Publisher 接收或者出现错误时，Publisher 会发送一个错误代码</li>
</ol>
<h3 id="表达"><a href="#表达" class="headerlink" title="表达"></a>表达</h3><p>只要得到了设备的 URL，就可以取得该设备表达的 URL，取得该设备表达的 HTML，然后可以将此 HTML 纳入 CP 的本地浏览器上。这部分还包括与用户对话的界面，以及与用户进行会话的处理。因此设备表达可以理解成“遥控器”。这部分定义描述界面，规范界面以及传输界面内容。远程界面是供 CP 用户使用的，CP 用户通过远程界面完成设备描述的获取，控制设备，订阅收取设备事件等等</p>
<h2 id="UPnP-消息描述"><a href="#UPnP-消息描述" class="headerlink" title="UPnP 消息描述"></a>UPnP 消息描述</h2><h3 id="UPnP-搜索"><a href="#UPnP-搜索" class="headerlink" title="UPnP 搜索"></a>UPnP 搜索</h3><pre><code>M-SEARCH * HTTP/1.1
Man: &quot;ssdp:discover&quot; // 固定
Mx: 10 // 等待时长
Host: 239.255.255.250:1900 // 多播地址
St: ssdp:all // 搜索所有 也可以指定特殊类型设备</code></pre><h3 id="UPnP-响应"><a href="#UPnP-响应" class="headerlink" title="UPnP 响应"></a>UPnP 响应</h3><pre><code>HTTP/1.1 200 OK
CACHE-CONTROL: max-age=100 // 生命周期
DATE: Tue, 06 Sep 2016 08:59:17 GMT // 响应时间
EXT: // 想控制点确认 MAN 头域已经被设备理解
LOCATION: http://192.168.31.242:49153/description.xml // 描述文件地址
OPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=01
01-NLS: 36b309d6-1dd2-11b2-a747-e67ed51c3f33
SERVER: Linux/2.6.32.11.as, UPnP/1.0, Portable SDK for UPnP devices/1.6.18 // 版本信息
X-User-Agent: redsonic
ST: upnp:rootdevice
USN: uuid:a22d1223-d889-b76b-0cc3-4c484a00002e::upnp:rootdevice</code></pre><h3 id="UPnP-通知"><a href="#UPnP-通知" class="headerlink" title="UPnP 通知"></a>UPnP 通知</h3><pre><code>NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900 // 多播地址
CACHE-CONTROL: max-age=100 // 缓存时间
LOCATION: http://192.168.31.242:49153/description.xml // 描述文件地址
OPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=01
01-NLS: 36b309d6-1dd2-11b2-a747-e67ed51c3f33
NT: urn:schemas-upnp-org:service:ConnectionManager:1
NTS: ssdp:alive
SERVER: Linux/2.6.32.11.as, UPnP/1.0, Portable SDK for UPnP devices/1.6.18
X-User-Agent: redsonic
USN: uuid:a22d1223-d889-b76b-0cc3-4c484a00002e::urn:schemas-upnp-org:service:ConnectionManager:1</code></pre><p>NT GENA 规定使用的标头。通知类型。必须采用以下一种形式。单一 URI。</p>
<ul>
<li>UPnP:rootdevice 向根设备发送一次。</li>
<li>uuid:device-UUID 向每种设备 （根设备或嵌入式设备） 发送一次。 设备 UUID 由 UPnP 厂商指定。</li>
<li>urn：schemas-UPnP-org:device:deviceType:v 向每种设备（根设备或嵌入式设备）发送一次。设备类型与版本 由 UPnP 论坛工作委员会定义。</li>
<li>urn：schemas-UPnP-org:service:serviceType:v 向每种服务发送一次。服务类型与版本由 UPnP 论坛工作委员会 定义。</li>
</ul>
<p>NTS GENA 规定使用的标头。通知子类型。必须是 ssdp:alive。单一 URI。</p>
<p>USN SSDP 要求使用的标头。 唯一服务名称。 必须是以下一种。 前缀（位于双冒号前）必须与设备描述中的 UDN 元素值相匹配。单一 URI。</p>
<ul>
<li>uuid:device-UUID::UPnP:rootdevice 向根设备发送一次。设备 UUID 由 UPnP 厂商指定。</li>
<li>uuid:device-UUID 向每种设备 （根设备或嵌入式设备） 发送一次。 设备 UUID 由 UPnP 厂商指定。</li>
<li>uuid:device-UUID::urn:schemas-UPnP-org:device:deviceType:v 向每种设备 （根设备或嵌入式设备） 发送一次。 设备 UUID 由 UPnP 厂商指定。设备类型与版本由 UPnP 论坛工作委员会定义。</li>
<li>uuid:device-UUID::urn:schemas-UPnP-org:service:serviceType:v 向每种服务发送一次。设备 UUID 由 UPnP 厂商指定。服务类型 与版本由 UPnP 论坛工作委员会定义。</li>
</ul>
<h3 id="UPnP-离线"><a href="#UPnP-离线" class="headerlink" title="UPnP 离线"></a>UPnP 离线</h3><pre><code>NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900 // 多播地址
NT: urn:schemas-upnp-org:service:ConnectionManager:1
NTS: ssdp:byebye
SERVER: Linux/2.6.32.11.as, UPnP/1.0, Portable SDK for UPnP devices/1.6.18
X-User-Agent: redsonic
USN: uuid:a22d1223-d889-b76b-0cc3-4c484a00002e::urn:schemas-upnp-org:service:ConnectionManager:1</code></pre><h2 id="UPnP-设备描述"><a href="#UPnP-设备描述" class="headerlink" title="UPnP 设备描述"></a>UPnP 设备描述</h2><p>一个设备的 UPnP 描述包含多个特定厂商信息、所有嵌入式设备定义、设 备展示 URL、以及所有服务列表，包括控制 URL 和事件触发 URL。除了定义非 标准设备之外，UPnP 厂商可以为标准设备添加新的嵌入式设备和服务。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;&gt;
    &lt;specVersion&gt;
        &lt;major&gt;1&lt;/major&gt;
        &lt;minor&gt;0&lt;/minor&gt;
    &lt;/specVersion&gt;
    &lt;URLBase&gt;base URL for all relative URLs&lt;/URLBase&gt;
    &lt;device&gt;
        &lt;deviceType&gt;urn:schemas-upnp-org:device:deviceType:v&lt;/deviceType&gt;
        &lt;friendlyName&gt;short user-friendly title&lt;/friendlyName&gt;
        &lt;manufacturer&gt;manufacturer name&lt;/manufacturer&gt;
        &lt;manufacturerURL&gt;URL to manufacturer site&lt;/manufacturerURL&gt;
        &lt;modelDescription&gt;long user-friendly title&lt;/modelDescription&gt;
        &lt;modelName&gt;model name&lt;/modelName&gt;
        &lt;modelNumber&gt;model number&lt;/modelNumber&gt;
        &lt;modelURL&gt;URL to model site&lt;/modelURL&gt;
        &lt;serialNumber&gt;manufacturer&#39;s serial number&lt;/serialNumber&gt;
        &lt;UDN&gt;uuid:UUID&lt;/UDN&gt;
        &lt;UPC&gt;Universal Product Code&lt;/UPC&gt;
        &lt;iconList&gt;
            &lt;icon&gt;
            &lt;mimetype&gt;image/format&lt;/mimetype&gt;
            &lt;width&gt;horizontal pixels&lt;/width&gt;
            &lt;height&gt;vertical pixels&lt;/height&gt;
            &lt;depth&gt;color depth&lt;/depth&gt;
            &lt;url&gt;URL to icon&lt;/url&gt;
            &lt;/icon&gt;
            XML to declare other icons, if any, go here
        &lt;/iconList&gt;
        &lt;serviceList&gt;
            &lt;service&gt;
            &lt;serviceType&gt;urn:schemas-upnp-org:service:serviceType:v&lt;/serviceType&gt;
            &lt;serviceId&gt;urn:upnp-org:serviceId:serviceID&lt;/serviceId&gt;
            &lt;SCPDURL&gt;URL to service description&lt;/SCPDURL&gt;
            &lt;controlURL&gt;URL for control&lt;/controlURL&gt;
            &lt;eventSubURL&gt;URL for eventing&lt;/eventSubURL&gt;
            &lt;/service&gt;
            Declarations for other services defined by a UPnP Forum working committee (if any)
            go here
            Declarations for other services added by UPnP vendor (if any) go here
        &lt;/serviceList&gt;
        &lt;deviceList&gt;
            Description of embedded devices defined by a UPnP Forum working committee (if any)
            go here
            Description of embedded devices added by UPnP vendor (if any) go here
        &lt;/deviceList&gt;
        &lt;presentationURL&gt;URL for presentation&lt;/presentationURL&gt;
    &lt;/device&gt;
&lt;/root&gt;</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://liuweiqiang.win/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/2016/08/29/DLNA-Cling.html" target="_blank" rel="noopener">DLNA 协议分析及应用</a></li>
<li><a href="http://lakeshire.github.io/2017/12/12//archivers/dlna-cling/" target="_blank" rel="noopener">DLNA 开源库——Cling</a></li>
<li><a href="https://www.jianshu.com/p/91b508b0260b" target="_blank" rel="noopener">DLNA 与 UPnP 初探</a></li>
<li><a href="http://101.96.10.64/trinea.github.io/doc/upnp/UPnP-arch-DeviceArchitecture-v1.1.pdf" target="_blank" rel="noopener">UPnP™ Device Architecture 1.1</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>upnp</tag>
        <tag>dlna</tag>
        <tag>ssdp</tag>
        <tag>soap</tag>
      </tags>
  </entry>
  <entry>
    <title>P2P 网络核心技术：UPnP 和 SSDP 协议</title>
    <url>/2019/02/22/upnp-and-ssdp/</url>
    <content><![CDATA[<p><code>DLNA</code> 和 <code>SAT&gt;IP</code> 等功能使用到的核心技术：</p>
<ol>
<li><code>UPnP</code></li>
<li><code>SSDP</code></li>
</ol>
<a id="more"></a>


<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a><strong>背景知识</strong></h2><p>UPnP， Universal Plug and Play，中文是 “通用即插即用”。在理解 UPnP 之前，我们先了解一下传统的 PnP 技术，因为 UPnP 是对于传统 PnP（即插即用）概念的扩展。</p>
<p>传统的 PnP <strong>“即插即用”</strong>是指 PC 电脑在添加硬件设备时可以自动处理的一种标准。在 PnP 技术出现以前，当需要为 PC 电脑安装新的硬件（比如：声卡，CD-ROM，打印机）时，这些设备需要用到 PC 电脑的 DMA 和 IRQ 等资源，为了避免硬件设备对计算机这些资源使用上的冲突，我们就需要<strong>手工为新添加的硬件设备设置中断和 I/O 端口</strong>（比如，想要为添加的声卡占用中断 5，就找一个小跳线在卡上标着中断 5 的针脚上一插）。这样的操作需要用户了解中断和 I/O 端口的知识，并且能够自己分配中断地址而不发生冲突，对普通用户提出这样的要求是不切实际的。</p>
<p>PnP “即插即用”技术出现以后，可以<strong>自动为新添加的硬件分配中断和 I/O 端口，用户无须再做手工跳线，也不必使用软件配置程序</strong>。唯一的要求就是操作系统需要支持 PnP 标准，同时所安装的新硬件也符合 PnP 规范的。</p>
<h2 id="UPnP-协议介绍"><a href="#UPnP-协议介绍" class="headerlink" title="UPnP 协议介绍"></a><strong>UPnP 协议介绍</strong></h2><p>现在我们讲 UPnP，在网络世界里，<strong>当一个主机加入网络时，其行为模式跟我们上述的添加和删除设备是类似的。</strong>尤其是在私有网络和公网交互的时候，私有网络中的主机使用的是内网 IP 地址，是无法被外网的主机直接访问的。必须借助 NAT 网关设备（本地路由器）把内网地址映射到网关的公网地址上。</p>
<p>简单来说就是， NAT 网关设备拥有一个公网 IP 地址（比如 10.59.116.19），内网中的主机（比如 192.168.1.101）想要与外界通信的话，NAT 网关设备可以为其做一个端口映射（比如：180.59.116.19 :80 —&gt; 192.168.1.101 :80），这样，外部的主机发往 NAT 网关的数据包都会被转发给内网的该主机，从而实现了内网中的主机与外部主机的通信。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b9a7c969540269a0f1243ad02487c084_hd.jpg" alt="img"></p>
<p>当内网中的主机想要被外界主机直接访问（比如开放 80 端口，对外提供 HTTP 服务），我们就需要在 NAT 设备中为当前主机手工配置端口映射，如果内网中有多台主机都想要被外界主机直接访问的话，我们必须在同一个 NAT 设备上为这些主机分别做端口映射，它们之间不能使用有冲突的端口。这个过程需要用户手工一一配置，显然给用户带来了很大的麻烦。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c0bea083aa0415c42042f7fe60506640_hd.jpg" alt="img"></p>
<p>UPnP 技术标准的出现就是为了解决这个问题，只要 NAT 设备（路由器）支持 UPnP，并开启。那么，当我们的主机（或主机上的应用程序）向 NAT 设备发出端口映射请求的时候，<strong>NAT 设备就可以自动为主机分配端口并进行端口映射</strong>。这样，我们的主机就能够像公网主机一样被网络中任何主机访问了。</p>
<h2 id="UPnP-的应用场景"><a href="#UPnP-的应用场景" class="headerlink" title="UPnP 的应用场景"></a><strong>UPnP 的应用场景</strong></h2><p>UPnP 典型的应用场景就是家庭智能设备的互联，还有，目前在网络应用比如 BitTorrent, eMule，IPFS，Ethereum 等使用 P2P 技术的软件，UPnP 功能为它们带来极大的便利。比如：利用 UPnP 能自动的把它们侦听的端口号映射到公网地址上，这样，公网上的用户也能对当前的 NAT 内网主机直接发起连接。</p>
<p>实现 UPnP 必须同时满足三个条件：</p>
<ul>
<li>NAT 网关设备必须支持 UPnP 功能；这是因为它需要扮演控制点（239.255.255.250:1900）的角色，控制点提供的是 SSDP 服务。</li>
<li>操作系统必须支持 UPnP 功能；比如 Windows 系列操作系统；</li>
<li>应用程序必须支持 UPnP 功能；比如 Bt、eMule、IPFS, Ethereum 等。</li>
</ul>
<p>以上三个条件必须同时满足，缺一不可。</p>
<p><strong>注：</strong>大多数路由器都是支持 UPnP 的，有的是默认开启，有的需要手工开启。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0640425d49c52e1aa83870111a608cb2_hd.jpg" alt="img"></p>
<h2 id="UPnP-这么好，那么我们应该立即开启吗？"><a href="#UPnP-这么好，那么我们应该立即开启吗？" class="headerlink" title="UPnP 这么好，那么我们应该立即开启吗？"></a>UPnP 这么好，那么我们应该立即开启吗？</h2><p>非也，如果我们的电脑并不需要 UPnP 所提供的功能，比如，我们的电脑并不想要对外直接提供服务，也不运行上述 P2P 软件，那么我们就无需开启 UPnP。因为一旦开启 UPnP，就意味着我们把自己的主机暴露在公网环境中，任何主机都可以向我们的电脑发起连接，NAT 设备会对所有收到的数据包不进行任何 authentication 认证而转发给我们的主机，这样，路由防火墙就会完全失效，我们的主机就很容易受到恶意的网络窥探，感染病毒或者恶意程序的几率也大大增加。</p>
<p><strong>注：</strong>上述 NAT 设备通常就是指我们本地的路由器。</p>
<h2 id="SSDP-协议"><a href="#SSDP-协议" class="headerlink" title="SSDP 协议"></a><strong>SSDP 协议</strong></h2><p>介绍完了 UPnP 的概况，为了完整性，现在再介绍一下 UPnP 规范下的 SSDP 协议，SSDP 全称是 Simple Service Discover Protocol 简单服务发现协议，这个协议是 UPnP 的核心，在 UPnP 中定义了一组协议框架，其中有控制点，根设备等概念，UPnP 设备通过 SSDP 协议与根设备（用户设备）进行交互。SSDP 是应用层协议，使用 HTTPU 和 HTTPMU 规范，基于 UDP 端口进行通信。</p>
<p><strong>SSDP 使用一个固定的组播地址 <code>239.255.255.250</code> 和 UDP 端口号 <code>1900</code> 来监听其他设备的请求。</strong></p>
<p>SSDP 协议的请求消息有两种类型，第一种是服务通知，设备和服务使用此类通知消息声明自己存在；第二种是查询请求，协议客户端用此请求查询某种类型的设备和服务。</p>
<h3 id="1）设备查询"><a href="#1）设备查询" class="headerlink" title="1）设备查询"></a><strong>1）设备查询</strong></h3><p>当一个客户端接入网络的时候，它可以向一个特定的多播地址的 SSDP 端口使用 <code>M-SEARCH</code> 方法发送 “ssdp:discover” 消息。当设备监听到这个保留的多播地址上由控制点发送的消息的时候，设备将通过单播的方式直接响应控制点的请求。</p>
<p>典型的设备查询请求消息格式：</p>
<pre><code class="bash">M-SEARCH * HTTP/1.1
S:uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6
Host:239.255.255.250:1900
Man:&quot;ssdp:discover&quot;ST:ge:fridge
MX:3</code></pre>
<p><strong>响应消息</strong></p>
<p>响应消息应该包含服务的位置信息（Location 或 AL 头），ST 和 USN 头。响应消息应该包含 cache 控制信息（max-age 或者 Expires 头）。</p>
<p>典型的响应消息格式：</p>
<pre><code class="js">HTTP/1.1 200 OK
Cache-Control: max-age= seconds until advertisement expires
S: uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6
Location: URL for UPnP description for root device
Cache-Control: no-cache=&quot;Ext&quot;,max-age=5000ST:ge:fridge // search targetUSN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6 // advertisement UUIDAL: &lt;blender:ixl&gt;&lt;http://foo/bar&gt;</code></pre>
<h3 id="2、设备通知消息"><a href="#2、设备通知消息" class="headerlink" title="2、设备通知消息"></a><strong>2、设备通知消息</strong></h3><p>在设备加入网络时，它应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:alive” 消息，以便宣布自己的存在，更新期限信息，更新位置信息。</p>
<h4 id="（1）ssdp-alive-消息"><a href="#（1）ssdp-alive-消息" class="headerlink" title="（1）ssdp:alive 消息"></a>（1）ssdp:alive 消息</h4><p>由于 UDP 协议是不可信的，设备应该定期发送它的公告消息。在设备加入网络时，它必须用 NOTIFY 方法发送一个多播传送请求。NOTIFY 方法发送的请求没有回应消息。</p>
<p>典型的设备通知消息格式如下：</p>
<pre><code class="text">NOTIFY * HTTP/1.1HOST: 239.255.255.250:1900CACHE-CONTROL: max-age = seconds until advertisement expiresLOCATION: URL for UPnP description for root deviceNT: search targetNTS: ssdp:aliveUSN: advertisement UUID</code></pre>
<h4 id="（2）ssdp-byebye-消息"><a href="#（2）ssdp-byebye-消息" class="headerlink" title="（2）ssdp:byebye 消息"></a>（2）ssdp:byebye 消息</h4><p>当一个设备计划从网络上卸载的时候，它也应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:byebye” 消息。但是，即使没有发送 “ssdp:byebye” 消息，控制点也会根据 “ssdp:alive” 消息指定的超时值，将超时并且没有再次收到的 “ssdp:alive” 消息对应的设备认为是失效的设备。</p>
<p>典型的设备卸载消息格式如下：</p>
<pre><code class="text">NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900NT: search target
NTS: ssdp:byebye
USN: advertisement UUID</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、SSDP 协议原文：<a href="http://link.zhihu.com/?target=http%3A//tools.ietf.org/html/draft-cai-ssdp-v1-03">http://tools.ietf.org/html/draft-cai-ssdp-v1-03</a><br>2、UPnP 协议框架：<a href="http://link.zhihu.com/?target=http%3A//www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.0.pdf">http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.0.pdf</a></p>
]]></content>
      <categories>
        <category>Network</category>
        <category>UPnP</category>
      </categories>
      <tags>
        <tag>upnp</tag>
        <tag>dlna</tag>
        <tag>sat2ip</tag>
        <tag>ssdp</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc 与 mmap 内存读写效率问题</title>
    <url>/2019/01/30/mmap-and-malloc/</url>
    <content><![CDATA[<p>记录由于 <code>cache</code> 导致的 <code>malloc</code> 和 <code>mmap</code> 读写速率差异，<a href="https://groups.google.com/forum/#!topic/zh-kernel/tywP7NFyBcs" target="_blank" rel="noopener">原文地址</a></p>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现在在一个嵌入式平台上遇到内存读写效率问题：<br>应用层分出 2 类内存：一种是 <code>malloc</code> 分配出来的，<br>第二种通过内核 <code>ioremap</code> 一块内存，再将这块内存 <code>mmap</code> 给应用。<br>（这块内存在内核管理范围之外，即 <code>DDR</code> 总共 128MB，内核参数指定 <code>mem=64MB</code>， <code>ioremap</code> 出后 64MB，然后 <code>mmap</code> 给应用）</p>
<p>应用层测试发现，</p>
<ol>
<li><code>malloc</code> 出的内存之间读写速度可以达到 170MBps，</li>
<li><code>malloc</code> 内存与 <code>mmap</code> 内存之间的读写速度只有 40MBps 左右，</li>
<li><code>mmap</code> 内存与 <code>mmap</code> 内存之间的读写速度更低些大约只有 30MBps。</li>
</ol>
<p>而内核下测试，<br><code>ioremap</code> 出的内存与 <code>vmalloc/kmalloc</code> 出的内存之间的读写速度，基本保持一致。</p>
<p>怀疑这种差异跟 <code>mmap</code> 有关，但是又不太熟悉内核内存管理这块，不太清楚 <code>malloc</code> 出的内存与 <code>mmap</code> 出的内存之间的本质区别，所以向各位请教下，这 2 种不同方式分配出的内存为什么读写效率上存在如此大的差异？</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li>在 <code>kernel</code> 里使用 <code>ioremap</code> 分配出来的一段 <code>memory</code> 不经过 <code>cache</code> （或者说对这一段 memory 的读写都会直接操作 memory）并且物理地址是连续的，而 <code>user space</code> 里使用 <code>malloc</code> 分配出来的 <code>memory</code> 则没有以上保证，我看不出来在 <code>MMU enable</code> 的情况下物理地址是否连续对 <code>memory</code> 的读写效率有什么影响，所以问题应该在是否经过 <code>cache</code> 这里，我也不是很确定。</li>
<li>感觉不是 <code>ioremap</code> 的问题，因为我用 <code>get_free_pages</code> 申请内核管理的一段连续内存再 <code>mmap</code> 给应用，情况也是一样。 我尝试在驱动的 <code>mmap</code> 函数中将 <code>vma-&gt;vm_page_prot</code> 由 <code>pgprot_noncached</code> 修改为 <code>pgprot_writecombine</code>。读取 <code>mmap</code> 内存到 <code>malloc</code> 内存的速度几乎无变化，但写 <code>malloac</code> 内存到 <code>mmap</code> 内存的速度有近乎 2 倍提升。</li>
<li><code>nocached</code> 和 <code>writecombine</code> 应该都是 <code>bypass</code>。 <code>cache</code> 系统的， <code>nocached</code> 是对每个 <code>byte</code> 操作都发起一个内存请求，而 <code>writecombine</code> 是能合并多个内存请求为一个，从而减少内存请求的数量。</li>
<li>使用默认的 <code>vm_page_prot</code> （使用 <code>cache</code> 和 <code>writebuffer</code> )， <code>mmap</code> 和 <code>malloc</code> 内存的速度测试可以一致。 之前使用 <code>nocache</code> 的原因是共享出的内存需要与另外一个异构核通信，为了避免 <code>cache</code> 引发通信出错而设置的。现在可以想办法区分这两种情况。</li>
</ol>
<h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><p>播放网络视频频繁缓冲，最后结论：</p>
<p><strong>usb 转网口拷贝时 DMA 使用的地址带 cache，而网卡直连时 DMA 使用的地址不带 cache，所以网卡直连时 memcpy 速度慢。</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MM</category>
      </categories>
      <tags>
        <tag>malloc</tag>
        <tag>linux</tag>
        <tag>cache</tag>
        <tag>mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>MPE Encapsulation</title>
    <url>/2019/01/18/dvb-mpe-Encapsulation/</url>
    <content><![CDATA[<p><code>MPE</code>数据封装格式</p>
<p><code>dvb ts</code> -&gt; <code>mpe</code> -&gt; <code>ip</code> -&gt; <code>udp</code></p>
<a id="more"></a>

<p><code>MPE table id</code>如下</p>
<p><img src="/images/mpe/mpe-tableid.png" alt="MPE Table Id"></p>
<p><code>MPE</code>数据封装如下</p>
<p><img src="/images/mpe/mpe.png" alt="MPE Data"></p>
<p><code>MPE Headers</code>如下</p>
<p><img src="/images/mpe/mpe-headers.png" alt="MPE Headers"></p>
<p><code>MPEG2 TS</code>及<code>MPE</code>如下</p>
<p><img src="/images/mpe/mpeg-ts.jpg" alt="TS Header"></p>
<p><code>ip header</code>如下</p>
<p><img src="/images/mpe/ip-header.jpg" alt="IP Header"></p>
<p><code>udp header</code>如下</p>
<p><img src="/images/mpe/udp-header.png" alt="UDP Header"></p>
]]></content>
      <categories>
        <category>DVB</category>
      </categories>
      <tags>
        <tag>dvb</tag>
        <tag>mpe</tag>
        <tag>ip header</tag>
        <tag>udp header</tag>
      </tags>
  </entry>
  <entry>
    <title>airkiss server 实现过程遇到的问题</title>
    <url>/2019/01/10/airkiss-udp-problems/</url>
    <content><![CDATA[<p><code>airkiss server</code>使用<code>udp broadcast</code>实现，包括两部分</p>
<ol>
<li><code>udp client</code>广播<code>airkiss</code>编码数据</li>
<li><code>udp server</code>接收<code>device</code>广播的<code>random</code>数据</li>
</ol>
<a id="more"></a>

<h2 id="socket-type"><a href="#socket-type" class="headerlink" title="socket type"></a>socket type</h2><p>常用的三种类型</p>
<ol>
<li><code>SOCK_STREAM</code>流式的套接字可以提供可靠的、面向连接的通讯流</li>
<li><code>SOCK_DGRAM</code>数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠，无差错</li>
<li><code>SOCK_RAW</code>原始套接字主要用于一些协议的开发，可以进行比较底层的操作</li>
</ol>
<p>关系如下<br><img src="/images/socket/SOCK-TYPE.jpg" alt=""></p>
<p>其中<code>SOCK_STREAM (TCP)</code>、<code>SOCK_DGRAM (UDP)</code>工作在传输层，<code>SOCK_RAW</code>工作在网络层。<code>SOCK_RAW</code>可以处理<code>ICMP</code>、<code>IGMP</code>等网络报文、特殊的<code>IPv4</code>报文、可以通过<code>IP_HDRINCL</code>套接字选项由用户构造<code>IP</code>头。</p>
<h2 id="setsocket-指定-interface"><a href="#setsocket-指定-interface" class="headerlink" title="setsocket 指定 interface"></a>setsocket 指定 interface</h2><p><code>socket</code>发送数据默认根据路由表来发送，如果要指定<code>interface</code>可以使用<code>setsocket</code>选项<code>SO_BINDTODEVICE</code>来实现</p>
<pre><code class="c">struct ifreq ifr;
memset(&amp;ifr, 0, sizeof(ifr));
snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), &quot;wlan0&quot;);
if ((rc = setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, (void *)&amp;ifr, sizeof(ifr))) &lt; 0) {
    perror(&quot;Server-setsockopt() error for SO_BINDTODEVICE&quot;);
    printf(&quot;%s\n&quot;, strerror(errno));
    close(sock);
    exit(-1);
}</code></pre>
<blockquote>
<p><strong>需要注意测试时，<code>server</code>与<code>client</code>要选定相同的<code>interface</code>，否则不再一个子网中，导致测试失败</strong></p>
</blockquote>
<p>参考文章：<a href="https://blog.csdn.net/eqiang8271/article/details/6793089" target="_blank" rel="noopener">setsockopt 的 SO_BINDTODEVICE 套接口选项</a></p>
<ol>
<li>对于<code>TCP 套接口</code>、<code>UDP 套接口</code>、<code>RAW 套接口</code>，可以通过<code>SO_BINDTODEVICE 套接口选项</code>将套接口绑定到指定的网络接口上。绑定之后，套接口的所有数据包收发都只经过指定的网络接口</li>
<li>对于<code>PACKET 类型的套接口</code>，不能通过<code>SO_BINDTODEVICE</code>绑定到指定的网络接口上，而要通过<code>bind(2)</code>来与特定的网络接口绑定，所用的套接口地址结构为<code>struct sockaddr_ll</code>，此套接口地址结构是链路层的地址结构，独立于具体的网络设备。比如，该地址结构既可以用于表示<code>PPP 设备</code>，也能用于表示<code>ethernet 设备</code></li>
</ol>
<h2 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h2><p>广播地址<code>255.255.255.255</code>，在头文件<code>netinet/in.h</code>中定义为<code>INADDR_BROADCAST</code></p>
<pre><code class="c">/* Address to accept any incoming messages. */
#define INADDR_ANY      ((unsigned long int) 0x00000000)

/* Address to send to all hosts. */
#define INADDR_BROADCAST    ((unsigned long int) 0xffffffff)</code></pre>
<ul>
<li><code>INADDR_ANYA</code>表示地址为<code>0.0.0.0</code>，表示不确定地址、任意地址或所有地址。也就是表示本机的所有<code>IP</code>，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡<code>IP</code>地址的意思</li>
<li><code>INADDR_BROADCAST</code>表示广播地址<code>255.255.255.255</code>，仅用于本地连接，如果不指定<code>interface</code>，根据路由表确定</li>
</ul>
<h3 id="设置广播属性"><a href="#设置广播属性" class="headerlink" title="设置广播属性"></a>设置广播属性</h3><pre><code class="c">/* Set socket to allow broadcast */
broadcastPermission = 1;
if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (void *) &amp;broadcastPermission,
               sizeof(broadcastPermission)) &lt; 0) {
    printf(&quot;setsockopt() SO_BROADCAST failed\n&quot;);
}</code></pre>
<h3 id="udp-broadcast"><a href="#udp-broadcast" class="headerlink" title="udp broadcast"></a>udp broadcast</h3><pre><code class="c">/* Create socket for sending/receiving datagrams */
if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0) {
    printf(&quot;socket() failed\n&quot;);
}
/* Set socket to allow broadcast */
broadcastPermission = 1;
if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (void *) &amp;broadcastPermission,
            sizeof(broadcastPermission)) &lt; 0) {
    printf(&quot;setsockopt() SO_BROADCAST failed\n&quot;);
}
struct sockaddr_in broadcastAddr;
char *buffer = NULL;

buffer = malloc(length);
memset(buffer, &#39;a&#39;, length);

/* Construct local address structure */
memset(&amp;broadcastAddr, 0, sizeof(broadcastAddr));           /* Zero out structure */
broadcastAddr.sin_family = AF_INET;                         /* Internet address family */
broadcastAddr.sin_addr.s_addr = INADDR_BROADCAST;           /* Broadcast IP address */
broadcastAddr.sin_port = htons(BROADCAST_PORT);             /* Broadcast port */

sendto(s_akHandler.sock_fd, buffer, length, 0, (struct sockaddr *)&amp;broadcastAddr, sizeof(broadcastAddr));</code></pre>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><ol>
<li><code>TCP</code>通信时，<code>server</code>必须<code>bind</code>自己本机地址和端口。<code>client</code>不需要<code>blind</code></li>
<li><code>UDP</code>通信时与<code>TCP</code>一样</li>
</ol>
<p><code>bind</code>不是<code>server</code>专属，一般情况下<code>client</code>是不用调用<code>bind</code>的，一切都交给内核搞定！</p>
<p><code>server</code>需要<code>bind</code>的原因</p>
<blockquote>
<p>因为服务器是时时在监听有没有客户端的连接，如果服务器不绑定 IP 和端口的话，客户端上线的时候怎么连到服务器呢，所以服务器要绑定 IP 和端口，而客户端就不需要了，客户端上线是主动向服务器发出请求的，因为服务器已经绑定了 IP 和端口，所以客户端上线的就向这个 IP 和端口发出请求，这时因为客户开始发数据了（发上线请求）, 系统就给客户端分配一个随机端口，这个端口和客户端的 IP 会随着上线请求一起发给服务器，服务收到上线请求后就可以从中获起发此请求的客户的 IP 和端口，接下来服务器就可以利用获起的 IP 和端口给客户端回应消息了</p>
</blockquote>
<p><code>server</code>需要<code>bind</code>：<code>port</code>和<code>ip addr</code></p>
<ul>
<li><code>port</code>包括公共端口和私有端口</li>
<li><code>ip addr</code>目的是限制了服务端进程创建的 socket 只接受那些目的地为此 IP 地址的客户链接，一般<code>server</code>使用<code>servaddr.sin_addr.s_addr = htonl(INADDR_ANY)</code>，表示不指定<code>client ip</code>，来者不拒</li>
</ul>
<h2 id="数据收发时限"><a href="#数据收发时限" class="headerlink" title="数据收发时限"></a>数据收发时限</h2><pre><code class="c">struct timeva timeout;
timeout.tv_sec=5;
timeout.tv_usec=0;

// 接受时限
setsockopt(serversocket, SQL_SOCKET,SO_RCVTIMEO, (char*)&amp;timeout,sizeof(timeout));

// 发送时限
setsockopt(serversocket, SQL_SOCKET,SO_SNDTIMEO, (char*)&amp;timeout,sizeof(timeout));</code></pre>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="udp-server"><a href="#udp-server" class="headerlink" title="udp server"></a>udp server</h3><pre><code class="c">#include &lt;stdio.h&gt;      // Default System Calls
#include &lt;stdlib.h&gt;     // Needed for OS X
#include &lt;string.h&gt;     // Needed for Strlen
#include &lt;sys/socket.h&gt; // Needed for socket creating and binding
#include &lt;netinet/in.h&gt; // Needed to use struct sockaddr_in
#include &lt;time.h&gt;       // To control the timeout mechanism

#define EXPR_SIZE   1024
#define BUFLEN      512
#define TRUE        1
#define SERVERLEN   1024

int main(int argc, char **argv){

    struct sockaddr_in myaddr;  // address of the server
    struct sockaddr_in claddr;  // address of the client
    char buf[BUFLEN];
    int fd;
    long recvlen;
    socklen_t clientlen;



    if((fd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0){
        perror(&quot;cannot create socket&quot;);
        return 0;
    }

    memset((char *)&amp;myaddr, 0, sizeof(myaddr));
    myaddr.sin_family = AF_INET;
    myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    myaddr.sin_port = htons(0);

    if(bind(fd, (struct sockaddr *)&amp;myaddr, sizeof(myaddr)) &lt; 0){
        perror(&quot;cannot bind&quot;);
        return 0;
    }
    clientlen = sizeof(claddr);

    while (TRUE) {
        recvlen = recvfrom(fd, buf, BUFLEN, 0, (struct sockaddr *)&amp;claddr, &amp;clientlen);
        if (recvlen &lt; 0) {
            perror(&quot;cannot recvfrom()&quot;);
            return 0;
        }
        printf(&quot;Received %ld bytes\n&quot;,recvlen);
        buf[recvlen] = 0;
        printf(&quot;Received message: \&quot;%s\&quot;\n&quot;,buf);

    }

    return 0;
}</code></pre>
<h3 id="udp-client"><a href="#udp-client" class="headerlink" title="udp client"></a>udp client</h3><p>使用<code>bind</code>版本</p>
<pre><code class="c">#include &lt;stdio.h&gt;      // Default System Calls
#include &lt;stdlib.h&gt;     // Needed for OS X
#include &lt;string.h&gt;     // Needed for Strlen
#include &lt;sys/socket.h&gt; // Needed for socket creating and binding
#include &lt;netinet/in.h&gt; // Needed to use struct sockaddr_in
#include &lt;time.h&gt;       // To control the timeout mechanism

#define EXPR_SIZE   1024
#define BUFLEN      512
#define TRUE        1
#define FALSE       0
#define SERVERLEN   1024

int main(int argc, char **argv){

    long portNum;           // Since it&#39;s possible to input a value bigger
                            // than 65535 we&#39;ll be using long to
                            // avoid overflows
    char expr[EXPR_SIZE];
    char server[SERVERLEN];
    int fd;                 // file descriptor for the connected socket
    int buf[512];
    struct hostent *h;           // information of the host
    unsigned int addrLen;        // address length after getting the port number
    struct sockaddr_in myaddr;   // address of the client
    struct sockaddr_in servaddr; // server&#39;s address
    unsigned int exprLen;
    socklen_t slen = sizeof(servaddr);

    printf(&quot;Enter server name or IP address:&quot;);
    scanf(&quot;%s&quot;,server);
    printf(&quot;Enter port:&quot;);
    scanf(&quot;%ld&quot;,&amp;portNum);
    if ((portNum &lt; 0) || (portNum &gt; 65535)) {
        printf(&quot;Invalid port number. Terminating.&quot;);
        return 0;
    }
    printf(&quot;Enter expression:&quot;);
    scanf(&quot;%s&quot;,expr);

    if((fd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0){
        perror(&quot;cannot create socket&quot;);
        return 0;
    }

    memset((char *)&amp;myaddr, 0, sizeof(myaddr));
    myaddr.sin_family = AF_INET;
    myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    myaddr.sin_port = htons(0);

    if(bind(fd, (struct sockaddr *)&amp;myaddr, sizeof(myaddr)) &lt; 0){
        perror(&quot;cannot bind&quot;);
        return 0;
    }

    /*
     // Discovering the port number the OS allocated
     addrLen = sizeof(myaddr);
     if(getsockname(fd, (struct sockaddr *)&amp;myaddr, &amp;addrLen) &lt; 0){
     perror(&quot;cannot getsockname&quot;);
     return 0;
     }
     printf(&quot;local port number = %d\n&quot;, ntohs(myaddr.sin_port));
     */

    memset((char*)&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htonl(portNum);

    exprLen = sizeof(expr);


    while(TRUE){
        printf(&quot;Sending message to %s port %ld\n&quot;,server, portNum);
        if (sendto(fd, expr, strlen(expr), 0, (struct sockaddr *)&amp;servaddr, slen) &lt; 0) {
            perror(&quot;cannot sendto()&quot;);
        }
        printf(&quot;Success\n&quot;);

    }


    return 0;
}</code></pre>
<p>不使用<code>bind</code>版本</p>
<pre><code class="c">#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;unistd.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;errno.h&gt;
#include&lt;netdb.h&gt;
#include&lt;stdarg.h&gt;
#include&lt;string.h&gt;

#define SERVER_PORT 8000
#define BUFFER_SIZE 1024
#define FILE_NAME_MAX_SIZE 512

int main()
{
    /* 服务端地址 */
    struct sockaddr_in server_addr;
    bzero(&amp;server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    //server_addr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
    server_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
    server_addr.sin_port = htons(SERVER_PORT);

    /* 创建 socket */
    int client_socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (client_socket_fd &lt; 0) {
        perror(&quot;Create Socket Failed:&quot;);
        exit(1);
    }

    /* 输入文件名到缓冲区 */
    char file_name[FILE_NAME_MAX_SIZE + 1];
    bzero(file_name, FILE_NAME_MAX_SIZE + 1);
    printf(&quot;Please Input File Name On Server:\t&quot;);
    scanf(&quot;%s&quot;, file_name);

    char buffer[BUFFER_SIZE];
    bzero(buffer, BUFFER_SIZE);
    strncpy(buffer, file_name, strlen(file_name) &gt; BUFFER_SIZE ? BUFFER_SIZE : strlen(file_name));

    /* 发送文件名 */
    if (sendto(client_socket_fd, buffer, BUFFER_SIZE, 0, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) {
        perror(&quot;Send File Name Failed:&quot;);
        exit(1);
    }

    close(client_socket_fd);
    return 0;
}</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://stackoverflow.com/questions/3998569/how-to-bind-raw-socket-to-specific-interface" target="_blank" rel="noopener">how to bind raw socket to specific interface</a></li>
<li><a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-45900/index.html" target="_blank" rel="noopener">广播及确定网络配置</a></li>
<li><a href="https://stackoverflow.com/questions/683624/udp-broadcast-on-all-interfaces" target="_blank" rel="noopener">UDP-Broadcast on all interfaces</a></li>
<li><a href="http://blog.51cto.com/a1liujin/1699540" target="_blank" rel="noopener">socket 下的广播与多播实现</a></li>
<li><a href="https://www.jianshu.com/p/498c63d13ff2" target="_blank" rel="noopener">Linux 网络编程之 UDP Socket 程序示例</a></li>
<li><a href="https://blog.csdn.net/suxinpingtao51/article/details/11809011" target="_blank" rel="noopener">socket 通信关于 bind 那点事</a></li>
<li><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/17482209" target="_blank" rel="noopener">简单分析一下 socket 中的 bind</a></li>
<li><a href="https://blog.csdn.net/stpeace/article/details/45001255" target="_blank" rel="noopener">为什么 TCP 服务端需要调用 bind 函数而客户端通常不需要呢？</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>Airkiss</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>airkiss</tag>
        <tag>udp</tag>
        <tag>broacast</tag>
      </tags>
  </entry>
  <entry>
    <title>无线嗅探及 airkiss 协议分析</title>
    <url>/2019/01/04/airkiss/</url>
    <content><![CDATA[<p><code>airkiss</code> 用于智能配网，基于 <code>802.11</code> 协议，本文记录相关知识点</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>airkiss</code> 首先需要网卡有监听空中无线包的能力，包括 <code>监听</code> 和 <code>混杂</code> 两种模式，并以 <code>802.11</code> 格式从数据链路层截取数据（要求的是不带 <code>radiotap header</code> 的 <code>802.11</code> 数据帧）</p>
<h2 id="radiotap-header"><a href="#radiotap-header" class="headerlink" title="radiotap header"></a>radiotap header</h2><p><code>radiotap</code> 包含了信号强度、噪声强度、信道、时间戳等信息。 <code>radiotap</code> 比传统的 <code>Prism</code> 或 <code>AVS</code> 头更有灵活性，成为 <code>ieee802.11</code> 事实上的标准。在 <code>WLAN</code> 无线网络抓包的时候不管是用 <code>wireshark</code>、 <code>tcpdump</code> 还是 <code>scapy</code> 都会出现 <code>Radiotap</code>、 <code>LLC</code>、 <code>SNAP</code> 协议层。典型数据帧如下</p>
<pre><code>Frame 6662: 103 bytes on wire (824 bits), 103 bytes captured (824 bits) on interface 0
Radiotap Header v0, Length 21
    Header revision: 0
    Header pad: 0
    Header length: 21
    Present flags
    Flags: 0x00
    Channel frequency: 2422 [BG 3]
    Channel flags: 0x0480, 2 GHz spectrum, Dynamic CCK-OFDM
    Antenna signal: -49dBm
    Antenna: 1
    RX flags: 0x0000
    MCS information
    [Data Rate: 65.0 Mb/s]
802.11 radio information
IEEE 802.11 QoS Data, Flags: .p.....T
Data (48 bytes)</code></pre><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>每一次接收到的 <code>802.11</code> 帧中只需要解析出 <code>length</code>， <code>airkiss</code> 就是围绕 <code>length</code> 进行编码的协议， <code>length</code> 为 <code>802.11</code> 数据帧长度，</p>
<p>配合开源工程 <a href="https://github.com/pannzh/Airkiss" target="_blank" rel="noopener">Airkiss</a> 分析协议过程如下</p>
<ul>
<li><code>Cap len</code> 为读取携带 <code>radiotap header</code> 的原始数据长度，十进制</li>
<li><code>length</code> 为计算之后 <code>802.11</code> 数据长度，且过滤不符合的数据帧，十六进制</li>
</ul>
<p><code>length</code> 为计算之后 <code>802.11</code> 数据长度，且过滤不符合的数据帧，十六进制</p>
<h3 id="discover-发现过程"><a href="#discover-发现过程" class="headerlink" title="discover- 发现过程"></a>discover- 发现过程</h3><p>协议规定发送前导码 <code>{1, 2, 3, 4}</code>，这个值是差异值，在 <code>wireshark</code> 抓包如下</p>
<pre><code>314    0.000342132    HuaweiTe_0e:74:56    Broadcast    802.11    100    795    QoS Data, SN=795, FN=0, Flags=.p.....T
318    0.000077578    HuaweiTe_0e:74:56    Broadcast    802.11    101    796    QoS Data, SN=796, FN=0, Flags=.p.....T
322    0.000007695    HuaweiTe_0e:74:56    Broadcast    802.11    102    797    QoS Data, SN=797, FN=0, Flags=.p.....T
326    0.000035866    HuaweiTe_0e:74:56    Broadcast    802.11    103    798    QoS Data, SN=798, FN=0, Flags=.p.....T</code></pre><p>其中 <code>radiotap header</code> 长度为 <code>21</code>，代码判断如下</p>
<pre><code class="c">// 1 2 3 4
if((_akcontext.data.guide_code.length_record[1] - _akcontext.data.guide_code.length_record[0] == 1) &amp;&amp;
(_akcontext.data.guide_code.length_record[2] - _akcontext.data.guide_code.length_record[1] == 1) &amp;&amp;
(_akcontext.data.guide_code.length_record[3] - _akcontext.data.guide_code.length_record[2] == 1))
{
    _akcontext.base_len = _akcontext.data.guide_code.length_record[0] - 1;
    success = 1;
}

if(success)
{
    _akcontext.airkiss_state = AIRKISS_STATE_SRC_LOCKED;
    resest_airkiss_data();
    akconf-&gt;printf(&quot;airkiss_recv_discover success\n&quot;);
    akconf-&gt;printf(&quot;base len:%d\n&quot;, _akcontext.base_len);
}</code></pre>
<p>调试打印</p>
<pre><code>Cap len:100
length:4f --&gt; 0x1
Cap len:46
length:1c
Cap len:34
length:10
Cap len:28
length:a
Cap len:101
length:50 --&gt; 0x2
Cap len:46
length:1c
Cap len:44
length:1a
Cap len:28
length:a
Cap len:34
length:10
Cap len:28
length:a
Cap len:102
length:51 -&gt; 0x3
Cap len:46
length:1c
Cap len:28
length:a
Cap len:34
length:10
Cap len:28
length:a
Cap len:103
length:52 --&gt; 0x4
airkiss_recv_discover success
base len:78
Lock channel in 3</code></pre><h3 id="magic-code-字段"><a href="#magic-code-字段" class="headerlink" title="magic code 字段"></a>magic code 字段</h3><p><code>magic code</code> 由 4 个 <code>9bits</code> 组成，格式如下</p>
<pre><code>第 1 个 9bits 0x0 length(high)
第 2 个 9bits 0x1 length(low)
第 3 个 9bits 0x2 ssid crc(high)
第 4 个 9bits 0x3 ssid crc(low)</code></pre><p><code>length</code> 为要发送数据的长度， <code>ssid crc</code> 为要发送 <code>ssid</code> 的 <code>crc8</code> 值</p>
<p>代码如下</p>
<pre><code class="c">if(((_akcontext.data.magic_code.record[0]&amp;0x01f0)==0x0000)&amp;&amp;
    ((_akcontext.data.magic_code.record[1]&amp;0x01f0)==0x0010)&amp;&amp;
        ((_akcontext.data.magic_code.record[2]&amp;0x01f0)==0x0020)&amp;&amp;
        ((_akcontext.data.magic_code.record[3]&amp;0x01f0)==0x0030))
{
    _akcontext.total_len = ((_akcontext.data.magic_code.record[0] &amp; 0x000F) &lt;&lt; 4) + (_akcontext.data.magic_code.record[1] &amp; 0x000F);
    _akcontext.ssid_crc = ((_akcontext.data.magic_code.record[2] &amp; 0x000F) &lt;&lt; 4) + (_akcontext.data.magic_code.record[3] &amp; 0x000F);
    //TODO:double check magic code
    _akcontext.airkiss_state = AIRKISS_STATE_MAGIC_CODE_COMPLETE;
    resest_airkiss_data();
    akconf-&gt;printf(&quot;airkiss_process_magic_code success\n&quot;);
    akconf-&gt;printf(&quot;total_len:%d, ssid crc:%x\n&quot;, _akcontext.total_len, _akcontext.ssid_crc);
}</code></pre>
<p>调试打印信息</p>
<pre><code>Cap len:100
length:4f --&gt; 0x1
Cap len:46
Cap len:34
Cap len:34
Cap len:34
Cap len:28
Cap len:124
length:67 --&gt; 0x19
Cap len:46
Cap len:119
Cap len:131
length:6e --&gt; 0x20
Cap len:46
Cap len:162
length:8d --&gt; 0x3f
airkiss_process_magic_code success
total_len:25, ssid crc:f</code></pre><h3 id="prefix-code"><a href="#prefix-code" class="headerlink" title="prefix code"></a>prefix code</h3><p><code>prefix code</code> 由 4 个 <code>9bits</code> 组成，格式如下</p>
<pre><code>第 1 个 9bits 0x4 psw length(high)
第 2 个 9bits 0x5 psw length(low)
第 3 个 9bits 0x6 psw len crc(high)
第 4 个 9bits 0x7 psw len crc(low)</code></pre><p><code>psw length</code> 为要发送 <code>psw</code> 的长度， <code>psw len crc</code> 为 <code>psw len</code> 的 <code>crc8</code> 值</p>
<p>代码如下：</p>
<pre><code class="c">if((_akcontext.data.prefix_code.record[0]&amp;0x01f0)==0x0040&amp;&amp;
    (_akcontext.data.prefix_code.record[1]&amp;0x01f0)==0x0050&amp;&amp;
        (_akcontext.data.prefix_code.record[2]&amp;0x01f0)==0x0060&amp;&amp;
        (_akcontext.data.prefix_code.record[3]&amp;0x01f0)==0x0070)
{
    _akcontext.pswd_len = ((_akcontext.data.prefix_code.record[0] &amp; 0x000F) &lt;&lt; 4) + (_akcontext.data.prefix_code.record[1] &amp; 0x000F);
    if(_akcontext.pswd_len &gt; PASSWORD_MAX_LEN)
        _akcontext.pswd_len = 0;
    _akcontext.pswd_lencrc = ((_akcontext.data.prefix_code.record[2] &amp; 0x000F) &lt;&lt; 4) + (_akcontext.data.prefix_code.record[3] &amp; 0x000F);
    if(calcrc_1byte(_akcontext.pswd_len)==_akcontext.pswd_lencrc)
    {
        _akcontext.airkiss_state = AIRKISS_STATE_PREFIX_CODE_COMPLETE;
    }
    else
    {
        akconf-&gt;printf(&quot;password length crc error.\n&quot;);
        resest_airkiss_data();
        return;
    }

    // only receive password and random
    _akcontext.need_seq = ((_akcontext.pswd_len + 1) + 3)/4;
    _akcontext.seq_success_map_cmp = (1 &lt;&lt; _akcontext.need_seq) - 1;

    resest_airkiss_data();
    akconf-&gt;printf(&quot;airkiss_process_prefix_code success\n&quot;);
    akconf-&gt;printf(&quot;pswd_len:%d, pswd_lencrc:%x, need seq:%d, seq map:%x\n&quot;,
            _akcontext.pswd_len, _akcontext.pswd_lencrc, _akcontext.need_seq, _akcontext.seq_success_map_cmp);
}</code></pre>
<p>调试信息</p>
<pre><code>Cap len:163
length:8e --&gt; ox40
Cap len:46
Cap len:158
Cap len:34
Cap len:28
Cap len:190
length:a9 --&gt; 0x5b
Cap len:46
Cap len:185
Cap len:34
Cap len:34
Cap len:34
Cap len:28
Cap len:197
length:b0 --&gt; 0x62
Cap len:46
Cap len:192
Cap len:34
Cap len:28
Cap len:211
length:be --&gt; 0x70
airkiss_process_prefix_code success
pswd_len:11, pswd_lencrc:20, need seq:3, seq map:7</code></pre><h3 id="sequence-header-amp-data"><a href="#sequence-header-amp-data" class="headerlink" title="sequence header &amp; data"></a>sequence header &amp; data</h3><p>将要发送的数据按照 4 字节为单位进行划分，每 4 个数据加上 <code>sequence header</code> 组成一个 <code>sequence</code>，以 <code>sequence</code> 为单位进行数据发送，<strong>如果最后一个 <code>sequence</code> 不够 4 字节，不用补全</strong>，格式如下</p>
<p><code>sequence header</code> 格式如下</p>
<pre><code>第 1 个 9bits 0 1 sequence crc8（低 7 位）
第 2 个 9bits 0 1 sequence index</code></pre><p><code>data</code> 格式如下</p>
<pre><code>第 1 个 9bits 1 data（第 7-0bit)
第 2 个 9bits 1 data（第 7-0bit)
第 3 个 9bits 1 data（第 7-0bit)
第 4 个 9bits 1 data（第 7-0bit)</code></pre><p>代码实现如下</p>
<pre><code class="c">if(((_akcontext.data.seq_code.record[0]&amp;0x180)==0x80) &amp;&amp;
    ((_akcontext.data.seq_code.record[1]&amp;0x180)==0x80) &amp;&amp;
    ((_akcontext.data.seq_code.record[2]&amp;0x0100)==0x0100) &amp;&amp;
    ((_akcontext.data.seq_code.record[3]&amp;0x0100)==0x0100) &amp;&amp;
    ((_akcontext.data.seq_code.record[4]&amp;0x0100)==0x0100) &amp;&amp;
    ((_akcontext.data.seq_code.record[5]&amp;0x0100)==0x0100) &amp;&amp;
    ((_akcontext.data.seq_code.record[1]&amp;0x7F) &lt;= ((_akcontext.total_len&gt;&gt;2)+1)))
{
    unsigned char tempBuffer[6] = {0};
    tempBuffer[0]=_akcontext.data.seq_code.record[0]&amp;0x7F; //seq crc
    tempBuffer[1]=_akcontext.data.seq_code.record[1]&amp;0x7F; //seq index
    tempBuffer[2]=_akcontext.data.seq_code.record[2]&amp;0xFF; //data, same as following
    tempBuffer[3]=_akcontext.data.seq_code.record[3]&amp;0xFF;
    tempBuffer[4]=_akcontext.data.seq_code.record[4]&amp;0xFF;
    tempBuffer[5]=_akcontext.data.seq_code.record[5]&amp;0xFF;

    if(tempBuffer[0] == (calcrc_bytes(tempBuffer+1,5)&amp;0x7F) )
        ...
    }
}</code></pre>
<p>调试信息</p>
<pre><code>Cap len:408
Cap len:338
length:13d --&gt; 0xef
Cap len:46
Cap len:34
Cap len:28
Cap len:229
length:d0 --&gt; 0x82
Cap len:46
Cap len:42
Cap len:28
Cap len:42
Cap len:28
Cap len:34
Cap len:34
Cap len:28
Cap len:412
length:187 -&gt; 0x139
Cap len:46
Cap len:34
Cap len:28
Cap len:408
length:183 -&gt; 0x135
Cap len:46
Cap len:34
Cap len:28
Cap len:412
length:187 -&gt; 0x139
Cap len:46
Cap len:28
Cap len:34
Cap len:34
Cap len:34
Cap len:34
Cap len:34
Cap len:34
Cap len:34
Cap len:34
Cap len:28
Cap len:416
length:18b -&gt; 0x13d
[crc:6f][index:2]:39,35,39,3d; seq mapped:4</code></pre><p><code>sequence header</code> 数据为 <code>0x13d-78</code> <code>0xd0-78</code> –&gt; <code>0xef 0x82</code></p>
<h2 id="802-11-802-2"><a href="#802-11-802-2" class="headerlink" title="802.11/802.2"></a>802.11/802.2</h2><ul>
<li><code>IEEE 802.11</code> 定义了媒体访问控制层（MAC 层）和物理层。物理层</li>
<li><code>IEEE 802.2</code> 是对数据链路层上层逻辑链路控制 (LLC) 连接的建立和管理的规范</li>
</ul>
<p>几个概念：</p>
<ul>
<li><code>PHY</code> 物理层的芯片我们简称之为 PHY，物理层 <code>Physical Layer</code></li>
<li>数据链路层 <code>Data Link Layer</code> 是 <code>OSI</code> 模型的第二层，负责建立和管理节点间的链路。该层通常又被分为介质访问控制 <code>MAC</code> 和逻辑链路控制 <code>LLC</code> 两个子层<ul>
<li><code>MAC</code> 数据链路层的芯片一般简称之为 MAC 控制器</li>
<li><code>LLC</code> 子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制</li>
</ul>
</li>
</ul>
<p>** <code>WIFI</code> <code>MAC</code> 和 <code>PHY</code> 层及协议在 <code>OSI</code> 位置**<br><img src="/images/wifi/WIFI.png" alt=""><br><img src="/images/wifi/802.11_OSI.png" alt=""></p>
<p><code>Airkiss</code> 需要关心的 <code>length</code> 从 <code>802.2 SNAP LLC</code> 解析，数据格式<br><img src="/images/wifi/snap.png" alt=""></p>
<p><code>802.11</code> 帧结构如下， <code>airkiss</code> 对 <code>Address1/Address2/Address3</code> 字段进行了过滤<br><img src="/images/wifi/80211.png" alt=""></p>
<h2 id="协议细节理解"><a href="#协议细节理解" class="headerlink" title="协议细节理解"></a>协议细节理解</h2><h3 id="前导码及发现过程"><a href="#前导码及发现过程" class="headerlink" title="前导码及发现过程"></a>前导码及发现过程</h3><blockquote>
<p>利用 <code>802.2 SNAP</code> 数据包中的 <code>Length</code> 字段进行通信。在实际应用中采用 <code>UDP</code> 广播包作为信息的载体。每一包的数据都是按照 <code>Airkiss</code> 通信协议进行编码。<strong>一个 <code>UDP</code> 包发送要经过 <code>IP</code> 层、数据链路层的封装，并且通过加密 ( <code>WPA2、WPA、WEP</code> ) 后才被发送出去，所以发送方发送 <code>UDP</code> 长度与接收方监听 <code>SNAP</code> 包长度存在差异，而且由于底层加密方式的差异，使得这个差异值也具有不确定性</strong></p>
</blockquote>
<p>因此需要监听信道计算差异值，这个差异值就是底层封装对 <code>Length</code> 的差异，后续传输的所有 <code>Length</code> 需要减去差异值</p>
<h3 id="误识别"><a href="#误识别" class="headerlink" title="误识别"></a>误识别</h3><p>如果发送数据中包括递增值，例如 <code>1234</code>、 <code>4567</code> 或 <code>abcd</code> 会导致前导码识别错误，正式库中有处理？</p>
<h3 id="应用数据组成"><a href="#应用数据组成" class="headerlink" title="应用数据组成"></a>应用数据组成</h3><p><code>password</code> + <code>random</code> + <code>ssid</code></p>
<ol>
<li><code>password</code> 和 <code>ssid</code> 可以发送经过 <code>AES</code> 加密后的数据， <code>AES Key</code> 私下协商， <code>Airkiss</code> 协议无规定？</li>
<li><code>random</code> 为 <code>airkiss server</code> 生成的随机数，在连接成功之后 <code>airkiss client</code> 将这个值发送回来以完成配网</li>
</ol>
<h3 id="端口的选择"><a href="#端口的选择" class="headerlink" title="端口的选择"></a>端口的选择</h3><ol>
<li><code>airkiss server</code> 可以是 <code>eth</code> 或 <code>wlan</code></li>
<li><code>airkiss client</code> 可以是 <code>eth</code> 或 <code>wlan</code></li>
<li>可以使用 <code>setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, (void *)&amp;ifr, sizeof(ifr)))</code> 限制使用具体 <code>interface</code></li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://iot.weixin.qq.com/wiki/airkiss_developer_manual.pdf" target="_blank" rel="noopener">AirKiss 库文件使用指南</a></li>
<li><a href="https://www.jianshu.com/p/b3a2a8ae7042" target="_blank" rel="noopener">揭开智能配置上网（微信 Airkiss）的奥妙面纱</a></li>
<li><a href="https://blog.csdn.net/u012503786/article/details/78783874" target="_blank" rel="noopener">IEEE 802.11 的帧格式介绍</a></li>
<li><a href="https://wenku.baidu.com/view/0e825981ad02de80d5d8409c.html" target="_blank" rel="noopener">Airkiss 协议详解</a></li>
<li><a href="https://github.com/pannzh/Airkiss" target="_blank" rel="noopener">Airkiss</a></li>
<li><a href="https://segmentfault.com/a/1190000011811798" target="_blank" rel="noopener">Radiotap 头信息解析</a></li>
<li><a href="https://www.freebuf.com/articles/wireless/130194.html" target="_blank" rel="noopener">无线网络嗅探中的 Radiotap</a></li>
<li><a href="https://www.cisco.com/c/zh_cn/support/docs/wireless-mobility/80211/200527-Fundamentals-of-802-11-Wireless-Sniffing.pdf" target="_blank" rel="noopener">基本 802.11 无线探测</a></li>
<li><a href="http://www.itcertnotes.com/2011/05/ieee-80211-frame-types.html" target="_blank" rel="noopener">IEEE 802.11 Frame Types</a></li>
<li><a href="https://blog.csdn.net/neilengineer/article/details/45962681" target="_blank" rel="noopener">WIFI MAC 和 PHY 在 OSI 模型中的层次</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Network</category>
        <category>Tools</category>
        <category>Network</category>
        <category>802.11</category>
        <category>Airkiss</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
        <tag>linux</tag>
        <tag>iw</tag>
        <tag>802.11</tag>
        <tag>802.2</tag>
        <tag>airkiss</tag>
        <tag>monitor mode</tag>
        <tag>radiotap header</tag>
      </tags>
  </entry>
  <entry>
    <title>无线网络分析 - 监听</title>
    <url>/2019/01/03/wireless-analysis-one-monitoring/</url>
    <content><![CDATA[<p>某些无线网卡具有监听能力 <code>monitor</code>，使用工具 <code>iw</code>、<code>iwconfig</code> 等将模式切换到 <code>monitor</code> 之后，可以使用 <code>tcpdump</code>、<code>wireshark</code> 等抓包工具抓包进行分析，本文记录各个过程中可能使用到的工具</p>
<a id="more"></a>

<h2 id="无线网卡的工作模式"><a href="#无线网卡的工作模式" class="headerlink" title="无线网卡的工作模式"></a>无线网卡的工作模式</h2><p>可以使用工具 <code>iw</code> 来确认选定网卡支持那些工作模式</p>
<pre><code class="shell">$ iw list
...
    Supported interface modes:
         * IBSS
         * managed
         * AP
         * AP/VLAN
         * monitor
         * P2P-client
         * P2P-GO
         * P2P-device
...</code></pre>
<p>其中 <code>Managed</code> 为托管模式，无线网卡只接受从 <code>WAP</code> 发给自己的数据报文； <code>monitor</code> 为监听模式，可以接收所有的无线通信数据包。</p>
<h2 id="设置网卡为监听模式"><a href="#设置网卡为监听模式" class="headerlink" title="设置网卡为监听模式"></a>设置网卡为监听模式</h2><h3 id="iwconfig"><a href="#iwconfig" class="headerlink" title="iwconfig"></a>iwconfig</h3><p><code>iwconfig</code> 可以用来查看无线网卡的状态，或修改无线网卡的模式</p>
<pre><code class="shell">$ iwconfig
lo        no wireless extensions.

wlan0     IEEE 802.11bgn  ESSID:&quot;defenceOTA&quot;
          Mode:Managed  Frequency:2.412 GHz  Access Point: 6C:72:20:5D:7F:57
          Bit Rate=130 Mb/s   Tx-Power=16 dBm
          Retry short limit:7   RTS thr:off   Fragment thr:off
          Power Management:off
          Link Quality=50/70  Signal level=-60 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:3  Invalid misc:4   Missed beacon:0

$ sudo ifconfig wlan0 down
$ sudo iwconfig wlan0 mode monitor
$ sudo ifconfig wlan0 up</code></pre>
<h3 id="aircrack-ng"><a href="#aircrack-ng" class="headerlink" title="aircrack-ng"></a>aircrack-ng</h3><p><code>aircrack-ng</code> 提供了一整套无线工具，每一个都小巧精练，各有春秋，如瑞士军刀一般， <code>airmon-ng</code> 就是其中之一。可以同时上网和监听数据</p>
<pre><code class="shell">$ sudo airmon-ng

Interface   Chipset     Driver

wlan0       Atheros AR9280  ath9k - [phy0]
enx0        Unknown     rtl8812au

$ sudo airmon-ng start wlan0

Found 3 processes that could cause trouble.
If airodump-ng, aireplay-ng or airtun-ng stops working after
a short period of time, you may want to kill (some of) them!

PID Name
12341   NetworkManager
12354   wpa_supplicant
12363   dhclient
Process with PID 12363 (dhclient) is running on interface wlan0

Interface   Chipset     Driver

wlan0       Atheros AR9280  ath9k - [phy0]
                (monitor mode enabled on mon0)</code></pre>
<p><code>airmon-ng</code> 新建了一个虚拟网卡 <code>mon0</code>，并在 <code>mon0</code> 上启用了监听模式，真实的无线网卡 <code>wlan0</code> 保持不变</p>
<p>另外可以使用 <code>airmon-ng check</code> 来检测系统中当前正在运行的进程，分析出哪些进程可能会对无线抓包有影响，并显示出来。可以使用 <code>airmon-ng check kill</code> 直接 <code>kill</code> 掉那些可能有影响的进程。</p>
<h3 id="iw"><a href="#iw" class="headerlink" title="iw"></a>iw</h3><p><code>iw</code> 是 <code>Linux</code> 系统上的另一款无线配置工具，它的出现是为了解决 <code>iwconfig</code> 的很多不足，或者说它完全是为了取代 <code>iwconfig</code> 而开发的。 <code>iw</code> 基于 <code>cfg80211</code> 框架设计，不再像 <code>Wireless-Extensions(Wext)</code> 使用 <code>ioctl</code>，而是使用 <code>Netlink</code></p>
<pre><code class="shell">$ iw list
$ iw dev
$ iw dev wlan0 info
$ iw dev wlan0 link
$ iw dev wlan0 interface add mon0 type monitor</code></pre>
<p><code>iw dev wlan0 interface add mon0 type monitor</code> 新增了一个虚拟网卡接口 <code>mon0</code>，并将 <code>mon0</code> 设置为监听模式。然后需要</p>
<pre><code class="shell">$ ifconfig mon0 up
$ iw dev mon0 set freq 2437</code></pre>
<h2 id="扫描无线网络"><a href="#扫描无线网络" class="headerlink" title="扫描无线网络"></a>扫描无线网络</h2><h3 id="iw-1"><a href="#iw-1" class="headerlink" title="iw"></a>iw</h3><pre><code class="shell">$ sudo iw dev wlan0 scan
$ sudo iw dev wlan0 scan | egrep &quot;^BSS|SSID&quot;</code></pre>
<h3 id="iwlist"><a href="#iwlist" class="headerlink" title="iwlist"></a>iwlist</h3><pre><code class="shell">$ sudo iwlist wlan0 scan
$ sudo iwlist wlan0 scan | egrep &quot;Cell|ESSID|Channel&quot;</code></pre>
<h3 id="kismet"><a href="#kismet" class="headerlink" title="kismet"></a>kismet</h3><p><code>kismet</code> 是一款 <code>Linux</code> 下的无线扫描程序，它的功能非常强大，不仅可以用来扫描周边的无线网络，也支持无线数据包的嗅探和破解，它还可以扫描出周围隐藏的无线热点，更厉害的是，它还内置了 <code>IDS（Intrusion Detection System，入侵检测系统）功能</code>，可以检测出周围是否有无线嗅探器。</p>
<p>需要使用 <code>root</code> 权限运行，其中一步需要添加 <code>interface</code>，如果输入的 <code>interface</code> 不是监听模式，会自动创建一个 <code>wlan0mon</code> 的监听网卡，然后启动监听模式</p>
<h3 id="airodump-ng"><a href="#airodump-ng" class="headerlink" title="airodump-ng"></a>airodump-ng</h3><pre><code class="shell">$ sudo airmon-ng start wlan0
$ sudo ifconfig mon0 up
$ sudo airodump-ng mon0</code></pre>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="kismet-抓包"><a href="#kismet-抓包" class="headerlink" title="kismet 抓包"></a>kismet 抓包</h3><p>譬如在启动 <code>kismet</code> 的时候， <code>kismet</code> 就会在启动目录生成好几个文件，如下</p>
<pre><code class="shell">$ ls -l Kis*
-rw-r--r-- 1 root root       0 8 月  15 22:32 Kismet-20160815-22-32-05-1.alert
-rw-r--r-- 1 root root     264 8 月  15 22:32 Kismet-20160815-22-32-05-1.gpsxml
-rw-r--r-- 1 root root   25111 8 月  15 22:32 Kismet-20160815-22-32-05-1.nettxt
-rw-r--r-- 1 root root   57768 8 月  15 22:32 Kismet-20160815-22-32-05-1.netxml
-rw-r--r-- 1 root root 1822733 8 月  15 22:32 Kismet-20160815-22-32-05-1.pcapdump</code></pre>
<p>其中， <code>Kismet-***.pcapdump</code> 就是捕获的数据包，可以使用 <code>Wireshark</code> 等数据包分析工具打开。默认情况下， <code>kismet</code> 会捕获所有的无线通信，数据包会变得非常大，可以通过指定 <code>filter_tracker</code> 参数来限制 <code>kismet</code> 只捕获特定 <code>BSSID</code> 的数据包，譬如下面这样：</p>
<pre><code class="shell">sudo kismet --filter-tracker BSSID\(6C:72:20:5D:7F:57\)</code></pre>
<h3 id="airodump-ng-抓包"><a href="#airodump-ng-抓包" class="headerlink" title="airodump-ng 抓包"></a>airodump-ng 抓包</h3><p><code>airodump-ng</code> 默认数据包是不存文件的，可以通过 <code>--write</code> 或 <code>-w</code> 参数将数据包保存到指定文件中：</p>
<pre><code class="shell">$ sudo airodump-ng -w pack mon0
$ ls -l pack*
-rw-r--r-- 1 root root  5645 8 月  15 23:48 pack-01.cap
-rw-r--r-- 1 root root  1651 8 月  15 23:48 pack-01.csv
-rw-r--r-- 1 root root  2457 8 月  15 23:48 pack-01.kismet.csv
-rw-r--r-- 1 root root 13460 8 月  15 23:48 pack-01.kismet.netxml</code></pre>
<p><code>xxx-01.cap</code> 就是捕获的数据包文件，可以使用 <code>Wireshark</code> 打开分析。同样的，这个文件也有可能会很大，因为保存了所有的无线数据报文，如果只需要监听某一个接入点，可以通过 <code>--bssid</code> 或 <code>--essid</code> 等参数指定：</p>
<pre><code class="shell">$ sudo airodump-ng mon0 --bssid 6C:72:20:5D:7F:57</code></pre>
<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><pre><code class="shell">$ sudo tcpdump -i mon0 -n -w wireless.cap</code></pre>
<h3 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h3><p>使用 <code>filter</code>： <code>wlan.ta == 6c:72:20:5d:7f:57</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.aneasystone.com/archives/2016/08/wireless-analysis-one-monitoring.html" target="_blank" rel="noopener">实战无线网络分析无线监听</a></li>
<li><a href="https://blog.csdn.net/u011781521/article/details/68948979" target="_blank" rel="noopener">Kali-WIFI 攻防（一）—- 无线网络嗅探工具 Kismet</a></li>
<li><a href="https://askubuntu.com/questions/454734/running-wireshark-lua-error-during-loading" target="_blank" rel="noopener">running wireshark “Lua: Error during loading”</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
        <tag>wireshark</tag>
        <tag>linux</tag>
        <tag>wireless</tag>
        <tag>iw</tag>
        <tag>omnipeek</tag>
        <tag>monitor</tag>
        <tag>sniffer</tag>
        <tag>802.11</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 mdev 检测 3g 设备并自动连接</title>
    <url>/2018/12/27/detect-3g-device-by-mdev/</url>
    <content><![CDATA[<p><code>udev</code> 有 <code>rules</code> 用于 <code>3G</code> 设备的自动连接，而嵌入式系统中使用精简版的 <code>mdev</code>，没有 <code>rules</code> 来完成 <code>3G</code> 设备的自动连接，本文记录折腾过程</p>
<a id="more"></a>

<p>Linux Version: 4.9.22</p>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p><code>插入设备</code> -&gt; <code>判断型号是否支持</code> -&gt; <code>usb modeswitch</code> -&gt; <code>ttyUSB/ttyACM</code> -&gt; <code>ppp</code></p>
<h2 id="Linux-内核配置"><a href="#Linux-内核配置" class="headerlink" title="Linux 内核配置"></a>Linux 内核配置</h2><p>针对 <code>3G ppp</code> 配置不再赘述，使用 <code>mdev</code> 对设备 <code>sg</code>，配置如下</p>
<pre><code class="mdev.conf">sg0 0:6 660 @ /etc/sbin/modeswitch $MDEV $ACTION</code></pre>
<p>内核需要打开 <code>CONFIG_CHR_DEV_SG</code>，从而产生设备节点 <code>/dev/sg*</code></p>
<p>在 <code>modeswitch</code> 中判断型号是否支持，进行 <code>usb modeswitch</code>，从而产生设备 <code>/dev/ttyUSB</code> 或 <code>/dev/ttyACM</code>，配置如下</p>
<pre><code class="mdev.conf">SUBSYSTEM=tty;ttyUSB0  0:6 660 * /etc/sbin/lookup $MDEV $ACTION
SUBSYSTEM=tty;ttyACM0  0:6 660 * /etc/sbin/lookup $MDEV $ACTION</code></pre>
<p>在 <code>lookup</code> 中将设备添加到管理列表中，从而完成设备的添加及删除</p>
<p>部分设备使用的是 <code>/dev/ttACM</code>，需要内核打开配置 <code>CONFIG_USB_ACM</code></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><code>Modeswitch</code></p>
<pre><code class="bash">for device in $usb_device_list
do
    # look up  usb 3g  storage config
    usb_3g_storage_list=$(grep &quot;support_id_usbdisc&quot; /home/sbin/3g_card_list | grep $device | wc -l)

    if [ $usb_3g_storage_list -eq 0 ];then
        continue
    fi

    usb_3g_vendor_id=$(echo $device | awk -F&quot;:&quot; &#39;{print $1}&#39;)
    usb_3g_product_id=$(echo $device | awk -F&quot;:&quot; &#39;{print $2}&#39;)

    if [ -z $usb_3g_vendor_id ];then
        # no usb 3g
        exit 1
    fi

    usb_3g_delay_ms=0
    if [ &quot;$usb_3g_vendor_id:$usb_3g_product_id&quot; = &quot;19d2:2000&quot; ];then
        usb_3g_delay_ms=5000
    fi

    usb_3g_modeswitch=$(ps -o comm | grep -w usb_modeswitch)
    if [ ! -z $usb_3g_modeswitch ];then
        #modeswitch not finish
        exit 1
    fi

    convert_device=/dev/ttyUSB0
    if [ &quot;$usb_3g_vendor_id:$usb_3g_product_id&quot; = &quot;19d2:1514&quot; ]; then
        convert_device=/dev/ttyACM0
    fi

    echo -e &quot;\033[1;31m[3G MODESWITCH] New 3G &lt;$device&gt; in $1, convert to $convert_device\033[0m&quot; &gt; /dev/ttyS0

    if [ ! -e $convert_device ];then
        # convert stroage device to ttyUSB0/ttyACM0
        if [ $usb_3g_delay_ms -gt 0 ];then
            usb_modeswitch -c /etc/usb_modeswitch.d/${usb_3g_vendor_id}:${usb_3g_product_id} -v 0x${usb_3g_vendor_id} -p 0x${usb_3g_product_id} -w $usb_3g_delay_ms &amp;
        else
            usb_modeswitch -c /etc/usb_modeswitch.d/${usb_3g_vendor_id}:${usb_3g_product_id} -v 0x${usb_3g_vendor_id} -p 0x${usb_3g_product_id} &amp;
            if [ &quot;$usb_3g_vendor_id:$usb_3g_product_id&quot; = &quot;0685:2000&quot; ];then
                sleep 5
            fi
        fi
    fi
    exit 0
done
exit 1</code></pre>
<p><code>Lookup</code></p>
<pre><code class="bash">usb_device_list=$(lsusb | awk &#39;{print $6}&#39; | uniq | grep -v $usb_host_vendor_id)

for device in $usb_device_list
do
    # look up usb 3g net card
    usb_eth3g_net_card_list=$(grep &quot;eth3g_id_switch&quot; /home/sbin/3g_card_list | grep $device | wc -l)
    if [ $usb_eth3g_net_card_list -ne 0 ];then
        echo $USB_ETH3G_DEVNAME-$device# &gt; $return_file
        echo -e &quot;\033[1;32m[3G LOOKUP] $2 $USB_ETH3G_DEVNAME-$device with $1\033[0m&quot; &gt; /dev/ttyS0
        exit 0
    fi

    usb_3g_net_card_list=$(grep &quot;support_id_switch&quot; /home/sbin/3g_card_list | grep $device | wc -l)
    if [ $usb_3g_net_card_list -ne 0 ];then
        echo $USB_3G_DEVNAME-$device# &gt; $return_file
        echo -e &quot;\033[1;32m[3G LOOKUP] $2 $USB_3G_DEVNAME-$device with $1\033[0m&quot; &gt; /dev/ttyS0
        exit 0
    fi
done

exit 1</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/u010944778/article/details/47251701" target="_blank" rel="noopener">FL2440 3G 上网卡拨号上网，并实现 mdev 自动挂载</a></li>
<li><a href="https://ubuntuforums.org/showthread.php?t=1472896" target="_blank" rel="noopener">lubuntu do not detect 3g mobile broadband huawei</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Huawei_E1550_3G_modem#Switch_into_modem_mode" target="_blank" rel="noopener">Huawei E1550 3G modem</a></li>
<li><a href="https://wiki.archlinux.org/index.php/USB_3G_Modem#Mode_switching" target="_blank" rel="noopener">USB 3G Modem</a></li>
<li><a href="https://forum.ubuntu.org.cn/viewtopic.php?f=116&t=482399" target="_blank" rel="noopener">关于华为 3G/4G 上网卡设备使用 usb modemswitch 的问题</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>3g</tag>
        <tag>mdev</tag>
        <tag>usb modeswitch</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA 相关概念以及 arm 实现</title>
    <url>/2018/12/19/linux-kernel-dma-cache-coherence/</url>
    <content><![CDATA[<p><code>Linux</code> 内核中 <code>DMA</code> 及 <code>Cache</code> 分析，涉及以下函数</p>
<ul>
<li><code>dma_alloc_coherent</code></li>
<li><code>dma_map_single</code></li>
<li><code>dma_alloc_writecombine</code></li>
<li><code>pgprot_noncached</code></li>
<li><code>remap_pfn_range</code></li>
</ul>
<a id="more"></a>

<ul>
<li>Linux Kernel: 4.9.22</li>
<li>Arch: arm</li>
</ul>
<h2 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h2><p><code>arch/arm/mm/dma-mapping.c</code><br><code>include/linux/dma-mapping.h</code></p>
<p>几个关键变量和函数</p>
<ul>
<li><code>atomic_pool_init</code> 和 <code>DEFAULT_DMA_COHERENT_POOL_SIZE</code></li>
<li><code>dma zone</code>、 <code>dma pool</code>、 <code>setup_dma_zone</code> 和 <code>CONFIG_ZONE_DMA</code></li>
<li><code>coherent_dma_mask</code> 和 <code>dma_zone_size</code></li>
</ul>
<h2 id="DMA-ZONE"><a href="#DMA-ZONE" class="headerlink" title="DMA ZONE"></a>DMA ZONE</h2><p>存在 <code>DMA ZONE</code> 的原因是某些硬件的 <code>DMA 引擎</code> 不能访问到所有的内存区域，因此，加上一个 <code>DMA ZONE</code>，当使用 <code>GFP_DMA</code> 方式申请内存时，获得的内存限制在 <code>DMA ZONE</code> 的范围内，这些特定的硬件需要使用 <code>GFP_DMA</code> 方式获得可以做 <code>DMA</code> 的内存；<br>如果系统中所有的设备都可选址所有的内存，那么 <code>DMA ZONE</code> 覆盖所有内存。<br><code>DMA ZONE</code> 的大小，以及 <code>DMA ZONE</code> 要不要存在，都取决于你实际的硬件是什么。<br>由于设计及硬件的使用模式， <code>DMA ZONE</code> 可以不存在</p>
<blockquote>
<p>由于现如今绝大多少的 <code>SoC</code> 都很牛逼，似乎 <code>DMA</code> 都没有什么缺陷了，根本就不太可能给我们机会指定 <code>DMA ZONE</code> 大小装逼了，那个这个 <code>ZONE</code> 就不太需要存在了。反正任何 <code>DMA</code> 在任何地方申请的内存，这个 <code>DMA</code> 都可以存取到。</p>
</blockquote>
<h2 id="DMA-ZONE-的内存只能做-DMA-吗？"><a href="#DMA-ZONE-的内存只能做-DMA-吗？" class="headerlink" title="DMA ZONE 的内存只能做 DMA 吗？"></a>DMA ZONE 的内存只能做 DMA 吗？</h2><p><code>DMA ZONE</code> 的内存做什么都可以。 <code>DMA ZONE</code> 的作用是让有缺陷的 <code>DMA</code> 对应的外设驱动申请 <code>DMA buffer</code> 的时候从这个区域申请而已，但是它不是专有的。其他所有人的内存（包括应用程序和内核）也可以来自这个区域。</p>
<h2 id="dma-mask-与-coherent-dma-mask-的定义"><a href="#dma-mask-与-coherent-dma-mask-的定义" class="headerlink" title="dma_mask 与 coherent_dma_mask 的定义"></a>dma_mask 与 coherent_dma_mask 的定义</h2><p><code>include/linux/device.h</code></p>
<pre><code class="c">struct device {
    ...
    u64     *dma_mask;  /* dma mask (if dma&#39;able device) */
    u64     coherent_dma_mask;/* Like dma_mask, but for
                        alloc_coherent mappings as
                        not all hardware supports
                        64 bit addresses for consistent
                        allocations such descriptors. */
    unsigned long   dma_pfn_offset;

    struct device_dma_parameters *dma_parms;

    struct list_head    dma_pools;  /* dma pools (if dma&#39;ble) */

    struct dma_coherent_mem *dma_mem; /* internal for coherent mem
    ...
};</code></pre>
<p><code>dma_mask</code> 与 <code>coherent_dma_mask</code> 这两个参数表示它能寻址的物理地址的范围，内核通过这两个参数分配合适的物理内存给 <code>device</code>。 <code>dma_mask</code> 是 <code>设备 DMA</code> 能访问的内存范围， <code>coherent_dma_mask</code> 则作用于申请 <code>一致性 DMA 缓冲区</code>。因为不是所有的硬件都能够支持 <code>64bit</code> 的地址宽度。如果 <code>addr_phy</code> 是一个物理地址，且 <code>(u64)addr_phy &lt;= *dev-&gt;dma_mask</code>，那么该 <code>device</code> 就可以寻址该物理地址。如果 <code>device</code> 只能寻址 <code>32</code> 位地址，那么 <code>mask</code> 应为 <code>0xffffffff</code>。依此类推。</p>
<p>例如内核代码 <code>arch/arm/mm/dma-mapping.c</code></p>
<pre><code class="c">static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
             gfp_t gfp, pgprot_t prot, bool is_coherent,
             unsigned long attrs, const void *caller)
{
    u64 mask = get_coherent_dma_mask(dev);
    struct page *page = NULL;
    void *addr;
    bool allowblock, cma;
    struct arm_dma_buffer *buf;
    struct arm_dma_alloc_args args = {
        .dev = dev,
        .size = PAGE_ALIGN(size),
        .gfp = gfp,
        .prot = prot,
        .caller = caller,
        .want_vaddr = ((attrs &amp; DMA_ATTR_NO_KERNEL_MAPPING) == 0),
        .coherent_flag = is_coherent ? COHERENT : NORMAL,
    };

#ifdef CONFIG_DMA_API_DEBUG
    u64 limit = (mask + 1) &amp; ~mask;
    if (limit &amp;&amp; size &gt;= limit) {
        dev_warn(dev, &quot;coherent allocation too big (requested %#x mask %#llx)\n&quot;,
            size, mask);
        return NULL;
    }
#endif
...
}</code></pre>
<p><code>limit</code> 就是通过 <code>mask</code> 计算得到的设备最大寻址范围</p>
<h2 id="dma-alloc-coherent-分配的内存一定在-DMA-ZONE-内吗？"><a href="#dma-alloc-coherent-分配的内存一定在-DMA-ZONE-内吗？" class="headerlink" title="dma_alloc_coherent 分配的内存一定在 DMA ZONE 内吗？"></a>dma_alloc_coherent 分配的内存一定在 DMA ZONE 内吗？</h2><p><code>dma_alloc_coherent()</code> 申请的内存来自于哪里，不是因为它的名字前面带了个 <code>dma_</code> 就来自 <code>DMA ZONE</code> 的，本质上取决于对应的 <code>DMA</code> 硬件是谁。应该说绝对多数情况下都不在 <code>DMA ZONE</code> 内，代码如下</p>
<p><code>dma_alloc_coherent</code> -&gt; <code>dma_alloc_attrs</code></p>
<pre><code class="c">static inline void *dma_alloc_attrs(struct device *dev, size_t size,
                       dma_addr_t *dma_handle, gfp_t flag,
                       unsigned long attrs)
{
    struct dma_map_ops *ops = get_dma_ops(dev);
    void *cpu_addr;

    BUG_ON(!ops);

    if (dma_alloc_from_coherent(dev, size, dma_handle, &amp;cpu_addr))
        return cpu_addr;

    if (!arch_dma_alloc_attrs(&amp;dev, &amp;flag))
        return NULL;
    if (!ops-&gt;alloc)
        return NULL;

    cpu_addr = ops-&gt;alloc(dev, size, dma_handle, flag, attrs);
    debug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr);
    return cpu_addr;
}</code></pre>
<p>在 <code>dma_alloc_attrs</code> 首先通过 <code>dma_alloc_from_coherent</code> 从 <code>device</code> 自己的 <code>dma memory</code> 中申请，如果没有再通过 <code>ops-&gt;alloc</code> 申请， <code>arm</code> 如下</p>
<pre><code class="c">static struct dma_map_ops *arm_get_dma_map_ops(bool coherent)
{
    return coherent ? &amp;arm_coherent_dma_ops : &amp;arm_dma_ops;
}

struct dma_map_ops arm_coherent_dma_ops = {
    .alloc          = arm_coherent_dma_alloc,
    .free           = arm_coherent_dma_free,
    .mmap           = arm_coherent_dma_mmap,
    .get_sgtable        = arm_dma_get_sgtable,
    .map_page       = arm_coherent_dma_map_page,
    .map_sg         = arm_dma_map_sg,
};
EXPORT_SYMBOL(arm_coherent_dma_ops);

static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
    dma_addr_t *handle, gfp_t gfp, unsigned long attrs)
{
    return __dma_alloc(dev, size, handle, gfp, PAGE_KERNEL, true,
               attrs, __builtin_return_address(0));
}

static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
             gfp_t gfp, pgprot_t prot, bool is_coherent,
             unsigned long attrs, const void *caller)
{
    u64 mask = get_coherent_dma_mask(dev);
    struct page *page = NULL;
    void *addr;
    bool allowblock, cma;
    struct arm_dma_buffer *buf;
    struct arm_dma_alloc_args args = {
        .dev = dev,
        .size = PAGE_ALIGN(size),
        .gfp = gfp,
        .prot = prot,
        .caller = caller,
        .want_vaddr = ((attrs &amp; DMA_ATTR_NO_KERNEL_MAPPING) == 0),
        .coherent_flag = is_coherent ? COHERENT : NORMAL,
    };

#ifdef CONFIG_DMA_API_DEBUG
    u64 limit = (mask + 1) &amp; ~mask;
    if (limit &amp;&amp; size &gt;= limit) {
        dev_warn(dev, &quot;coherent allocation too big (requested %#x mask %#llx)\n&quot;,
            size, mask);
        return NULL;
    }
#endif

    if (!mask)
        return NULL;

    buf = kzalloc(sizeof(*buf),
              gfp &amp; ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM));
    if (!buf)
        return NULL;

    if (mask &lt; 0xffffffffULL)
        gfp |= GFP_DMA;

    /*
     * Following is a work-around (a.k.a. hack) to prevent pages
     * with __GFP_COMP being passed to split_page() which cannot
     * handle them.  The real problem is that this flag probably
     * should be 0 on ARM as it is not supported on this
     * platform; see CONFIG_HUGETLBFS.
     */
    gfp &amp;= ~(__GFP_COMP);
    args.gfp = gfp;

    *handle = DMA_ERROR_CODE;
    allowblock = gfpflags_allow_blocking(gfp);
    cma = allowblock ? dev_get_cma_area(dev) : false;

    if (cma)
        buf-&gt;allocator = &amp;cma_allocator;
    else if (nommu() || is_coherent)
        buf-&gt;allocator = &amp;simple_allocator;
    else if (allowblock)
        buf-&gt;allocator = &amp;remap_allocator;
    else
        buf-&gt;allocator = &amp;pool_allocator;

    addr = buf-&gt;allocator-&gt;alloc(&amp;args, &amp;page);

    if (page) {
        unsigned long flags;

        *handle = pfn_to_dma(dev, page_to_pfn(page));
        buf-&gt;virt = args.want_vaddr ? addr : page;

        spin_lock_irqsave(&amp;arm_dma_bufs_lock, flags);
        list_add(&amp;buf-&gt;list, &amp;arm_dma_bufs);
        spin_unlock_irqrestore(&amp;arm_dma_bufs_lock, flags);
    } else {
        kfree(buf);
    }

    return args.want_vaddr ? addr : page;
}</code></pre>
<p><code>&amp;pool_allocator</code> 从 <code>DMA POOL</code> 中分配，使用函数 <code>atomic_pool_init</code> 创建</p>
<p>代码段</p>
<pre><code class="c">    if (mask &lt; 0xffffffffULL)
        gfp |= GFP_DMA;</code></pre>
<p><code>GFP_DMA</code> 标记被设置，以指挥内核从 <code>DMA ZONE</code> 申请内存。但是 <code>mask</code> 覆盖了整个 4GB，调用 <code>dma_alloc_coherent()</code> 获得的内存就不需要一定是来自 <code>DMA ZONE</code></p>
<h2 id="dma-alloc-coherent-申请的内存是非-cache-的吗？"><a href="#dma-alloc-coherent-申请的内存是非-cache-的吗？" class="headerlink" title="dma_alloc_coherent() 申请的内存是非 cache 的吗？"></a>dma_alloc_coherent() 申请的内存是非 cache 的吗？</h2><p>缺省情况下， <code>dma_alloc_coherent()</code> 申请的内存缺省是进行 <code>uncache</code> 配置的。但是现代 <code>SOC</code> 有可能会将内核的通用实现 <code>overwrite</code> 掉，变成 <code>dma_alloc_coherent()</code> 申请的内存也是可以带 <code>cache</code> 的。</p>
<pre><code class="c">static struct dma_map_ops *arm_get_dma_map_ops(bool coherent)
{
    return coherent ? &amp;arm_coherent_dma_ops : &amp;arm_dma_ops;
}

struct dma_map_ops arm_coherent_dma_ops = {
    .alloc          = arm_coherent_dma_alloc,
    .free           = arm_coherent_dma_free,
    .mmap           = arm_coherent_dma_mmap,
    .get_sgtable        = arm_dma_get_sgtable,
    .map_page       = arm_coherent_dma_map_page,
    .map_sg         = arm_dma_map_sg,
};
EXPORT_SYMBOL(arm_coherent_dma_ops);</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/skyflying2012/article/details/48023447" target="_blank" rel="noopener">kernel 如何保证 cache 数据一致性</a></li>
<li><a href="https://blog.csdn.net/21cnbao/article/details/79133658" target="_blank" rel="noopener">关于 DMA ZONE 和 dma_alloc_coherent 若干误解的澄清</a></li>
<li><a href="https://blog.csdn.net/ganggexiongqi/article/details/6867034" target="_blank" rel="noopener">DMA 及 cache 一致性的学习心得</a></li>
<li><a href="https://blog.csdn.net/waterhawk/article/details/50723677" target="_blank" rel="noopener">DMA 导致的 CACHE 一致性问题解决方案</a></li>
<li><a href="https://blog.csdn.net/jasonchen_gbd/article/details/79462064" target="_blank" rel="noopener">Linux 内存管理 —— DMA 和一致性缓存</a></li>
<li><a href="https://blog.csdn.net/dianhuiren/article/details/6896129" target="_blank" rel="noopener">cache 一致性问题</a></li>
<li><a href="http://ju.outofmemory.cn/entry/243055" target="_blank" rel="noopener">简单粗暴有效的 mmap 与 remap_pfn_range</a></li>
<li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">认真分析 mmap：是什么 为什么 怎么用</a></li>
<li><a href="https://www.jianshu.com/p/187eada7b900" target="_blank" rel="noopener">mmap 函数：原理与使用（含代码）</a></li>
<li><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/9080173" target="_blank" rel="noopener">Linux 内存映射函数 mmap（）函数详解</a></li>
<li><a href="http://www.eeworld.com.cn/mp/ymc/a52767.jspx" target="_blank" rel="noopener">宋宝华： 关于 DMA ZONE 和 dma alloc coherent 若干误解的彻底澄清</a></li>
<li><a href="http://huhb.github.io/blog/2012/12/05/dma/" target="_blank" rel="noopener">Loongson3A 的 DMA 传输</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>dma</tag>
        <tag>cache</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式系统中 DMA 和 cache 一致性问题</title>
    <url>/2018/12/19/Cache-incoherence-due-to-DMA/</url>
    <content><![CDATA[<p><code>DMA</code> 和 <code>Cache</code> 一致性问题相关知识点</p>
<ol>
<li><code>DMA</code></li>
<li><code>Cache</code></li>
<li><code>pgprot_noncached</code></li>
</ol>
<a id="more"></a>

<p>关于代码深入分析见<a href="/2018/12/19/linux-kernel-dma-cache-coherence/" title="DMA 相关概念以及 arm 实现">DMA 相关概念以及 arm 实现</a></p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p><code>DMA(Direct memory access)</code> <strong>直接内存访问</strong>是一种硬件机制，它允许 <code>外围设备</code> 和 <code>主内存</code> 之间直接传输它们的 <code>I/O</code> 数据，而不需要 <code>CPU</code> 的参与。使用这种机制可以大大提高与设备通信的吞吐量</p>
<p><code>DMA</code> 方式的数据传输由 <code>DMA 控制器 (DMAC)</code> 控制，在传输期间 <code>CPU</code> 可以并发地执行其他任务，当 <code>DMA</code> 结束后， <code>DMAC</code> 通过中断通知 <code>CPU</code> 数据传输已经结束，然后由 <code>CPU</code> 执行相应的中断服务程序进行后续处理</p>
<p><img src="/images/linux/DMA.png" alt="DMA"></p>
<h2 id="Cache-和不一致性问题"><a href="#Cache-和不一致性问题" class="headerlink" title="Cache 和不一致性问题"></a>Cache 和不一致性问题</h2><p><code>Cache</code> 即高速缓冲存储器，是一种特殊的存储器子系统，其中复制了频繁使用的数据以利于快速访问。</p>
<p>假设 <code>DMA</code> 针对内存的目的地址和 <code>Cache</code> 缓存的对象没有重叠区域， <code>DMA</code> 和 <code>Cache</code> 之间就相安无事，但是，如果有重叠呢，经过 <code>DMA</code> 操作， <code>Cache</code> 缓存对应的内存的数据已经被修改，而 <code>CPU</code> 本身并不知道，它仍然认为 <code>Cache</code> 中的数据仍然还是内存中的数据，以后访问 <code>Cache</code> 映射的内存时，它仍然使用陈旧的 <code>Cache</code> 数据，这就会发生 <code>Cache</code> 与 <code>内存</code> 之间数据 <code>不一致性</code> 的错误。</p>
<p><strong>最简单的方法是直接禁止 <code>DMA 目标地址范围内内存的 Cache 功能</code>，当然这是牺牲性能的，但却高可靠。</strong></p>
<p><code>Cache</code> 带来的高效率与 <code>一致性问题</code> 需要平衡</p>
<p>只要 <code>Cache</code> 的空间与主存空间在一定范围内保持适当比例的映射关系， <code>Cache</code> 的命中率还是相当高的。一般规定 <code>Cache</code> 与内存的空间比为 <code>4：1000</code>，即 <code>128kB Cache</code> 可映射 <code>32MB</code> 内存； <code>256kB Cache</code> 可映射 <code>64MB</code> 内存。在这种情况下。命中率都在 <code>90％</code> 以上。至于没有命中的数据， <code>CPU</code> 只好直接从内存获取。获取的同时，也把它拷进 <code>Cache</code>。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p><code>cache</code> 有两种工作模式</p>
<ol>
<li><code>wirte through</code>， <code>CPU</code> 对 <code>主存</code> 写数据时，不经过 <code>cache</code> 直接写到内存，此时对于写的实现比较简单，如果系统只用写穿模式的话， <code>cache</code> 则变成了读缓存</li>
<li><code>write back</code>， <code>CPU</code> 写入数据时，不直接将数据写入内存，而是写入 <code>cache</code>，当 <code>cache</code> 数据被替换出去或者系统做 <code>cache flush</code> 时才写回主存</li>
</ol>
<h3 id="Cache-接口"><a href="#Cache-接口" class="headerlink" title="Cache 接口"></a>Cache 接口</h3><ol>
<li><code>Flush</code>，把 <code>Cache</code> 内容写回 <code>Main Memory</code> , 当 <code>Cache</code> 为 <code>Write through</code> , 不需要 <code>Flush</code></li>
<li><code>Invalidate</code>，把 <code>Cache</code> 内容直接丢掉不要</li>
</ol>
<h3 id="Cache-使用场景"><a href="#Cache-使用场景" class="headerlink" title="Cache 使用场景"></a>Cache 使用场景</h3><p>当有 <code>DMA</code> 在使用 <code>Main Memory</code> 的时候，一般要用到 <code>cache</code> 的处理。因为 <code>DMA</code> 在访问 <code>Main Memory</code> 时是不经过 <code>cache</code> 的。比较典型的比如在 <code>Ethernet</code>， <code>wireless</code>， <code>USB</code> 等驱动中， <code>DMA</code> 会操作 <code>descriptors</code> 和 <code>packet buffers</code>，驱动需要实现如下：</p>
<ul>
<li>如果 <code>Driver</code> 使用 <code>descripter</code> 和 <code>packet buffer</code> 的地址都是 <code>cache</code> 的地址，那么<ol>
<li><code>Driver</code> 在 <code>读 descripter</code> 里一些状态比如 <code>Owned by CPU/DMA</code>，有没有收到包时，要对 <code>descripter</code> 当前结构里的内容做 <code>cache invalidate</code>，收到 <code>packet</code> 后，也要对 <code>packet buffer</code> 做 <code>cache invalidate</code></li>
<li><code>Driver</code> 在 <code>写 descripter</code> 里一些状态比如 <code>Owned by DMA</code>，要发送包时，要对 <code>descripter</code> 当前结构里的内容做 <code>cache flush</code>，发送 <code>packet</code> 时，也要对 <code>packet buffer</code> 做 cache flush</li>
</ol>
</li>
<li>有些 <code>Driver</code> 会对 <code>descripter</code> 使用 <code>uncache 地址</code>，那么上面两种情况里 <code>invalidate/flush</code> 就不用做了。一般很少会对 <code>packet buffer</code> 也用 <code>uncache 地址</code> 的，<strong>因为对 <code>packet</code> 内容的处理将会很频繁，使用 <code>uncache</code> 会很慢。而 <code>descripter</code> 一般由于结构比较小，如果也使用 <code>cache</code> 地址的话，做 <code>invalidate/flush</code> 的时间消耗可能会比 <code>uncache</code> 的还要多。</strong></li>
</ul>
<h2 id="DMA-映射"><a href="#DMA-映射" class="headerlink" title="DMA 映射"></a>DMA 映射</h2><p>因此在 <code>DMA</code> 是否使用 <code>cache</code> 的问题上，可以根据 <code>DMA</code> 缓冲区期望保留的的时间长短来决策。根据 <code>DMA</code> 缓冲区期望保留的时间长短，区分两种类型的 <code>DMA</code> 映射：</p>
<ol>
<li><code>一致性 DMA 映射 (Coherent DMA buffers)</code><blockquote>
<p><code>一致性 DMA 映射</code> 申请的缓存区<strong>不使用 cache，因此可以保持 cache 一致性</strong>。一致性映射具有很长的生命周期，在这段时间内占用的映射寄存器，即使不使用也不会释放。生命周期为该驱动的生命周期</p>
</blockquote>
</li>
<li><code>流式 DMA 映射</code><blockquote>
<p><code>流式 DMA 映射</code> 实现比较复杂。<strong>生命周期比较短，而且使用 cache，需要处理一致性问题</strong>。一些硬件对流式映射有优化。建立 <code>流式 DMA 映射</code>，需要告诉内核数据的流动方向</p>
</blockquote>
<ol>
<li><code>DMA</code> 从外设读取数据到供处理器使用时，可先 <code>invalidate</code> 操作。这样将迫使处理器在读取 <code>cache</code> 中的数据时，先从内存中读取数据到缓存，保证缓存和内存中数据的一致性</li>
<li><code>DMA</code> 向外设写入由处理器提供的数据时，可先 <code>writeback</code> 操作。这样可以 <code>DMA</code> 传输数据之前先将缓存中的数据写回到内存中</li>
<li>如果不清楚 <code>DMA</code> 操作的方向，也可先同时进行 <code>invalidate</code> 和 <code>writeback</code> 操作。操作的结果等同于 <code>invalidate</code> 和 <code>writeback</code> 操作效果的和。</li>
</ol>
</li>
</ol>
<h3 id="一致性-DMA-映射"><a href="#一致性-DMA-映射" class="headerlink" title="一致性 DMA 映射"></a>一致性 DMA 映射</h3><p><code>dma_alloc_coherent()</code> 首先分配一组连续的物理页用作后续 <code>DMA</code> 操作的缓冲区，然后在软件层面将该段物理地址空间重新映射到非缓存的虚拟地址空间，具体来说在页目录和页表项中<strong>关闭了这段映射区间上的 cache 功能，使得 cache 的一致性问题不再成为问题</strong>。因为关闭了 cache，失去了高速缓存功能，所以一致性映射在性能上打了折扣。</p>
<h3 id="流式-DMA-映射"><a href="#流式-DMA-映射" class="headerlink" title="流式 DMA 映射"></a>流式 DMA 映射</h3><p>在 <code>流式 DMA 映射</code> 场合， <code>DMA</code> 传输通道所使用的缓冲区往往不是由当前驱动程序自身分配的，而且往往每次 <code>DMA</code> 传输都会重新建立一个 <code>流式映射的缓冲区</code>。此外，由于无法确定外部模块传入的 <code>DMA</code> 缓冲区的映射情况，所以设备驱动程序必须小心地处理可能会出现的 <code>cache 一致性问题</code>。</p>
<p>需要注意的是，在某些平台上，比如 <code>ARM</code>，** <code>CPU</code> 的读 / 写用的是不同的 cache（读用的是 <code>cache</code>，写则用的是 <code>write buffer</code> ），所以建立 <code>流式 DMA 映射</code> 需要指明数据在 <code>DMA</code> 通道中的流向，以便由内核决定是操作 <code>cache</code> 还是 <code>write buffer</code>。**</p>
<h2 id="pgprot-noncached"><a href="#pgprot-noncached" class="headerlink" title="pgprot_noncached"></a><code>pgprot_noncached</code></h2><p><code>arch:arm</code></p>
<p><code>pgprot_noncached()</code> 是一个宏，它实际上<strong>禁止了相关页的 cache 和写缓冲 (write buffer)</strong>, 另外一个稍微少的一些限制的宏是：</p>
<p><code>pgprot_writecombine(prot)</code> 它则没有禁止写缓冲</p>
<pre><code class="c">#define pgprot_noncached(prot) \
    __pgprot_modify(prot, L_PTE_MT_MASK, L_PTE_MT_UNCACHED)

#define pgprot_writecombine(prot) \
    __pgprot_modify(prot, L_PTE_MT_MASK, L_PTE_MT_BUFFERABLE)</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Direct_memory_access" target="_blank" rel="noopener">Direct memory access</a></li>
<li>[[Linux 内存』DMA 学习笔记一』(<a href="https://blog.csdn.net/u013686805/article/details/26607163" target="_blank" rel="noopener">https://blog.csdn.net/u013686805/article/details/26607163</a>)</li>
<li><a href="https://blog.csdn.net/xinghun_4/article/details/8572822" target="_blank" rel="noopener">DMA 和 cache 不一致</a></li>
<li><a href="https://blog.csdn.net/tangtang_yue/article/details/50635451" target="_blank" rel="noopener">DMA 映射</a></li>
<li><a href="https://blog.csdn.net/waterhawk/article/details/50723677" target="_blank" rel="noopener">DMA 导致的 CACHE 一致性问题解决方案</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>dma</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 自动在 /dev 下创建设备文件</title>
    <url>/2018/12/18/linux-auto-mknod/</url>
    <content><![CDATA[<p><code>insmod *.ko</code> 之后，部分驱动需要执行 <code>mknod</code> 才能正常工作，区别如下</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>针对驱动实现不同，使用不同，主要在于是否需要手动创建设备文件</p>
<pre><code class="shell">mknod /dev/panel0 c 22 0
insmod /lib/modules/ `uname -r` /panel.ko</code></pre>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>在 <code>Linux</code> 中有手动和自动两种设备管理，一种是 <code>mknod</code>，在 <code>insmod</code> 后 <code>/dev</code> 下必须有对应的设备文件，需要 <code>mknod</code> 来创建；另外一种在驱动中自动创建</p>
<p>利用 <code>udev（mdev）</code> 来实现设备文件的自动创建，首先应保证支持 <code>udev（mdev）</code>，由 <code>busybox</code> 配置。</p>
<p>在驱动用加入对 <code>mdev</code> 的支持主要做的就是：在驱动初始化的代码里调用 <code>class_create(...)</code> 为该设备创建一个 <code>class</code>，再为每个设备调用 <code>device_create(...)</code> 创建对应的设备。</p>
<p>内核中定义的 <code>struct class</code> 结构体，顾名思义，一个 <code>struct class</code> 结构体类型变量对应一个类，内核同时提供了 <code>class_create(…)</code> 函数，可以用它来创建一个类，这个类存放于 <code>sysfs</code> 下面，一旦创建好了这个类，再调用 <code>device_create(…)</code> 函数来在 <code>/dev</code> 目录下创建相应的设备节点。</p>
<p>这样，加载模块的时候，用户空间中的 <code>mdev</code> 会自动响应 <code>device_create()</code> 函数，去 <code>/sysfs</code> 下寻找对应的类从而创建设备节点。</p>
<pre><code class="c">
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/device.h&gt;

static int major = 250;
static int minor=0;
static dev_t devno;
static struct class *cls;
static struct device *test_device;

static int hello_open (struct inode *inode, struct file *filep)
{
    printk(&quot;hello_open \n&quot;);
    return 0;
}
static struct file_operations hello_ops=
{
    .open = hello_open,
};

static int hello_init(void)
{
    int ret;
    printk(&quot;hello_init \n&quot;);


    devno = MKDEV(major,minor);
    ret = register_chrdev(major,&quot;hello&quot;,&amp;hello_ops);

    cls = class_create(THIS_MODULE, &quot;myclass&quot;);
    if(IS_ERR(cls))
    {
        unregister_chrdev(major,&quot;hello&quot;);
        return -EBUSY;
    }
    test_device = device_create(cls,NULL,devno,NULL,&quot;hello&quot;);//mknod /dev/hello
    if(IS_ERR(test_device))
    {
        class_destroy(cls);
        unregister_chrdev(major,&quot;hello&quot;);
        return -EBUSY;
    }
    return 0;
}
static void hello_exit(void)
{
    device_destroy(cls,devno);
    class_destroy(cls);
    unregister_chrdev(major,&quot;hello&quot;);
    printk(&quot;hello_exit \n&quot;);
}
MODULE_LICENSE(&quot;GPL&quot;);
module_init(hello_init);
module_exit(hello_exit);</code></pre>
<p>下面可以看几个 class 几个名字的对应关系：<br><img src="/images/linux/mknod.png" alt="mknod"></p>
<h3 id="不同内核版本区别"><a href="#不同内核版本区别" class="headerlink" title="不同内核版本区别"></a>不同内核版本区别</h3><pre><code class="c">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,28)
#   define CLASS_DEV_CREATE(class, devt, device, id)      device_create(class, devt, device, NULL, &quot;hello%d&quot;, id)
#   define CLASS_DEV_DESTROY(class, devt)                 device_destroy(class, devt)
#elif LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,26)
#   define CLASS_DEV_CREATE(class, devt, device, id)      device_create(class, devt, device, NULL, &quot;hello%d&quot;, id)
#   define CLASS_DEV_DESTROY(class, devt)                 device_destroy(class, devt)
#elif LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,15)
#   define CLASS_DEV_CREATE(class, devt, device, id)      class_device_create(class, devt, device, NULL, &quot;hello%d&quot;, id)
#   define CLASS_DEV_DESTROY(class, devt)                 class_device_destroy(class, devt)
#else
#   define CLASS_DEV_CREATE(class, devt, device, id)      device_create_drvdata(class, devt, device, &quot;hello%d&quot;, id)
#   define CLASS_DEV_DESTROY(classs, devt)                device_destroy(class, devt)
#endif</code></pre>
<h2 id="mdev"><a href="#mdev" class="headerlink" title="mdev"></a>mdev</h2><pre><code class="shell">echo &quot;mdev...&quot;
echo /sbin/mdev &gt; /proc/sys/kernel/hotplug
/sbin/mdev -s</code></pre>
<p><code>mdev.conf</code> 如下</p>
<pre><code class="mdev.conf">null                   0:0 666
zero                   0:0 666
urandom                0:0 444

kmem                   0:9 000
mem                    0:9 640
port                   0:9 640

console                0:5 600
ptmx                   0:5 660
pty[a-z].              0:0 660
tty[a-z].              0:0 660
tty[0-9][0-9]          0:0 660

ttyS[0-9]              0:20 640

sd[a-z][0-9]*          0:6 660 * /etc/hotplug/usb/automount.sh $MDEV $ACTION
fd[0-9]*    0:11 660
hd[a-z]*    0:6 660</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/zqixiao_09/article/details/50849735" target="_blank" rel="noopener">Linux 字符设备驱动结构（二）—— 自动创建设备节点</a></li>
<li><a href="https://blog.csdn.net/seanyxie/article/details/5726128" target="_blank" rel="noopener">自动在 /dev/ 下创建设备文件</a></li>
<li><a href="http://www.cnblogs.com/hnrainll/archive/2011/06/24/2088577.html" target="_blank" rel="noopener">内核驱动模块如何在 /dev 文件下自动创建设备</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mknod</tag>
        <tag>insmod</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存屏障</title>
    <url>/2018/12/17/linux-memory-barrier/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://ifeve.com/memory-barriers-or-fences/" target="_blank" rel="noopener">内存屏障</a></li>
<li><a href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" target="_blank" rel="noopener">一文解决内存屏障</a></li>
<li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">内存屏障</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33626920" target="_blank" rel="noopener">为什么我们需要内存屏障？</a></li>
<li><a href="https://blog.codingnow.com/2007/12/fence_in_multi_core.html" target="_blank" rel="noopener">多核环境下的内存屏障指令</a></li>
<li><a href="https://blog.csdn.net/dd864140130/article/details/56494925" target="_blank" rel="noopener">谈乱序执行和内存屏障</a></li>
<li><a href="https://blog.csdn.net/puncha/article/details/8462835" target="_blank" rel="noopener">并发学习之：乱序执行和内存屏障</a></li>
<li><a href="https://www.cnblogs.com/DeanWang/p/7087959.html" target="_blank" rel="noopener">为什么在多核处理器下需要内存屏障（MenmoryBarrier）？</a></li>
<li><a href="https://blog.csdn.net/wentianyao/article/details/51250764" target="_blank" rel="noopener">线程同步 (1): 原子操作，内存屏障，锁综述</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 嵌入式文件系统</title>
    <url>/2018/12/17/linux-filesystem/</url>
    <content><![CDATA[<p>基于 <code>Flash</code> 的文件系统，包括只读文件系统和可读写文件系统</p>
<a id="more"></a>

<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是对一个存储设备上的数据和元数据进行组织的机制。 <code>Linux</code> 文件系统接口实现为分层的体系结构，从而将用户接口层、文件系统实现和操作存储设备的驱动程序分隔开。</p>
<h2 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h2><h3 id="Flash-内存技术"><a href="#Flash-内存技术" class="headerlink" title="Flash 内存技术"></a>Flash 内存技术</h3><p><code>Flash</code> 分为 <code>nor</code> 和 <code>nand</code> 两种：</p>
<ol>
<li><code>nor</code> 支持较高的读性能，但以降低容量为代价</li>
<li><code>nand</code> 提供更大容量的同时实现快速的写擦性能。还需要更复杂的输入 / 输出接口</li>
</ol>
<p>Flash 部件通常分为多个分区，允许同时进行多个操作（擦除某个分区的同时读取另一个分区）。分区再划分为块（通常大小为 64KB 或 128KB）。使用分区的固件可以进一步对块进行独特的分段 — 例如，一个块中有 512 字节的分段，但不包括元数据。</p>
<p>Flash 设备有一个常见的限制，即与其他存储设备（如 RAM 磁盘）相比，它需要进行设备管理。flash 内存设备中惟一允许的 Write 操作是将 1 修改为 0。如果需要撤销操作，那么必须擦除整个块（将所有数据重置回状态 1）。这意味着必须删除该块中的其他有效数据来实现持久化。NOR flash 内存通常一次可以编写一个字节，而 NAND flash 内存必须编写多个字节（通常为 512 字节）。</p>
<p>这两种内存类型在擦除块方面有所不同。每种类型都需要一个特殊的 Erase 操作，该操作可以涵盖 flash 内存中的一个整块。NOR 技术需要通过一个准备步骤将所有值清零，然后再开始 Erase 操作。Erase 是针对 flash 设备的特殊操作，非常耗费时间。擦除操作与电有关，它将整个块的所有单元中的电子放掉。</p>
<p>NOR flash 设备通常需要花费几秒时间来执行 Erase 操作，而 NAND 设备只需要几毫秒。flash 设备的一个关键特性是可执行的 Erase 操作的数量。在 NOR 设备中，flash 内存中的每个块可被擦除 100,000 次，而在 NAND flash 内存中可达到一百万次。</p>
<h3 id="Flash-内存面临的挑战"><a href="#Flash-内存面临的挑战" class="headerlink" title="Flash 内存面临的挑战"></a>Flash 内存面临的挑战</h3><ul>
<li><code>垃圾收集</code> 是一个回收无效块的过程（无效块中包含了一些无效数据）。回收过程包括将有效数据移动到新块，然后擦除无效块从而使它变为可用。</li>
<li><code>管理坏块</code></li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/" target="_blank" rel="noopener">Linux 文件系统剖析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-flash-filesystems/index.html" target="_blank" rel="noopener">Linux flash 文件系统剖析</a></li>
<li><a href="https://blog.csdn.net/yiwuxue/article/details/10464277" target="_blank" rel="noopener">Flash 文件系统介绍和平台采用 squashfs+ubifs 原因</a></li>
<li><a href="https://blog.csdn.net/iceiilin/article/details/22721029" target="_blank" rel="noopener">嵌入式：jffs2,yaffs2,logfs,ubifs 文件系统性能分析</a></li>
<li><code>Filesystem in Userspace（FUSE）</code> 是一个支持在用户空间中开发文件系统的内核模块。文件系统驱动程序实现将来自 <code>VFS</code> 的请求发送回用户空间。这是一种在不借助内核开发的情况下开发文件系统的好方法</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>filesystem</tag>
        <tag>fuse</tag>
        <tag>jffs</tag>
        <tag>jffs2</tag>
        <tag>yaffs</tag>
        <tag>yaffs2</tag>
        <tag>cramfs</tag>
        <tag>squashfs</tag>
        <tag>minifs</tag>
        <tag>romfs</tag>
        <tag>ramfs</tag>
        <tag>tmpfs</tag>
        <tag>ubifs</tag>
        <tag>logfs</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-ftrace</title>
    <url>/2018/12/13/linux-ftrace/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/index.html" target="_blank" rel="noopener">使用 ftrace 调试 Linux 内核</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22130013" target="_blank" rel="noopener">在 Linux 下做性能分析 2：ftrace</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27190018" target="_blank" rel="noopener">动态追踪技术：trace your kernel Functions!</a></li>
<li><a href="http://lzz5235.github.io/2013/11/22/ltrace-strace-ftrace.html" target="_blank" rel="noopener">调试工具 ltrace strace ftrace 的使用</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html" target="_blank" rel="noopener">ftrace 简介</a></li>
<li><a href="https://blog.csdn.net/longerzone/article/details/16884703" target="_blank" rel="noopener">Linux 内核调试工具 Ftrace 进阶使用手册</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Linux 内核栈溢出检测</title>
    <url>/2018/12/12/linux-kernel-stack-check/</url>
    <content><![CDATA[<p>借助 <code>Linux debugfs</code> 来检测内核栈使用状态及溢出检测</p>
<a id="more"></a>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><code>Linux</code> 内核中有 <code>KASAN</code> 和 <code>kmemcheck</code></p>
<p><code>KASAN</code> 只支持 <code>arm64</code> 和 <code>x86</code>，见内核文档 <code>Documentation/features/debug/KASAN/arch-support.txt</code></p>
<p><code>kmemcheck</code> 仅支持 <code>x86</code></p>
<p>因此在 <code>arm</code> 下使用 <code>debugfs</code> 来跟踪内核栈使用情况</p>
<h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><ul>
<li><code>debugfs</code> 支持</li>
<li><code>ftrace</code> 支持<pre><code class="kconfig">Kernel hacking -&gt;
  Tracers -&gt;
      [*]   Trace max stack</code></pre>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code class="shell"># mount -t debugfs nodev /sys/kernel/debug
# echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled</code></pre>
<p>检查以下状态</p>
<pre><code class="shell"># cat /sys/kernel/debug/tracing/stack_max_size
# cat /sys/kernel/debug/tracing/stack_trace

# cat /sys/kernel/debug/tracing/stack_max_size
7272
# cat /sys/kernel/debug/tracing/stack_trace
        Depth    Size   Location    (61 entries)
        -----    ----   --------
  0)     7080     224   select_task_rq_fair+0x3be/0x980
  1)     6856     112   try_to_wake_up+0x14a/0x400
  2)     6744      16   wake_up_process+0x15/0x20
  3)     6728      16   wakeup_softirqd+0x35/0x40
  4)     6712      48   raise_softirq_irqoff+0x4f/0x90
  5)     6664      48   __blk_complete_request+0x132/0x140
  6)     6616      16   blk_complete_request+0x25/0x30
  7)     6600      32   scsi_done+0x2f/0x60
  8)     6568      48   megasas_queue_command+0xd1/0x140 [megaraid_sas]
  9)     6520      48   scsi_dispatch_cmd+0x1ac/0x340
 10)     6472      96   scsi_request_fn+0x415/0x590
 11)     6376      32   __generic_unplug_device+0x32/0x40</code></pre>
<ul>
<li><code>stack_max_size</code> 内核栈使用的峰值</li>
<li><code>stack_trace</code> 表示此峰值下的 <code>callstack</code> 和 <code>callstack</code> 中个个函数使用的栈的大小</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://linuxperf.com/?p=116" target="_blank" rel="noopener">内核栈溢出</a></li>
<li><a href="https://blog.csdn.net/tiantao2012/article/details/77993000" target="_blank" rel="noopener">kernel 内核栈的检测</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1608_tengr_kasan/index.html" target="_blank" rel="noopener">Kasan - Linux 内核的内存检测工具</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>stack</tag>
        <tag>debugfs</tag>
        <tag>tracer</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统 procfs、sysfs 和 debugfs</title>
    <url>/2018/12/12/linux-procfs-sysfs-debugfs/</url>
    <content><![CDATA[<p>内核中有三个常用的伪文件系统： <code>procfs</code>， <code>debugfs</code> 和 <code>sysfs</code></p>
<ul>
<li><code>procfs</code> — The proc filesystem is a pseudo-filesystem which provides an interface to kernel data structures.</li>
<li><code>sysfs</code> — The filesystem for exporting kernel objects.</li>
<li><code>debugfs</code> — Debugfs exists as a simple way for kernel developers to make information available to user space.</li>
</ul>
<a id="more"></a>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>都用于 <code>Linux 内核</code> 和 <code>用户空间</code> 的数据交换，但是适用的场景有所差异：</p>
<ul>
<li><code>procfs</code> 历史最早，最初就是用来跟内核交互的唯一方式，用来获取处理器、内存、设备驱动、进程等各种信息</li>
<li><code>sysfs</code> 跟 <code>kobject</code> 框架紧密联系，而 <code>kobject</code> 是为设备驱动模型而存在的，所以 <code>sysfs</code> 是为设备驱动服务的</li>
<li><code>debugfs</code> 从名字来看就是为 <code>debug</code> 而生，所以更加灵活</li>
</ul>
<p>挂载方式</p>
<pre><code class="shell">$ sudo mount -t proc nondev /proc/
$ sudo mount -t sys nondev /sys/
$ sudo mount -t debugfs nondev /sys/kernel/debug/</code></pre>
<p>内核文档路径</p>
<ul>
<li><code>procfs</code> — Documentation/filesystems/proc.txt</li>
<li><code>sysfs</code> — Documentation/filesystems/sysfs.txt</li>
<li><code>debugfs</code> — Documentation/filesystems/debugfs.txt</li>
</ul>
<h2 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h2><p><code>procfs</code> 其目的是反映进程的状态信息，而 <code>sysfs</code> 主要用于 <code>Linux 设备模型</code>，使用 <code>debugfs</code> 来调试内核，把我们需要关心的数据映射到用户空间</p>
<p>挂载命令</p>
<pre><code class="shell">mount -t debugfs none /sys/kernel/debug</code></pre>
<p>内核选项</p>
<pre><code class="kconfig">Kernelhacking ---&gt;
    [*]Debug Filesystem</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://tinylab.org/show-the-usage-of-procfs-sysfs-debugfs/" target="_blank" rel="noopener">Linux 文件系统：procfs, sysfs, debugfs 用法简介</a></li>
<li><a href="http://jingpin.jikexueyuan.com/article/56379.html" target="_blank" rel="noopener">linux 内核 DebugFS</a></li>
<li><a href="https://blog.csdn.net/wealoong/article/details/7992071" target="_blank" rel="noopener">Linux 驱动调试中的 Debugfs 的使用简介</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>debugfs</tag>
        <tag>procfs</tag>
        <tag>sysfs</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU hotplug in the Kernel</title>
    <url>/2018/12/11/linux-cpu-hotplug/</url>
    <content><![CDATA[<p><code>Linux</code> 支持多核 <code>CPU</code> 热插拔</p>
<a id="more"></a>

<h2 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a><a href="https://www.jianshu.com/p/81233f3c2c14" target="_blank" rel="noopener">CPU 架构</a></h2><ul>
<li><code>SMP(Symmetric Multiprocessing)</code> 对称多处理器</li>
<li><code>NUMA(Non-Uniform Memory Access)</code> 非均匀访问存储模型</li>
<li><code>MPP(Massive Parallel Processing)</code></li>
</ul>
<p>使用的嵌入式内核为 <code>SMP</code>，在 SMP 中所有的处理器都是对等的，它们通过总线连接共享同一块物理内存，这也就导致了系统中所有资源 ( <code>CPU</code>、 <code>内存</code>、 <code>I/O</code> 等）都是共享的</p>
<h2 id="cpu-hotplug"><a href="#cpu-hotplug" class="headerlink" title="cpu hotplug"></a>cpu hotplug</h2><p>内核配置</p>
<pre><code class="kconfig">[*] Symmetric Multi-Processing
    [*]   Allow booting SMP kernel on uniprocessor systems
    [*]   Support cpu topology definition
    [ ]     Multi-core scheduler support
    [ ]     SMT scheduler support
    -*- Architected timer support
    [ ] Multi-Cluster Power Management
    [ ] big.LITTLE support (Experimental)
        Memory split (3G/1G user/kernel split)  ---&gt;
    (2) Maximum number of CPUs (2-32)
    -*- Support for hot-pluggable CPUs</code></pre>
<p>使用命令 <code>ls -l /sys/devices/system/cpu/</code> 查询多核状态<br>使用命令 <code>echo 0 &gt; /sys/devices/system/cpu/cpu1/online</code> 关闭 <code>cpu1</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu hotplug</tag>
        <tag>smp</tag>
      </tags>
  </entry>
  <entry>
    <title>ps/pstree/top 支持 thread</title>
    <url>/2018/12/11/ps-support-thread/</url>
    <content><![CDATA[<p><code>嵌入式 Linux</code> 系统中增加 <code>thread</code> 支持</p>
<a id="more"></a>

<p><code>ps -T</code> 显示系统中的 <code>threads</code>，需要打开 <code>busybox</code> 中的配置项 <code>Support thread display in ps/pstree/top</code></p>
<p>打开之后 <code>ps/pstree/top</code> 支持 <code>thread</code></p>
<p>针对 <code>SMP</code> 系统可以打开 <code>top</code> 多个选项增强调试信息</p>
<pre><code class="kconfig">[*] top
    [*]   Accept keyboard commands
    [*]   Show CPU per-process usage percentage
    [*]     Show CPU global usage percentage
    [*]       SMP CPU usage display (&#39;c&#39; key)
    [*]     Show 1/10th of a percent in CPU/mem statistics
    [*]   Show CPU process runs on (&#39;j&#39; field)
    [*]   Topmem command (&#39;s&#39; key)</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>thread</tag>
        <tag>ps</tag>
        <tag>pstree</tag>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title>udhcpc 不能正常工作</title>
    <url>/2018/12/07/udhcpc-default-scripts/</url>
    <content><![CDATA[<p>嵌入式环境下使用 <code>udhcpc</code> 不能正确获取地址，记录解决过程</p>
<a id="more"></a>

<p>使用命令如下</p>
<pre><code class="shell">udhcpc -t 10 -T 3 -n -q -i &quot;$dev&quot;</code></pre>
<p>执行命令之后无返回， <code>ps</code> 如下</p>
<pre><code> 1783 root     {default.script} /bin/sh /usr/share/udhcpc/default.script bound
 1784 root     ifconfig eth0 192.168.110.25 netmask 255.255.254.0 broadcast +
 3677 root     /bin/sh -c wired_start eth0
 3678 root     {wired_start} /bin/sh /usr/local/sbin/wired_start eth0
 3731 root     {if_set_cfg} /bin/sh /usr/local/sbin/if_set_cfg /tmp/ethernet/mo
 3746 root     udhcpc -t 20 -T 1 -n -q -i eth0
 3749 root     {default.script} /bin/sh /usr/share/udhcpc/default.script bound
 3750 root     ifconfig eth0 192.168.110.25 netmask 255.255.254.0 broadcast +</code></pre><p><code>default.script</code> 为 <code>udhcpc</code> 调用的脚本，卡在 <code>ifconfig eth0 192.168.110.25 netmask 255.255.254.0 broadcast +</code> 此处</p>
<p>经测试原因为使用参数 <code>broadcast +</code></p>
<p>查找 <code>busybox</code> 配置，发现选项 <code>CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS</code> 未打开，打开此选项以支持 <code>broadcast +</code> 解决问题</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>dhcp</tag>
        <tag>ifconfig</tag>
      </tags>
  </entry>
  <entry>
    <title>system-and-popen</title>
    <url>/2018/12/05/system-and-popen/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/suifengpiao_2011/article/details/41280941" target="_blank" rel="noopener">使用 popen 和 system 阻塞进程的区别</a></li>
<li><a href="https://bbs.csdn.net/topics/390830188" target="_blank" rel="noopener">system 函数阻塞问题</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_8043547601017qk0.html" target="_blank" rel="noopener">对于 linux 下 system() 函数的深度理解</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>使用 cmake 同时生成静态和动态库</title>
    <url>/2018/12/05/how-to-use-cmake-build-both-static-and-shared-library/</url>
    <content><![CDATA[<p>使用 <code>cmake</code> 同时编译出静态和动态库文件</p>
<a id="more"></a>

<ol>
<li><code>ADD_LIBRARY( ${name} SHARED ${ARGN} )</code> 编译动态库</li>
<li><code>ADD_LIBRARY(MyLibStatic STATIC source1.c source2.c)</code> 编译静态库</li>
</ol>
<p><code>ADD_LIBRARY</code> 原型</p>
<pre><code class="cmake">ADD_LIBRARY(&lt;name&gt; [STATIC | SHARED | MODULE]
              [EXCLUDE_FROM_ALL]
              source1 source2 ... sourceN)</code></pre>
<p><code>ADD_LIBRARY</code> 可以指定 <code>STATIC</code>、 <code>SHARED</code> 或 <code>MODULE</code> 三种类型之一，如果没有类型被显式指定，这个选项将会根据变量 <code>BUILD_SHARED_LIBS</code> 的当前值是否为真决定是 <code>STATIC</code> 还是 <code>SHARED</code></p>
<pre><code class="cmake"># User-configurable options
SET(BUILD_SHARED_LIBS OFF CACHE BOOL
    &quot;Build shared libraries instead of static ones.&quot;)

FUNCTION(ADD_N_LIBRARY name)
    # 生成动态库目标
    IF (OS STREQUAL LINUX)
        ADD_LIBRARY( ${name} SHARED ${ARGN} )
        SET_TARGET_PROPERTIES(${name} PROPERTIES CLEAN_DIRECT_OUTPUT 1)
        SET_TARGET_PROPERTIES(${name} PROPERTIES VERSION 1.0 SOVERSION 1)
        INSTALL( TARGETS ${name} LIBRARY DESTINATION ${PATH}/lib/share)
    ENDIF()
    # 生成静态库目标
    ADD_LIBRARY( ${name}_static ${ARGN} )
    # 指定静态库的输出名称
    SET_TARGET_PROPERTIES(${name}_static PROPERTIES OUTPUT_NAME ${name})
    SET_TARGET_PROPERTIES(${name}_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)
    INSTALL( TARGETS ${name}_static ARCHIVE DESTINATION ${PATH}/lib)
ENDFUNCTION(ADD_N_LIBRARY name)</code></pre>
<p>注意生成静态库时不能使用与动态库一样的名字，例如 <code>ADD_LIBRARY( ${name} ${ARGN} )</code>，重名会导致静态构建失效。而我们需要静态与动态同名，需要使用 <code>SET_TARGET_PROPERTIES</code> 用来设置输出的名称，对于动态库，还可以用来指定动态库版本</p>
<pre><code class="cmake">SET_TARGET_PROPERTIES(target1 target2 ...
                    PROPERTIES prop1 value1
                    prop2 value2 ...)</code></pre>
<p><code>VERSION</code> 指代动态库版本， <code>SOVERSION</code> 指代 <code>API 版本</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译 libusb、libusb-compat 和 usb_modeswitch</title>
    <url>/2018/12/04/libusb-and-libusb-compat-and-usb-modeswitch/</url>
    <content><![CDATA[<p>交叉编译 <code>libusb</code>、 <code>libusb-compat</code> 以及 <code>usb_modeswitch</code>，以及之间的关系</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>usb modeswitch</code> 实现无线上网卡从 USB Storage 模式切换到 Modem 模式。<a href="http://www.draisberghof.de/usb_modeswitch/" target="_blank" rel="noopener">usb modeswitch</a></li>
<li><code>libusb</code>、 <code>libusb-compat</code>， <code>usb_modeswitch</code> 需要 <code>libusb</code> 的支持。 <code>libusb</code> 分为 <code>1.0 版</code> 和 <code>0.1 版</code> 两种版本， <code>1.0</code> 并不向下兼容 <code>0.1</code>，需要 <code>libusb-compat</code> 的支持</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>交叉编译 <code>libusb</code> -&gt; <code>libusb-compat</code> -&gt; <code>usb_modeswitch</code></p>
<p>设置变量用于编译链接</p>
<pre><code class="makefile">PKG_CONFIG_PATH=$(INST_DIR)/lib/pkgconfig
export PKG_CONFIG_PATH</code></pre>
<h3 id="libusb"><a href="#libusb" class="headerlink" title="libusb"></a>libusb</h3><pre><code class="shell">./configure --host=$(HOST) --disable-udev --prefix=$(INST_DIR) ac_cv_func_gettimeofday=yes
make
make install</code></pre>
<p>安装完成后有如下信息</p>
<pre><code>...
Libraries have been installed in:
   &lt;Your Install DIR&gt;
If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR&#39;
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;
See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
...</code></pre><p>结构</p>
<pre><code class="shell">$ tree
.
├── bin
│   └── libusb-config
├── include
│   ├── libusb-1.0
│   │   └── libusb.h
│   └── usb.h
└── lib
    ├── libusb-1.0.a
    ├── libusb-1.0.la
    ├── libusb.a
    ├── libusb.la
    └── pkgconfig
        ├── libusb-1.0.pc
        └── libusb.pc</code></pre>
<p>当编译后续包时需要依赖已交叉编译的包</p>
<h3 id="libusb-compat"><a href="#libusb-compat" class="headerlink" title="libusb-compat"></a>libusb-compat</h3><pre><code class="shell">./configure LDFLAGS=&quot;-L$(INST_DIR)/lib $(CONFIG_EXTRA_FLAGS)&quot; --host=$(HOST) --prefix=$(INST_DIR)
make
make install</code></pre>
<h3 id="usb-modeswitch"><a href="#usb-modeswitch" class="headerlink" title="usb_modeswitch"></a>usb_modeswitch</h3><pre><code class="shell">make $J CC=$(CONFIG_CROSS_COMPILE)gcc   LDFLAGS=&quot;-L$(INST_DIR)/lib -lusb-1.0 -static -lpthread $(CONFIG_EXTRA_FLAGS)&quot; CFLAGS=&quot;-I$(INST_DIR)/include/libusb-1.0 $(CONFIG_EXTRA_FLAGS)&quot;</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>libusb</tag>
        <tag>libusb-compat</tag>
        <tag>modeswitch</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Panic 原因及分析</title>
    <url>/2018/11/30/linux-panic/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/varistor/article/details/50462252" target="_blank" rel="noopener">linux panic 问题定位</a></li>
<li><a href="https://blog.csdn.net/liukuan73/article/details/45537889" target="_blank" rel="noopener">Linux 内核 kernel panic 机制浅析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-deadlock</title>
    <url>/2018/11/29/linux-kernel-deadlock/</url>
    <content><![CDATA[<p>系统出现死机问题，终端无法操作，怀疑是死锁问题，开启内核选项来辅助调试</p>
<a id="more"></a>

<h2 id="Linux-kernel-configuration"><a href="#Linux-kernel-configuration" class="headerlink" title="Linux kernel configuration"></a>Linux kernel configuration</h2><ol>
<li><code>General setup</code> -&gt; <code>Configure standard kernel features</code> 开启，使用默认值并保证子选项 <code>Load all symbols for debugging/ksymoops</code> 打开</li>
<li><code>Kernel hacking</code> -&gt; <code>Panic on Oops</code> 开启</li>
<li><code>Kernel hacking</code> -&gt; <code>Lock Debugging (spinlocks, mutexes, etc...)</code> 开启子选项<ul>
<li><code>RT Mutex debugging, deadlock detection</code></li>
<li><code>Spinlock and rw-lock debugging: basic checks</code></li>
<li><code>Mutex debugging: basic checks</code></li>
</ul>
</li>
</ol>
<h2 id="panic-分析"><a href="#panic-分析" class="headerlink" title="panic 分析"></a>panic 分析</h2><p>死机时输出如下信息，可以看出是 <code>spinlock</code> 导致的问题</p>
<pre><code>[  304.883867] VPU_DecClose: success
[  309.036689] BUG: spinlock lockup suspected on CPU#0, thread-demux0/801
[  309.044130]  lock: gxdmxdev+0x580/0xffe44a4c [av], .magic: dead4ead, .owner: dumpfilter_thre/10758, .owner_cpu: 1
[  309.054407] CPU: 0 PID: 801 Comm: thread-demux0 Tainted: G           O    4.9.y #7
[  309.061979] Hardware name: nationalchip sirius
[  309.066458] [&lt;c010f290&gt;] (unwind_backtrace) from [&lt;c010b834&gt;] (show_stack+0x10/0x14)
[  309.074220] [&lt;c010b834&gt;] (show_stack) from [&lt;c0374618&gt;] (dump_stack+0x94/0xa8)
[  309.081460] [&lt;c0374618&gt;] (dump_stack) from [&lt;c015d860&gt;] (do_raw_spin_lock+0xfc/0x1b8)
[  309.089309] [&lt;c015d860&gt;] (do_raw_spin_lock) from [&lt;c0651830&gt;] (_raw_spin_lock_irqsave+0x10/0x18)
[  309.098594] [&lt;c0651830&gt;] (_raw_spin_lock_irqsave) from [&lt;bf004e9c&gt;] (gxfifo_put+0x110/0x144 [av])
[  309.108335] [&lt;bf004e9c&gt;] (gxfifo_put [av]) from [&lt;bf05ff9c&gt;] (gx3211_tsw_dealwith+0x210/0x35c [av])
[  309.118203] [&lt;bf05ff9c&gt;] (gx3211_tsw_dealwith [av]) from [&lt;bf060814&gt;] (gx3211_tsw_isr+0x144/0x244 [av])
[  309.128405] [&lt;bf060814&gt;] (gx3211_tsw_isr [av]) from [&lt;bf059da0&gt;] (demux_irq_thread+0xa4/0xe0 [av])
[  309.137781] [&lt;bf059da0&gt;] (demux_irq_thread [av]) from [&lt;c01385d4&gt;] (kthread+0xdc/0xf4)
[  309.145720] [&lt;c01385d4&gt;] (kthread) from [&lt;c0107678&gt;] (ret_from_fork+0x14/0x3c)
[  309.152951] NMI backtrace for cpu 0</code></pre><p>需要使用的几种工具 <code>objdump</code>、 <code>addr2line</code></p>
<p><code>[&lt;bf004e9c&gt;] (gxfifo_put [av]) from [&lt;bf05ff9c&gt;] (gx3211_tsw_dealwith+0x210/0x35c [av])</code> 解析如下</p>
<ul>
<li><code>&lt;bf004e9c&gt;</code> 当前栈指针</li>
<li><code>gxfifo_put</code> 当前调用</li>
<li><code>[av]</code> 模块名</li>
<li><code>from [&lt;bf05ff9c&gt;]</code> 上一栈指针</li>
<li><code>gx3211_tsw_dealwith</code> 函数调用</li>
<li><code>0x210/0x35c</code>， <code>0x210</code> 偏移， <code>0x35c</code> 函数大小</li>
</ul>
<p>可以使用 <code>objdump -d -t -S linux/a.o</code> 查看函数</p>
<p>另外模块在加载时存在偏移量，使用 <code>lsmod</code> 查询偏移量已计算绝对值</p>
<pre><code class="shell">$ lsmod
av 2552573 3 - Live 0xbf000000 (O)</code></pre>
<p><code>[&lt;bf004e9c&gt;] (gxfifo_put [av]) from [&lt;bf05ff9c&gt;] (gx3211_tsw_dealwith+0x210/0x35c [av])</code></p>
<p>反汇编代码截取如下， <code>0x5ff9c = 0x0005fd8c + 0x210</code></p>
<pre><code>0005fd8c &lt;gx3211_tsw_dealwith&gt;:
    .
    .
    5ff98:   ebfffffe    bl  4d8c &lt;gxfifo_put&gt;
    5ff9c:   eaffffac    b   5fe54 &lt;gx3211_tsw_dealwith+0xc8&gt;
    5ffa0:   e1a0200a    mov r2, sl
    .</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>panic</tag>
        <tag>deadlock</tag>
        <tag>oops</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel 内核 uIamge 与 zImage 区别</title>
    <url>/2018/11/28/linux-kernel-uImage-zImage/</url>
    <content><![CDATA[<p><code>Linux</code> 编译可以生成 <code>uImage</code>、 <code>Image</code> 以及 <code>zImage</code> 内核，其中 <code>uImage</code> 是 <code>uboot</code> 专用内核映像文件</p>
<a id="more"></a>

<h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><p><code>Linux</code> 内核编译默认生成 <code>Image</code> 和 <code>zImage</code>，其中 <code>Image</code> 为内核映像文件，而 <code>zImage</code> 为内核的一种映像压缩文件</p>
<p><code>uImage</code> 为 <code>uboot</code> 专用的映像文件，是在 <code>zImage</code> 之前加上一个长度为 64 字节的头，说明这个内核的版本、加载位置、生成时间、大小等信息；其 0x40 之后与 <code>zImage</code> 没区别，64 字节头部结构如下</p>
<pre><code class="c">typedef struct image_header {
    uint32_tih_magic;
    uint32_tih_hcrc;
    uint32_tih_time;
    uint32_tih_size;
    uint32_tih_load;
    uint32_tih_ep;
    uint32_tih_dcrc;
    uint8_tih_os;
    uint8_tih_arch;
    uint8_tih_type;
    uint8_tih_comp;
    uint8_tih_name[IH_NMLEN];
} image_header_t;</code></pre>
<p><code>zImage</code> 由 <code>vmlinux</code> <code>objcopy</code> 出来的纯二进制文件以及解压缩程序组成， <code>zImage</code> 自带了解压缩程序</p>
<p><code>uImage</code> 和 <code>zImage</code> 都是压缩后的内核映像。而 <code>uImage</code> 是用 <code>mkimage 工具</code> 根据 <code>zImage</code> 制作而来的</p>
<p>编译 <code>uImage</code> 需要指定 <code>make ARCH=arm CROSS_COMPILE=arm-linux- uImage LOADADDR=0x8000</code></p>
<h2 id="LOADADDR"><a href="#LOADADDR" class="headerlink" title="LOADADDR"></a>LOADADDR</h2><p>当编译 <code>uImage</code> 时需要指定一个参数 <code>LOADADDR</code>，指定内核映像所在的地址，对于 <code>arm</code> 来将这个是惯例</p>
<blockquote>
<p>Despite the ability to place zImage anywhere within memory, convention has it that it is loaded at the base of physical RAM plus an offset of 0x8000 (32K). This leaves space for the parameter block usually placed at offset 0x100, zero page exception vectors and page tables. This convention is very common.</p>
</blockquote>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/chenqiai0/article/details/8533625" target="_blank" rel="noopener">Image uImage zImage U-Boot 的区别</a></li>
<li><a href="https://stackoverflow.com/questions/31725605/building-kernel-uimage-using-loadaddr" target="_blank" rel="noopener">Building kernel uImage using LOADADDR</a></li>
<li><a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html" target="_blank" rel="noopener">Booting ARM Linux</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uboot</tag>
        <tag>uImage</tag>
        <tag>zImage</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 repo manfiest 管理项目代码</title>
    <url>/2018/11/27/repo-manfiest-management/</url>
    <content><![CDATA[<p>使用 <code>repo</code> 管理工程代码，需要切换不同仓库和不同分支，记录如下</p>
<a id="more"></a>

<p>需要在原有 <code>repo</code> 中增加其他工程指定分支代码</p>
<ol>
<li><p>下载指定 <code>repo manfiest</code>，指定分支</p>
<pre><code class="shell">git clone ssh://git@ip/to/manifests.git
cd manifests
git checkout origin/$SOURCE $SOURCE</code></pre>
</li>
<li><p><code>default.xml</code> 如下</p>
<pre><code class="xml">&lt;manifest&gt;
 &lt;remote  name=&quot;aosp&quot;
         fetch=&quot;https://android.googlesource.com/&quot;/&gt;

 &lt;default revision=&quot;master&quot;
         remote=&quot;aosp&quot;
         sync-j=&quot;4&quot; /&gt;

 &lt;project path=&quot;art&quot; name=&quot;platform/art&quot; /&gt;
 &lt;project path=&quot;bionic&quot; name=&quot;platform/bionic&quot; groups=&quot;pdk&quot; /&gt;
 &lt;project path=&quot;tools/adt/eclipse&quot; name=&quot;platform/tools/adt/eclipse&quot; groups=&quot;notdefault,tools&quot; /&gt;
&lt;/manifest&gt;</code></pre>
</li>
<li><p>编辑 <code>default.xml</code>，增加另一个仓库指定分支代码， <code>remote</code> 指定仓库， <code>revision</code> 指定分支或 <code>tag</code></p>
<pre><code class="xml">&lt;manifest&gt;
 &lt;remote  name=&quot;aosp&quot;
         fetch=&quot;https://android.googlesource.com/&quot;/&gt;
 &lt;remote  name=&quot;udinic&quot;
         fetch=&quot;https://github.com/udinic/&quot;/&gt;

 &lt;default revision=&quot;master&quot;
         remote=&quot;aosp&quot;
         sync-j=&quot;4&quot; /&gt;

 &lt;project path=&quot;art&quot; name=&quot;platform/art&quot; /&gt;
 &lt;project path=&quot;bionic&quot; name=&quot;platform/bionic&quot; groups=&quot;pdk&quot; /&gt;
 &lt;project path=&quot;dalvik&quot; name=&quot;platform_dalvik” remote=“udinic”/&gt;
 &lt;project path=&quot;frameworks/base&quot; name=&quot;platform_frameworks_base&quot; remote=“udinic&quot; revision=“statusbar_fixes&quot;/&gt;
 &lt;project path=&quot;tools/adt/eclipse&quot; name=&quot;platform/tools/adt/eclipse&quot; groups=&quot;notdefault,tools&quot; /&gt;
&lt;/manifest&gt;</code></pre>
</li>
<li><p>上传 <code>default.xml</code> 到指定分支 <code>$SOURCE</code></p>
<pre><code class="shell">git add default.xml
git commit -m &quot;add some projects&quot;
git push</code></pre>
</li>
<li><p><code>repack</code> 对松散对象进行打包</p>
<pre><code class="shell">ssh git@ip -t /home/git/repac</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Repo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
        <tag>repo</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>repo manifest 使用指南</title>
    <url>/2018/11/23/repo-manifest-tutorial/</url>
    <content><![CDATA[<p>使用 <code>repo</code> 管理工程源码及分支，需要对 <code>manfiest.xml</code> 有深入了解，本文记录主要关注点</p>
<a id="more"></a>

<h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><p><code>repo init -u $URL -b $BRANCH -m $MANIFEST</code> 相当于执行如下命令队列</p>
<pre><code>  mkdir .repo
  cd .repo
  git clone https://android.googlesource.com/tools/repo
  git clone --bare $URL manifests.git
  mkdir -p manifests/.git; cd manifests/.git
  for i in ../../manifests.git/*; do ln -s $ı .; done
  cd ..
  git checkout $BRANCH -- .
  cd ..
  ln -s manifests/$MANIFEST manifest.xml</code></pre><h2 id="manfiest-xml"><a href="#manfiest-xml" class="headerlink" title="manfiest.xml"></a>manfiest.xml</h2><p><code>repo v1.3</code></p>
<pre><code>&lt;!DOCTYPE manifest [
  &lt;!ELEMENT manifest (remote*,
                      default?,
                      project*,
                      add-remote*)&gt;
  &lt;!ELEMENT remote (EMPTY)&gt;
  &lt;!ATTLIST remote name         ID    #REQUIRED&gt;
  &lt;!ATTLIST remote fetch        CDATA #REQUIRED&gt;
  &lt;!ATTLIST remote review       CDATA #IMPLIED&gt;
  &lt;!ATTLIST remote project-name CDATA #IMPLIED&gt;
  &lt;!ELEMENT default (EMPTY)&gt;
  &lt;!ATTLIST default remote   IDREF #IMPLIED&gt;
  &lt;!ATTLIST default revision CDATA #IMPLIED&gt;
  &lt;!ELEMENT project (remote*)&gt;
  &lt;!ATTLIST project name     CDATA #REQUIRED&gt;
  &lt;!ATTLIST project path     CDATA #IMPLIED&gt;
  &lt;!ATTLIST project remote   IDREF #IMPLIED&gt;
  &lt;!ATTLIST project revision CDATA #IMPLIED&gt;
  &lt;!ELEMENT add-remote (EMPTY)&gt;
  &lt;!ATTLIST add-remote to-project   ID    #REQUIRED&gt;
  &lt;!ATTLIST add-remote name         ID    #REQUIRED&gt;
  &lt;!ATTLIST add-remote fetch        CDATA #REQUIRED&gt;
  &lt;!ATTLIST add-remote review       CDATA #IMPLIED&gt;
  &lt;!ATTLIST add-remote project-name CDATA #IMPLIED&gt;
]&gt;</code></pre><p>需要关注 <code>remote</code>、 <code>default</code> 和 <code>project</code></p>
<h3 id="manfiest-示例"><a href="#manfiest-示例" class="headerlink" title="manfiest 示例"></a><code>manfiest</code> 示例</h3><pre><code class="xml">&lt;manifest&gt;
    &lt;remote  name=&quot;aosp&quot;
            fetch=&quot;https://android.googlesource.com/&quot;/&gt;
    &lt;remote  name=&quot;udinic&quot;
            fetch=&quot;https://github.com/udinic/&quot;/&gt;

    &lt;default revision=&quot;master&quot;
            remote=&quot;aosp&quot;
            sync-j=&quot;4&quot; /&gt;

    &lt;project path=&quot;art&quot; name=&quot;platform/art&quot; /&gt;
    &lt;project path=&quot;bionic&quot; name=&quot;platform/bionic&quot; groups=&quot;pdk&quot; /&gt;
    &lt;project path=&quot;dalvik&quot; name=&quot;platform_dalvik” remote=“udinic”/&gt;
    &lt;project path=&quot;frameworks/base&quot; name=&quot;platform_frameworks_base&quot; remote=“udinic&quot; revision=“statusbar_fixes&quot;/&gt;
    &lt;project path=&quot;tools/adt/eclipse&quot; name=&quot;platform/tools/adt/eclipse&quot; groups=&quot;notdefault,tools&quot; /&gt;
&lt;/manifest&gt;</code></pre>
<h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p><code>&lt;remote&gt;</code> 指定 <code>remote</code> 地址，可以有多个，可以使用 <code>name 进行区分</code>，主要参数如下</p>
<ul>
<li><code>name</code>，必须</li>
<li><code>fetch</code>，必须，The Git URL prefix for all projects which use this remote.</li>
<li><code>review</code>，代码评审地址</li>
</ul>
<p>例如</p>
<pre><code class="xml">    &lt;remote  name=&quot;aosp&quot;
            fetch=&quot;https://android.googlesource.com/&quot;/&gt;
            review=&quot;https://android.googlesource.com/review&quot;/&gt;
    &lt;remote  name=&quot;udinic&quot;
            fetch=&quot;https://github.com/udinic/&quot;/&gt;
            fetch=&quot;https://192.168.110.10/review&quot;/&gt;
    &lt;remote  name=&quot;test&quot;
            fetch=&quot;https://github.com/test/&quot;/&gt;</code></pre>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p><code>&lt;default&gt;</code> 为可选项，指定默认 <code>&lt;remote&gt;</code>，主要设置参数如下：</p>
<ul>
<li><code>remote</code> 选择指定 <code>&lt;remote&gt;</code></li>
<li><code>revision</code> 指定默认 <code>revision</code>，包括 <code>branch</code> 或 <code>tag</code>，例如 <code>master</code>、 <code>dev</code>、 <code>refs/tags/v1.0.1</code> 等</li>
</ul>
<h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p><code>&lt;project&gt;</code> 指定工程，主要参数如下</p>
<ul>
<li><code>name</code> 远程相对与 <code>remote</code> 地址的路径，必须项</li>
<li><code>path</code> 本地相对路径，不指定的话表示和 <code>name</code> 相同</li>
<li><code>remote</code> 选择 <code>&lt;remote&gt;</code></li>
<li><code>revision</code> 选择指定分支或 <code>tag</code></li>
<li><code>copyfile</code> 复制文件</li>
</ul>
<p>将工程下的 <code>make.sh</code> 复制到根目录</p>
<pre><code class="xml">&lt;project path=&quot;tools&quot;               name=&quot;test&quot; &gt;
  &lt;copyfile src=&quot;make.sh&quot; dest=&quot;make.sh&quot; /&gt;
&lt;/project&gt;</code></pre>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>实现意图， <code>repo</code> 管理两部分代码，一部分为私有代码，另外一部分为公共代码，位于不同的分支，修改 <code>manfiest.xml</code> 如下</p>
<pre><code class="xml">&lt;manifest&gt;
    &lt;remote  name=&quot;aosp&quot;
            fetch=&quot;https://android.googlesource.com/&quot;/&gt;
    &lt;remote  name=&quot;udinic&quot;
            fetch=&quot;https://github.com/udinic/&quot;/&gt;

    &lt;default revision=&quot;master&quot;
            remote=&quot;aosp&quot;
            sync-j=&quot;4&quot; /&gt;

    &lt;project path=&quot;art&quot; name=&quot;platform/art&quot; /&gt;
    &lt;project path=&quot;bionic&quot; name=&quot;platform/bionic&quot; groups=&quot;pdk&quot; /&gt;
    &lt;project path=&quot;dalvik&quot; name=&quot;platform_dalvik” remote=“udinic”/&gt;
    &lt;project path=&quot;frameworks/base&quot; name=&quot;platform_frameworks_base&quot; remote=“udinic&quot; revision=“statusbar_fixes&quot;/&gt;
    &lt;project path=&quot;tools/adt/eclipse&quot; name=&quot;platform/tools/adt/eclipse&quot; groups=&quot;notdefault,tools&quot; /&gt;
&lt;/manifest&gt;</code></pre>
<p>未指定 <code>revision</code> 的 <code>project</code> 下载 <code>default</code> 指定的 <code>master</code> 分支</p>
<h2 id="建立分支或-tag"><a href="#建立分支或-tag" class="headerlink" title="建立分支或 tag"></a>建立分支或 <code>tag</code></h2><p><code>repo</code> 管理下建立 <code>branch</code> 或 <code>tag</code>，主要是管理 <code>manfiest</code> 以及 <code>project</code> 各个仓库</p>
<h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a><code>branch</code></h3><ol>
<li>管理 <code>manfiest</code>，克隆 <code>git</code> 仓库之后，根据 <code>source</code> 建立 <code>release</code> 分支，并修改 <code>default.xml</code> 跟踪 <code>refs/tags/$RELEASE</code>，推送 <code>branch</code> 及 <code>tag</code> 到服务器<pre><code class="shell">git clone ssh://git@192.168.110.10/manifests.git
git co origin/$SOURCE -b $RELEASE
sed -i &quot;s/\&quot;$SOURCE\&quot;/\&quot;refs\/tags\/$RELEASE\&quot;/g&quot; ./default.xml
git ci -m &quot;$RELEASE&quot; -a
git push --all</code></pre>
</li>
<li>管理 <code>project</code>，根据 <code>SOURCE</code> 迁出代码，然后上传 <code>tag</code> 信息<pre><code class="shell">git tag $RELEASE
git push $SOURCE --tags</code></pre>
</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://nicekwell.net/blog/20171112/ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi.html" target="_blank" rel="noopener">把已有的 repo 工程提交到服务器</a></li>
<li><a href="https://forum.xda-developers.com/showthread.php?t=2329228" target="_blank" rel="noopener">Learn about the repo tool , manifests and local manifests and 5 important tips !</a></li>
<li><a href="http://blog.udinic.com/2014/05/24/aosp-part-1-get-the-code-using-the-manifest-and-repo" target="_blank" rel="noopener">Get the code using the Manifest and Repo tool</a></li>
<li><a href="https://docs.sel4.systems/RepoCheatsheet.html" target="_blank" rel="noopener">Repo Cheatsheet</a></li>
<li><a href="https://gerrit.googlesource.com/git-repo/+/HEAD/docs/manifest-format.md" target="_blank" rel="noopener">repo Manifest Format</a></li>
<li><a href="https://gerrit.googlesource.com/git-repo/+/v1.3/docs/manifest-format.txt" target="_blank" rel="noopener">manifest-format.txt</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Repo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title>repo 以及 git tag branch</title>
    <url>/2018/11/22/repo-and-git-tag/</url>
    <content><![CDATA[<p>开发环境由 <code>gerrit</code>、 <code>git</code> 以及 <code>repo</code> 搭建而成，本文记录此开发环境下对 <code>branch</code> 以及 <code>tag</code> 的管理</p>
<a id="more"></a>

<h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><p><code>repo</code> 是用来管理 <code>git</code> 仓库的脚本工具，常用命令如下</p>
<ul>
<li><code>repo init</code></li>
<li><code>repo sync</code></li>
<li><code>repo forall</code></li>
</ul>
<h3 id="repo-init"><a href="#repo-init" class="headerlink" title="repo init"></a>repo init</h3><p>可以使用 <code>repo init --help</code> 查询具体命令，常用命令如下</p>
<pre><code>repo init -u xxx -b branch_name -m NAME.xml</code></pre><p><code>repo</code> 可以管理多个 <code>branch</code> / <code>revision</code> 和多个 <code>manifest file</code>，默认分别为 <code>master</code> 和 <code>default.xml</code></p>
<h3 id="repo-sync"><a href="#repo-sync" class="headerlink" title="repo sync"></a>repo sync</h3><p>可以使用 <code>repo sync --help</code> 查询具体命令，常用命令如下</p>
<pre><code class="shell">repo sync
repo sync project_name
repo sync -c -d</code></pre>
<h3 id="repo-forall"><a href="#repo-forall" class="headerlink" title="repo forall"></a>repo forall</h3><p>可以使用 <code>repo sync --help</code> 查询具体命令，常用命令如下</p>
<pre><code class="shell">repo forall -c &#39;command line&#39;
repo forall -c &#39;git checkou .&#39;
repo forall -c &#39;git tag newtag&#39;</code></pre>
<h3 id="repo-切换分支"><a href="#repo-切换分支" class="headerlink" title="repo 切换分支"></a>repo 切换分支</h3><pre><code class="shell">repo init -b new_branch
repo sync
repo forall -c git reset --hard
repo init -b new_branch
repo sync</code></pre>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><code>tag</code> 是 <code>branch</code> 上的一个节点，是静态的里程碑。 <code>tag</code> 名字就是这个节点的别名。</p>
<h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF" target="_blank" rel="noopener">Git 分支</a></p>
<pre><code class="shell">git branch -a
git branch -av
git branch -avv
git checkout -b newbranch
git branch newbranch
git branch -d newbranch
git checkout v2 -b origin/v2.5.0</code></pre>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p><a href="https://www.yiibai.com/git/git_tag.html" target="_blank" rel="noopener">git tag 命令</a><br><a href="https://blog.csdn.net/albertsh/article/details/63253614" target="_blank" rel="noopener">git tag 常用操作</a></p>
<pre><code class="shell">git tag
git tag -l &#39;regex&#39;
git show tagname
git branch -a --contains tagname
git checkout tagname
git branch branchname tagname
git tag v0.2.0
git tag v0.2.0 -light
git tag -a v0.1.0 -m &quot;release 0.1.0 version&quot;
git tag -d v0.1.2
git tag -a v0.1.0 49e0cd22f6bd9510fe65084e023d9c4316b446a6
git push origin v0.1.0
git push origin -–tags</code></pre>
<h2 id="gerrit"><a href="#gerrit" class="headerlink" title="gerrit"></a>gerrit</h2><p><a href="https://review.openstack.org/Documentation/cmd-query.html" target="_blank" rel="noopener">gerrit query</a><br><a href="https://review.openstack.org/Documentation/cmd-review.html" target="_blank" rel="noopener">gerrit review</a><br><a href="https://gerrit-review.googlesource.com/Documentation/cmd-create-branch.html" target="_blank" rel="noopener">gerrit create-branch</a></p>
<p>通过 <code>ssh</code> 可以直接操作 <code>gerrit</code>，涉及到如下命令</p>
<pre><code class="shell">ssh -p 29418 review.example.com gerrit create-branch myproject newbranch master</code></pre>
<pre><code class="shell">  $ ssh -p 29418 review.example.com gerrit review \
    --verified +1 \
    --code-review +2 \
    --submit \
    --project this/project \
    $(git rev-list origin/master..HEAD)</code></pre>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code class="shell">git clone ssh://git@192.168.110.254/manfiest.git
cd manfiest
git co origin/$SOURCE_VERSION -b $RELEASE_VERSION
sed -i &quot;s/\&quot;$SOURCE_VERSION\&quot;/\&quot;$RELEASE_VERSION\&quot;/g&quot; ./default.xml
git ci -m &quot;$RELEASE_VERSION&quot; -a
git push --all

ssh git@192.168.110.254 -t /home/git/repack

ssh -p 29418 git@192.168.110.254 gerrit create-branch projects/xx $RELEASE_VERSION $SOURCE_VERSION</code></pre>
<h3 id="创建-tag"><a href="#创建-tag" class="headerlink" title="创建 tag"></a>创建 tag</h3><pre><code class="shell">git clone ssh://git@192.168.110.254/manfiest.git
cd manfiest
git co origin/$SOURCE_VERSION -b $RELEASE_VERSION
sed -i &quot;s/\&quot;$SOURCE_VERSION\&quot;/\&quot;refs\/tags\/$RELEASE_VERSION\&quot;/g&quot; ./default.xml
git ci -m &quot;$RELEASE_VERSION&quot; -a
git push --all

ssh git@192.168.110.254 -t /home/git/repack

cd xx; git tag $RELEASE_VERSION; git push $SOURCE_VERSION --tags; cd -</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/fengxingzhe001/article/details/64921578" target="_blank" rel="noopener">Repo 切换分支与同步代码</a></li>
<li><a href="https://gerrit-review.googlesource.com/Documentation/" target="_blank" rel="noopener">Gerrit Code Review for Git</a></li>
<li><a href="https://gerrit-review.googlesource.com/Documentation/cmd-index.html" target="_blank" rel="noopener">Gerrit Code Review - Command Line Tools</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
        <category>Repo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>repo</tag>
        <tag>gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title>device-tree-and-linux-driver</title>
    <url>/2018/11/20/device-tree-and-linux-driver/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/u013377887/article/details/52966198" target="_blank" rel="noopener">设备树 – 驱动和设备树交互过程</a></li>
<li><a href="https://blog.csdn.net/yuntongsf/article/details/78224078" target="_blank" rel="noopener">设备树在 platform 设备驱动中的使用</a></li>
<li><a href="https://blog.csdn.net/qq_28992301/article/details/53321610" target="_blank" rel="noopener">设备树详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>device tree</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireless-network-configuration</title>
    <url>/2018/11/20/Wireless-network-configuration/</url>
    <content><![CDATA[<p>配置无线网络一般分两步：第一步是识别硬件、安装正确的驱动程序并进行配置，安装盘中已经包含驱动，但是通常需要额外安装；第二步是选择一种管理无线连接的方式。这篇文章涵盖了这两方面，并提供了无线管理工具的链接地址。</p>
<a id="more"></a>
<p><a href="https://wiki.archlinux.org/index.php/Wireless_network_configuration_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Rfkill_%E8%AD%A6%E5%91%8A" target="_blank" rel="noopener">Wireless network configuration</a></p>
]]></content>
  </entry>
  <entry>
    <title>MT7603U 移植问题</title>
    <url>/2018/11/20/linux-filp-open/</url>
    <content><![CDATA[<p>在 <code>Linux 4.9</code> 移植 <code>MT7603U</code> 时遇到 <code>no file read method</code> 错误导致读取配置出错，设备工作不正常，本文记录解决方法及相关知识点</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在 <code>Linux 4.9</code> 编译 <code>MT7603U</code> 之后，复制 <code>MT7603USTA.dat</code>，启动之后出现错误</p>
<pre><code>[ 2804.262246] no file read method
[ 2804.265509] Read file &quot;/etc/Wireless/RT2870STA/MT7603USTA.dat&quot; failed(errCode=-1)!
[ 2804.273097] ERROR!!! [ 2804.275221] RTMPReadParametersHook failed, Status[=0xffffffff]
[ 2804.338301] !!! rt28xx init fail !!!</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>内核中可以使用 <code>printk(&quot;func name:%pF\n&quot;, ptr)</code> 来打印函数名</p>
</blockquote>
<p>搜索驱动代码找到出错函数代码并添加打印如下</p>
<pre><code class="c">int RtmpOSFileRead(RTMP_OS_FD osfd, char *pDataPtr, int readLen)
{
    printk(&quot;read:%p\n&quot;, osfd-&gt;f_op-&gt;read);
    printk(&quot;open:%pF\n&quot;, osfd-&gt;f_op-&gt;open);
    printk(&quot;name:%s\n&quot;, osfd-&gt;f_op-&gt;owner-&gt;name);
    /* The object must have a read method */
    if (osfd-&gt;f_op &amp;&amp; osfd-&gt;f_op-&gt;read) {
        return osfd-&gt;f_op-&gt;read(osfd, pDataPtr, readLen, &amp;osfd-&gt;f_pos);
    } else {
      DBGPRINT(RT_DEBUG_ERROR, (&quot;no file read method\n&quot;));
      return -1;
    }
}</code></pre>
<p>打印信息如下</p>
<pre><code>[ 3886.638124] read:  (null)
[ 3886.640808] open:nfs_file_open+0x0/0x54
[ 3886.644741] name:(null)
[ 3886.647211] no file read method
[ 3886.650381] Read file &quot;/etc/Wireless/RT2870STA/MT7603USTA.dat&quot; failed(errCode=-1)!
[ 3886.658037] ERROR!!! [ 3886.660161] RTMPReadParametersHook failed, Status[=0xffffffff]
[ 3886.722205] !!! rt28xx init fail !!!</code></pre><p>内核中找到 <code>kernel/4.9.y/fs/nfs/file.c</code></p>
<pre><code class="c">const struct file_operations nfs_file_operations = {
    .llseek     = nfs_file_llseek,
    .read_iter  = nfs_file_read,
    .write_iter = nfs_file_write,
    .mmap       = nfs_file_mmap,
    .open       = nfs_file_open,
    .flush      = nfs_file_flush,
    .release    = nfs_file_release,
    .fsync      = nfs_file_fsync,
    .lock       = nfs_lock,
    .flock      = nfs_flock,
    .splice_read    = generic_file_splice_read,
    .splice_write   = iter_file_splice_write,
    .check_flags    = nfs_check_flags,
    .setlease   = simple_nosetlease,
};</code></pre>
<p>在 <code>nfs</code> 文件系统下确实不存在 <code>read/write</code> 导致不正常，但是 <code>Linux 2.6</code> 下工作正常，代码如下</p>
<pre><code class="c">const struct file_operations nfs_file_operations = {
    .llseek     = nfs_file_llseek,
    .read       = do_sync_read,
    .write      = do_sync_write,
    .aio_read   = nfs_file_read,
    .aio_write  = nfs_file_write,
#ifdef CONFIG_MMU
    .mmap       = nfs_file_mmap,
#else
    .mmap       = generic_file_mmap,
#endif
    .open       = nfs_file_open,
    .flush      = nfs_file_flush,
    .release    = nfs_file_release,
    .fsync      = nfs_file_fsync,
    .lock       = nfs_lock,
    .flock      = nfs_flock,
    .splice_read    = nfs_file_splice_read,
    .check_flags    = nfs_check_flags,
    .setlease   = nfs_setlease,
};</code></pre>
<p>查找 <code>do_sync_read/do_sync_write</code> 在文件 <code>fs/read_write.c</code>，在 <code>Linux 4.9</code> 中查找替换函数如下</p>
<pre><code class="c">static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
{
    struct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };
    struct kiocb kiocb;
    struct iov_iter iter;
    ssize_t ret;

    init_sync_kiocb(&amp;kiocb, filp);
    kiocb.ki_pos = *ppos;
    iov_iter_init(&amp;iter, WRITE, &amp;iov, 1, len);

    ret = filp-&gt;f_op-&gt;write_iter(&amp;kiocb, &amp;iter);
    BUG_ON(ret == -EIOCBQUEUED);
    if (ret &gt; 0)
        *ppos = kiocb.ki_pos;
    return ret;
}

ssize_t __vfs_write(struct file *file, const char __user *p, size_t count,
            loff_t *pos)
{
    if (file-&gt;f_op-&gt;write)
        return file-&gt;f_op-&gt;write(file, p, count, pos);
    else if (file-&gt;f_op-&gt;write_iter)
        return new_sync_write(file, p, count, pos);
    else
        return -EINVAL;
}

EXPORT_SYMBOL(__vfs_write);

ssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)
{
    mm_segment_t old_fs;
    const char __user *p;
    ssize_t ret;

    if (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))
        return -EINVAL;

    old_fs = get_fs();
    set_fs(get_ds());
    p = (__force const char __user *)buf;
    if (count &gt; MAX_RW_COUNT)
        count =  MAX_RW_COUNT;
    ret = __vfs_write(file, p, count, pos);
    set_fs(old_fs);
    if (ret &gt; 0) {
        fsnotify_modify(file);
        add_wchar(current, ret);
    }
    inc_syscw(current);
    return ret;
}

EXPORT_SYMBOL(__kernel_write);

ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
{
    ssize_t ret;

    if (!(file-&gt;f_mode &amp; FMODE_WRITE))
        return -EBADF;
    if (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))
        return -EINVAL;
    if (unlikely(!access_ok(VERIFY_READ, buf, count)))
        return -EFAULT;

    ret = rw_verify_area(WRITE, file, pos, count);
    if (!ret) {
        if (count &gt; MAX_RW_COUNT)
            count =  MAX_RW_COUNT;
        file_start_write(file);
        ret = __vfs_write(file, buf, count, pos);
        if (ret &gt; 0) {
            fsnotify_modify(file);
            add_wchar(current, ret);
        }
        inc_syscw(current);
        file_end_write(file);
    }

    return ret;
}

EXPORT_SYMBOL(vfs_write);</code></pre>
<p>使用 <code>vfs_write/vfs_read</code> 来替换之前的函数解决这个问题，修改如下</p>
<pre><code class="c">int RtmpOSFileRead(RTMP_OS_FD osfd, char *pDataPtr, int readLen)
{
    /* The object must have a read method */
    if (osfd-&gt;f_op &amp;&amp; osfd-&gt;f_op-&gt;read) {
        return vfs_read(osfd, pDataPtr, readLen, &amp;osfd-&gt;f_pos);
    } else {
      DBGPRINT(RT_DEBUG_ERROR, (&quot;no file read method\n&quot;));
      return -1;
    }
}</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/lwfinger/rtlwifi_new/issues/215" target="_blank" rel="noopener">Compilation failed for rtl8723be driver on Xubuntu 16.04.2</a></li>
<li><a href="http://chrisrc.me/2015/09/06/linux-broadcom-driver-for-kernel-4/" target="_blank" rel="noopener">Broadcom Wireless Driver for Linux Kernel 4.0</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mt7603u</tag>
        <tag>filp</tag>
        <tag>vfs_read</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux dtb 文件及相关启动流程</title>
    <url>/2018/11/20/linux-dtb-and-boot/</url>
    <content><![CDATA[<p>介绍 <code>Linux</code> 内核设备树 <code>Device Tree</code>，及其他相关知识，包括镜像制作及启动内核</p>
<a id="more"></a>

<h2 id="Device-Tree"><a href="#Device-Tree" class="headerlink" title="Device Tree"></a>Device Tree</h2><p>开源文档中对设备树的描述是，一种描述硬件资源的数据结构，<strong>它通过 <code>BootLoader</code> 将硬件资源传给内核，使得内核和硬件资源描述相对独立。</strong>ARM 内核版本 <code>3.x</code> 之后引入<br><code>Device Tree</code> 可以描述的信息包括</p>
<ul>
<li>CPU 的数量和类别</li>
<li>内存基地址和大小</li>
<li>总线</li>
<li>桥</li>
<li>外设连接</li>
<li>中断控制器</li>
<li>中断使用情况</li>
<li>GPIO 控制器和 GPIO 使用情况</li>
<li>Clock 控制器和 Clock 使用情况。</li>
<li>热插拔设备的控制器</li>
</ul>
<p>另外，<strong>设备树对于可热插拔的设备不进行具体描述，它只描述用于控制该热插拔设备的控制器。</strong></p>
<p>设备树的主要优势：<strong>对于同一 SOC 的不同主板，只需要更换设备树文件 <code>.dtb</code> 即可实现不同主板的无差异支持，而无需更换内核文件。</strong></p>
<blockquote>
<p>要使得 <code>3.x</code> 之后的内核支持使用设备树，除了内核编译时需要打开相对应的选项外， <code>BootLoader</code> 也需要支持将设备树的数据结构传给内核。</p>
</blockquote>
<h2 id="设备树的组成"><a href="#设备树的组成" class="headerlink" title="设备树的组成"></a>设备树的组成</h2><p><code>设备树</code> 包括 <code>DTC（device tree compiler）</code> , <code>DTS(device tree source)</code> 和 <code>DTB（device tree binary）</code>。<br><code>1 个 dts 文件</code> + <code>n 个 dtsi 文件</code>，它们经 <code>DTC</code> 编译而成的 <code>dtb 文件</code> 就是真正的设备树</p>
<h3 id="DTS"><a href="#DTS" class="headerlink" title="DTS"></a>DTS</h3><p><code>soc 厂商</code> 会把 <code>soc</code> 公共的特性和多块开发板公用的特性提炼为 <code>dtsi</code>，而 <code>dts</code> 则负责描述某个具体的产品（开发板）的特性。 <code>dts</code> 直接或间接的包含多个 <code>dtsi</code> （类似于 c 语言的头文件），就体现了一个完整的产品（开发板）所有的特性。以 <code>solidrun</code> 公司的 <code>hummingboard</code> 为例，其组成为</p>
<p>目录 <code>arch/arm/boot/dts/imx6dl-hummingboard.dts</code></p>
<pre><code class="dts">#include &quot;imx6dl.dtsi&quot;
#include &quot;imx6qdl-hummingboard.dtsi&quot;

/ {
    model = &quot;SolidRun HummingBoard Solo/DualLite&quot;;
    compatible = &quot;solidrun,hummingboard/dl&quot;, &quot;fsl,imx6dl&quot;;
};</code></pre>
<blockquote>
<p><code>dts/dtsi</code> 兼容 <code>c</code> 语言的一些语法，能使用宏定义，也能包含 <code>.h</code> 文件</p>
</blockquote>
<p><code>dts</code> 语法可以看<a href="https://blog.csdn.net/qq_28992301/article/details/53321610" target="_blank" rel="noopener">设备树详解</a></p>
<h3 id="DTC"><a href="#DTC" class="headerlink" title="DTC"></a>DTC</h3><p><code>DTC</code> 为编译工具，它可以将 <code>.dts</code> 文件编译成 <code>.dtb</code> 文件。 <code>DTC</code> 的源码位于内核的 <code>scripts/dtc</code> 目录下，内核选中 <code>CONFIG_OF</code>，编译内核的时候，主机可执行程序 <code>DTC</code> 就会被编译出来。</p>
<h3 id="DTB"><a href="#DTB" class="headerlink" title="DTB"></a>DTB</h3><p><code>DTC</code> 编译 <code>.dts</code> 生成的 <code>二进制文件 (.dtb)</code> ,** <code>bootloader</code> 在引到内核时，会预先读取 <code>.dtb</code> 到内存，进而由内核解析。**</p>
<p>使用 <code>DTC</code> 工具可以将 <code>.dtb</code> 生成 <code>.dts</code></p>
<pre><code class="shell">dtc -I dtb -O dts -o xxxxxxx.dts /arch/arm64/boot/dts/qcom/xxxx.dtb</code></pre>
<h2 id="内核启动与-DTB"><a href="#内核启动与-DTB" class="headerlink" title="内核启动与 DTB"></a>内核启动与 DTB</h2><p>内核必须知道 <code>DTB</code> 文件地址进行解析，这一步是由 <code>bootloader</code> 来传入，以 <code>uboot</code> 为例来介绍</p>
<p>需要在编译 <code>u-boot</code> 时打开 <code>#define CONFIG_OF_LIBFDT</code>，传入参数一般分为三种情况</p>
<ol>
<li>利用 <code>U-boot</code> 的命令，在引导 <code>kernel</code> 时将 <code>dts</code> 传入。这种方式需要将 <code>dtb</code> 的地址写到 <code>uboot</code> 中（一般是环境变量），比如：首先将 <code>kernel</code> 载入内存，然后用 <code>fdt addr ${fdtaddr}</code> 命令将 <code>dtb</code> 载入内存，最后使用 <code>bootz ${loadaddr} ${initrdaddr} ${fdtaddr}</code> 来引导内核，（其中 <code>initrd</code> 是临时文件系统，嵌入式中用得极少）实际使用时用 <code>-</code> 代替： <code>bootz ${loadaddr} - ${fdtaddr}</code>。总之， <code>U-boot</code> 中的命令和环境变量是很灵活的，可以随意组合</li>
<li>将 <code>dts</code> 和 <code>kernel</code> 打包为 <code>pImage</code>。这种方式无需将 <code>dtb</code> 的地址写到 <code>uboot</code> 中（<strong>但 <code>uboot</code> 中要实现读 <code>pImage</code> 头部的功能</strong>）， <code>uboot</code> 可以去 <code>pImage</code> 的头部信息处读取到 <code>dtb</code> 的地址，然后传给传递给 <code>kernel</code></li>
<li>启用 <code>kernel</code> 中 <code>ARM_APPENDED_DTB</code> 选项，该选项的意思是将 <code>dtb</code> 和 <code>kernel</code> 打包在一起，如此一来 <code>kernel</code> 启动时会去紧挨着它的地方寻找 <code>dtb</code>，这样就不需要 <code>uboot</code> 来传递 <code>dtb</code> 地址</li>
</ol>
<p>项目中选用第二种，因此需要修改相应的 <code>boot</code> 和 <code>镜像制作工具</code></p>
<p><code>uboot</code> 传参及引导，最后把入口地址 <code>ep</code> 转化为一个函数指针 <code>theKernel = (void (*)(int, int, uint))ep</code>，然后通过函数指针去执行镜像。</p>
<pre><code class="c">    void (*theKernel)(int zero, int arch, uint params);// 定义了一个函数指针
    // 中间代码略过
    theKernel = (void (*)(int, int, uint))ep;// 把入口地址赋给函数指针
    // 中间代码略过
    theKernel (0, machid, bd-&gt;bi_boot_params);// 跳到内核入口执行内核，再也不返回</code></pre>
<h2 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h2><p>内核编译完成之后生成 <code>uImage</code> 和 <code>.dtb</code>，使用 <code>genflash</code> 来制作镜像，核心代码如下</p>
<p>从配置文件中解析 <code>.dtb</code> 文件名</p>
<pre><code class="c">else if (keycmp(str, &quot;dtb_file&quot;) == 0) {
    key = strtok(str, &quot; \t&quot;);
    value = strtok(NULL, &quot; \t&quot;);
    trim(value);

    strcpy(dtb_file, value);
} else {</code></pre>
<p>将 <code>KERNLE</code> 及 <code>DTB</code> 合并</p>
<pre><code class="c">if ((keycmp(info-&gt;name, &quot;KERNEL&quot;) == 0) &amp;&amp; (*dtb_file)) {
    size_t dtb_size = 0;
    void *dtb_buf = NULL;
    snprintf(filename, 255, &quot;%s/%s&quot;, basedir, dtb_file);
    dtb_buf = x_fmmap(filename, &amp;dtb_size);
    if (!dtb_buf)
        return NULL;
    total_size = dtb_size + org_size;
    total_buf = malloc(total_size);
    if (!total_buf)
        return NULL;
    memcpy(total_buf, dtb_buf, dtb_size);
    memcpy(total_buf + dtb_size, org_buf, org_size);
    x_munmap(dtb_buf, dtb_size);
} else {
    total_size = org_size;
    total_buf = malloc(total_size);
    memcpy(total_buf, org_buf, total_size);
}</code></pre>
<p>镜像制作之后 <code>.dtb</code> 被放在头部</p>
<h2 id="bootloader-传递-DTB"><a href="#bootloader-传递-DTB" class="headerlink" title="bootloader 传递 DTB"></a>bootloader 传递 DTB</h2><p>采用第二种方式的 <code>bootloader</code> 流程如下</p>
<p><code>doboot_kernel</code> 函数</p>
<pre><code class="c">...
// 解析 DTB 头部，计算长度，得到内核偏移地址
if (modify_dtb(&amp;kernel_offset) &lt; 0) {
    printf(&quot;errror: %s %s %d\n&quot;, __FILE__, __func__, __LINE__);
    return -1;
}

// 启动内核
while (kernel_names[id]) {
    if (loader_file(&amp;part, kernel_names[id], kernel_offset) == 0) {
        run_kernel(part.dest);
        return 0;
    }
    id++;
}
...</code></pre>
<p><code>modify_dtb</code> 实现 <code>FDT</code> 解析 <code>.dtb</code></p>
<pre><code class="c">static int modify_dtb(unsigned int *kernel_offset)
{
    int ret = -1;
    char *dtb_addr = (char *)KERNEL_DTB_START_ADDR;
    unsigned int dtb_totalsize = KERNEL_DTB_SIZE;
    char *cmdline = (char *)((struct tag *)bootstr_cmdline)-&gt;u.cmdline.cmdline;

    if (get_dtb(dtb_addr, dtb_totalsize) &lt; 0)
        return ret;
    if (fdt_check_header((void *)dtb_addr) &lt; 0)
        return ret;
    *kernel_offset = fdt_totalsize((void *)dtb_addr);
    if (fdt_open_into((void *)dtb_addr, (void *)dtb_addr, dtb_totalsize))
        return ret;
    if (fdt_chosen((void *)dtb_addr, cmdline))
        return ret;

    ret = 0;
    return ret;
}</code></pre>
<blockquote>
<p><code>fdt_chosen</code> 将设备树中的 <code>bootargs</code> 覆盖掉，实现将 <code>bootloader</code> 中的 <code>cmdline</code> 加载到树中</p>
</blockquote>
<p><code>run_kernel</code> 实现如下</p>
<pre><code class="c">    param_to_kernel = (char *)KERNEL_DTB_START_ADDR;
    void (*theKernel) ( unsigned int, unsigned int, char*) = (void (*) (unsigned int, unsigned int, char*))addr;
    (*theKernel)(0, 0, param_to_kernel);</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/CaspianSea/article/details/39367169" target="_blank" rel="noopener">使用 dtb 文件引导内核</a></li>
<li><a href="https://blog.csdn.net/qq_28992301/article/details/53321610" target="_blank" rel="noopener">设备树详解</a></li>
<li><a href="https://blog.csdn.net/qq_28992301/article/details/51873201" target="_blank" rel="noopener">U-boot 引导内核流程分析</a></li>
<li>[[uboot] （番外篇）uboot 之 fdt 介绍』(<a href="https://blog.csdn.net/ooonebook/article/details/53206623" target="_blank" rel="noopener">https://blog.csdn.net/ooonebook/article/details/53206623</a>)</li>
<li><a href="http://www.aichengxu.com/linux/3978191.htm" target="_blank" rel="noopener">基于 tiny4412 的 Linux 内核移植（支持 device tree）</a></li>
<li><a href="http://lacie-nas.org/doku.php?id=making_kernel_with_dtb" target="_blank" rel="noopener">making_kernel_with_dtb</a></li>
<li><a href="https://blog.csdn.net/ooonebook/article/details/53070065" target="_blank" rel="noopener">uboot 流程——uboot 启动流程</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>boot</tag>
        <tag>dts</tag>
        <tag>dtsi</tag>
        <tag>dtb</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>引用其它的 Makefile</title>
    <url>/2018/11/19/makefile-include-other-makefile/</url>
    <content><![CDATA[<p>在 <code>makefile</code> 中引用其他 <code>makefile</code></p>
<a id="more"></a>

<p><a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">跟我一起写 Makefile</a></p>
<p>在 <code>makefile</code> 中可以使用 <code>include</code> 来引用其他 <code>makefile</code></p>
<pre><code class="makefile">include &lt;filename&gt;</code></pre>
<p><code>filename</code> 可以是当前操作系统 <code>shell</code> 的文件模式（可以包含路径和通配符）</p>
<p>在 <code>include</code> 前面可以有一些空字符，但是绝不能是 <code>Tab</code> 键开始。 <code>include</code> 和 <code>&lt;filename&gt;</code> 可以用一个或多个空格隔开。举个例子，你有这样几个 <code>Makefile</code>： <code>a.mk</code>、 <code>b.mk</code>、 <code>c.mk</code>，还有一个文件叫 <code>foo.make</code>，以及一个变量 <code>$(bar)</code>，其包含了 <code>e.mk</code> 和 <code>f.mk</code>，那么，下面的语句：</p>
<pre><code class="makefile">include foo.make *.mk $(bar)</code></pre>
<p>等价于</p>
<pre><code class="makefile">include foo.make a.mk b.mk c.mk e.mk f.mk</code></pre>
<p>如果有文件没有找到的话， <code>make</code> 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 <code>makefile</code> 的读取， <code>make</code> 会再重试这些没有找到，或是不能读取的文件，如果还是不行， <code>make</code> 才会出现一条<strong>致命信息</strong>。如果你想让 <code>make</code> 不理那些无法读取的文件，而继续执行，你可以在 <code>include</code> 前加一个减号 <code>-</code>。如：</p>
<pre><code class="makefile">-include &lt;filename&gt;</code></pre>
<p>其表示，无论 <code>include</code> 过程中出现什么错误，都不要报错继续执行。和其它版本 <code>make</code> 兼容的相关命令是 <code>sinclude</code>，其作用和这一个是一样的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>确认 Linux 内核支持 wifi 型号列表</title>
    <url>/2018/11/19/How-to-check-linux-support-usb-wifi-list/</url>
    <content><![CDATA[<p><code>Linux</code> 内核版本为 <code>4.9.22</code>，需要在此添加型号为 <code>Bus 002 Device 040: ID 0bda:8179 Realtek Semiconductor Corp. RTL8188EUS 802.11n Wireless Network Adapter</code> 支持</p>
<a id="more"></a>

<h2 id="usb-wifi-型号确认"><a href="#usb-wifi-型号确认" class="headerlink" title="usb wifi 型号确认"></a>usb wifi 型号确认</h2><p>使用命令 <code>lsusb</code></p>
<pre><code class="shell">$ lsusb
Bus 002 Device 037: ID 1d57:fa60 Xenta
Bus 002 Device 036: ID 1a40:0101 Terminus Technology Inc. Hub
Bus 002 Device 040: ID 0bda:8179 Realtek Semiconductor Corp. RTL8188EUS 802.11n Wireless Network Adapter
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</code></pre>
<h2 id="确认内核是否支持"><a href="#确认内核是否支持" class="headerlink" title="确认内核是否支持"></a>确认内核是否支持</h2><p>以 <code>Realtek</code> 为例</p>
<pre><code class="kconfig">Device Drivers  ---&gt;
    [*] Network device support  ---&gt;
        [*]   Wireless LAN  ---&gt;
            [*]   Realtek devices
                &lt; &gt;     Realtek 8187 and 8187B USB support
                &lt; &gt;     Realtek rtlwifi family of devices  ---&gt;
                    &lt;*&gt;   Realtek RTL8192CU/RTL8188CU USB Wireless Network Adapter
                    [*]   Debugging output for rtlwifi driver family
                &lt; &gt;     RTL8723AU/RTL8188[CR]U/RTL819[12]CU (mac80211) support</code></pre>
<p>从内核配置中不能找到 <code>RTL8188EUS</code> 型号支持，查看内核源码进行确认</p>
<h2 id="内核代码"><a href="#内核代码" class="headerlink" title="内核代码"></a>内核代码</h2><p>源码路径如下 <code>drivers/net/wireless/realtek</code>，搜索 <code>MODULE_DEVICE_TABLE</code></p>
<pre><code class="shell">$ ag MODULE_DEVICE_TABLE
rtl8xxxu/rtl8xxxu_core.c
6349:MODULE_DEVICE_TABLE(usb, dev_table);

rtl818x/rtl8180/dev.c
87:MODULE_DEVICE_TABLE(pci, rtl8180_table);

rtl818x/rtl8187/dev.c
85:MODULE_DEVICE_TABLE(usb, rtl8187_table);

rtlwifi/rtl8723ae/sw.c
378:MODULE_DEVICE_TABLE(pci, rtl8723e_pci_ids);

rtlwifi/rtl8192cu/sw.c
393:MODULE_DEVICE_TABLE(usb, rtl8192c_usb_ids);

rtlwifi/rtl8723be/sw.c
382:MODULE_DEVICE_TABLE(pci, rtl8723be_pci_ids);

rtlwifi/rtl8821ae/sw.c
429:MODULE_DEVICE_TABLE(pci, rtl8821ae_pci_ids);

rtlwifi/rtl8192se/sw.c
415:MODULE_DEVICE_TABLE(pci, rtl92se_pci_ids);

rtlwifi/rtl8192de/sw.c
363:MODULE_DEVICE_TABLE(pci, rtl92de_pci_ids);

rtlwifi/rtl8192ce/sw.c
366:MODULE_DEVICE_TABLE(pci, rtl92ce_pci_ids);

rtlwifi/rtl8192ee/sw.c
364:MODULE_DEVICE_TABLE(pci, rtl92ee_pci_ids);

rtlwifi/rtl8188ee/sw.c
387:MODULE_DEVICE_TABLE(pci, rtl88ee_pci_ids);</code></pre>
<p>可以看到有两种接口方式 <code>usb</code> 和 <code>pci</code>，另外可以搜索 <code>USB_VENDOR 0x0bda</code> 和 <code>0x8179</code>，发现内核不支持此型号</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p><a href="https://github.com/quickreflex/rtl8188eus" target="_blank" rel="noopener">github</a></p>
<p>可以在代码中找到如下内容 <code>MODULE_DEVICE_TABLE(usb, rtw_usb_id_tbl)</code>， <code>probe</code> 函数 <code>rtw_drv_init</code></p>
<pre><code class="c">/*=== Realtek demoboard ===*/
{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8179),.driver_info = RTL8188E}, /* 8188EUS */
{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x0179),.driver_info = RTL8188E}, /* 8188ETV */</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核配置项解析</title>
    <url>/2018/11/18/linux-kernel-configuration-analysis/</url>
    <content><![CDATA[<p>解析 <code>Linux 4.9</code> 内核配置项</p>
<a id="more"></a>

<h2 id="General-setup-常规设置"><a href="#General-setup-常规设置" class="headerlink" title="General setup 常规设置"></a>General setup 常规设置</h2><ul>
<li><code>Cross-compiler tool prefix</code> 交叉编译工具前缀（比如 <code>arm-linux-</code> 相当于使用 <code>make CROSS_COMPILE=arm-linux-</code> 进行编译）. 除非你想配置后默认自动进行交叉编译，否则不要使用此选项</li>
<li><code>Compile also drivers which will not load</code> 显示专属于其他平台 <code>（非 x86 平台）</code> 的驱动选项（需要交叉编译）, 仅供驱动开发者使用，普通的发行版制作者应该选 <code>N</code></li>
<li><code>Local version - append to kernel release</code> 在内核版本后面加上自定义的版本字符串（最大 64 字符）, 可以用 <code>uname -a</code> 命令看到</li>
<li><code>Automatically append version information to the version string</code> 自动在版本字符串 <code>CONFIG_LOCALVERSION</code> 后面添加版本信息（类似 <code>-gxxxxxxxx</code> 格式）, 需要有 <code>perl</code> 以及 <code>git 仓库</code> 支持</li>
<li><code>Kernel compression mode</code> 内核镜像的压缩格式，可选 <code>Gzip/Bzip2/LZMA/XZ/LZO</code> 格式之一. 你的系统中需要有相应的压缩工具</li>
</ul>
<p><code>Default hostname</code><br><code>CONFIG_DEFAULT_HOSTNAME</code><br>设置默认主机名，默认值是”(none)”. 用户可以随后使用系统调用 sethostname() 来修改主机名。<br><code>Support for paging of anonymous memory (swap)</code><br>CONFIG_SWAP<br>使用交换分区或者交换文件来做为虚拟内存<br>System V IPC<br>CONFIG_SYSVIPC<br>System V 进程间通信 (IPC) 支持，用于进程间同步和交换数据，许多程序需要这个功能. 选”Y”, 除非你确实知道自己在做什么<br>POSIX Message Queues<br>CONFIG_POSIX_MQUEUE<br>POSIX 消息队列是 POSIX IPC 的一部分，如果你想编译和运行那些使用”mq_*”系统调用的程序（比如为 Solaris 开发的程序）, 或者需要使用 Docker 容器，就必须开启此选项.POSIX 消息队列可以作为”mqueue”文件系统挂载以方便用户对队列进行操作. 不确定的选”Y”.<br>open by fhandle syscalls<br>CONFIG_FHANDLE<br>用户程序可以使用句柄（而非文件名）来追踪文件（使用 open_by_handle_at(2)/name_to_handle_at(2) 系统调用）, 即使某文件被重命名，用户程序依然可定位那个文件. 此特性有助于实现用户空间文件服务器 (userspace file server). 建议选”Y”, 因为 systemd 和 udev 依赖于它。<br>uselib syscall<br>CONFIG_USELIB<br>启用老旧的 uselib() 系统接口支持，仅在你需要使用基于 libc5 的古董级程序时才需要，不确定的选”N”.<br>Auditing support<br>CONFIG_AUDIT<br>内核审计（跟踪每个进程的活动情况）支持，某些安全相关的内核子系统（例如 SELinux) 需要它. 但是它会与 systemd 冲突，所以在使用 systemd 的系统上必须关闭。<br>Enable system-call auditing support<br>CONFIG_AUDITSYSCALL<br>对系统调用进行审计. 既可独立使用，也可被其他内核子系统（例如 SELinux) 使用。<br>Make audit loginuid immutable<br>CONFIG_AUDIT_LOGINUID_IMMUTABLE<br>审计时使用固定的 loginuid. 在使用 systemd 之类的系统上应该开启 (login 服务由 init 进程负责重启）, 在使用 SysVinit 或 Upstart 之类的系统上应该关闭 (login 服务由系统管理员手动重启）.OpenRC 就是一个基于 SysVinit 的系统。<br>IRQ subsystem<br>IRQ（中断请求）子系统<br>Expose hardware/virtual IRQ mapping via debugfs<br>CONFIG_IRQ_DOMAIN_DEBUG<br>通过 debugfs 中的 irq_domain_mapping 文件向用户显示硬件 IRQ 号 /Linux IRQ 号之间的对应关系. 仅用于开发调试。<br>Support sparse irq numbering<br>CONFIG_SPARSE_IRQ<br>稀疏 IRQ 号支持. 它允许在小型设备上（例如嵌入式设备）定义一个很高的 CONFIG_NR_CPUS 值，但仍然不希望占用太多内核”memory footprint”（一段可以被操作或被管理的内存区域）的场合. 稀疏 IRQ 也更适合 NUMA 平台，因为它以一种对 NUMA 更友好的方式分发中断描述符. 不确定的选”N”.<br>Timers subsystem<br>Linux 内核时钟子系统<br>Timer tick handling<br>内核时钟滴答处理程序，更多信息可以参考内核源码树下的”Documentation/timers/NO_HZ.txt”文件<br>Periodic timer ticks (constant rate, no dynticks)<br>CONFIG_HZ_PERIODIC<br>无论 CPU 是否需要，都强制按照固定频率不断触发时钟中断. 这是最耗电的方式，不推荐使用<br>Idle dynticks system (tickless idle)<br>CONFIG_NO_HZ_IDLE<br>CPU 在空闲状态时不产生不必要的时钟中断，以使处理器能够在较低能耗状态下运行以节约电力，适合于大多数场合<br>Full dynticks system (tickless)<br>CONFIG_NO_HZ_FULL<br>完全无滴嗒：即使 CPU 在忙碌状态也尽可能关闭所有时钟中断，适用于 CPU 在同一时间仅运行一个任务，或者用户空间程序极少与内核交互的场合. 即使开启此选项，也需要额外设置”nohz_full=?”内核命令行参数才能真正生效。<br>Full dynticks system on all CPUs by default<br>CONFIG_NO_HZ_FULL_ALL<br>即使没有设置”nohz_full”引导参数，也默认对所有 CPU(boot CPU 除外）开启完全无滴答特性。<br>Old Idle dynticks config<br>CONFIG_NO_HZ<br>等价于 CONFIG_NO_HZ_IDLE, 临时用来兼容老版本内核选项，未来会被删除。<br>High Resolution Timer Support<br>CONFIG_HIGH_RES_TIMERS<br>高精度定时器 (hrtimer) 是从 2.6.16 开始引入，用于取代传统 timer wheel（基于 jiffies 定时器）的时钟子系统. 可以降低与内核其他模块的耦合性，还可以提供比 1 毫秒更高的精度（因为它可以读取 HPET/TSC 等新型硬件时钟源）, 可以更好的支持音视频等对时间精度要求较高的应用. 建议选”Y”.『提示』这里说的”定时器”是指”软件定时器”, 而不是主板或 CPU 上集成的硬件时钟发生器 (ACPI PM Timer/HPET Timer/TSC Timer).<br>CPU/Task time and stats accounting<br>CPU/ 进程的时间及状态统计<br>Cputime accounting<br>CPU 时间统计方式<br>Simple tick based cputime accounting<br>CONFIG_TICK_CPU_ACCOUNTING<br>简单的基于滴答的统计，适用于大多数场合<br>Deterministic task and CPU time accounting<br>CONFIG_VIRT_CPU_ACCOUNTING_NATIVE<br>通过读取 CPU 计数器进行统计，可以提供更精确的统计，但是对性能有一些不利影响。<br>Full dynticks CPU time accounting<br>CONFIG_VIRT_CPU_ACCOUNTING_GEN<br>利用上下文跟踪子系统，通过观察每一个内核与用户空间的边界进行统计. 该选项对性能有显著的不良影响，目前仅用于完全无滴答子系统 (CONFIG_NO_HZ_FULL) 的调试<br>Fine granularity task level IRQ time accounting<br>CONFIG_IRQ_TIME_ACCOUNTING<br>通过读取 TSC 时间戳进行统计，这是统计进程 IRQ 时间的更细粒度的统计方式，但对性能有些不良影响（特别是在 RDTSC 指令速度较慢的 CPU 上）.<br>BSD Process Accounting<br>CONFIG_BSD_PROCESS_ACCT<br>BSD 进程记账支持. 用户空间程序可以要求内核将进程的统计信息写入一个指定的文件，主要包括进程的创建时间 / 创建者 / 内存占用等信息. 不确定的选”N”.<br>BSD Process Accounting version 3 file format<br>CONFIG_BSD_PROCESS_ACCT_V3<br>使用新的 v3 版文件格式，可以包含每个进程的 PID 和其父进程的 PID, 但是不兼容老版本的文件格式. 比如 GNU Accounting Utilities 这样的工具可以识别 v3 格式<br>Export task/process statistics through netlink<br>CONFIG_TASKSTATS<br>通过 netlink 接口向用户空间导出进程的统计信息，与 BSD Process Accounting 的不同之处在于这些统计信息在整个进程生存期都是可用的。<br>Enable per-task delay accounting<br>CONFIG_TASK_DELAY_ACCT<br>在统计信息中包含进程等候系统资源 (cpu,IO 同步，内存交换等）所花费的时间<br>Enable extended accounting over taskstats<br>CONFIG_TASK_XACCT<br>在统计信息中包含进程的更多扩展信息. 不确定的选”N”.<br>Enable per-task storage I/O accounting<br>CONFIG_TASK_IO_ACCOUNTING<br>在统计信息中包含进程在存储设备上的 I/O 字节数。<br>RCU Subsystem<br>RCU(Read-Copy Update) 子系统. 它允许程序查看到正在被修改 / 更新的文件. 在读多写少的情况下，这是一个高性能的锁机制，对于被 RCU 保护的共享数据结构，读者不需要获得任何锁就可以访问它（速度非常快）, 但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据，速度非常慢.RCU 只适用于读多写少的情况：如网络路由表的查询更新，设备状态表的维护，数据结构的延迟释放以及多径 I/O 设备的维护等。<br>RCU Implementation<br>RCU 的实现方式<br>Tree-based hierarchical RCU<br>CONFIG_TREE_RCU<br>基于树型分层结构的实现. 最适用于多 CPU 的非实时系统。<br>Preemptible tree-based hierarchical RCU<br>CONFIG_TREE_PREEMPT_RCU<br>抢占式基于树型分层结构的实现. 最适用于那些要求快速响应的多 CPU 实时系统。<br>UP-only small-memory-footprint RCU<br>CONFIG_TINY_RCU<br>最简单的实现，能够大幅降低 RCU 系统的内存占用. 最适用于单 CPU 的非实时系统。<br>Preemptible UP-only small-memory-footprint RCU<br>CONFIG_TINY_PREEMPT_RCU<br>抢占式简单实现，能够大幅降低 RCU 系统的内存占用. 最适用于那些要求快速响应的单 CPU 实时系统。<br>Consider userspace as in RCU extended quiescent state<br>CONFIG_RCU_USER_QS<br>在内核和用户边界设置钩子函数，将运行在用户态的 CPU 从全局 RCU 状态机制中移除，这样就不会在 RCU 系统中维护此 CPU 的时钟滴答. 除非你想要帮助开发 CONFIG_NO_HZ_FULL 模块，否则不要打开此选项，而且它还会对性能有不利影响。<br>Force context tracking<br>CONFIG_CONTEXT_TRACKING_FORCE<br>默认在内核和用户边界进行探测（上下文跟踪）, 以便测试依赖于此特性的各种功能（比如用户空间的 RCU extended quiescent state), 这个特性目前仅用于调试目的，未来也许会用于为 CONFIG_NO_HZ_FULL 模块提供支持<br>Tree-based hierarchical RCU fanout value<br>CONFIG_RCU_FANOUT<br>这个选项控制着树形 RCU 层次结构的端点数 (fanout), 以允许 RCU 子系统在拥有海量 CPU 的系统上高效工作. 这个值必须至少等于 CONFIG_NR_CPUS 的 1/4 次方 (4 次根号）. 生产系统上应该使用默认值 (64). 仅在你想调试 RCU 子系统时才需要减小此值。<br>Tree-based hierarchical RCU leaf-level fanout value<br>CONFIG_RCU_FANOUT_LEAF<br>这个选项控制着树形 RCU 层次结构的叶子层的端点数 (leaf-level fanout). 对于期望拥有更高能耗比（更节能）的系统，请保持其默认值 (16). 对于拥有成千上万个 CPU 的系统来说，应该考虑将其设为最大值 (CONFIG_RCU_FANOUT).<br>Disable tree-based hierarchical RCU auto-balancing<br>CONFIG_RCU_FANOUT_EXACT<br>强制按照 CONFIG_RCU_FANOUT_LEAF 的值，而不是使用自动平衡树结构来实现 RCU 子系统. 目前仅用于调试目的. 未来也许会用于增强 NUMA 系统的性能。<br>Accelerate last non-dyntick-idle CPU’s grace periods<br>CONFIG_RCU_FAST_NO_HZ<br>即使 CPU 还在忙碌，也允许进入 dynticks-idle 状态，并且阻止 RCU 每 4 个滴答就唤醒一次该 CPU, 这样能够更有效的使用电力，同时也拉长了 RCU grace period 的时间，造成性能降低. 如果能耗比对你而言非常重要（你想节省每一分电力）, 并且你不在乎系统性能的降低 (CPU 唤醒时间增加）, 可以开启此选项. 台式机和服务器建议关闭此选项。<br>Enable RCU priority boosting<br>CONFIG_RCU_BOOST<br>允许提升 RCU 子系统的实时优先级（包括读操作与写操作）, 以避免 RCU 操作被阻塞太长时间. 如果系统的 CPU 负载经常很重，或者你需要快速的实时响应系统，那么就选”Y”, 否则应该选”N”.<br>Real-time priority to boost RCU readers to<br>CONFIG_RCU_BOOST_PRIO<br>允许提升被长时间抢占（阻塞）的 RCU 读操作的实时优先级到什么程度. 取值范围是 [1,99]. 默认值”1”适用于实时应用程序中不包含 CPU 密集型 (CPU-bound) 线程的常规场合（例如大多数桌面系统）. 但是如果你的实时应用程序拥有一个或多个 CPU 密集型线程，那么可能需要增加这个值，具体可以参考内核帮助的说明. 仅在你确实理解了的情况下再改变默认值。<br>Milliseconds to delay boosting after RCU grace-period start<br>CONFIG_RCU_BOOST_DELAY<br>在提升 RCU 读操作的优先级之前，允许有多长时间潜伏期（阻塞）, 取值范围是 [0,3000], 单位是毫秒，默认值是”500”. 不确定的请使用默认值。<br>Offload RCU callback processing from boot-selected CPUs<br>CONFIG_RCU_NOCB_CPU<br>如果你想帮助调试内核可以开启，否则请关闭。<br>Build-forced no-CBs CPUs<br>在开启 CONFIG_RCU_NOCB_CPU 选项的情况下，指定哪些 CPU 是 No-CB CPU, 相当于预先设置”rcu_nocbs=”内核引导参数。<br>Kernel .config support<br>CONFIG_IKCONFIG<br>把内核的配置信息编译进内核中，以后可以通过 scripts/extract-ikconfig 脚本从内核镜像中提取这些信息<br>Enable access to .config through /proc/config.gz<br>CONFIG_IKCONFIG_PROC<br>允许通过 /proc/config.gz 文件访问内核的配置信息<br>Kernel log buffer size<br>CONFIG_LOG_BUF_SHIFT<br>设置内核日志缓冲区的最小尺寸（合理的设置应该等于 CONFIG_LOG_CPU_MAX_BUF_SHIFT<em>最大 CPU 数量）: 12（最小值）=4KB,…,16=64KB,17=128KB,18=256KB,…,25（最大值）<br>CPU kernel log buffer size contribution<br>CONFIG_LOG_CPU_MAX_BUF_SHIFT<br>每个 CPU 的内核日志缓存大小（通常只有几行文字，但在报告故障时可能会产生大量文字）. 例如在最大 CPU 数量（包含热插拔 CPU) 为 64 的系统上，如果 CONFIG_LOG_BUF_SHIFT=18, 那么该值应该设为 12<br>Memory placement aware NUMA scheduler<br>CONFIG_NUMA_BALANCING<br>允许自动根据 NUMA 系统的节点分布状况进行进程 / 内存均衡（方法很原始，就是简单的内存移动）. 这个选项对 UMA 系统无效.『提示』UMA 系统的例子：(1) 只有一颗物理 CPU（即使是多核）的电脑，(2) 不支持”虚拟 NUMA”, 或”虚拟 NUMA”被禁用的虚拟机（即使所在的物理机是 NUMA 系统）<br>Automatically enable NUMA aware memory/task placement<br>CONFIG_NUMA_BALANCING_DEFAULT_ENABLED<br>在 NUMA(Non-Uniform Memory Access Architecture) 系统上自动启用进程 / 内存均衡，也就是自动开启 CONFIG_NUMA_BALANCING 特性。<br>Control Group support<br>CONFIG_CGROUPS<br>Cgroup(Control Group) 是一种进程管理机制，可以针对一组进程进行系统资源的分配和管理，可用于 Cpusets,CFS（完全公平调度器）, 内存管理等子系统. 此外，systemd 与 Docker/LXC 等容器也依赖于它. 更多细节可以参考内核的”Documentation/cgroups/cgroups.txt”文件<br>Example debug cgroup subsystem<br>CONFIG_CGROUP_DEBUG<br>导出 cgroups 框架的调试信息，仅用于调试目的。<br>Freezer cgroup subsystem<br>CONFIG_CGROUP_FREEZER<br>允许冻结 / 解冻 cgroup 内所有进程.Docker 依赖于它。<br>PIDs cgroup subsystem<br>CONFIG_CGROUP_PIDS<br>允许限制同一 cgroup 内所有进程的数量，超出限制后将无法 fork() 出新进程。<br>Device controller for cgroups<br>CONFIG_CGROUP_DEVICE<br>允许为 cgroup 建立设备白名单，这样 cgroup 内的进程将仅允许对白名单中的设备进行 mknod/open 操作.Docker 依赖于它。<br>Cpuset support<br>CONFIG_CPUSETS<br>CPUSET 支持：允许将 CPU 和内存进行分组，并指定某些进程只能运行于特定的分组.Docker 依赖于它. 这里有一篇 CPUSET 的用法<br>Include legacy /proc/<pid>/cpuset file<br>CONFIG_PROC_PID_CPUSET<br>提供过时的 /proc/<pid>/cpuset 文件接口<br>Simple CPU accounting cgroup subsystem<br>CONFIG_CGROUP_CPUACCT<br>提供一个简单的资源控制器 (Resource Controller, 用于实现一组任务间的资源共享）, 以监控 cgroup 内所有进程的总 CPU 使用量.Docker 依赖于它。<br>Resource counters<br>CONFIG_RESOURCE_COUNTERS<br>为 cgroup 提供独立于 controller 资源计数器<br>Memory Resource Controller for Control Groups<br>CONFIG_MEMCG<br>为 cgroup 添加内存资源控制器，包含匿名内存和页面缓存 (Documentation/cgroups/memory.txt). 开启此选项后，将会增加关联到每个内存页 fixed memory 大小，具体在 64 位系统上是 40bytes/PAGE_SIZE. 仅在你确实明白什么是 memory resource controller 并且确实需要的情况下才开启此选项. 此功能可以通过命令行选项”cgroup_disable=memory”进行关闭.Docker 依赖于它。<br>Memory Resource Controller Swap Extension<br>CONFIG_MEMCG_SWAP<br>给 Memory Resource Controller 添加对 swap 的管理功能. 这样就可以针对每个 cgroup 限定其使用的 mem+swap 总量. 如果关闭此选项，memory resource controller 将仅能限制 mem 的使用量，而无法对 swap 进行控制（进程有可能耗尽 swap). 开启此功能会对性能有不利影响，并且为了追踪 swap 的使用也会消耗更多的内存（如果 swap 的页面大小是 4KB, 那么每 1GB 的 swap 需要额外消耗 512KB 内存）, 所以在内存较小的系统上不建议开启。<br>Memory Resource Controller Swap Extension enabled by default<br>CONFIG_MEMCG_SWAP_ENABLED<br>如果开启此选项，那么将默认开启 CONFIG_MEMCG_SWAP 特性，否则将默认关闭. 即使默认开启也可以通过内核引导参数”swapaccount=0”禁止此特性。<br>Memory Resource Controller Kernel Memory accounting<br>CONFIG_MEMCG_KMEM<br>为 Memory Resource Controller 添加对内核对象所占用内存的管理功能. 和标准的 Memory Resource Controller 对内存的控制不一样之处在于：这些内核对象所占用的内存是基于每个内存页的，并且可以被 swap 到硬盘. 使用这个功能可以确保 cgroup 中的进程不会单独耗尽所有内核资源。<br>HugeTLB Resource Controller for Control Groups<br>CONFIG_CGROUP_HUGETLB<br>为 cgroup 添加对 HugeTLB 页的资源控制功能. 开启此选项之后，你就可以针对每个 cgroup 限定其对 HugeTLB 的使用.Docker 依赖于它。<br>Enable perf_event per-cpu per-container group (cgroup) monitoring<br>CONFIG_CGROUP_PERF<br>将 per-cpu 模式进行扩展，使其可以监控属于特定 cgroup 并运行于特定 CPU 上的线程。<br>Group CPU scheduler<br>CONFIG_CGROUP_SCHED<br>让 CPU 调度程序可以在不同的 cgroup 之间分配 CPU 的带宽.Docker 依赖于它.systemd 资源控制单元 (resource control unit) 的 CPUShares 功能依赖于它。<br>Group scheduling for SCHED_OTHER<br>CONFIG_FAIR_GROUP_SCHED<br>公平 CPU 调度策略，也就是在多个 cgroup 之间平均分配 CPU 带宽.”鸡血补丁”CONFIG_SCHED_AUTOGROUP（自动分组调度功能）依赖于它.Docker 依赖于它.systemd 资源控制单元 (resource control unit) 的 CPUShares 功能也依赖于它。<br>CPU bandwidth provisioning for FAIR_GROUP_SCHED<br>CONFIG_CFS_BANDWIDTH<br>允许用户为运行在 CONFIG_FAIR_GROUP_SCHED 中的进程定义 CPU 带宽限制. 对于没有定义 CPU 带宽限制的 cgroup 而言，可以无限制的使用 CPU 带宽. 详情参见 Documentation/scheduler/sched-bwc.txt 文件.systemd 资源控制单元 (resource control unit) 的 CPUQuota 功能也依赖于它。<br>Group scheduling for SCHED_RR/FIFO<br>CONFIG_RT_GROUP_SCHED<br>允许用户为 cgroup 分配实时 CPU 带宽，还可以对非特权用户的实时进程组进行调度. 详情参见 Documentation/scheduler/sched-rt-group.txt 文档. 使用 systemd 的系统应该选”N”.<br>Block IO controller<br>CONFIG_BLK_CGROUP<br>通用的块 IO 控制器接口，可以用于实现各种不同的控制策略. 目前，IOSCHED_CFQ 用它来在不同的 cgroup 之间分配磁盘 IO 带宽（需要额外开启 CONFIG_CFQ_GROUP_IOSCHED),block io throttle 也会用它来针对特定块设备限制 IO 速率上限（需要额外开启 CONFIG_BLK_DEV_THROTTLING). 更多信息可以参考”Documentation/cgroups/blkio-controller.txt”文件。<br>Enable Block IO controller debugging<br>CONFIG_DEBUG_BLK_CGROUP<br>仅用于调试 Block IO controller 目的。<br>Checkpoint/restore support<br>CONFIG_CHECKPOINT_RESTORE<br>在内核中添加”检查点 / 恢复”支持. 也就是添加一些辅助的代码用于设置进程的 text, data, heap 段，并且在 /proc 文件系统中添加一些额外的条目. 用于检测两个进程是否共享同一个内核资源的 kcmp() 系统调用依赖于它. 使用 systemd 的建议开启此项。<br>Namespaces support<br>CONFIG_NAMESPACES<br>命名空间支持. 主要用于支持基于容器的轻量级虚拟化技术（比如 LXC 和 Linux-VServer 以及 Docker).<br>UTS namespace<br>CONFIG_UTS_NS<br>uname() 系统调用的命名空间支持<br>IPC namespace<br>CONFIG_IPC_NS<br>进程间通信对象 ID 的命名空间支持<br>User namespace<br>CONFIG_USER_NS<br>允许容器使用 user 命名空间. 如果开启此项，建议同时开启 CONFIG_MEMCG 和 CONFIG_MEMCG_KMEM 选项，以允许用户空间使用”memory cgroup”限制非特权用户的内存使用量. 不确定的选”N”, 如果你打算构建一个 VPS 服务器就必须选”Y”.<br>PID Namespaces<br>CONFIG_PID_NS<br>进程 PID 命名空间支持<br>Network namespace<br>CONFIG_NET_NS<br>网络协议栈的命名空间支持.systemd 服务单元 (service unit) 中的”PrivateNetwork/PrivateDevices”依赖于它。<br>Require conversions between uid/gids and their internal representation<br>CONFIG_UIDGID_STRICT_TYPE_CHECKS<br>强制将 uid/gid 转换为内部表示形式，以让那些未对 uid/gid 进行转换的内核子系统代码也能正常编译. 不确定的选”N”.<br>Automatic process group scheduling<br>CONFIG_SCHED_AUTOGROUP<br>每个 TTY 动态地创建任务分组 (cgroup), 这样就可以降低高负载情况下的桌面延迟. 也就是传说中的桌面”鸡血补丁”, 桌面用户建议开启. 但服务器建议关闭。<br>Enable deprecated sysfs features to support old userspace tools<br>CONFIG_SYSFS_DEPRECATED<br>为了兼容旧版本的应用程序而保留过时的 sysfs 特性. 仅当在使用 2008 年以前的发行版时才需要开启，2009 年之后的发行版中必须关闭. 此外，使用 udev 或 systemd 的系统也必须关闭。<br>Enable deprecated sysfs features by default<br>CONFIG_SYSFS_DEPRECATED_V2<br>默认开启上述特性<br>Kernel-&gt;user space relay support (formerly relayfs)<br>CONFIG_RELAY<br>在某些文件系统（比如 debugfs) 中提供中继 (relay) 支持（从内核空间向用户空间传递大批量数据）. 主要用于调试内核。<br>Initial RAM filesystem and RAM disk (initramfs/initrd) support<br>CONFIG_BLK_DEV_INITRD<br>初始内存文件系统 (initramfs,2.6 以上内核的新机制，使用 cpio 格式，占据的内存随数据的增减自动增减）与初始内存盘 (initrd,2.4 以前内核遗留的老机制，使用 loop 设备，占据一块固定的内存，需要额外开启 CONFIG_BLK_DEV_RAM 选项才生效）支持，一般通过 lilo/grub 的 initrd 指令加载. 更多细节可以参考”Documentation/initrd.txt”文件，关于 initrd 到 initramfs 的进化（墙内镜像）, 可以参考 IBM 上的两篇文章：Linux2.6 内核的 Initrd 机制解析和 Linux 初始 RAM 磁盘（initrd）概述。<br>Initramfs source file(s)<br>CONFIG_INITRAMFS_SOURCE<br>如果你想将 initramfs 镜像直接嵌入内核（比如嵌入式环境或者想使用 EFI stub kernel), 而不是通过 lilo/grub 这样的引导管理器加载，可以使用此选项，否则请保持空白. 这个选项指明用来制作 initramfs 镜像的原料，可以是一个.cpio 文件，或一个 Initramfs 虚根目录（其下包含”bin,dev,etc,lib,proc,sys”等子目录）, 或一个描述文件. 细节可以参考”Documentation/early-userspace/README”文档.『注意』内核帮助文档说可以指定多个目录或文件是错误的，实际只能接受单一的目录或文件<br>User ID to map to 0 (user root)<br>INITRAMFS_ROOT_UID<br>此选项仅在 CONFIG_INITRAMFS_SOURCE 中包含目录时才有效，将此值设为非零（例如”37”), 那么所有 UID=37 的文件在打包到 initramfs 镜像内时，其 UID 都将被设为”0”.<br>Group ID to map to 0 (group root)<br>INITRAMFS_ROOT_GID<br>此选项仅在 CONFIG_INITRAMFS_SOURCE 中包含目录时才有效，将此值设为非零（例如”37”), 那么所有 GID=37 的文件在打包到 initramfs 镜像内时，其 GID 都将被设为”0”.<br>Support initial ramdisks compressed using gzip<br>CONFIG_RD_GZIP<br>支持经过 gzip 压缩的 ramdisk 或 cpio 镜像<br>Support initial ramdisks compressed using bzip2<br>CONFIG_RD_BZIP2<br>支持经过 bzip2 压缩的 ramdisk 或 cpio 镜像<br>Support initial ramdisks compressed using LZMA<br>CONFIG_RD_LZMA<br>支持经过 LZMA 压缩的 ramdisk 或 cpio 镜像<br>Support initial ramdisks compressed using XZ<br>CONFIG_RD_XZ<br>支持经过 XZ 压缩的 ramdisk 或 cpio 镜像<br>Support initial ramdisks compressed using LZO<br>CONFIG_RD_LZO<br>支持经过 LZO 压缩的 ramdisk 或 cpio 镜像<br>Built-in initramfs compression mode<br>选择 initramfs 镜像的压缩格式.”gzip”是兼容性最好的格式，但是压缩率却最低.”XZ”是目前渐渐流行的格式，压缩率高，解压速度也不慢。<br>Optimize for size<br>CONFIG_CC_OPTIMIZE_FOR_SIZE<br>编译时优化内核尺寸（使用 GCC 的”-Os”而不是”-O2”参数编译）, 这会得到更小的内核，但是运行速度可能会更慢. 主要用于嵌入式环境。<br>Configure standard kernel features (expert users)<br>CONFIG_EXPERT<br>配置标准的内核特性（仅供专家使用）. 这个选项允许你改变内核的”标准”特性（比如用于需要”非标准”内核的特定环境中）, 仅在你确实明白自己在干什么的时候才开启。<br>Enable 16-bit UID system calls<br>CONFIG_UID16<br>允许对 UID 系统调用进行过时的 16-bit 包装，建议关闭<br>Multiple users, groups and capabilities support<br>CONFIG_MULTIUSER<br>多用户（组）支持. 若选”N”, 则所有进程都将以”UID=0,GID=0”运行（也就是禁止存在非 root 用户）. 选”Y”, 除非你确实知道自己在干什么。<br>sgetmask/ssetmask syscalls support<br>CONFIG_SGETMASK_SYSCALL<br>是否开启已被反对使用的 sys_sgetmask/sys_ssetmask 系统调用（已不再被 libc 支持）. 建议选”N”.<br>Sysfs syscall support<br>CONFIG_SYSFS_SYSCALL<br>是否开启已被反对使用的 sys_sysfs 系统调用（已不再被 libc 支持）. 建议选”N”.<br>Sysctl syscall support<br>CONFIG_SYSCTL_SYSCALL<br>二进制 sysctl 接口支持. 由于现在流行直接通过 /proc/sys 以 ASCII 明码方式修改内核参数（需要开启 CONFIG_PROC_SYSCTL 选项）, 所以已经不需要再通过二进制接口去控制内核参数，建议关闭它以减小内核尺寸。<br>Load all symbols for debugging/ksymoops<br>CONFIG_KALLSYMS<br>装载所有的调试符号表信息，会增大内核体积，仅供调试时选择<br>Include all symbols in kallsyms<br>CONFIG_KALLSYMS_ALL<br>在 /proc/kallsyms 中包含内核知道的所有符号，内核将会增大 300K, 仅在你确实需要的时候再开启<br>Enable support for printk<br>CONFIG_PRINTK<br>允许内核向终端打印字符信息. 任何由 printk 显示的字符串通常记录在 /var/log/messages 文件里. 如果关闭，内核在初始化过程中将不会输出字符信息，这会导致很难诊断系统故障，并且”dmesg”命令也会失效. 仅在你确实不想看到任何内核信息时选”N”. 否则请选”Y”.<br>BUG() support<br>CONFIG_BUG<br>显示故障和失败条件 (BUG 和 WARN), 禁用它将可能导致隐含的错误被忽略. 建议仅在嵌入式设备或者无法显示故障信息的系统上关闭<br>Enable ELF core dumps<br>CONFIG_ELF_CORE<br>内存转储支持，可以帮助调试 ELF 格式的程序，用于调试和开发用户态程序<br>Enable PC-Speaker support<br>CONFIG_PCSPKR_PLATFORM<br>主板上的蜂鸣器支持. 主板上的蜂鸣器只能发出或长或短的”滴”或”嘟嘟”声，一般用于系统报警. 不要和能够播放音乐的扬声器混淆. 如果你的主板上没有就关闭，有的话（开机自检完成后一般能听到”滴”的一声）还是建议开启。<br>Enable full-sized data structures for core<br>CONFIG_BASE_FULL<br>在内核中使用全尺寸的数据结构. 禁用它将使得某些内核的数据结构减小以节约内存，但是将会降低性能<br>Enable futex support<br>CONFIG_FUTEX<br>快速用户空间互斥 (fast userspace mutexes) 可以使线程串行化以避免竞态条件，也提高了响应速度. 禁用它将导致内核不能正确的运行基于 glibc 的程序<br>Enable eventpoll support<br>CONFIG_EPOLL<br>Epoll 系列系统调用 (epoll_</em>) 支持，这是当前在 Linux 下开发大规模并发网络程序（比如 Nginx) 的热门人选，设计目的是取代既有 POSIX select(2) 与 poll(2) 系统接口，systemd 依赖于它. 建议开启。<br>Enable signalfd() system call<br>CONFIG_SIGNALFD<br>signalfd() 系统调用支持，建议开启. 传统的处理信号的方式是注册信号处理函数，由于信号是异步发生的，要解决数据的并发访问和可重入问题.signalfd 可以将信号抽象为一个文件描述符，当有信号发生时可以对其 read, 这样可以将信号的监听放到 select/poll/epoll 监听队列中.systemd 依赖于它。<br>Enable timerfd() system call<br>CONFIG_TIMERFD<br>timerfd() 系统调用支持，建议开启.timerfd 可以实现定时器功能，将定时器抽象为文件描述符，当定时器到期时可以对其 read, 这样也可以放到 select/poll/epoll 监听队列中. 更多信息可以参考 linux 新的 API signalfd、timerfd、eventfd 使用说明.systemd 依赖于它。<br>Enable eventfd() system call<br>CONFIG_EVENTFD<br>eventfd() 系统调用支持，建议开启.eventfd 实现了线程之间事件通知的方式，eventfd 的缓冲区大小是 sizeof(uint64_t), 向其 write 可以递增这个计数器，read 操作可以读取，并进行清零.eventfd 也可以放到 select/poll/epoll 监听队列中. 当计数器不是 0 时，有可读事件发生，可以进行读取。<br>Enable bpf() system call<br>CONFIG_BPF_SYSCALL<br>开启内核的 bpf() 系统调用支持（从 3.15 版本开始引入）, 以支持 eBPF 功能. 可用于内核调试与网络包过滤 (tcpdump,libpcap,iptables). 不确定的选”N”.<br>Use full shmem filesystem<br>CONFIG_SHMEM<br>完全使用 shmem 来代替 ramfs.shmem 是基于共享内存的文件系统（可以使用 swap), 在启用 CONFIG_TMPFS 后可以挂载为 tmpfs 供用户空间使用，它比简单的 ramfs 先进许多. 仅在微型嵌入式环境中且没有 swap 的情况下才可能会需要使用原始的 ramfs.<br>Enable AIO support<br>CONFIG_AIO<br>开启 POSIX 异步 IO 支持. 它常常被高性能的多线程程序使用，建议开启<br>Enable madvise/fadvise syscalls<br>CONFIG_ADVISE_SYSCALLS<br>开启内核的 madvise()/fadvise() 系统调用支持 (2.6.16 版本开始引入）. 以允许应用程序预先提示内核，它将如何使用特定的内存与文件. 这种措施有助于提升应用程序的性能. 建议选”Y”.<br>Enable userfaultfd() system call<br>CONFIG_USERFAULTFD<br>开启内核的 userfaultfd() 系统调用支持（从 4.3 版本开始引入）. 该特性可以被诸如 QEMU/KVM 之类的虚拟化技术用来提高 GuestOS 热迁移性能。<br>Enable PCI quirk workarounds<br>CONFIG_PCI_QUIRKS<br>开启针对多种 PCI 芯片组的错误规避功能，仅在确定你的 PCI 芯片组确实没有没有任何 bug 时才关闭此功能. 至于究竟哪些芯片组有 bug, 你可以直接打开”drivers/pci/quirks.c”文件查看. 不确定的选”Y”.<br>Enable membarrier() system call<br>CONFIG_MEMBARRIER<br>开启内核的 membarrier() 系统调用支持（与 Memory Barrier 相关）. 有助于提升多 CPU 场景下的并行计算性能. 建议选”Y”.<br>Embedded system<br>CONFIG_EMBEDDED<br>如果你是为嵌入式系统编译内核，可以开启此选项，这样一些高级选项就会显示出来. 单独选中此项本身对内核并无任何改变。<br>Kernel Performance Events And Counters<br>CONFIG_PERF_EVENTS<br>性能相关的事件和计数器支持（既有硬件的支持也有软件的支持）. 大多数现代 CPU 都会通过性能计数寄存器对特定类型的硬件事件（指令执行，缓存未命中，分支预测失败）进行计数，同时又丝毫不会减慢内核和应用程序的运行速度. 这些寄存器还会在某些事件计数到达特定的阈值时触发中断，从而可以对代码进行性能分析。Linux Performance Event 子系统对上述特性进行了抽象，提供了针对每个进程和每个 CPU 的计数器，并可以被 tools/perf/ 目录中的”perf”工具使用。<br>Debug: use vmalloc to back perf mmap() buffers<br>CONFIG_DEBUG_PERF_USE_VMALLOC<br>主要用于调试 vmalloc 代码。<br>Enable VM event counters for /proc/vmstat<br>CONFIG_VM_EVENT_COUNTERS<br>“/proc/vmstat”中包含了从内核导出的虚拟内存的各种统计信息. 开启此项后可以显示较详细的信息（包含各种事件计数器）, 关闭此项则仅仅显示内存页计数. 主要用于调试和统计。<br>Enable SLUB debugging support<br>CONFIG_SLUB_DEBUG<br>SLUB 调试支持，禁用后可显著降低内核大小，同时 /sys/kernel/slab 也将不复存在。<br>Disable heap randomization<br>CONFIG_COMPAT_BRK<br>禁用堆随机化 (heap randomization) 功能. 堆随机化可以让针对堆溢出的攻击变得困难，但是不兼容那些古董级的二进制程序 (2000 年以前）. 如果你不需要使用这些古董程序，那么选”N”.<br>Choose SLAB allocator<br>选择内存分配管理器<br>SLAB<br>CONFIG_SLAB<br>久经考验的 slab 内存分配器，在大多数情况下都具有良好的适应性。<br>SLUB (Unqueued Allocator)<br>CONFIG_SLUB<br>SLUB 与 SLAB 兼容，但通过取消大量的队列和相关开销，简化了 slab 的结构. 特别是在多核时拥有比 slab 更好的性能和更好的系统可伸缩性。<br>SLOB (Simple Allocator)<br>CONFIG_SLOB<br>SLOB 针对小型系统设计，做了非常激进的简化，以适用于内存非常有限（小于 64M) 的嵌入式环境。<br>SLUB per cpu partial cache<br>CONFIG_SLUB_CPU_PARTIAL<br>让 SLUB 内存分配器使用基于每个 CPU 的局部缓存，这样可以加速分配和释放属于此 CPU 范围内的对象，但这样做的代价是增加对象释放延迟的不确定性. 因为当这些局部缓存因为溢出而要被清除时，需要使用锁，从而导致延迟尖峰. 对于需要快速响应的实时系统，应该选”N”, 服务器则可以选”Y”.<br>Provide system-wide ring of trusted keys<br>CONFIG_SYSTEM_TRUSTED_KEYRING<br>在内核中创建一个密钥环，从而允许向密钥环上添加受信任的密钥，主要用于内核模块的签名. 如果你开启了 CONFIG_MODULE_SIG, 此项将被自动选中. 不需要使用内核模块签名检查功能的应该选”N”<br>Profiling support<br>CONFIG_PROFILING<br>添加扩展的性能分析支持，可以被 OProfile 之类的工具使用. 仅用于调试目的。<br>OProfile system profiling<br>CONFIG_OPROFILE<br>OProfile 性能分析工具支持，仅用于调试目的。<br>OProfile multiplexing support<br>CONFIG_OPROFILE_EVENT_MULTIPLEX<br>OProfile multiplexing 技术支持<br>Kprobes<br>CONFIG_KPROBES<br>Kprobes 是一个轻量级的内核调试工具，能在内核运行的几乎任意时间点进行暂停 / 读取 / 修改等操作的调试工具. 仅供调试使用。<br>Optimize very unlikely/likely branches<br>CONFIG_JUMP_LABEL<br>针对内核中某些”几乎总是为真”或者”几乎总是为假”的条件分支判断使用”asm goto”进行优化（在分支预测失败时会浪费很多时间在回退上，但是这种情况极少发生）. 很多内核子系统都支持进行这种优化. 建议开启。<br>Static key selftest<br>CONFIG_STATIC_KEYS_SELFTEST<br>在内核启动时对上述分支优化补丁进行一次自我检查。<br>Transparent user-space probes<br>CONFIG_UPROBES<br>Uprobes 与 Kprobes 类似，但主要用于用户空间的调试。<br>Stack Protector buffer overflow detection<br>GCC 的”stack-protector”功能可以在函数开始执行时，在函数的返回地址末端设置一个敏感值，当函数执行完成要返回时，检查这个敏感值，看看是否存在溢出. 如果有溢出则表明可能受到了堆栈溢出攻击，内核将通过 panic 来阻止可能的攻击. 选项中的”None”表示关闭此功能，”Regular”表示启用此功能但是仅提供较弱的保护（需要 GCC-4.2 及以上版本）,”Strong”则表示提供较强的保护（需要 GCC-4.9 及以上版本）<br>Enable GCOV-based kernel profiling<br>CONFIG_GCOV_KERNEL<br>基于 GCC 的 gcov（代码覆盖率测试工具）的代码分析支持，仅用于调试<br>Profile entire Kernel<br>CONFIG_GCOV_PROFILE_ALL<br>支持对整个内核进行分析. 内核体积将会显著增大，并且运行速度显著减慢。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://wiki.gentoo.org/wiki/Kernel/Configuration" target="_blank" rel="noopener">Kernel/Configuration</a></li>
<li><a href="https://bhavyanshu.me/configuring-the-kernel/08/31/2013/" target="_blank" rel="noopener">Configuring the kernel</a></li>
<li><a href="http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html" target="_blank" rel="noopener">Linux Kernel 4.4 Configuration</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 支持 NTFS 文件系统</title>
    <url>/2018/11/18/linux-support-ntfs/</url>
    <content><![CDATA[<p><code>Linux 4.9</code> 内核不支持 <code>ntfs</code>，需要移植 <code>ntfs-3g</code> 来支持相关硬盘挂载</p>
<a id="more"></a>

<p><a href="https://www.tuxera.com/community/open-source-ntfs-3g/" target="_blank" rel="noopener">Open Source: NTFS-3G</a><br><a href="http://www.tuxera.com/community/ntfs-3g-manual/" target="_blank" rel="noopener">ntfs-3g-manual</a></p>
<p>交叉编译之后生成 <code>ntfs-3g</code></p>
<p>使用 <code>mount</code> 命令</p>
<pre><code class="shell">mount -t ntfs-3g /dev/sdc1 /mnt/usb
ntfs-3g ntfs-3g /dev/sdc1 /mnt/usb</code></pre>
<p>注意参数 <code>big_writes</code></p>
<blockquote>
<p>This option prevents fuse from splitting write buffers into 4K chunks, enabling big write buffers to be transferred from the application in a single step (up to some system limit, generally 128K bytes).</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ntfs</tag>
      </tags>
  </entry>
  <entry>
    <title>信号 SIGPIPE 忽略的原因</title>
    <url>/2018/11/14/Linux-ignore-SIGPIPE/</url>
    <content><![CDATA[<p>系统遇到 <code>SIGPIPE</code> 相关问题导致死机，记录原因及解决方法</p>
<a id="more"></a>

<h2 id="SIGPIPE-信号"><a href="#SIGPIPE-信号" class="headerlink" title="SIGPIPE 信号"></a><code>SIGPIPE</code> 信号</h2><p>对一个 <code>对端已经关闭的 socket</code> <strong>调用两次 write，第二次将会生成 <code>SIGPIPE</code> 信号，而该信号默认结束进程</strong></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>为了避免进程退出，可以 <code>捕获 SIGPIPE 信号</code>，或者 <code>忽略它</code></p>
<pre><code class="c">signal(SIGPIPE,SIG_IGN);</code></pre>
<p>或者在捕获函数中处理</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.cnblogs.com/jingzhishen/p/3453727.html" target="_blank" rel="noopener">socket 编程—— 服务器遇到 Broken Pipe 崩溃</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 Linux 下的 ldd</title>
    <url>/2018/11/14/linux-embedded-linux-ldd/</url>
    <content><![CDATA[<p><code>pc</code> 环境下可以很方便使用 <code>ldd</code> 来查看动态库依赖，嵌入式平台下可以使用 <code>readelf</code> 来完成相同的功能</p>
<a id="more"></a>

<p><code>pc</code> 下</p>
<pre><code class="shell">$ ldd /lib32/libc-2.26.so
    /lib/ld-linux.so.2 (0xf7f8f000)
    linux-gate.so.1 =&gt;  (0xf7f8d000)</code></pre>
<p>而使用交叉编译工具链编译不能使用 <code>ldd</code> 查看</p>
<pre><code class="shell">$ ldd output/out.elf
    not a dynamic executable</code></pre>
<p>使用 <code>readelf</code> 查看依赖</p>
<pre><code class="shell">$ arm-linux-gnueabihf-readelf -d output/out.elf

Dynamic section at offset 0x42f79c contains 29 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [libm.so.6]
 0x00000001 (NEEDED)                     Shared library: [librt.so.1]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x1a964
 0x0000000d (FINI)                       0x2c5e10
 0x00000019 (INIT_ARRAY)                 0x43f000
 0x0000001b (INIT_ARRAYSZ)               212 (bytes)
 0x0000001a (FINI_ARRAY)                 0x43f0d4
 0x0000001c (FINI_ARRAYSZ)               4 (bytes)
 0x00000004 (HASH)                       0x10194
 0x00000005 (STRTAB)                     0x156dc
 0x00000006 (SYMTAB)                     0x1192c
 0x0000000a (STRSZ)                      16199 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x44f8ac
 0x00000002 (PLTRELSZ)                   2336 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x1a044
 0x00000011 (REL)                        0x19f0c
 0x00000012 (RELSZ)                      312 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x19ddc
 0x6fffffff (VERNEEDNUM)                 6
 0x6ffffff0 (VERSYM)                     0x19624
 0x00000000 (NULL)                       0x0</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ldd</tag>
        <tag>readelf</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 Linux 支持 PPPoE</title>
    <url>/2018/11/13/linux-kernel-support-pppoe/</url>
    <content><![CDATA[<p>配置 <code>Linux 内核</code> 已支持 <code>PPPoE</code></p>
<a id="more"></a>

<h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><p>内核版本：v4.9.22</p>
<pre><code>CONFIG_PPP=y
CONFIG_PPP_ASYNC=y
CONFIG_PPP_SYNC_TTY=y
CONFIG_PPP_DEFLATE=y
CONFIG_PPP_BSDCOMP=y
CONFIG_PPPOE=y</code></pre><p>可以参考 <code>rp-pppoe</code> 中文件 <code>doc/KERNEL-MODE-PPPOE</code></p>
<pre><code class="txt">configuration settings:

    CONFIG_PPP=m          or CONFIG_PPP=y
    CONFIG_PPP_ASYNC=m    or CONFIG_PPP_ASYNC=y
    CONFIG_PPP_SYNC_TTY=m or CONFIG_PPP_SYNC_TTY=y
    CONFIG_PPP_DEFLATE=m  or CONFIG_PPP_DEFLATE=y
    CONFIG_PPP_BSDCOMP=m  or CONFIG_PPP_BSDCOMP=y
    CONFIG_PPPOE=m        or CONFIG_PPPOE=y
    CONFIG_N_HDLC=m       or CONFIG_N_HDLC=y
    CONFIG_UNIX98_PTYS=y</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://norean.freecontrib.org/nakooki/SVN/snapshot/nakooki/0.3/docs/pppoe-HOW-TO.html" target="_blank" rel="noopener">DSL connection using pppoe kernel-mode, HOW-TO</a></li>
<li><a href="https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/skoll/skoll_html/index.html" target="_blank" rel="noopener">A PPPoE Implementation for Linux</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ppp</tag>
        <tag>pppoe</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 Linux 系统支持 GSM/3G</title>
    <url>/2018/11/13/linux-kernel-support-GSM/</url>
    <content><![CDATA[<p>编译 <code>Linux Kernel</code> 支持 <code>GSM/3G/4G</code></p>
<a id="more"></a>

<h2 id="Linux-内核选项"><a href="#Linux-内核选项" class="headerlink" title="Linux 内核选项"></a>Linux 内核选项</h2><p>Linux Version: v4.9.22</p>
<p>内核配置保证打开如下选项</p>
<pre><code>Device Drivers  ---&gt;
   [*] Network device support  ---&gt;
        &lt;*&gt;   PPP (point-to-point protocol) support
        &lt; &gt;     PPP BSD-Compress compression
        &lt; &gt;     PPP Deflate compression
        [*]     PPP filtering
        &lt; &gt;     PPP MPPE compression (encryption)
        [*]     PPP multilink support
        &lt; &gt;     PPP over Ethernet
        &lt; &gt;     PPP support for async serial ports
        &lt; &gt;     PPP support for sync tty ports
   [*] USB support  ---&gt;
        &lt;*&gt;   USB Serial Converter support  ---&gt;
            &lt;*&gt;   USB driver for GSM and CDMA modems</code></pre><p>工作之后有如下错误信息</p>
<pre><code>Couldn&#39;t set tty to PPP discipline: Invalid argument</code></pre><p>参考文章 <a href="http://pptpclient.sourceforge.net/howto-diagnosis.phtml" target="_blank" rel="noopener">PPTP Client</a></p>
<p>打开选项 <code>CONFIG_PPP_ASYNC</code></p>
<p>注意其中 <code>compression</code> 为压缩选项</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://pptpclient.sourceforge.net/howto-diagnosis.phtml" target="_blank" rel="noopener">PPTP Client</a></li>
<li><a href="https://www.toradex.com/zh-cn/blog/how-to-use-gsm-3g-4g-in-embedded-linux-systems" target="_blank" rel="noopener">如何在嵌入式 Linux 系统中使用 GSM/3G/4G 模块</a></li>
<li><a href="https://www.linuxjournal.com/article/2109" target="_blank" rel="noopener">A 10-Minute Guide for Using PPP to Connect Linux to the Internet</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>3g</tag>
        <tag>gsm</tag>
        <tag>4g</tag>
        <tag>ppp</tag>
      </tags>
  </entry>
  <entry>
    <title>静态编译使用 getaddrinfo 出现警告及动态静态混合使用</title>
    <url>/2018/11/12/statically-linked-binary-that-uses-getaddrinfo/</url>
    <content><![CDATA[<p>使用 <code>-static</code> 编译出现以下警告</p>
<pre><code>libcurl.a(netrc.c.o): In function `Curl_parsenetrc&#39;:
netrc.c:(.text.Curl_parsenetrc+0x23e): warning: Using &#39;getpwuid&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
libplayer.a(stream_wfd.c.o): In function `wfd_stream_open&#39;:
stream_wfd.c:(.text.wfd_stream_open+0x5fe): warning: Using &#39;getaddrinfo&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</code></pre><blockquote>
<p>glibc uses libnss to support a number of different providers for address resolution services. Unfortunately, you cannot statically link libnss, as exactly what providers it loads depends on the local system’s configuration.</p>
</blockquote>
<p>相关功能不能正常工作，需要使用 <code>动态编译</code> 解决此问题或者更换编译工具链为 <code>uclibc</code>、 <code>musl-gcc</code></p>
<a id="more"></a>

<h2 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h2><p>动态库后缀为 <code>.so</code>，是 <code>Shared Object</code> 的缩写，程序运行时的动态链接，多个进程可以链接同一个共享库。动态库在程序编译时并不会被连接到目标代码中，程序运行时被载入，因此在程序运行时还需要动态库存在。</p>
<h3 id="编译生成动态库"><a href="#编译生成动态库" class="headerlink" title="编译生成动态库"></a>编译生成动态库</h3><pre><code class="shell">gcc -fPIC -shared -o libmax.so max.c</code></pre>
<ul>
<li><code>-fPIC</code> 为编译器选项，是 <code>Position Independent Code</code> 的缩写，表示要生成位置无关的代码，这是动态库需要的特性</li>
<li><code>-shared</code> 为链接器选项，告诉 gcc 生成动态库而不是可执行文件</li>
</ul>
<h3 id="使用动态连接库"><a href="#使用动态连接库" class="headerlink" title="使用动态连接库"></a>使用动态连接库</h3><pre><code class="shell">gcc test.c -L. -lmax</code></pre>
<ul>
<li>生成可执行文件 <code>a.out</code></li>
<li><code>-L.</code> 表示搜索要链接的库文件时包含当前路径</li>
<li><code>-lmax</code> 表示要链接 <code>libmax.so</code>，如果同一目录下同时存在同名的动态库和静态库，比如 <code>libmax.so</code> 和 <code>libmax.a</code> 都在当前路径下，则 <code>gcc</code> 会优先链接动态库</li>
</ul>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre><code class="shell">$ ./a.out
./a.out: error while loading shared libraries: libmax.so: cannot open shared object file: No such file or directory</code></pre>
<p>找不到 <code>libmax.so</code>，原来 <code>Linux</code> 是通过 <code>/etc/ld.so.cache</code> 文件搜寻要链接的动态库的。而 <code>/etc/ld.so.cache</code> 是 <code>ldconfig</code> 程序读取 <code>/etc/ld.so.conf</code> 文件生成的。（ <code>/etc/ld.so.conf</code> 中并不必包含 <code>/lib</code> 和 <code>/usr/lib</code>， <code>ldconfig</code> 程序会自动搜索这两个目录）<br>如果我们把 <code>libmax.so</code> 所在的路径添加到 <code>/etc/ld.so.conf</code> 中，再以 <code>root</code> 权限运行 <code>ldconfig</code> 程序，更新 <code>/etc/ld.so.cache</code>， <code>a.out</code> 运行时，就可以找到 <code>libmax.so</code>。</p>
<p>还有另一种简单的方法，就是为 <code>a.out</code> 指定 <code>LD_LIBRARY_PATH</code></p>
<pre><code class="shell">LD_LIBRARY_PATH=. ./a.out</code></pre>
<p><code>LD_LIBRARY_PATH</code> 是寻找链接的动态库路径</p>
<blockquote>
<p>对于 <code>elf 格式的可执行程序</code>，是由 <code>ld-linux.so*</code> 来完成的，它先后搜索 <code>elf 文件</code> 的 <code>DT_RPATH</code> 段，环境变量 <code>LD_LIBRARY_PATH</code> , <code>/etc/ld.so.cache</code> 文件列表， <code>/lib/</code> , <code>/usr/lib</code> 目录，找到库文件后将其载入内存</p>
</blockquote>
<h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>静态库后缀为 <code>.a</code>，静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。</p>
<pre><code>LDFLAGS += -static</code></pre><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h3><p>使用 <code>ldd</code> 查看可执行程序依赖那些动态库或着动态库依赖于那些动态库</p>
<pre><code class="shell">$ ldd /lib/libxtables.so.10
    linux-vdso.so.1 =&gt;  (0x00007ffdf51f5000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fb9cda56000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb9cd676000)
    /lib64/ld-linux-x86-64.so.2 (0x00007fb9cde67000)</code></pre>
<h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h3><p>使用 <code>nm</code> 工具，查看静态库和动态库中有那些函数名</p>
<pre><code class="shell">$ nm /lib/libxtables.so.10</code></pre>
<p><code>nm</code> 列出的符号有很多， 常见的有三种：</p>
<ul>
<li><code>T 类</code>：是在库中定义的函数，用 T 表示，这是最常见的</li>
<li><code>U 类</code>：是在库中被调用，但并没有在库中定义（表明需要其他库支持），用 U 表示</li>
<li><code>W 类</code>：是所谓的 <code>弱态</code> 符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用 W 表示</li>
</ul>
<h3 id="ar"><a href="#ar" class="headerlink" title="ar"></a>ar</h3><p>使用 <code>ar</code> 工具，可以生成静态库，同时可以查看静态库中包含那些 <code>.o</code> 文件，即有那些源文件构成</p>
<pre><code class="shell">$ ar -t libpng.a
pngerror.c.o
pngmem.c.o
pngrio.c.o
pngrutil.c.o
pngtrans.c.o
png.c.o
pngget.c.o
pngread.c.o
pngpread.c.o
pngrtran.c.o
pngset.c.o</code></pre>
<h3 id="如何查看动态库和静态库是-32-位，还是-64-位下的库"><a href="#如何查看动态库和静态库是-32-位，还是-64-位下的库" class="headerlink" title="如何查看动态库和静态库是 32 位，还是 64 位下的库"></a>如何查看动态库和静态库是 32 位，还是 64 位下的库</h3><ul>
<li><code>file .so</code></li>
<li><code>objdump -x .a</code></li>
</ul>
<h2 id="混合链接"><a href="#混合链接" class="headerlink" title="混合链接"></a>混合链接</h2><p>当 <code>ld</code> 使用了选项 <code>-static</code> 时会导致所有的库使用静态链接，因此当使用混合链接是一定不能使用 <code>-static</code>，只能通过 <code>-Wl,-Bstatic -llibname</code> 或 <code>-Wl,-Bdynamic -llibname</code> 来指定链接方式</p>
<ul>
<li><code>LIBRARY_PATH</code> 环境变量：指定程序静态链接库文件搜索路径</li>
<li><code>LD_LIBRARY_PATH</code> 环境变量：指定程序动态链接库文件搜索路径</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://stackoverflow.com/questions/2725255/create-statically-linked-binary-that-uses-getaddrinfo" target="_blank" rel="noopener">statically-linked binary that uses getaddrinfo?</a></li>
<li><a href="https://www.linuxquestions.org/questions/programming-9/glibc-warning-concerning-use-of-getaddrinfo-in-static-library-734169/" target="_blank" rel="noopener">Glibc warning concerning use of getaddrinfo() in static library</a></li>
<li><a href="https://akkadia.org/drepper/no_static_linking.html" target="_blank" rel="noopener">Static Linking Considered Harmful</a></li>
<li><a href="https://blog.csdn.net/yangyihongyangjiying/article/details/50616642" target="_blank" rel="noopener">linux 库 动态 静态 编译 混合 使用</a></li>
<li><a href="https://blog.csdn.net/tenfyguo/article/details/5737974" target="_blank" rel="noopener">关于 GCC 中同时使用动态和静态库链接的操作参数和解释</a></li>
<li><a href="https://stackoverflow.com/questions/3430400/linux-static-linking-is-dead" target="_blank" rel="noopener">Linux static linking is dead?</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linux</tag>
        <tag>libnss</tag>
        <tag>static</tag>
        <tag>getaddrinfp</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 ARM 板子 Busybox 域名解析失败</title>
    <url>/2018/11/09/Busybox-nslookup-fails/</url>
    <content><![CDATA[<p>嵌入式 ARM 平台 <code>busybox</code> 可以 <code>ping ip</code>，但是不能 <code>ping domain name</code></p>
<p>本篇主要涉及</p>
<ul>
<li>gcc v4.9</li>
<li>libnss 动态链接库</li>
<li>busybox 动态与静态编译</li>
<li>busybox 动态编译下使用域名解析</li>
<li>busybox 静态编译下使用域名解析</li>
</ul>
<a id="more"></a>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Linux v4.9.22</li>
<li>Busybox v1.27.2</li>
<li>Gcc v4.9</li>
</ul>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><code>ping IP</code> 可以正常工作， <code>ping domain name</code> 时报错如下</p>
<pre><code class="shell"># ping www.baidu.com
ping: bad address &#39;www.baidu.com&#39;
# nslookup www.baidu.com
Server:    192.168.110.1
Address 1: 192.168.110.1

nslookup: can&#39;t resolve &#39;www.baidu.com&#39;</code></pre>
<h2 id="确认环境设置"><a href="#确认环境设置" class="headerlink" title="确认环境设置"></a>确认环境设置</h2><p>需要确认路由表及 <code>nameserver</code>，如下：</p>
<pre><code class="shell"># route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.110.1   0.0.0.0         UG    0      0        0 eth0
192.168.110.0   *               255.255.254.0   U     0      0        0 eth0

# cat /etc/resolv.conf
nameserver 192.168.110.1
nameserver 114.114.114.114
nameserver 202.101.172.35</code></pre>
<p><strong>相同的配置在使用 <code>uclibc</code> 编译的开发板上工作正常</strong></p>
<p>添加默认路由表命令如下</p>
<pre><code class="shell">route add default gw 192.168.110.1 dev eth0</code></pre>
<h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><ol>
<li><a href="https://unix.stackexchange.com/questions/124283/busybox-ping-ip-works-but-hostname-nslookup-fails-with-bad-address" target="_blank" rel="noopener">Busybox ping IP works, but hostname nslookup fails with “bad address”</a></li>
<li><a href="https://www.cnblogs.com/cute/archive/2012/05/17/2506332.html" target="_blank" rel="noopener">ping: bad address ‘www.baidu.com’</a></li>
<li><a href="https://bugs.archlinux.org/task/41769" target="_blank" rel="noopener">FS#41769 - [busybox] DNS lookups don’t work</a></li>
<li><a href="https://unix.stackexchange.com/questions/278864/name-resolution-in-busybox" target="_blank" rel="noopener">Name resolution in busybox</a></li>
<li><a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=757941" target="_blank" rel="noopener">libc6 version 2.19 breaks NSS loading for static binaries</a></li>
<li><a href="https://blog.csdn.net/water_cow/article/details/6901981" target="_blank" rel="noopener">Linux 文件系统域名解析实现</a></li>
<li><a href="https://blog.csdn.net/u013625451/article/details/79007441" target="_blank" rel="noopener">arm 开发板无法使用 dns 解析问题</a></li>
</ol>
<p>包括 <code>busybox</code> 下文档 <code>busybox_footer.pod</code> 下解释</p>
<blockquote>
<p>LIBC NSS</p>
</blockquote>
<blockquote>
<p>GNU Libc (glibc) uses the Name Service Switch (NSS) to configure the behavior<br>of the C library for the local environment, and to configure how it reads<br>system data, such as passwords and group information.  This is implemented<br>using an /etc/nsswitch.conf configuration file, and using one or more of the<br>/lib/libnss_* libraries.  BusyBox tries to avoid using any libc calls that make<br>use of NSS.  Some applets however, such as login and su, will use libc functions<br>that require NSS.</p>
</blockquote>
<blockquote>
<p>If you enable CONFIG_USE_BB_PWD_GRP, BusyBox will use internal functions to<br>directly access the /etc/passwd, /etc/group, and /etc/shadow files without<br>using NSS.  This may allow you to run your system without the need for<br>installing any of the NSS configuration files and libraries.</p>
</blockquote>
<blockquote>
<p><strong>When used with glibc, the BusyBox ‘networking’ applets will similarly require<br>that you install at least some of the glibc NSS stuff (in particular,<br>/etc/nsswitch.conf, /lib/libnss_dns<em>, /lib/libnss_files</em>, and /lib/libresolv*).</strong></p>
</blockquote>
<blockquote>
<p>Shameless Plug: As an alternative, one could use a C library such as uClibc.  In<br>addition to making your system significantly smaller, <strong>uClibc does not require the<br>use of any NSS support files or libraries.</strong></p>
</blockquote>
<p>从以上可以获知：</p>
<ol>
<li><code>libnss</code> 设计就是动态库，不建议静态编译。要静态编译，请先重新编译 <code>glibc</code>，把 <code>–enable-libnss-static</code> 放上</li>
<li><code>glibc</code> 需要 <code>libnss</code> 库支持，编译工具链中直接包含了相关的文件，是动态库<pre><code class="shell">✔ ~/gcc-linaro-4.9.4-2017.01-i686_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib &gt; ll libnss_dns*
 libnss_dns-2.19-2014.08-1-git.so
 libnss_dns.so.2 -&gt; libnss_dns-2.19-2014.08-1-git.so
✔ ~/gcc-linaro-4.9.4-2017.01-i686_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib &gt; ll libnss_files*
 libnss_files-2.19-2014.08-1-git.so
 libnss_files.so.2 -&gt; libnss_files-2.19-2014.08-1-git.so
✔ ~/gcc-linaro-4.9.4-2017.01-i686_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib &gt; ll libresolv*
 libresolv-2.19-2014.08-1-git.so
 libresolv.so.2 -&gt; libresolv-2.19-2014.08-1-git.so</code></pre>
</li>
<li><code>busybox</code> 需要动态编译来完成对 <code>libnss</code> 的使用</li>
</ol>
<h2 id="NSS-Name-Service-Switch-与-nsswitch-conf"><a href="#NSS-Name-Service-Switch-与-nsswitch-conf" class="headerlink" title="NSS(Name Service Switch 与 nsswitch.conf"></a>NSS(Name Service Switch 与 nsswitch.conf</h2><p><a href="https://en.wikipedia.org/wiki/Name_Service_Switch" target="_blank" rel="noopener">Name Service Switch</a></p>
<p><code>NSS(Name Service Switch)</code> 是 <code>类 unix 操作系统</code> 中的一种工具，它为通用配置数据库和名称解析机制提供了各种来源。这些源文件包括本地操作系统文件（例如 <code>/etc/passwd</code>、 <code>/etc/group</code> 和 <code>/etc/hosts</code> )、 <code>域名系统 (DNS)</code>、 <code>网络信息服务 (NIS)</code> 和 <code>LDAP</code></p>
<p><code>nsswitch.conf(name service switch configuration，名称服务切换配置）</code> 文件位于 <code>/etc</code> 目录下，<strong>由它规定通过哪些途径以及按照什么顺序以及通过这些途径来查找特定类型的信息，还可以指定某个方法奏效或失效时系统将采取什么动作</strong></p>
<p>本篇文章中涉及到 <code>DNS 解析顺序</code></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h3><p><code>busybox</code> 使用动态编译，然后将 <code>libnss</code> 相关文件拷贝到 <code>rootfs/lib</code> 下，并配置文件 <code>/etc/hosts, /etc/resolv.conf, /etc/nsswitch.conf</code></p>
<h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>参考文章：<a href="https://blog.csdn.net/prog_6103/article/details/78569510" target="_blank" rel="noopener">nslookup 在静态编译的 busybox 上如何正常解析域名</a></p>
<p>使用 <code>getaddrinfo</code> 进行域名解析。这个函数是 <code>libnss</code> 里的一个 <code>API</code> （可以在 <code>glibc</code> 源码中查看 <code>nss</code> 目录）。解决办法是绕过它，自己实现域名解析</p>
<p>搜索 <code>busybox</code> 源文件</p>
<pre><code class="shell">busybox-1.27.2 &gt; grep &quot;getaddrinfo&quot; * -Rn
libbb/inet_common.c:160:    s = getaddrinfo(name, NULL, &amp;req, &amp;ai);
libbb/inet_common.c:162:        bb_error_msg(&quot;getaddrinfo: %s: %d&quot;, name, s);
libbb/xconnect.c:5: * Connect to host at port using address resolution from getaddrinfo
libbb/xconnect.c:247:    /* Next two if blocks allow to skip getaddrinfo()
libbb/xconnect.c:249:     * getaddrinfo() initializes DNS resolution machinery,
libbb/xconnect.c:285:    rc = getaddrinfo(host, NULL, &amp;hint, &amp;result);
networking/nslookup.c:90:    rc = getaddrinfo(hostname, NULL /*service*/, &amp;hint, &amp;result);
networking/nslookup.c:200:    /* getaddrinfo and friends are free to request a resolver
networking/nslookup.c:202:     * after getaddrinfo (in server_print). This reportedly helps</code></pre>
<p><code>inet_common.c</code> 、 <code>xconnect.c</code> 以及 <code>nslookup.c</code> 这三个文件中的 <code>getaddrinfo</code> 使用 <a href="https://github.com/dna2github/dna2oslab/blob/master/linux/getaddrinfo.h" target="_blank" rel="noopener">getaddrinfo.h</a> 覆盖解决此问题</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://ixyzero.com/blog/archives/4061.html" target="_blank" rel="noopener">LINUX 系统下的 NSS 服务和 /ETC/NSSWITCH.CONF 文件学习</a></li>
<li><a href="http://www.firewall.cx/networking-topics/protocols/domain-name-system-dns/161-protocols-dns-response.html" target="_blank" rel="noopener">DNS RESPONSE MESSAGE FORMAT</a></li>
<li><a href="https://www.binarytides.com/dns-query-code-in-c-with-linux-sockets/" target="_blank" rel="noopener">DNS Query Code in C with linux sockets</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>busybox</tag>
        <tag>libnss</tag>
        <tag>nslookup</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核配置支持 MT7601U</title>
    <url>/2018/11/09/Linux-Kernel-cfg80211-wireless-extensions-compatibility/</url>
    <content><![CDATA[<p>内核版本 <code>4.9.22</code> 支持 <code>MT7601U</code>，设备发现之后不能扫描 AP，需要 <code>cfg80211 wireless extensions compatibility</code> 支持</p>
<p>内核描述如下</p>
<blockquote>
<p>Enable this option if you need old userspace for wireless extensions with cfg80211-based drivers.</p>
</blockquote>
<a id="more"></a>

<p>内核配置如下</p>
<pre><code class="kconfig">[*] Networking support  ---&gt;
      -*-   Wireless  ---&gt;
        &lt;*&gt;   cfg80211 - wireless configuration API
        [ ]     nl80211 testmode command (NEW)
        [ ]     enable developer warnings (NEW)
        [*]     enable powersave by default (NEW)
        [ ]     cfg80211 DebugFS entries (NEW)
        [*]     cfg80211 wireless extensions compatibility
        &lt;*&gt;   Generic IEEE 802.11 Networking Stack (mac80211)
                Default rate control algorithm (Minstrel)  ---&gt;
        [ ]   Enable mac80211 mesh networking (pre-802.11s) support (NEW)
        [ ]   Export mac80211 internals in DebugFS (NEW)
        [ ]   Trace all mac80211 debug messages (NEW)
        [ ]   Select mac80211 debugging features (NEW)  ---</code></pre>
<ol>
<li><a href="https://github.com/friendlyarm/linux-3.4.y/issues/12" target="_blank" rel="noopener">cfg80211 needs to be enabled for MAC80211</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>wext</tag>
        <tag>cfg80211</tag>
      </tags>
  </entry>
  <entry>
    <title>无线管理工具</title>
    <url>/2018/11/08/wireless-tools/</url>
    <content><![CDATA[<p><code>wireless</code> 管理工具 <code>iwconfig</code> 和 <code>iw</code></p>
<ul>
<li><a href="https://hewlettpackard.github.io/wireless-tools/Tools.html" target="_blank" rel="noopener">iwconfig</a> 使用 <code>Wireless Extension (WE)</code> 接口</li>
<li><a href="https://www.openhub.net/p/iw" target="_blank" rel="noopener">iw</a> 一种新的基于 <code>nl80211</code> 的用于无线设备的 <code>CLI 配置实用程序</code>。它支持最近已添加到内核所有新的驱动程序。采用无线扩展接口的旧工具 <code>iwconfig</code> 已被废弃，强烈建议切换到 <code>iw</code> 和 <code>nl80211</code></li>
</ul>
<p><a href="https://wireless.wiki.kernel.org/en/users/documentation/iw/replace-iwconfig#replacing_iwconfig_with_iw" target="_blank" rel="noopener">Replacing iwconfig with iw</a></p>
<a id="more"></a>

<h2 id="iw"><a href="#iw" class="headerlink" title="iw"></a>iw</h2><p><code>iw list</code> 可以查看 <code>wifi</code> 相关信息</p>
<pre><code class="shell">$ iw list
Wiphy phy0
    max # scan SSIDs: 20
    max scan IEs length: 439 bytes
    max # sched scan SSIDs: 20
    max # match sets: 11
    max # scan plans: 2
    max scan plan interval: 65535
    max scan plan iterations: 254
    Retry short limit: 7
    Retry long limit: 4
    Coverage class: 0 (up to 0m)
    Device supports RSN-IBSS.
    Device supports AP-side u-APSD.
    Supported Ciphers:
        * WEP40 (00-0f-ac:1)
        * WEP104 (00-0f-ac:5)
        * TKIP (00-0f-ac:2)
        * CCMP-128 (00-0f-ac:4)
        * CMAC (00-0f-ac:6)
    Available Antennas: TX 0 RX 0
    Supported interface modes:
         * IBSS
         * managed
         * AP
         * AP/VLAN
         * monitor
         * P2P-client
         * P2P-GO
         * P2P-device
    Band 1:
        Capabilities: 0x11ee
            HT20/HT40
            SM Power Save disabled
            RX HT20 SGI
            RX HT40 SGI
            TX STBC
            RX STBC 1-stream
            Max AMSDU length: 3839 bytes
            DSSS/CCK HT40
        Maximum RX AMPDU length 65535 bytes (exponent: 0x003)
        Minimum RX AMPDU time spacing: 4 usec (0x05)
        HT Max RX data rate: 300 Mbps
        HT TX/RX MCS rate indexes supported: 0-15
        Bitrates (non-HT):
            * 1.0 Mbps
            * 2.0 Mbps (short preamble supported)
            * 5.5 Mbps (short preamble supported)
            * 11.0 Mbps (short preamble supported)
            * 6.0 Mbps
            * 9.0 Mbps
            * 12.0 Mbps
            * 18.0 Mbps
            * 24.0 Mbps
            * 36.0 Mbps
            * 48.0 Mbps
            * 54.0 Mbps
        Frequencies:
            * 2412 MHz [1] (22.0 dBm)
            * 2417 MHz [2] (22.0 dBm)
            * 2422 MHz [3] (22.0 dBm)
            * 2427 MHz [4] (22.0 dBm)
            * 2432 MHz [5] (22.0 dBm)
            * 2437 MHz [6] (22.0 dBm)
            * 2442 MHz [7] (22.0 dBm)
            * 2447 MHz [8] (22.0 dBm)
            * 2452 MHz [9] (22.0 dBm)
            * 2457 MHz [10] (22.0 dBm)
            * 2462 MHz [11] (22.0 dBm)
            * 2467 MHz [12] (22.0 dBm) (no IR)
            * 2472 MHz [13] (22.0 dBm) (no IR)
    Supported commands:
         * new_interface
         * set_interface
         * new_key
         * start_ap
         * new_station
         * new_mpath
         * set_mesh_config
         * set_bss
         * authenticate
         * associate
         * deauthenticate
         * disassociate
         * join_ibss
         * join_mesh
         * remain_on_channel
         * set_tx_bitrate_mask
         * frame
         * frame_wait_cancel
         * set_wiphy_netns
         * set_channel
         * set_wds_peer
         * start_sched_scan
         * probe_client
         * set_noack_map
         * register_beacons
         * start_p2p_device
         * set_mcast_rate
         * connect
         * disconnect
         * channel_switch
         * set_qos_map
         * add_tx_ts
         * Unknown command (121)
    Supported TX frame types:
         * IBSS: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
         * managed: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
         * AP: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
         * AP/VLAN: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
         * mesh point: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
         * P2P-client: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
         * P2P-GO: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
         * P2P-device: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
    Supported RX frame types:
         * IBSS: 0x40 0xb0 0xc0 0xd0
         * managed: 0x40 0xd0
         * AP: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0
         * AP/VLAN: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0
         * mesh point: 0xb0 0xc0 0xd0
         * P2P-client: 0x40 0xd0
         * P2P-GO: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0
         * P2P-device: 0x40 0xd0
    WoWLAN support:
         * wake up on disconnect
         * wake up on magic packet
         * wake up on pattern match, up to 20 patterns of 16-128 bytes,
           maximum packet offset 0 bytes
         * can do GTK rekeying
         * wake up on GTK rekey failure
         * wake up on EAP identity request
         * wake up on 4-way handshake
         * wake up on rfkill release
         * wake up on network detection, up to 11 match sets
         * wake up on TCP connection
    software interface modes (can always be added):
         * AP/VLAN
         * monitor
    valid interface combinations:
         * #{ managed } &lt;= 1, #{ AP, P2P-client, P2P-GO } &lt;= 1, #{ P2P-device } &lt;= 1,
           total &lt;= 3, #channels &lt;= 2
    HT Capability overrides:
         * MCS: ff ff ff ff ff ff ff ff ff ff
         * maximum A-MSDU length
         * supported channel width
         * short GI for 40 MHz
         * max A-MPDU length exponent
         * min MPDU start spacing
    Device supports TX status socket option.
    Device supports HT-IBSS.
    Device supports SAE with AUTHENTICATE command
    Device supports low priority scan.
    Device supports scan flush.
    Device supports per-vif TX power setting
    P2P GO supports CT window setting
    P2P GO supports opportunistic powersave setting
    Driver supports full state transitions for AP/GO clients
    Driver supports a userspace MPM
    Driver/device bandwidth changes during BSS lifetime (AP/GO mode)
    Device supports static SMPS
    Device supports dynamic SMPS
    Device supports WMM-AC admission (TSPECs)
    Device supports configuring vdev MAC-addr on create.</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/trochiluses/article/details/13621677" target="_blank" rel="noopener">无线网卡的查看与配置——iw，iwconfig，ethtool</a></li>
<li><a href="https://wireless.wiki.kernel.org/en/users/Documentation/iw" target="_blank" rel="noopener">About iw</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>wifi</tag>
        <tag>wireless</tag>
        <tag>iw</tag>
        <tag>iwconfig</tag>
      </tags>
  </entry>
  <entry>
    <title>Busybox udhcpc 不能正常工作</title>
    <url>/2018/11/08/Linux-udhcpc-client-not-recieving-dchp-offer/</url>
    <content><![CDATA[<p><code>udhcpc client</code> 不能正常工作，需要内核打开 <code>packet socket</code> 支持</p>
<a id="more"></a>

<p><code>Networking support</code> -&gt; <code>Networking options</code> -&gt; <code>Packet socket</code></p>
<p>说明</p>
<pre><code>CONFIG_PACKET:                                                                                                            │
  │                                                                                                                           │
  │ The Packet protocol is used by applications which communicate                                                             │
  │ directly with network devices without an intermediate network                                                             │
  │ protocol implemented in the kernel, e.g. tcpdump.  If you want them                                                       │
  │ to work, choose Y.                                                                                                        │
  │                                                                                                                           │
  │ To compile this driver as a module, choose M here: the module will                                                        │
  │ be called af_packet.                                                                                                      │
  │                                                                                                                           │
  │ If unsure, say Y.</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>dhcp</tag>
        <tag>busybox</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Ioctl Number 使用不规范导致的问题</title>
    <url>/2018/11/08/Linux-ioctl-number/</url>
    <content><![CDATA[<p><code>Linux Modules</code> 编写不规范导致出现奇怪现象，部分 <code>ioctl</code> 不能正常调用</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><code>Modules</code> 使用的 <code>ioctl</code> 定义如下</p>
<pre><code class="c">typedef enum
{
    IO_STR,
    IO_NUM,
    IO_KEY,
    IO_LOCK,
    IO_QUALITY,
    IO_TIME,
}IoctlKey;</code></pre>
<p>发现其他 <code>ioctl</code> 可以正常调用，而某一个 <code>ioctl</code> 不能执行成功， <code>case</code> 分支都不会进入</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>需要按照标准定义 <code>ioctl</code></p>
<p>例如 <code>dvbapi</code></p>
<pre><code class="c">#define FE_DISEQC_RESET_OVERLOAD   _IO(&#39;o&#39;, 62)
#define FE_DISEQC_SEND_MASTER_CMD  _IOW(&#39;o&#39;, 63, struct dvb_diseqc_master_cmd)
#define FE_DISEQC_RECV_SLAVE_REPLY _IOR(&#39;o&#39;, 64, struct dvb_diseqc_slave_reply)
#define FE_DISEQC_SEND_BURST       _IO(&#39;o&#39;, 65)  /* fe_sec_mini_cmd_t */</code></pre>
<p>上述 <code>enum</code> 定义导致冲突</p>
<p>不同 <code>Modules</code> 定义 <code>ioctl number</code> 需要查看内核文件 <code>Documentation/ioctl/ioctl-number.txt</code> 来保证不会冲突</p>
<p>截取一段如下</p>
<pre><code class="txt">Code  Seq#(hex) Include File        Comments
========================================================
0x00    00-1F   linux/fs.h      conflict!
0x00    00-1F   scsi/scsi_ioctl.h   conflict!
0x00    00-1F   linux/fb.h      conflict!
0x00    00-1F   linux/wavefront.h   conflict!
0x02    all linux/fd.h
0x03    all linux/hdreg.h
0x04    D2-DC   linux/umsdos_fs.h   Dead since 2.6.11, but don&#39;t reuse these.
0x06    all linux/lp.h
0x09    all linux/raid/md_u.h
0x10    00-0F   drivers/char/s390/vmcp.h
0x10    10-1F   arch/s390/include/uapi/sclp_ctl.h
0x10    20-2F   arch/s390/include/uapi/asm/hypfs.h
0x12    all linux/fs.h
        linux/blkpg.h
0x1b    all InfiniBand Subsystem    &lt;http://infiniband.sourceforge.net/&gt;
0x20    all drivers/cdrom/cm206.h
0x22    all scsi/sg.h
&#39;#&#39; 00-3F   IEEE 1394 Subsystem Block for the entire subsystem
&#39;$&#39; 00-0F   linux/perf_counter.h, linux/perf_event.h
&#39;%&#39; 00-0F   include/uapi/linux/stm.h
                    System Trace Module subsystem
                    &lt;mailto:alexander.shishkin@linux.intel.com&gt;
&#39;&amp;&#39; 00-07   drivers/firewire/nosy-user.h
&#39;1&#39; 00-1F   &lt;linux/timepps.h&gt;   PPS kit from Ulrich Windl</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>modules</tag>
        <tag>ioctl</tag>
      </tags>
  </entry>
  <entry>
    <title>编译 Linux 模块出错</title>
    <url>/2018/11/08/Compiling-Kernel-Modules-Error/</url>
    <content><![CDATA[<p>开发 <code>Linux Modules</code> 时编译出错，某些头文件找不到</p>
<a id="more"></a>

<p><code>Linux Modules</code> 编译时出现错误</p>
<pre><code>a.c:123:2: error: implicit declaration of function ‘memset’ [-Werror=implicit-function-declaration]</code></pre><p>添加头文件 <code>#include &lt;string.h&gt;</code> 或 <code>#include &quot;string.h&quot;</code> 错误变成</p>
<pre><code>b.c:3:20: fatal error: string.h: No such file or directory
 #include &lt;string.h&gt;
                    ^
compilation terminated.</code></pre><p>继续修改为 <code>#include &lt;linux/string.h&gt;</code> 解决问题</p>
<p><code>Modules</code> 编译时 <code>&lt;&gt;</code> 指定的头文件会从 <code>KERNEL PATH</code> 中找，<strong>并不是在编译工具链中搜索</strong></p>
<pre><code class="shell">../4.0.0/include &gt; fd string.h
asm-generic/string.h
linux/string.h
linux/string_helpers.h
linux/ucs2_string.h
uapi/linux/netfilter/xt_string.h
uapi/linux/string.h</code></pre>
<p>因此需要添加 <code>#include &lt;linux/string.h&gt;</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>modules</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 重定向</title>
    <url>/2018/11/07/shell-redirect/</url>
    <content><![CDATA[<p><code>shell</code> 输出重定向 <code>&amp;&gt;</code> 与 <code>2&gt;&amp;1</code></p>
<a id="more"></a>

<p>man page</p>
<pre><code>  Redirecting Standard Output and Standard Error
      This  construct allows both the standard output (file descriptor 1) and
      the standard error output (file descriptor 2) to be redirected  to  the
      file whose name is the expansion of word.

      There  are  two  formats  for  redirecting standard output and standard
      error:

             &amp;&gt;word
      and
             &gt;&amp;word

      Of the two forms, the first is preferred.  This is semantically equiva‐
      lent to

             &gt;word 2&gt;&amp;1</code></pre><ul>
<li><code>&gt;</code> Syntax: <code>file_descriptoropt &gt; file_name</code></li>
<li><code>&gt;&amp;</code> Syntax: <code>file_descriptoropt &gt;&amp; file_descriptor</code></li>
<li><code>&amp;&gt;</code> Syntax: <code>&amp;&gt; file_name</code></li>
</ul>
<p>If the file descriptor is omitted, the default is 0 (stdin) for input, or 1 (stdout) for output.  2 means stderr.</p>
<ul>
<li><code>&gt;name</code> means <code>1&gt;name</code> – redirect stdout to the file name</li>
<li><code>&amp;&gt;name</code> means <code>1&gt;name 2&gt;name</code> – redirect stdout and stderr to the file name</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>udhcpc -t 20 -T 1 -n -q -i &quot;$dev&quot; &amp;&gt; &quot;logs&quot;</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://unix.stackexchange.com/questions/170572/what-is-in-a-shell-script" target="_blank" rel="noopener">What is &amp;&gt;&gt; in a shell script [duplicate]</a></li>
<li><a href="https://stackoverflow.com/questions/24793069/what-does-do-in-bash" target="_blank" rel="noopener">What does &amp;&gt; do in bash? </a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>redirect</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核 4.9 无法挂载文件系统</title>
    <url>/2018/11/07/Linux-Kernel-4-9-Unable-to-mount-root-fs/</url>
    <content><![CDATA[<p>Linux 内核 4.9 启动时发现无法挂载文件系统，检查 <code>Documentation/Changes</code> 中的 <code>Current Minimal Requirements</code></p>
<a id="more"></a>

<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><pre><code>[    1.351872] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(31,4)
[    1.360234] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.9.y #1
[    1.366069] Hardware name: nationalchip sirius
[    1.370557] [&lt;c010f2c4&gt;] (unwind_backtrace) from [&lt;c010b868&gt;] (show_stack+0x10/0x14)
[    1.378319] [&lt;c010b868&gt;] (show_stack) from [&lt;c0393da4&gt;] (dump_stack+0x94/0xa8)
[    1.385558] [&lt;c0393da4&gt;] (dump_stack) from [&lt;c01c796c&gt;] (panic+0xdc/0x254)
[    1.392452] [&lt;c01c796c&gt;] (panic) from [&lt;c0801254&gt;] (mount_block_root+0x248/0x294)
[    1.399951] [&lt;c0801254&gt;] (mount_block_root) from [&lt;c08014a8&gt;] (mount_root+0x11c/0x124)
[    1.407881] [&lt;c08014a8&gt;] (mount_root) from [&lt;c0801634&gt;] (prepare_namespace+0x184/0x1c8)
[    1.415898] [&lt;c0801634&gt;] (prepare_namespace) from [&lt;c0800e68&gt;] (kernel_init_freeable+0x268/0x278)
[    1.424782] [&lt;c0800e68&gt;] (kernel_init_freeable) from [&lt;c05cce60&gt;] (kernel_init+0x8/0x114)
[    1.432974] [&lt;c05cce60&gt;] (kernel_init) from [&lt;c0107678&gt;] (ret_from_fork+0x14/0x3c)
[    1.440556] CPU0: stopping
[    1.443276] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.9.y #1</code></pre><h2 id="Minimal-Requirements"><a href="#Minimal-Requirements" class="headerlink" title="Minimal Requirements"></a>Minimal Requirements</h2><pre><code class="txt">====================== ===============  ========================================
        Program        Minimal version       Command to check the version
====================== ===============  ========================================
GNU C                  3.2              gcc --version
GNU make               3.80             make --version
binutils               2.12             ld -v
util-linux             2.10o            fdformat --version
module-init-tools      0.9.10           depmod -V
e2fsprogs              1.41.4           e2fsck -V
jfsutils               1.1.3            fsck.jfs -V
reiserfsprogs          3.6.3            reiserfsck -V
xfsprogs               2.6.0            xfs_db -V
squashfs-tools         4.0              mksquashfs -version</code></pre>
<p>更新 <code>mksquashfs v4.2</code> 解决此问题</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mksquashfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核编译</title>
    <url>/2018/11/06/Linux-Kernel-Compile/</url>
    <content><![CDATA[<p><code>Linux Kernel</code> 编译常用命令</p>
<a id="more"></a>

<p>Linux Kernel Version: 4.9.22</p>
<ol>
<li><code>make mrproper</code> 主要清除环境变量及配置文件</li>
<li><code>O=/path/to/output/</code> 来指定输出文件的位置，默认放在源码位置</li>
<li><code>make -C Kernel ARCH=$ARCH CROSS_COMPILE=$COMPILER</code></li>
<li><code>make distclean</code> Remove editor backup files, patch leftover files and the like</li>
<li><code>make prepare</code> <code>make scripts</code> This will prepare some files necessary to build a kernel module</li>
<li><code>make $J -C $TARGET_DIR ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage vmlinux dtbs</code></li>
<li><code>make zImage</code> build the kernel image</li>
<li><code>make vmLinux</code> build the kernel image</li>
<li><code>make uImage</code> build the kernel image</li>
<li><code>make -j4 uImage dtbs modules</code> Compile the dtb from Linux kernel source code</li>
<li><code>make $J LOADADDR=0x00008000 uImage</code> LOADADDR specifies the address where the kernel image will be located by U-Boot and is stored in the U-Boot header by the mkimage utility.</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>make</tag>
        <tag>kbuild</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 与子进程</title>
    <url>/2018/11/05/shell-and-subshell/</url>
    <content><![CDATA[<p><code>shell</code> 与子进程 <code>subshell</code></p>
<a id="more"></a>

<h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>子进程，是从父子进程的概念出发的， <code>unix</code> 操作系统的进程从 <code>init 进程</code> 开始（ <code>init 进程</code> 为 1, 而进程号 0 为系统原始进程，以下讨论的进程原则上不包括进程 0) 均有其对应的子进程，就算是由于父进程先行结束导致的孤儿进程，也会被 <code>init</code> 领养，使其父进程 ID 为 1。</p>
<h2 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h2><p>常见的创建子进程的方式：</p>
<ul>
<li><code>&amp;</code> 提交后台作业</li>
<li><code>|</code> 管道</li>
<li><code>()</code> 括号运算</li>
<li>执行外部命令及脚本， <code>./filename</code> 或 <code>filename</code></li>
</ul>
<h2 id="不创建子进程的执行方式"><a href="#不创建子进程的执行方式" class="headerlink" title="不创建子进程的执行方式"></a>不创建子进程的执行方式</h2><ul>
<li><code>source filename</code></li>
<li><code>. filename</code></li>
</ul>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ol>
<li>创建子进程<pre><code class="shell">28264 root       0:00 /bin/sh -c 3g_lookup /tmp/ethernet/monitor/usb3gDev
28265 root       0:00 {3g_lookup} /bin/bash /usr/local/sbin/3g_lookup /tmp/ethernet/monitor/usb3gDev
28270 root       0:00 {exe} sleep 3</code></pre>
</li>
<li>不创建子进程<pre><code class="shell">29381 root       0:00 /bin/sh -c 3g_lookup /tmp/ethernet/monitor/usb3gDev
29382 root       0:00 {3g_lookup} /bin/bash /usr/local/sbin/3g_lookup /tmp/ethernet/monitor/usb3gDev</code></pre>
</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/lineuman/article/details/52443422" target="_blank" rel="noopener">shell 与 subshell 与执行脚本的几种方式</a></li>
<li><a href="https://www.jianshu.com/p/56716e193cd9" target="_blank" rel="noopener">shell 脚本几种执行方式的区别</a></li>
<li><a href="https://blog.csdn.net/sosodream/article/details/5683515" target="_blank" rel="noopener">实例解析 shell 子进程</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
        <tag>subshell</tag>
      </tags>
  </entry>
  <entry>
    <title>在 NFS 环境下使能网络</title>
    <url>/2018/11/05/nfs-with-network/</url>
    <content><![CDATA[<p>挂载网络文件系统的同时可以使用 <code>eth0</code> 访问网络</p>
<a id="more"></a>

<p>当使用 <code>nfs</code> 时访问外部网络时会出现 <code>Network is unreachable</code></p>
<p>需要添加路由表</p>
<pre><code>route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.110.1</code></pre><p>或添加默认路由表</p>
<pre><code>route add default gw 192.168.110.1 dev eth0</code></pre><p>之后，可以访问 <code>ip 地址</code>，但是仍然不能访问网站，需要添加 <code>nameserver</code></p>
<pre><code>echo &#39;nameserver 192.168.110.1&#39; &gt; /etc/resolv.conf</code></pre><p>经过上述两步修改之后，可以正常访问外部网络</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>linux</tag>
        <tag>nfs</tag>
        <tag>route</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark 基础知识</title>
    <url>/2018/10/31/wireshark-basic-knowledge/</url>
    <content><![CDATA[<p><code>Wireshark 数据包分析实战详解</code> 第一章读书笔记</p>
<a id="more"></a>

<h2 id="wireshark-作用"><a href="#wireshark-作用" class="headerlink" title="wireshark 作用"></a>wireshark 作用</h2><p><code>Wireshark</code> 是一个开源的广受欢迎的网络数据包分析软件，使用 <code>Wireshark</code> 可以快速分析一些任务</p>
<ol>
<li><strong>一般分析任务</strong><ul>
<li>找出在一个网络内的发送数据包最多的主机</li>
<li>查看网络通信</li>
<li>查看某个主机使用了哪些程序</li>
<li>了解基本正常的网络通</li>
<li>验证特有的网络操作</li>
<li>了解尝试连接无线网络的用户</li>
<li>同时捕获多个网络的数据</li>
<li>实施无人值守数据捕获</li>
<li>捕获并分析到 / 来自一个特定主机或子网的数据</li>
<li>通过 FTP 或 HTTP 查看和重新配置文件传输</li>
<li>从其它捕获工具导入跟踪文件</li>
<li>使用最少的资源捕获数据</li>
</ul>
</li>
<li><strong>故障任务</strong><ul>
<li>为故障创建一个自定义的分析环境</li>
<li>确定路径、客户端和服务延迟</li>
<li>确定 TCP 问题</li>
<li>检查 HTTP 代理问题</li>
<li>检查应用程序错误响应</li>
<li>通过查看图形显示的结果，找出相关的网络问题</li>
<li>确定重载的缓冲区</li>
<li>比较缓慢的通信到正常通信的一个基准</li>
<li>找出重复的 IP 地址</li>
<li>确定 DHCP 服务或网络代理问题</li>
<li>确定 WLAN 信号强度问题</li>
<li>检测 WLAN 连接的次数</li>
<li>检查各种网络配置错误</li>
<li>确定应用程序正在加载一个网络片段</li>
</ul>
</li>
<li><strong>安全分析（网络取证）任务</strong><ul>
<li>为网络取证创建一个自定义分析环境</li>
<li>检查使用非标准端口的应用程序</li>
<li>确定到 / 来自可疑主机的数据</li>
<li>查看哪台主机正在尝试获取一个 IP 地址</li>
<li>确定 <code>phone home</code> 数据</li>
<li>确定网络侦查过程</li>
<li>全球定位和映射远程目标地址</li>
<li>检查可疑数据重定向</li>
<li>检查单个 TCP 或 UDP 客户端和服务器之间的会话</li>
<li>检查到恶意畸形的帧</li>
<li>在网络数据中找出攻击签名的关键因素</li>
</ul>
</li>
<li><strong>应用程序分析任务</strong><ul>
<li>了解应用程序和协议如何工作</li>
<li>图形应用程序的带宽使用情况</li>
<li>确定是否将支持应用程序的链接</li>
<li>更新 / 升级后检查应用程序性能</li>
<li>从一个新安装的应用程序中检查错误响应</li>
<li>确定哪个用户正在运行一个特定的应用程序</li>
<li>检查应用程序如何使用传输协议，如 TCP 或 UDP</li>
</ul>
</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell">$ sudo apt-get install wireshark</code></pre>
<p><strong>也可以下载源码手动编译安装</strong></p>
<h2 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h2><p><code>Wireshark</code> 为了捕获数据依赖于网络适配器和网卡驱动</p>
<h2 id="认识数据包"><a href="#认识数据包" class="headerlink" title="认识数据包"></a>认识数据包</h2><p>数据包分为 <code>帧</code>、 <code>包</code> 和 <code>段</code></p>
<p>例如 <code>tcp</code> 数据层次如下</p>
<pre><code class="tcp">Frame 77: 54 bytes on wire (432 bits), 54 bytes captured (432 bits) on interface 0
    Interface id: 0 (eth0)
    Encapsulation type: Ethernet (1)
    Arrival Time: Oct 31, 2018 09:24:06.106787573 CST
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1540949046.106787573 seconds
    [Time delta from previous captured frame: 0.000031648 seconds]
    [Time delta from previous displayed frame: 0.000031648 seconds]
    [Time since reference or first frame: 0.098032168 seconds]
    Frame Number: 77
    Frame Length: 54 bytes (432 bits)
    Capture Length: 54 bytes (432 bits)
    [Frame is marked: False]
    [Frame is ignored: False]
    [Protocols in frame: eth:ethertype:ip:tcp]
    [Coloring Rule Name: TCP]
    [Coloring Rule String: tcp]
Ethernet II, Src: LcfcHefe_62:89:b1 (28:d2:44:62:89:b1), Dst: Intel_e0:e2:eb (00:90:27:e0:e2:eb)
    Destination: Intel_e0:e2:eb (00:90:27:e0:e2:eb)
        Address: Intel_e0:e2:eb (00:90:27:e0:e2:eb)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Source: LcfcHefe_62:89:b1 (28:d2:44:62:89:b1)
        Address: LcfcHefe_62:89:b1 (28:d2:44:62:89:b1)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IPv4 (0x0800)
Internet Protocol Version 4, Src: 192.168.110.55, Dst: 183.134.92.103
    0100 .... = Version: 4
    .... 0101 = Header Length: 20 bytes (5)
    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)
    Total Length: 40
    Identification: 0x83d5 (33749)
    Flags: 0x02 (Don&#39;t Fragment)
    Fragment offset: 0
    Time to live: 64
    Protocol: TCP (6)
    Header checksum: 0x742d [validation disabled]
    [Header checksum status: Unverified]
    Source: 192.168.110.55
    Destination: 183.134.92.103
    [Source GeoIP: Unknown]
    [Destination GeoIP: China, AS4134 No.31,Jin-rong Street, China, AS4134 No.31,Jin-rong Street, 28.179199, 113.113602]
Transmission Control Protocol, Src Port: 35720, Dst Port: 443, Seq: 1, Ack: 54021, Len: 0
    Source Port: 35720
    Destination Port: 443
    [Stream index: 0]
    [TCP Segment Len: 0]
    Sequence number: 1    (relative sequence number)
    Acknowledgment number: 54021    (relative ack number)
    0101 .... = Header Length: 20 bytes (5)
    Flags: 0x010 (ACK)
    Window size value: 2786
    [Calculated window size: 2786]
    [Window size scaling factor: -1 (unknown)]
    Checksum: 0x42e8 [unverified]
    [Checksum Status: Unverified]
    Urgent pointer: 0
    [SEQ/ACK analysis]</code></pre>
<ul>
<li>物理层数据帧 Frame 77: 54 bytes on wire (432 bits), 54 bytes captured (432 bits) on interface 0</li>
<li>数据链路层以太网帧头部信息 Ethernet II, Src: LcfcHefe_62:89:b1 (28:d2:44:62:89:b1), Dst: Intel_e0:e2:eb (00:90:27:e0:e2:eb)</li>
<li>互联网层 IP 包头信息 Internet Protocol Version 4, Src: 192.168.110.55, Dst: 183.134.92.103</li>
<li>传输层数据段头信息 Transmission Control Protocol, Src Port: 35720, Dst Port: 443, Seq: 1, Ack: 54021, Len: 0</li>
</ul>
<h2 id="Wiki-Protocol-Page"><a href="#Wiki-Protocol-Page" class="headerlink" title="Wiki Protocol Page"></a>Wiki Protocol Page</h2><p>在需要看的协议上 <code>右键</code> 选择 <code>Wiki Protocol Page</code>，例如上面的 <code>Internet Protocol Version 4</code> 可以查看 <code>IPv4 协议</code></p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>在开始捕捉之前现选择 <code>Interface</code></li>
<li>使用 <code>filter</code> 过滤数据</li>
<li>打开 <code>Draw packets using you Coloring rules</code> 用于配色，可以方便找出各个协议以及出错帧</li>
<li>左下角的 <code>专家信息</code> 按键用于显示更高的信息，可以提醒用户捕捉到的网络数据包中的问题</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 搜索插件 fzf.vim</title>
    <url>/2018/10/26/vim-plugin-fzf/</url>
    <content><![CDATA[<p>文件搜索可以使用 <code>ctrlp.vim</code>、 <code>ctrlsf.vim</code> 等插件<br>搜索 <code>tags</code> 发现两个插件 <code>fzf.vim</code> 和 <code>LeaderF</code>，选择使用 <code>fzf.vim</code></p>
<a id="more"></a>

<h2 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h2><p><code>fzf</code> 是目前最快的 <code>fuzzy finder</code>。使用 <code>golang</code> 编写。结合其他工具 ( <code>比如 ag 和 fasd</code> ) 可以完成非常多的工作。 让你通过输入模糊的关键词就可以定位文件或文件夹。<br>在 <code>vim</code> 中搭配 <code>fzf.vim</code> 使用</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="vim">Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --bin&#39; }
Plug &#39;junegunn/fzf.vim&#39;</code></pre>
<p>如果不支持安装，可以在插件安装之后手动完成 <code>fzf</code> 安装</p>
<pre><code class="shell">$ cd ~/.vim/bundle/fzf
$ ./install --bin</code></pre>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code class="vim">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
&quot; FZF
&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
if isdirectory(expand(&quot;~/.vim/bundle/fzf/&quot;))
    let g:fzf_command_prefix = &#39;Fzf&#39;

    &quot; This is the default extra key bindings
    let g:fzf_action = {
                \ &#39;ctrl-t&#39;: &#39;tab split&#39;,
                \ &#39;ctrl-x&#39;: &#39;split&#39;,
                \ &#39;ctrl-v&#39;: &#39;vsplit&#39; }

    &quot; Default fzf layout
    &quot; - down / up / left / right
    let g:fzf_layout = { &#39;down&#39;: &#39;~40%&#39; }

    &quot; Customize fzf colors to match your color scheme
    let g:fzf_colors =
                \ { &#39;fg&#39;:      [&#39;fg&#39;, &#39;Normal&#39;],
                \ &#39;bg&#39;:      [&#39;bg&#39;, &#39;Normal&#39;],
                \ &#39;hl&#39;:      [&#39;fg&#39;, &#39;Comment&#39;],
                \ &#39;fg+&#39;:     [&#39;fg&#39;, &#39;CursorLine&#39;, &#39;CursorColumn&#39;, &#39;Normal&#39;],
                \ &#39;bg+&#39;:     [&#39;bg&#39;, &#39;CursorLine&#39;, &#39;CursorColumn&#39;],
                \ &#39;hl+&#39;:     [&#39;fg&#39;, &#39;Statement&#39;],
                \ &#39;info&#39;:    [&#39;fg&#39;, &#39;PreProc&#39;],
                \ &#39;border&#39;:  [&#39;fg&#39;, &#39;Ignore&#39;],
                \ &#39;prompt&#39;:  [&#39;fg&#39;, &#39;Conditional&#39;],
                \ &#39;pointer&#39;: [&#39;fg&#39;, &#39;Exception&#39;],
                \ &#39;marker&#39;:  [&#39;fg&#39;, &#39;Keyword&#39;],
                \ &#39;spinner&#39;: [&#39;fg&#39;, &#39;Label&#39;],
                \ &#39;header&#39;:  [&#39;fg&#39;, &#39;Comment&#39;] }

    &quot; Enable per-command history.
    &quot; CTRL-N and CTRL-P will be automatically bound to next-history and
    &quot; previous-history instead of down and up. If you don&#39;t like the change,
    &quot; explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
    let g:fzf_history_dir = &#39;~/.local/share/fzf-history&#39;

    function! s:fzf_statusline()
        &quot; Override statusline as you like
        highlight fzf1 ctermfg=161 ctermbg=251
        highlight fzf2 ctermfg=23 ctermbg=251
        highlight fzf3 ctermfg=237 ctermbg=251
        setlocal statusline=%#fzf1#\ &gt;\ %#fzf2#fz%#fzf3#f
    endfunction

    autocmd! User FzfStatusLine call &lt;SID&gt;fzf_statusline()

    nnoremap &lt;leader&gt;&lt;leader&gt;x :FzfTags&lt;cr&gt;
endif</code></pre>
<p>设置 <code>let g:fzf_command_prefix = &#39;Fzf&#39;</code> 之后，可以使用 <code>FzfTags</code> 来搜索 <code>tags</code>、 <code>FzfFiles</code> 来搜索文件等</p>
<h2 id="搜索语法"><a href="#搜索语法" class="headerlink" title="搜索语法"></a>搜索语法</h2><p><code>fzf</code> 默认会以 <code>extened-search</code> 模式启动， 这种模式下你可以输入多个以空格分隔的搜索关键词， 如 <code>^music .mp3$, sbtrkt !fire.</code></p>
<ul>
<li><code>sbtrkt</code>     fuzzy-match    匹配 sbtrkt</li>
<li><code>^music</code>     prefix-exact-match    以 music 开头</li>
<li><code>.mp3$</code>     suffix-exact-match    以.mp3 结尾</li>
<li><code>&#39;wild</code>     exact-match(quoted)    精确包含 wild</li>
<li><code>!fire</code>     inverse-exact-match    不包含 fire</li>
<li><code>!.mp3$</code>     inverse-suffix-exact-match    不以.mp3 结尾</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><code>Ctrl-J/Ctrl-K/Up/Down</code> 可以用来将光标上下移动</li>
<li><code>Enter</code> 键用来选中条目， <code>Ctrl-C/Ctrl-G/Esc</code> 用来退出</li>
<li>在多选模式下 <code>（-m)</code> , <code>TAB</code> 和 <code>Shift-TAB</code> 用来多选</li>
<li><code>Mouse</code> : 上下滚动， 选中， 双击； <code>Shift-click</code> 或 <code>shift-scoll</code> 用于多选模式</li>
</ul>
<h2 id="有哪些工具可以方便的和-FZF-一起使用"><a href="#有哪些工具可以方便的和-FZF-一起使用" class="headerlink" title="有哪些工具可以方便的和 FZF 一起使用"></a>有哪些工具可以方便的和 FZF 一起使用</h2><ul>
<li>Find （目录搜索）</li>
<li>Grep （文本搜索）</li>
<li>Ag （文本搜索）</li>
<li>fd （目录搜索）</li>
<li>ripgrep （文本搜索）</li>
</ul>
<p>后两个是最新出的两个搜索方面的新秀，应该是目前速度最快的。</p>
<h2 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h2><p><a href="https://github.com/junegunn/fzf#respecting-gitignore-hgignore-and-svnignore" target="_blank" rel="noopener">Respecting .gitignore</a></p>
<pre><code class="zshrc">export FZF_DEFAULT_COMMAND=&quot;fd --type f --exclude &#39;*.a&#39; --exclude &#39;*.bmp&#39; --exclude &#39;*.png&#39;&quot;</code></pre>
<p>使用命令 <code>FZF_DEFAULT_COMMAND</code> 来完成一些文件的排除</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/junegunn/fzf#as-vim-plugin" target="_blank" rel="noopener">fzf</a></li>
<li><a href="https://github.com/junegunn/fzf.vim" target="_blank" rel="noopener">fzf.vim</a></li>
<li><a href="https://segmentfault.com/a/1190000011328080" target="_blank" rel="noopener">模糊搜索神器 fzf</a></li>
<li><a href="https://segmentfault.com/a/1190000016186043" target="_blank" rel="noopener">模糊搜索神器 FZF 番外篇</a></li>
<li><a href="https://segmentfault.com/a/1190000016186540" target="_blank" rel="noopener">FZF and VIM</a></li>
<li><a href="https://www.jianshu.com/p/bb91582317ed" target="_blank" rel="noopener">在 Vim 中使用 fzf</a></li>
<li><a href="https://github.com/junegunn/fzf.vim/issues/514" target="_blank" rel="noopener">how do I exclude files from fzf leader-t command? </a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>fzf</tag>
      </tags>
  </entry>
  <entry>
    <title>线程条件变量</title>
    <url>/2018/10/26/pthread-cond/</url>
    <content><![CDATA[<p><strong>线程条件变量与互斥锁不同，条件变量是用来等待而不是用来上锁的。</strong><br><strong>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</strong></p>
<a id="more"></a>

<a href="/2014/11/11/Linux-system-programming-pthread_cont/" title="Linux系统编程-多线程同步条件变量">Linux系统编程-多线程同步条件变量</a>

<h2 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a>pthread_cond_wait</h2><p><code>pthread_cond_wait</code> 用于阻塞当前线程，等待别的线程使用 <code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code> 来唤醒它。 <code>pthread_cond_wait</code> 必须与 <code>pthread_mutex</code> 配套使用。<br><code>pthread_cond_wait</code> 一进入 <code>wait 状态</code> 就会 <code>自动 release mutex</code>。当其他线程通过 <code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code>，把该线程唤醒，使 <code>pthread_cond_wait</code> 返回时，该线程又 <code>自动获得该 mutex</code>。</p>
<h2 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a>pthread_cond_signal</h2><p><code>pthread_cond_signal</code> 函数的作用是发送一个信号给另外一个正在处于阻塞等待状态的线程，使其脱离阻塞状态，继续执行. 如果没有线程处在阻塞等待状态， <code>pthread_cond_signal</code> 也会成功返回。<br>假如有多个线程正在阻塞等待着这个条件变量的话，那么是根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。如果各线程优先级相同，则根据等待时间的长短来确定哪个线程获得信号。但无论如何一个 <code>pthread_cond_signal</code> 最多发信一次。</p>
<h2 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast"></a>pthread_cond_broadcast</h2><p><code>pthread_cond_broadcast</code> 唤醒全部线程</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html" target="_blank" rel="noopener">通用线程：POSIX 线程详解，第 3 部分</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>pthread</tag>
        <tag>cond</tag>
      </tags>
  </entry>
  <entry>
    <title>某 HTTPS 链接无法正常播放</title>
    <url>/2018/10/22/https-url-error/</url>
    <content><![CDATA[<p>某个 <code>https</code> 无法播放，通过抓包来分析问题</p>
<a id="more"></a>

<h2 id="抓包数据"><a href="#抓包数据" class="headerlink" title="抓包数据"></a>抓包数据</h2><p><a href="https://blog.csdn.net/u010726042/article/details/53408077" target="_blank" rel="noopener">https（ssl）协议以及 wireshark 抓包分析与解密</a></p>
<p><strong>ClientHello</strong></p>
<p><img src="/images/http/client.png" alt="ClientHello"></p>
<p><strong>ServerHello</strong></p>
<p><img src="/images/http/server.png" alt="ServerHello"></p>
<p>从 <code>ServerHello</code> 可以看到服务器使用 <code>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</code> 加密套件</p>
<h2 id="加密套件"><a href="#加密套件" class="headerlink" title="加密套件"></a>加密套件</h2><p><a href="https://blog.csdn.net/mrpre/article/details/77868633" target="_blank" rel="noopener">TLS/SSL 协议详解 (20) 加密套件的选择</a></p>
<ol>
<li>服务器选择算法时有两种优先级：客户端优先或服务器优先。客户端优先是根据客户端提供的加密套件，从上到下，看是否有本地支持的；服务器优先是根据自身配置的加密套件顺序，一个个在 <code>client hello</code> 中找</li>
<li>服务器配置 <code>ECC 证书</code> 时，加密套件只能选择 <code>XXX_ECDSA_XXX</code> 或者 <code>ECDH_XXX</code></li>
<li>服务器配置 <code>RSA 证书</code> 时，只能选择 <code>RSA_XXX</code> 或者 <code>ECDHE_RSA_XXX</code> 形式的加密套件</li>
<li>如果加密套件选择 <code>ECDH_RSA</code> 或者 <code>ECDH_ECDSA</code> 时，由于 <code>ECDH 加密套件</code> 默认表明了握手需要 <code>ECC 证书</code>，第二部分 <code>_RSA</code> 和 <code>_ECDSA</code> 表明的是想要的服务器证书签名类型</li>
</ol>
<h2 id="wolfssl"><a href="#wolfssl" class="headerlink" title="wolfssl"></a>wolfssl</h2><p><a href="https://www.wolfssl.com/" target="_blank" rel="noopener">wolfssl</a></p>
<p>加密套件 <code>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</code></p>
<p>名词解释：</p>
<ol>
<li><code>ECDH</code> 是基于 <code>ECC</code> （Elliptic Curve Cryptosystems，椭圆曲线密码体制，参看 ECC）的 <code>DH</code> （ Diffie-Hellman）密钥交换算法</li>
<li><code>RSA</code> 是一种非对称加密算法</li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener">AES256</a></li>
<li><code>GCM</code></li>
<li><code>SHA384</code></li>
</ol>
<p>在 <code>wolfssl</code> 源码中搜索</p>
<pre><code class="shell">$ag TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
src/keys.c
739:#ifdef BUILD_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
740:    case TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 :

$ag BUILD_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
wolfssl/internal.h
486:                            #define BUILD_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</code></pre>
<p>打开文件 <code>wolfssl/internal.h</code> 可以查到 <code>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</code> 依赖于 <code>WOLFSSL_STATIC_DH</code>、 <code>WOLFSSL_SHA384</code>、 <code>HAVE_AESGCM</code> 和 <code>HAVE_ECC</code></p>
<p>定义以上几个依赖宏定义以支持相关加密套件</p>
<pre><code class="shell">$ ./autogen.sh
$ ./configure --enable-opensslextra --enable-des3 --enable-dh --enable-ecc --enable-dtls --enable-aesgcm --enable-aesccm --enable-sha512</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/xueyepiaoling/article/details/62433378" target="_blank" rel="noopener">关于 ECDSA/ECC（密钥加密传输）和 ECDSA/ECDH（密钥磋商）</a></li>
<li>[Getting started with wolfSSL`s ECC](<a href="https://www.wolfssl.com/getting-started-with-wolfssls-ecc-2/" target="_blank" rel="noopener">https://www.wolfssl.com/getting-started-with-wolfssls-ecc-2/</a>)</li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>Tools</category>
        <category>HTTP</category>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>ecc</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL/TLS 协议</title>
    <url>/2018/10/16/SSL-and-TLS/</url>
    <content><![CDATA[<p>讲述 <code>HTTP</code> 核心 <code>SSL/TLS 协议</code>，本篇从 SSL/TLS 发展历史到握手以及传输的详细过程来讲解。</p>
<a id="more"></a>

<ul>
<li><a href="/2018/10/05/encrypt-and-hash/" title="加密和哈希">加密和哈希</a></li>
<li><a href="/2018/10/15/Digital-Certificate-and-Digital-Signature/" title="数字证书与数字签名">数字证书与数字签名</a></li>
<li><a href="/2018/10/16/SSL-and-TLS/" title="SSL&#x2F;TLS 协议">SSL&#x2F;TLS 协议</a>

</li>
</ul>
<h2 id="SSL-TLS-协议"><a href="#SSL-TLS-协议" class="headerlink" title="SSL/TLS 协议"></a>SSL/TLS 协议</h2><p><code>SSL/TLS</code> 在计算机网络模型中位于 <code>传输层</code> 和 <code>应用层</code> 之间的协议，例如 <code>TCP/IP</code> 与 <code>HTTP</code> 之间，它通过 <code>握手协议 (Handshake Protocol)</code> 和 <code>传输协议 (Record Protocol)</code> 来解决传输安全的问题。</p>
<p><code>SSL</code> 是 <code>NetScape</code> 公司设计发布，更新到 <code>SSL3.0</code> 之后， <code>IETF</code> 将 <code>SSL</code> 标准化改名为 <code>TLS</code>，发布 1.0 版，最新版本为 <code>TLS 1.3</code></p>
<h2 id="SSL-TLS-运行过程"><a href="#SSL-TLS-运行过程" class="headerlink" title="SSL/TLS 运行过程"></a>SSL/TLS 运行过程</h2><p>主要有两个阶段： <code>握手</code> 和 <code>传输</code></p>
<ol>
<li><code>握手协议</code> 就是建立起连接的过程，这个阶段采用 <code>非对称加密</code>，这个过程完毕后会生成一个 <code>对话秘钥</code></li>
<li><code>传输协议</code> 过程，就是用这个 <code>对话秘钥</code> 使用 <code>对称加密</code> 进行传输</li>
<li>之所以这样做，是因为，<strong>非对称加密是很耗性能的</strong>。而握手协议过程中，使用数字证书保证了公钥的安全性。当然这个过程既可以双向证书验证，也可以只验证服务端的证书单向证书验证</li>
</ol>
<p>SSL/TLS 运行过程：<br><img src="/images/http/SSL.png" alt="SSL 运行过程"></p>
<h3 id="客户端发出请求-Client-Hello"><a href="#客户端发出请求-Client-Hello" class="headerlink" title="客户端发出请求 (Client Hello)"></a>客户端发出请求 (Client Hello)</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 <code>ClientHello 请求</code>。客户端主要向服务器提供以下信息：</p>
<ol>
<li>支持的 <code>SSL/TLS</code> 协议版本</li>
<li>支持的加密套件列表 <code>(cipher suite)</code></li>
<li>支持的压缩算法列表 <code>(compression methods)</code>，用于后续的压缩传输</li>
<li>产生的一个随机数 <code>random_C(random number)</code>，客户端有存留，稍后用于生成 <code>&quot;对话密钥 (session key)&quot;</code></li>
</ol>
<h3 id="服务端回应-Server-Hello"><a href="#服务端回应-Server-Hello" class="headerlink" title="服务端回应 (Server Hello)"></a>服务端回应 (Server Hello)</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做 <code>SeverHello</code>。服务器的回应包含以下内容：</p>
<ol>
<li>确认使用的加密通信协议版本，比如 <code>TLS 1.0 版本</code>。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信</li>
<li>确认加密套件，压缩算法</li>
<li>产生的一个随机数 <code>random_S(random number)</code>，服务端有存留，稍后用于生成 <code>&quot;对话密钥 (session key)&quot;</code></li>
<li>服务端数字证书（证明自己的身份，传递公钥）</li>
<li>如果需要验证客户端，发出请求，要求客户端提供证书</li>
</ol>
<h3 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：</p>
<ol>
<li>如果服务端有请求证书，发送自己的数字证书</li>
<li>再产生一个随机数 <code>pre-master key(random number)</code>，并且用服务端数字证书中的公钥加密，防止被窃听</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验</li>
</ol>
<p>客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把 <code>对话密钥 (session key)</code></p>
<p>为什么使用三个随机数，解释：</p>
<blockquote>
<p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于 RSA 密钥交换算法来说，pre-master-key 本身就是一个随机数，再加上 hello 消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>pre master 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre master secret 就有可能被猜出来，那么仅适用 pre master secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 pre master secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。</p>
</blockquote>
<h3 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h3><p>如果有客户端的证书，就先验证客户端的证书</p>
<p>服务器收到客户端的第三个随机数 <code>pre-master key</code> 之后，计算生成本次会话所用的 <code>对话密钥 (session key)</code>。然后，向客户端最后发送下面信息。</p>
<ol>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验</li>
</ol>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用 <code>对话密钥 (session key)</code> 加密内容。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/c93612b3abac" target="_blank" rel="noopener">HTTPS 从原理到应用（三）：SSL/TLS 协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>数字证书与数字签名</title>
    <url>/2018/10/15/Digital-Certificate-and-Digital-Signature/</url>
    <content><![CDATA[<p>使用 <code>数字证书 (Digital Certificate)</code> 与 <code>数字签名 (Digital Signature)</code> 来保证公钥</p>
<a id="more"></a>

<ul>
<li><a href="/2018/10/05/encrypt-and-hash/" title="加密和哈希">加密和哈希</a></li>
<li><a href="/2018/10/15/Digital-Certificate-and-Digital-Signature/" title="数字证书与数字签名">数字证书与数字签名</a></li>
<li><a href="/2018/10/16/SSL-and-TLS/" title="SSL&#x2F;TLS 协议">SSL&#x2F;TLS 协议</a>

</li>
</ul>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p><code>数字证书</code> 就是网络通讯中标志通讯各方身份信息的一系列数据，其作用类似于现实生活中的身份证。<strong>它是由一个权威机构发行的，人们可以在互联网上用它来识别对方的身份。</strong></p>
<p>数字证书：<br>颁发者：CA 证书授权 (Certificate Authority) 中心<br>拥有者：申请到证书的通信者<br>证明的能力：身份认证，也就是说证明我就是我</p>
<h2 id="数字证书的组成"><a href="#数字证书的组成" class="headerlink" title="数字证书的组成"></a>数字证书的组成</h2><ol>
<li><strong>Certificate（证书）</strong>：<ol>
<li>Common Name（证书所有人姓名，简称 CN，其实就是证书的名字，如第一幅图看到的：ABA.ECOMRoot….)</li>
<li>Version（版本，现在一般是 V3 了）</li>
<li>Issuer（发证机关）</li>
<li>Validity（有效日期）</li>
<li>Subject（证书信息，你会发现它和 Issuer 里面的内容是一样的）</li>
<li>Subject’s Public Key Info（证书所有人公钥，刚才所说的公钥就是这个！)</li>
<li>Extension（扩展信息）</li>
<li>Certificate Signature Algorithm（公钥加密算法）、</li>
</ol>
</li>
<li><strong>Certificate Signature Algorithm</strong>: 这是描述证书的加密算法</li>
<li><strong>Certificate Signature Value</strong>: 这记录的是证书被加密后的密文</li>
</ol>
<p><img src="/images/http/crt.jpeg" alt="证书"></p>
<h2 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h2><p>数字证书认证机构（英语：Certificate Authority，缩写为 CA），也称为电子商务认证中心、电子商务认证授权机构，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p>
<p><strong>CA 中心为每个使用公开密钥的用户发放一个数字证书，数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。CA 机构的数字签名使得攻击者不能伪造和篡改证书。</strong></p>
<p><img src="/images/http/CA.png" alt="CA 认证中心之间的关系"></p>
<p><code>CA 认证中心</code> 之间是一个树状结构， <code>根 CA 认证中心</code> 可以授权多个 <code>二级的 CA 认证中心</code>， <code>二级 CA 认证中心</code> 也可以授权多个 <code>三级的 CA 认证中心</code> … 如果你是 <code>数字证书申请人</code>，你可以向 <code>根 CA 认证中心</code>，或者 <code>二级，三级的 CA 认证中心</code> 申请数字证书，这是没有限制的，当你成功申请后，你就称为了 <code>数字证书所有人</code>。</p>
<p>值得注意的是，根 CA 认证中心是有多个的，也就是说会有多棵这样的结构树。</p>
<h2 id="权威性"><a href="#权威性" class="headerlink" title="权威性"></a>权威性</h2><p>上图中的 <code>CA 认证中心所有人</code>，他们都有一个数字证书，和属于自己的公钥和私钥，这些是他们的 <code>父 CA 认证中心</code> 颁发给他们的。 <code>根 CA 认证中心</code> 的证书称为 <code>根证书</code>，<strong>根证书自己认证自己的有效性，根证书是整个证书体系安全的根本</strong>，如果根证书出了问题，他下面所有子证书都不可被信任，因为子证书都是依赖根证书证明自己的有效性的，从而形成 <code>证书信任链</code>。</p>
<p><strong>对于私钥：CA 认证中心 / 数字证书所有人自己保存，不公开</strong><br><strong>对于公钥：CA 认证中心 / 数字证书所有人会把公钥存在他的 CA 认证中心的数字证书内</strong></p>
<h2 id="数字签名过程"><a href="#数字签名过程" class="headerlink" title="数字签名过程"></a>数字签名过程</h2><p><code>数字证书</code> 使用 <code>数字签名</code> 作验证</p>
<ol>
<li>证书内容计算 <code>hash 值</code></li>
<li>然后 <code>hash 值</code> *<em>会被发布这个数字签名的 CA 认证机构的 <code>私钥</code> 进行 <code>RSA 加密</code> *</em>，例如现在被加密的数字证书是属于 <code>二级 CA 认证机构</code> 的，那么用来加密这个证书的私钥是 <code>根 CA 认证机构的私钥</code></li>
</ol>
<h2 id="数字证书验证合法性"><a href="#数字证书验证合法性" class="headerlink" title="数字证书验证合法性"></a>数字证书验证合法性</h2><p>当你要验证这个数字证书可信 / 合法性时，</p>
<ol>
<li>找到** <code>上一层 CA 认证中心</code> 的数字证书，并且从中获取公钥**</li>
<li>对数字证书中的 <code>密文 F&#39;</code> 进行 <code>RSA 解密</code>，得到 hash 值 h1</li>
<li>计算数字证书 hash 值得到 h2</li>
<li>比较 h1 和和 h2</li>
<li>如果相等，则认为证书是可信的，合法的！</li>
</ol>
<p><strong>验证一个证书是否合法，需要验证到他的最顶层的根证书是否合法！所以上面说到根证书是整个证书体系安全的根本。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数字证书的制作使用了数字签名，每一个数字证书里面都包含了申请者的公钥。<br><code>Alice</code> 与 <code>Bob</code> 通信之前， <code>Alice</code> 不直接要 <code>Bob</code> 的公钥，而是去要一个 <code>Bob 去 CA 申请的数字证书</code>，数字证书中有 <code>Bob</code> 的公钥，而且数字证书证明了他就是 <code>Bob</code>， <code>Alice</code> 只要验证数字证书没有问题就可以开始通信了。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a></li>
<li><a href="https://www.jianshu.com/p/e767a4e9252e" target="_blank" rel="noopener">HTTPS 从原理到应用（二）：数字证书 (Digital Certificate) 与数字签名 (Digital Signature)</a></li>
<li><a href="https://www.jianshu.com/p/42bf7c4d6ab8" target="_blank" rel="noopener">什么是数字证书</a></li>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html" target="_blank" rel="noopener">浅析数字证书</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>Digital Certificate</tag>
        <tag>Digital Signature</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu apt-file 解决依赖的利器</title>
    <url>/2018/10/12/apt-file/</url>
    <content><![CDATA[<p><code>ubuntu</code> 安装软件经常遇到各种依赖以及头文件缺失，可以使用 <code>apt-file</code> 来查询</p>
<a id="more"></a>

<pre><code class="shell">$ sudo apt-get install apt-file
$ sudo apt-file update
$ sudo apt-file search libz.so.1
lib32z1: /usr/lib32/libz.so.1
lib32z1: /usr/lib32/libz.so.1.2.11
libx32z1: /usr/libx32/libz.so.1
libx32z1: /usr/libx32/libz.so.1.2.11
libzadc4: /usr/lib/x86_64-linux-gnu/genwqe/libz.so.1
zlib1g: /lib/x86_64-linux-gnu/libz.so.1
zlib1g: /lib/x86_64-linux-gnu/libz.so.1.2.11</code></pre>
<pre><code class="shell">$ sudo apt-file -a i386 update
$ sudo apt-get install libwhatever:i386</code></pre>
<p>使用命令更新</p>
<pre><code>$ sudo apt-file update
$ sudo apt-file -a i386 update</code></pre><p>搜索</p>
<pre><code>$ sudo apt-file search
$ sudo apt-file -a i386 search</code></pre><p>安装</p>
<pre><code>$ sudo apt install libxxx
$ sudo apt install libxxx:i386</code></pre><p>如何查找缺失依赖库，确认是否安装正确以及确认需要 32/64</p>
<pre><code>$ ldd /opt/4.9.4/cc1
    linux-gate.so.1 (0xf7f80000)
    libmpc.so.3 =&gt; /usr/lib/i386-linux-gnu/libmpc.so.3 (0xf7f3b000)
    libmpfr.so.4 =&gt; not found
    libgmp.so.10 =&gt; /usr/lib/i386-linux-gnu/libgmp.so.10 (0xf7eb0000)
    libdl.so.2 =&gt; /lib/i386-linux-gnu/libdl.so.2 (0xf7eab000)
    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7ccf000)
    /lib/ld-linux.so.2 (0xf7f82000)
    libmpfr.so.6 =&gt; /usr/lib/i386-linux-gnu/libmpfr.so.6 (0xf7c47000)</code></pre><p>如上最后一行只需要执行</p>
<pre><code>$ sudo ln -s /usr/lib/i386-linux-gnu/libmpfr.so.6 /usr/lib/i386-linux-gnu/libmpfr.so.4</code></pre><p>如果没有输出最后一行，执行如下命令</p>
<pre><code>$ sudo apt-file -a i386 search libmpfr.so
libmpfr-dev: /usr/lib/i386-linux-gnu/libmpfr.so
libmpfr6: /usr/lib/i386-linux-gnu/libmpfr.so.6
libmpfr6: /usr/lib/i386-linux-gnu/libmpfr.so.6.0.1

$ sudo apt install libmpfr6:i386
$ sudo ln -s /usr/lib/i386-linux-gnu/libmpfr.so.6 /usr/lib/i386-linux-gnu/libmpfr.so.4</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://unix.stackexchange.com/questions/119798/mint-correct-way-to-install-lib-i386-linux-gnu-libgmp-so-3" target="_blank" rel="noopener">Mint: correct way to install /lib/i386-linux-gnu/libgmp.so.3</a></li>
</ol>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>apt-file</tag>
      </tags>
  </entry>
  <entry>
    <title>非关系数据库、mongoDB 和 pymongo</title>
    <url>/2018/10/12/pymongo/</url>
    <content><![CDATA[<ul>
<li>SQL 与 NoSQL</li>
<li>mongoDB 安装与使用</li>
<li>mongoDB Web 管理</li>
<li>pymongo 使用</li>
</ul>
<a id="more"></a>

<p>##</p>
<h2 id="pymongo"><a href="#pymongo" class="headerlink" title="pymongo"></a>pymongo</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><pre><code class="python">import pymongo
from pymongo import IndexModel, ASCENDING

class MongoDBPipeline(object):
    def __init__(self):
        clinet = pymongo.MongoClient(&quot;localhost&quot;, 27017)
        db = clinet[&quot;Hub&quot;]
        self.PhRes = db[&quot;PhRes&quot;]
        idx = IndexModel([(&#39;link_url&#39;, ASCENDING)], unique=True)
        self.PhRes.create_indexes([idx])
        # if your existing DB has duplicate records, refer to:
        # https://stackoverflow.com/questions/35707496/remove-duplicate-in-mongodb/35711737

    def process_item(self, item, spider):
        print &#39;MongoDBItem&#39;, item
        &quot;&quot;&quot; 判断类型 存入 MongoDB &quot;&quot;&quot;
        if isinstance(item, VideoItem):
            print &#39;VideoItem True&#39;
            try:
                self.PhRes.update_one({&#39;link_url&#39;: item[&#39;link_url&#39;]}, {&#39;$set&#39;: dict(item)}, upsert=True)
            except Exception:
                pass
        return item</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.zhihu.com/question/24225007" target="_blank" rel="noopener">非关系型数据库和关系型数据库区别，优势比较？</a></li>
<li><a href="https://www.jianshu.com/p/2d2a951fe0df" target="_blank" rel="noopener">一文读懂非关系型数据库（NoSQL）</a></li>
<li><a href="https://www.jianshu.com/p/5598f1dcbb98" target="_blank" rel="noopener">Ubuntu 安装 Mongodb</a></li>
<li><a href="https://www.jianshu.com/p/79caa1cc49a5" target="_blank" rel="noopener">MongoDB 用户名密码登录</a></li>
<li><a href="https://www.jianshu.com/p/988054962433" target="_blank" rel="noopener">MongoDB 学习</a></li>
<li><a href="https://blog.csdn.net/yabingshi_tech/article/details/48159169" target="_blank" rel="noopener">Mongodb 怎样进入 web 控制台</a></li>
<li><a href="https://www.jianshu.com/p/8e0077c8fd60" target="_blank" rel="noopener">DBA 的 MongoDB 管理工具 -Robomongo</a></li>
<li><a href="https://juejin.im/post/5addbd0e518825671f2f62ee" target="_blank" rel="noopener">Python 操作 MongoDB 看这一篇就够了</a></li>
<li><a href="https://www.jianshu.com/p/6ac3f647cfcd" target="_blank" rel="noopener">pymongo 学习记录</a></li>
<li><a href="https://api.mongodb.com/python/current/" target="_blank" rel="noopener">PyMongo 3.7.2 Documentation</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pymongo</tag>
        <tag>mongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>python 面向对象编程</title>
    <url>/2018/10/10/python-OOP/</url>
    <content><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318645694388f1f10473d7f416e9291616be8367ab5000" target="_blank" rel="noopener">Python 面向对象编程和高级编程</a></p>
<a id="more"></a>

<h2 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h2><ol>
<li><p>面向对象的设计思想是抽象出 <code>Class</code>，根据 <code>Class</code> 创建 <code>Instance</code></p>
</li>
<li><p>面向对象的抽象程度又比函数要高，因为一个 <code>Class</code> 既包含数据，又包含操作数据的方法 <code>Method</code></p>
</li>
<li><p>数据封装、继承和多态是面向对象的三大特点</p>
<pre><code class="python">class Student(object):

 def __init__(self, name, score):
     self.name = name
     self.score = score

 def print_score(self):
     print(&#39;%s: %s&#39; % (self.name, self.score))</code></pre>
</li>
</ol>
<h3 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h3><ol>
<li>面向对象最重要的概念就是类 <code>Class</code> 和实例 <code>Instance</code></li>
<li>类是抽象的模板</li>
<li>实例是根据类创建出来的一个个具体的 <code>对象</code></li>
<li>定义类是通过 <code>class</code> 关键字<pre><code class="python">class Student(object):
 pass</code></pre>
<blockquote>
<p><code>class</code> 后面紧接着是类名，即 <code>Student</code>，类名通常是大写开头的单词，紧接着是 <code>(object)</code>，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用 <code>object</code> 类，这是所有类最终都会继承的类</p>
</blockquote>
</li>
<li>创建实例是通过 <code>类名 +()</code> 实现的<pre><code class="python">bart = Student()</code></pre>
</li>
<li>通过方法 <code>__init__</code> 绑定一些属性<pre><code class="python">def __init__(self, name, score):
 self.name = name
 self.score = score</code></pre>
</li>
<li>创建实例的时候，必须传入与 <code>__init__方法</code> 匹配的参数，但 self 不需要传<pre><code class="python">bart = Student(&#39;Bart Simpson&#39;, 59)</code></pre>
</li>
</ol>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><ol>
<li>属性名前加上 <code>__</code> 将属性编程私有变量，只有内部可以访问，外部不能访问<blockquote>
<p>有些时候会看到以一个下划线开头的实例变量名，比如 <code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，<strong>虽然我可以被访问，但是，请把我视为私有变量，不要随意访问</strong></p>
</blockquote>
</li>
</ol>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><ol>
<li>从某个现有的 <code>class</code> 继承，新的 <code>class</code> 称为子类 <code>Subclass</code>，而被继承的 <code>class</code> 称为基类、父类或超类 <code>Base class、Super class</code>，继承使子类获得了父类的全部功能</li>
<li>当子类和父类都存在相同的方法时，子类的方法覆盖了父类的方法，在代码运行的时候，总是会调用子类的方法。即：多态</li>
<li>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</li>
</ol>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000" target="_blank" rel="noopener">多态示例</a></p>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><ol>
<li>基本类型都可以用 <code>type()</code> 判断</li>
<li><code>class</code> 类型使用 <code>isinstance()</code> 判断</li>
</ol>
<h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><ol>
<li>实例和类都可以绑定属性</li>
<li>实例绑定的属性只有这个实例可以访问</li>
<li>类绑定的属性，所有实例都可以访问</li>
<li>如果实例与类绑定的属性名一样，类属性会将实例属性覆盖掉<pre><code class="python">&gt;&gt;&gt; class Student(object):
...     name = &#39;Student&#39;
...
&gt;&gt;&gt; s = Student() # 创建实例 s
&gt;&gt;&gt; print(s.name) # 打印 name 属性，因为实例并没有 name 属性，所以会继续查找 class 的 name 属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的 name 属性
Student
&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定 name 属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的 name 属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用 Student.name 仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的 name 属性
&gt;&gt;&gt; print(s.name) # 再次调用 s.name，由于实例的 name 属性没有找到，类的 name 属性就显示出来了
Student</code></pre>
</li>
</ol>
<h2 id="面对对象高级编程"><a href="#面对对象高级编程" class="headerlink" title="面对对象高级编程"></a>面对对象高级编程</h2><h3 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用 __slots__"></a>使用 <code>__slots__</code></h3><p><code>python</code> 作为动态语言可以动态对实例或类添加属性或方法，为了限制这种特性，可以使用 <code>__slots__</code></p>
<pre><code class="python">class Student(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用 tuple 定义允许绑定的属性名称</code></pre>
<p>使用 <code>__slots__</code> 要注意， <code>__slots__</code> 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<pre><code class="python">&gt;&gt;&gt; class GraduateStudent(Student):
...     pass
...
&gt;&gt;&gt; g = GraduateStudent()
&gt;&gt;&gt; g.score = 9999</code></pre>
<p>除非在子类中也定义 <code>__slots__</code>，这样，子类实例允许定义的属性就是自身的 <code>__slots__</code> 加上父类的 <code>__slots__</code></p>
<h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用 @property"></a>使用 <code>@property</code></h3><p><code>python</code> 内置的 <code>@property</code> 装饰器把一个方法变成属性调用的：</p>
<pre><code class="python">class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value</code></pre>
<p>可以定义只读属性</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如， <code>Ostrich</code> 继承自 <code>Bird</code>。但是，如果需要 <code>混入</code> 额外的功能，通过多重继承就可以实现，比如，让 <code>Ostrich</code> 除了继承自 <code>Bird</code> 外，再同时继承 <code>Runnable</code>。这种设计通常称之为 <code>MixIn</code>。</p>
<pre><code class="python">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
<h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p><code>python</code> 提供 <code>Enum</code> 来定义枚举类</p>
<pre><code class="python">from enum import Enum

Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))

for name, member in Month.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)</code></pre>
<p><code>value</code> 属性则是自动赋给成员的 <code>int</code> 常量，默认从 <code>1</code> 开始计数</p>
<p>如果需要更精确地控制枚举类型，可以从 <code>Enum</code> 派生出自定义类：</p>
<pre><code class="python">from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun 的 value 被设定为 0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6</code></pre>
<p><code>@unique</code> 装饰器可以帮助我们检查保证没有重复值</p>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>python 模块</title>
    <url>/2018/10/10/python-module/</url>
    <content><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318447437605e90206e261744c08630a836851f5183000" target="_blank" rel="noopener">python 模块</a></p>
<a id="more"></a>

<ol>
<li>一个 <code>python</code> 文件就是一个模块 <code>Module</code></li>
<li>为了避免模块名重名问题，因此包 <code>Package</code>，按照目录来组织管理 <code>Module</code></li>
<li>每一个 <code>Package</code> 目录下必须存在一个 <code>__init__.py</code> 文件，可以是空文件。否则会被视为普通目录</li>
<li><code>__init__.py</code> 也是 <code>Module</code>，模块名为目录名<pre><code class="shell">mycompany
├─ web
│  ├─ __init__.py
│  ├─ utils.py
│  └─ www.py
├─ __init__.py
├─ abc.py
└─ xyz.py</code></pre>
<code>web</code> 和 <code>mycompany</code> 均为 <code>Package</code>， <code>.py</code> 均为 <code>Module</code><br>文件 <code>www.py</code> 模块名为 <code>mycompany.web.www</code> , <code>abc.py</code> 模块名为 <code>mycompany.abc</code></li>
<li><code>__xxx__</code> 这类变量是特殊变量，例如 <code>__name__</code>、 <code>__author__</code></li>
<li><code>_xxx</code> 或 <code>__xxx</code> 这样的函数或变量就是非公开的（private），不应该被直接引用</li>
<li>特殊变量 <code>__name__</code> , 当在命令行运行此模块时，Python 解释器会将 <code>__name__</code> 置为 <code>__main__</code> , 如果在其他地方导入模块时， <code>__name__</code> 不为 <code>__main__</code><pre><code class="shell">if __name__==&#39;__main__&#39;:
 test()</code></pre>
<blockquote>
<p>这种 if 测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>自动生成和安装 requirements.txt 依赖</title>
    <url>/2018/10/09/python-auto-generate-requirements/</url>
    <content><![CDATA[<p>使用 <code>requirements.txt</code> 来管理 python 工程依赖包</p>
<a id="more"></a>

<p>有两种方式可以生成 <code>requirements.txt</code></p>
<ul>
<li><code>pip freeze &gt; requirements.txt</code></li>
<li><code>pipreqs .</code></li>
</ul>
<h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>遇到错误</p>
<pre><code class="shell">$ pip
Traceback (most recent call last):
  File &quot;/usr/local/bin/pip&quot;, line 7, in &lt;module&gt;
    from pip import main
ImportError: cannot import name main</code></pre>
<p>将 <code>pip</code> 内容修改为</p>
<pre><code class="python">from pip import __main__
if __name__ == &#39;__main__&#39;:
    sys.exit(__main__._main())</code></pre>
<p>使用 <code>pip freeze &gt; requirements.txt</code> 需要搭配 <code>virtualenv</code> 来使用，否则会将整个环境中的包都列出来</p>
<p>应该在使用 <code>virtualenv</code> 建立虚拟环境中的文件夹中使用</p>
<h2 id="pipreqs"><a href="#pipreqs" class="headerlink" title="pipreqs"></a>pipreqs</h2><p>可以通过对项目目录的扫描，自动发现使用了那些类库，自动生成依赖清单</p>
<pre><code class="shell">$ pip install pipreqs
$ pipreqs ./</code></pre>
<p>可以在指定目录生成 <code>requirements.txt</code></p>
<h2 id="使用-requirements-txt"><a href="#使用-requirements-txt" class="headerlink" title="使用 requirements.txt"></a>使用 <code>requirements.txt</code></h2><pre><code class="shell">$ pip install -r requirements.txt</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
        <tag>requirements.txt</tag>
      </tags>
  </entry>
  <entry>
    <title>pyenv-and-pyenv-virtualenv</title>
    <url>/2018/10/08/pyenv-and-pyenv-virtualenv/</url>
    <content><![CDATA[<p>使用 <code>pyenv</code> 和 <code>pyenv-virtualenv</code> 来管理 <code>python</code> 版本</p>
<p><a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">pyenv</a> 是个 <code>shell</code> 脚本，能够轻松得实现各个不同版本 <code>python</code> 的相互间切换，而且各个版本的 <code>python</code> 切换不限于全局切换，甚至不同文件夹都可以拥有不同的 <code>python</code> 版本。</p>
<p><a href="https://github.com/pyenv/pyenv-virtualenv" target="_blank" rel="noopener">pyenv-virtualenv</a> 是 <code>pyenv</code> 的插件，为 <code>pyenv</code> 设置的 <code>python</code> 版本提供隔离的虚拟环境，设置虚拟环境后，在这个目录下面安装的第三方库及修改库搜索路径都不会影响其他环境，相当于一个沙盒环境，互相不影响。</p>
<a id="more"></a>

<h2 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h2><ul>
<li>进行全局的 Python 版本切换</li>
<li>为单个项目提供对应的 Python 版本</li>
<li>只依赖 Python 本身</li>
<li>能够进行 virtualenv 管理</li>
<li>提供下载不同的 Python 版本和衍生版本</li>
</ul>
<p>使用 <code>pyenv --help</code> 查看具体命令</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>确定你想把 <code>pyenv</code> 安装在哪。推荐安装在 <code>$HOME/.pyenv</code>，但你也可以安装在任意位置</p>
<pre><code class="shell">$ git clone https://github.com/pyenv/pyenv.git ~/.pyenv</code></pre>
</li>
<li><p>定义你 <code>PYENV_ROOT</code> 的环境变量来指定你把 <code>pyenv</code> 仓库克隆到了哪，并把 <code>$PYENV_ROOT/bin</code> 添加到你的 <code>$PATH</code> 中，这样就能在命令行使用 <code>pyenv</code> 命令</p>
<pre><code class="shell">$ echo &#39;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#39; &gt;&gt; ~/.zshrc
$ echo &#39;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc</code></pre>
</li>
<li><p>设置启动 shell 时自动加载 <code>pyenv</code> 脚本。在 shell 配置文件的最后面加上 <code>eval &quot;$(pyenv init -)&quot;</code></p>
<pre><code class="shell">$ echo &#39;eval &quot;$(pyenv init -)&quot;&#39; &gt;&gt; ~/.zshrc</code></pre>
</li>
<li><p>重启 shell，使脚本生效</p>
<pre><code class="shell">$ exec &quot;$SHELL&quot;</code></pre>
</li>
<li><p>安装不同的 <code>python</code> 版本到 <code>$(pyenv root)/versions</code> 文件夹<br>在 <code>pyenv</code> 安装之前的所有 <code>python</code> 版本都归为 <code>system</code> 版本。可以用 <code>pyenv versions</code> 查看当前安装的 <code>python</code> 版本）。<br>在安装 <code>python</code> 之前，可以使用 <code>pyenv install -l</code> 查看当前可以安装哪些 <code>python</code> 版本。<br>然后使用 <code>pyenv install 选择的版本</code> 来安装你所选择的 <code>python</code> 版本。比如 <code>pyenv install 3.6.1</code> 安装 <code>python</code> 官网的版本。</p>
</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li><code>pyenv versions</code> 查看当前已安装的 python 版本</li>
<li><code>pyenv install ...</code> 安装指定版本的 python</li>
<li><code>pyenv global python 版本</code> 切换全局 python 版本</li>
<li><code>pyenv local python 版本</code> 切换当前文件夹下的 python 版本</li>
<li><code>pyenv shell python 版本</code> 切换当前 shell 中的 python 版本</li>
<li><code>pyenv version</code> 查看当前使用的 python 版本</li>
</ul>
<h3 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h3><p><code>pyenv install</code> 命令在安装的时候是下载源代码到本地编译安装的，所以需要安装相关的开发库及依赖包</p>
<p><a href="https://github.com/pyenv/pyenv/wiki" target="_blank" rel="noopener">pyenv wiki</a></p>
<pre><code class="shell">$ sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \
libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \
xz-utils tk-dev libffi-dev liblzma-dev
$ sudo apt install libedit-dev</code></pre>
<p>安装指定版本</p>
<pre><code class="shell">$ pyenv install 2.7.14
Downloading Python-2.7.14.tar.xz...
-&gt; https://www.python.org/ftp/python/2.7.14/Python-2.7.14.tar.xz
error: failed to download Python-2.7.14.tar.xz

BUILD FAILED (Ubuntu 17.10 using python-build 1.2.7-7-g21c75c19)</code></pre>
<p>解决方法</p>
<p><a href="https://github.com/pyenv/pyenv/issues/303" target="_blank" rel="noopener">pyenv install fails at download stage</a></p>
<pre><code class="shell">$ cat /tmp/python-build.20181008151222.32112.log
/tmp/python-build.20181008151222.32112 ~/.pyenv
curl: (1) Protocol &quot;https&quot; not supported or disabled in libcurl

$ wget https://curl.haxx.se/download/curl-7.61.1.tar.gz
$ tar xf curl-7.61.1.tar.gz
$ cd curl-7.61.1
$ ./configure --with-ssl &amp; make &amp; sudo make install
$ curl --version
curl 7.61.1 (x86_64-pc-linux-gnu) libcurl/7.61.1 OpenSSL/1.0.2g zlib/1.2.11
Release-Date: 2018-09-05
Protocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp
Features: AsynchDNS IPv6 Largefile NTLM NTLM_WB SSL libz TLS-SRP UnixSockets HTTPS-proxy</code></pre>
<p>安装完成之后需要刷新数据库</p>
<pre><code class="shell">pyenv rehash</code></pre>
<p>安装 <code>python2</code> 和 <code>python3</code></p>
<pre><code class="shell">$ pyenv install -l
$ pyenv install 2.7.14
$ pyenv install 3.6.6
$ pyenv versions
* system (set by /home/yanwzh/.pyenv/version)
  2.7.14
  3.6.6</code></pre>
<h3 id="卸载指定版本"><a href="#卸载指定版本" class="headerlink" title="卸载指定版本"></a>卸载指定版本</h3><pre><code class="shell">pyenv uninstall x.x.x</code></pre>
<h3 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h3><ul>
<li>全局版本切换 <code>pyenv global 2.7.14</code></li>
<li>局部版本切换 <code>pyenv local 3.6.6</code> #在某目录下执行，只在该目录下生效</li>
<li>取消当前设置的版本使用 <code>pyenv local --unset</code></li>
</ul>
<p>例如设置指定文件夹为 <code>3.6.6</code></p>
<pre><code class="shell">$ mkdir 3.6.6
$ pyenv local
pyenv: no local version configured for this directory
$ pyenv local 3.6.6
$ pyenv local
3.6.6
$ python
Python 3.6.6 (default, Oct  8 2018, 15:46:38)
[GCC 7.2.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
$ cd ..
$ python
Python 2.7.14 (default, Sep 23 2017, 22:06:14)
[GCC 7.2.0] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
$ cd -
$ pyenv local --unset
$ python
Python 2.7.14 (default, Sep 23 2017, 22:06:14)
[GCC 7.2.0] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;</code></pre>
<h3 id="更新-pyenv"><a href="#更新-pyenv" class="headerlink" title="更新 pyenv"></a>更新 pyenv</h3><pre><code class="shell">$ cd $(pyenv root)
$ git pull</code></pre>
<h3 id="卸载-pyenv"><a href="#卸载-pyenv" class="headerlink" title="卸载 pyenv"></a>卸载 pyenv</h3><ol>
<li>禁用 <code>pyenv</code> , 把 <code>pyenv init</code> 从 shell 的配置文件中移除，然后重启 shell （移除后 <code>pyenv</code> 命令仍然能使用，但是版本切换命令不会生效）</li>
<li>卸载 <code>pyenv</code> , 执行上一步，然后把 <code>pyenv</code> 的根目录删除即可</li>
</ol>
<h2 id="pyenv-virtualenv"><a href="#pyenv-virtualenv" class="headerlink" title="pyenv-virtualenv"></a>pyenv-virtualenv</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol>
<li>需要将 <code>pyenv-virtualenv</code> 克隆到 <code>pyenv</code> 的 <code>plugin</code> 文件夹下<pre><code class="shell">$ git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</code></pre>
</li>
<li>(OPTIONAL) 添加 <code>pyenv virtualenv-init</code> 到你的 <code>shell</code> 配置文件中，这样进入指定文件夹自动进入虚拟环境，离开文件夹退出虚拟环境<pre><code class="shell">$ echo &#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39; &gt;&gt; ~/.zshrc</code></pre>
</li>
<li><code>exec &quot;$SHELL&quot;</code></li>
</ol>
<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><ul>
<li><code>pyenv virtualenv x.x.x name</code></li>
</ul>
<p>如果不指定版本 <code>x.x.x</code> , 则默认使用当前 <code>pyenv version</code> 的 python 版本</p>
<p>创建的虚拟环境位于 <code>$(pyenv root)/versions/</code> 下的指定 python 版本的文件夹中 <code>envs/</code> 文件夹下</p>
<h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><h4 id="自动激活"><a href="#自动激活" class="headerlink" title="自动激活"></a>自动激活</h4><ol>
<li>在 <code>.zshrc</code> 添加 <code>eval &quot;$(pyenv virtualenv-init -)&quot;</code>，然后 <code>exec &quot;$SHELL&quot;</code> 重启 shell</li>
<li>在想要激活虚拟环境的文件夹中新建 <code>.python-version</code> 文件，并写入虚拟环境的名字</li>
<li>以后进入该的文件夹就会自动激活虚拟环境，离开该文件夹就会退出虚拟环境。</li>
</ol>
<h4 id="手动激活"><a href="#手动激活" class="headerlink" title="手动激活"></a>手动激活</h4><ul>
<li><code>pyenv activate name</code> 激活虚拟环境。</li>
<li><code>pyenv deactivate</code> 退出虚拟环境</li>
</ul>
<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><ol>
<li>删除 <code>$(pyenv root)/versions</code> 和 <code>$(pyenv root)/versions/{version}/envs</code> 的相关文件夹即可</li>
<li>命令行运行 <code>pyenv uninstall name</code></li>
</ol>
<h3 id="列出现有-virtualenvs"><a href="#列出现有-virtualenvs" class="headerlink" title="列出现有 virtualenvs"></a>列出现有 virtualenvs</h3><pre><code class="shell">$ pyenv virtualenvs
  3.6.6/envs/P-env-3.6.6 (created from ~/.pyenv/versions/3.6.6)
* P-env-3.6.6 (created from ~/.pyenv/versions/3.6.6)</code></pre>
<p>每个 <code>virtualenv</code> 有两个条目，较短的一个只是一个符号链接</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><pre><code class="shell">$ pyenv virtualenv 3.6.6 P-env-3.6.6
$ mkdir 3.6.6
$ cd 3.6.6
$ touch .python-version
$ echo P-env-3.6.6 &gt; .python-version
$ pyenv local
P-env-3.6.6</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/5e00ca8a10d5" target="_blank" rel="noopener">pyenv 及 pyenv-virtualenv 安装</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000" target="_blank" rel="noopener">virtualenv</a></li>
<li><a href="http://www.airghc.top/2017/01/17/haha/" target="_blank" rel="noopener">Linux 下多版本 python 共存</a></li>
<li><a href="https://www.jianshu.com/p/526a9ff5a43d" target="_blank" rel="noopener">Python 版本控制神器</a></li>
<li><a href="https://www.jianshu.com/p/60f361822a7e" target="_blank" rel="noopener">Python 版本管理</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyenv</tag>
        <tag>pyenv-virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS 加密算法与 CA 证书签名算法</title>
    <url>/2018/10/06/https-encrypt-and-ca/</url>
    <content><![CDATA[<p>加密算法和签名算法</p>
<a id="more"></a>

<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>性能高，密钥泄露风险高</p>
<p>常用的算法：DES、3DES、AES、Blowfish、IDEA、RC5、RC6</p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>计算量大，需要消耗大量的系统资源，性能低。知道公钥，也无法计算出来密钥</p>
<p>常用的算法：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>加密是为了保护传输数据</p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名是为了校验身份以及验证信息的内容是否被篡改</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://imququ.com/post/ecc-certificate.html" target="_blank" rel="noopener">开始使用 ECC 证书</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33195438" target="_blank" rel="noopener">数字签名算法介绍和区别</a></li>
<li><a href="https://www.jianshu.com/p/67bcb140d804" target="_blank" rel="noopener">HTTPS 原理 - 内容加密</a></li>
<li><a href="https://juejin.im/post/5b38dc2de51d455eff37ec5f" target="_blank" rel="noopener">HTTPS 详解 - 加密算法</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
        <category>Security</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>tls</tag>
        <tag>ca</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>加密和哈希</title>
    <url>/2018/10/05/encrypt-and-hash/</url>
    <content><![CDATA[<p>安全相关概念： <code>加密 Encrypt</code> 与 <code>哈希 Hash</code></p>
<a id="more"></a>

<ul>
<li><a href="/2018/10/05/encrypt-and-hash/" title="加密和哈希">加密和哈希</a></li>
<li><a href="/2018/10/15/Digital-Certificate-and-Digital-Signature/" title="数字证书与数字签名">数字证书与数字签名</a></li>
<li><a href="/2018/10/16/SSL-and-TLS/" title="SSL&#x2F;TLS 协议">SSL&#x2F;TLS 协议</a>

</li>
</ul>
<h2 id="Encrypt"><a href="#Encrypt" class="headerlink" title="Encrypt"></a>Encrypt</h2><ul>
<li>加密的概念：简单来说就是一组含有 <code>参数 k</code> 的 <code>变换 E</code>。 <code>信息 m</code> 通过 <code>变换 E</code> 得到 <code>c = E(m)</code>。原始信息 m 为 <code>明文</code>，通过变换得到的信息 c 为 <code>密文</code>。从明文得到密文的过程叫做 <code>加密</code>， <code>变换 E</code> 为 <code>加密算法</code>， <code>参数 k</code> 称作 <code>秘钥</code>。同一个加密算法，可以取不同的密钥，得出不同的加密结果。从 <code>密文 c</code> 恢复 <code>明文 m</code> 的过程称作 <code>解密</code>， <code>解密算法 D</code> 是 <code>加密算法 E</code> 的逆运算。解密算法也有参数，称作解密算法的秘钥。</li>
<li>加密的方式： <code>私钥密码 - 对称加密</code> 和 <code>公钥密码 - 非对称加密</code></li>
</ul>
<h3 id="私钥密码"><a href="#私钥密码" class="headerlink" title="私钥密码"></a>私钥密码</h3><p>又称<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">对称密钥加密</a><br>这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。<br>私钥加密的秘钥是对称的，只要知道加密秘钥就能推出解密秘钥（所以称为 <code>对称加密</code> )。</p>
<p>常见的对称加密算法有： <code>DES</code>、 <code>3DES</code>、 <code>AES</code>、 <code>Blowfish</code>、 <code>IDEA</code>、 <code>RC5</code> 和 <code>RC6</code></p>
<h3 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>这种密码是非对称的，也就是说，<strong>不能从加密密钥推算出解密密钥</strong>，所以又称之为 <code>非对称加密</code>。加密密钥不需要保密，可以公开，称之为 <code>公钥</code>，只需要保守解密秘钥称之为 <code>私钥</code>。公钥和私钥是成对的。常见的非对称加密算法有： <code>RSA</code>、 <code>Elgamal</code>、 <code>背包算法</code>、 <code>Rabin</code>、 <code>D-H</code>、 <code>ECC</code>。</p>
<h4 id="加密和认证"><a href="#加密和认证" class="headerlink" title="加密和认证"></a>加密和认证</h4><ul>
<li><code>加密</code> 是保证数据的安全性</li>
<li><code>认证</code> 是确保用户的真实性。只有通信双方确定是真正要通信的双方，通信才有进行下去的必要</li>
</ul>
<h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><ol>
<li><code>Bob</code> 将他的公钥传送给 <code>Alice</code></li>
<li><code>Alice</code> 用 <code>Bob</code> 的公钥加密她的消息，然后传送给 <code>Bob</code></li>
<li><code>Bob</code> 用他的私钥解密 <code>Alice</code> 的消息</li>
</ol>
<p>** <code>Alice</code> 使用 <code>Bob</code> 的公钥进行加密， <code>Bob</code> 用自己的私钥进行解密**</p>
<h4 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h4><p><code>Alice</code> 有一对公私钥， <code>Alice</code> 想让 <code>Bob</code> 知道自己是真实的 <code>Alice</code>，而不是假冒的，整个身份认证的过程如下：</p>
<ol>
<li><code>Alice</code> 用她的私钥对文件加密，从而对 <code>文件签名</code></li>
<li><code>Alice</code> 将签名的文件传送给 <code>Bob</code></li>
<li><code>Bob</code> 用 <code>Alice</code> 的公钥解密文件，从而 <code>验证签名</code></li>
</ol>
<p>** <code>Alice</code> 使用自己的私钥加密， <code>Bob</code> 用 <code>Alice</code> 的公钥进行解密**</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>如何保证 <code>公钥</code> 的安全</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/images/http/encrypt.png" alt="两种加密方式对比"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><code>哈希 (Hash)</code> 是将目标文本转换成具有 <code>相同长度</code> 的、 <code>不可逆</code> 的杂凑字符串（或叫做 <code>消息摘要</code> )，而 <code>加密 (Encrypt)</code> 是将目标文本转换成具有 <code>不同长度</code> 的、 <code>可逆</code> 的 <code>密文</code>。</p>
<p>两者有如下重要区别：</p>
<ol>
<li>哈希算法往往被设计成生成具有相同长度的文本，而加密算法生成的文本长度与明文本身的长度有关</li>
<li>哈希算法是不可逆的，而加密算法是可逆的</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/2542c95fb023" target="_blank" rel="noopener">HTTPS 从原理到应用（一）：加密 (Encrypt) 与哈希 (Hash)</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>encrypt</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>strncpy 与 strlcpy</title>
    <url>/2018/09/26/strncpy-and-strlcpy/</url>
    <content><![CDATA[<p><code>strcpy</code> 函数遇到非标准字符串有溢出的风险，因此需要使用安全函数 <code>strncpy</code> 或 <code>strlcpy</code></p>
<p>使用非标准函数 <code>strlcpy</code> 替换标准函数 <code>strncpy</code> 来提升字符串拷贝的效率。</p>
<a id="more"></a>

<h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h2><p><code>strncpy</code> 为 <code>ANSI C</code> 标准函数，实现为</p>
<pre><code class="c">#include &lt;string.h&gt;

char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);</code></pre>
<p>但是 <code>strncpy</code> 不符合使用字符串使用习惯，不保证结尾为 <code>\0</code></p>
<ol>
<li>当 <code>src</code> 大于 <code>dest</code> 时，没有 <code>\0</code></li>
<li>当 <code>src</code> 小于 <code>dest</code> 时，剩余空间都会填 <code>\0</code>，存在效率问题</li>
</ol>
<p><code>strncpy</code> 标准用法</p>
<pre><code class="c">strncpy(buf, str, buflen - 1);
if (buflen &gt; 0)
    buf[buflen - 1]= &#39;\0&#39;;</code></pre>
<h2 id="strlcpy"><a href="#strlcpy" class="headerlink" title="strlcpy"></a>strlcpy</h2><p><code>strlcpy</code> 并不属于 <code>ANSI C</code>，至今也还不是标准。</p>
<p><code>strlcpy</code> 来源于 <code>OpenBSD 2.4</code>，之后很多 <code>unix-like</code> 系统的 <code>libc</code> 中都加入了 <code>strlcpy</code> 函数</p>
<pre><code class="c">// Copy src to string dst of size siz. At most siz-1 characters
// will be copied. Always NUL terminates (unless siz == 0).
// Returns strlen(src); if retval &gt;= siz, truncation occurred.

size_t strlcpy(char *dst, const char *src, size_t siz);</code></pre>
<p>使用 <code>strlcpy</code> 不用去手动负责 /0 了，仅需要把 sizeof(dst) 告之 strlcpy 即可</p>
<pre><code class="c">strlcpy(path, src, sizeof(path));
len = strlen(path);
if (len &gt;= sizeof(path))
    printf(&quot;src is truncated.&quot;);</code></pre>
<p>并且 <code>strlcpy</code> 传回的是 <code>strlen(str)</code>，因此我们也很方便的可以判断数据是否被截断</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Device-Tree</title>
    <url>/2018/09/20/Linux-Device-Tree/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/21cnbao/article/details/8457546" target="_blank" rel="noopener">ARM Linux 3.x 的设备树</a></li>
<li><a href="https://blog.csdn.net/Klaus_Wei/article/details/42915545" target="_blank" rel="noopener">设备树历史最详解</a></li>
<li><a href="https://elinux.org/Device_Tree_Usage" target="_blank" rel="noopener">Device Tree Usage</a></li>
<li><a href="https://wiki.phytec.com/pages/viewpage.action?pageId=69501647" target="_blank" rel="noopener">linux kernel device tree modify guide</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>device tree, DT</tag>
        <tag>device tree source, DTS</tag>
        <tag>device tree compiler, DTC</tag>
      </tags>
  </entry>
  <entry>
    <title>iwpriv 命令</title>
    <url>/2018/09/19/iwpriv/</url>
    <content><![CDATA[<p><code>iwpriv</code> 工具通过 <code>ioctl</code> 动态获取相应无线网卡驱动的 <code>private_args</code> 所有扩展参数</p>
<a id="more"></a>

<p><code>iwpriv</code> -&gt; <code>main</code> -&gt; <code>set_private</code> -&gt; <code>iw_get_priv_info</code> -&gt; <code>iw_get_ext(skfd, ifname, SIOCGIWPRIV, &amp;wrq)</code> -&gt; <code>ioctl</code></p>
<p><code>wifi 驱动</code> 中 <code>NETIF/os/linux/sta_ioctl.c</code></p>
<pre><code class="c">case SIOCGIWPRIV:
    if (wrqin-&gt;u.data.pointer)
    {
        if ( access_ok(VERIFY_WRITE, wrqin-&gt;u.data.pointer, sizeof(privtab)) != TRUE)
            break;
        if ((sizeof(privtab) / sizeof(privtab[0])) &lt;= wrq-&gt;u.data.length)
        {
            wrqin-&gt;u.data.length = sizeof(privtab) / sizeof(privtab[0]);
            if (copy_to_user(wrqin-&gt;u.data.pointer, privtab, sizeof(privtab)))
                Status = -EFAULT;
        }
        else
            Status = -E2BIG;
    }
    break;</code></pre>
<p>其中 <code>privtab</code> 及为支持列表</p>
<pre><code class="c">struct iw_priv_args privtab[] = {
{ RTPRIV_IOCTL_SET,
  IW_PRIV_TYPE_CHAR | 1024, 0,
  &quot;set&quot;},

{ RTPRIV_IOCTL_SHOW, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK,
  &quot;&quot;},
/* --- sub-ioctls definitions --- */
#ifdef MAT_SUPPORT
    { SHOW_IPV4_MAT_INFO,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;ipv4_matinfo&quot; },
    { SHOW_IPV6_MAT_INFO,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;ipv6_matinfo&quot; },
    { SHOW_ETH_CLONE_MAC,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;cloneMAC&quot; },
#endif /* MAT_SUPPORT */
    { SHOW_CONN_STATUS,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;connStatus&quot; },
    { SHOW_DRVIER_VERION,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;driverVer&quot; },
    { SHOW_BA_INFO,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;bainfo&quot; },
    { SHOW_DESC_INFO,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;descinfo&quot; },
    { RAIO_OFF,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;radio_off&quot; },
    { RAIO_ON,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;radio_on&quot; },
#ifdef QOS_DLS_SUPPORT
    { SHOW_DLS_ENTRY_INFO,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;dlsentryinfo&quot; },
#endif /* QOS_DLS_SUPPORT */
    { SHOW_CFG_VALUE,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;show&quot; },
    { SHOW_ADHOC_ENTRY_INFO,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;adhocEntry&quot; },
#ifdef DOT11Z_TDLS_SUPPORT
    { SHOW_TDLS_ENTRY_INFO,
      IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;tdlsentryinfo&quot; },
#endif /* DOT11Z_TDLS_SUPPORT */
    {SHOW_DEV_INFO,
    IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;devinfo&quot;},
    {SHOW_STA_INFO,
    IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, &quot;stainfo&quot;},
/* --- sub-ioctls relations --- */

#ifdef DBG
{ RTPRIV_IOCTL_BBP,
  IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK,
  &quot;bbp&quot;},
{ RTPRIV_IOCTL_MAC,
  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
  &quot;mac&quot;},
#if defined(RLT_RF) || defined(RTMP_RF_RW_SUPPORT)
{ RTPRIV_IOCTL_RF,
  IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK,
  &quot;rf&quot;},
#endif /* RTMP_RF_RW_SUPPORT */
{ RTPRIV_IOCTL_E2P,
  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
  &quot;e2p&quot;},
#endif  /* DBG */

{ RTPRIV_IOCTL_STATISTICS,
  0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK,
  &quot;stat&quot;},
{ RTPRIV_IOCTL_GSITESURVEY,
  0, IW_PRIV_TYPE_CHAR | 1024,
  &quot;get_site_survey&quot;},

#ifdef WSC_STA_SUPPORT
{ RTPRIV_IOCTL_SET_WSC_PROFILE_U32_ITEM,
  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, &quot;&quot; },
{ RTPRIV_IOCTL_SET_WSC_PROFILE_U32_ITEM,
  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, &quot;&quot; },
{ RTPRIV_IOCTL_SET_WSC_PROFILE_STRING_ITEM,
  IW_PRIV_TYPE_CHAR | 128, 0, &quot;&quot; },
/* --- sub-ioctls definitions --- */
    { WSC_CREDENTIAL_COUNT,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, &quot;wsc_cred_count&quot; },
    { WSC_CREDENTIAL_SSID,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_cred_ssid&quot; },
    { WSC_CREDENTIAL_AUTH_MODE,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_cred_auth&quot; },
    { WSC_CREDENTIAL_ENCR_TYPE,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_cred_encr&quot; },
    { WSC_CREDENTIAL_KEY_INDEX,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_cred_keyIdx&quot; },
    { WSC_CREDENTIAL_KEY,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_cred_key&quot; },
    { WSC_CREDENTIAL_MAC,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_cred_mac&quot; },
    { WSC_SET_DRIVER_CONNECT_BY_CREDENTIAL_IDX,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, &quot;wsc_conn_by_idx&quot; },
    { WSC_SET_DRIVER_AUTO_CONNECT,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, &quot;wsc_auto_conn&quot; },
    { WSC_SET_CONF_MODE,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, &quot;wsc_conf_mode&quot; },
    { WSC_SET_MODE,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, &quot;wsc_mode&quot; },
    { WSC_SET_PIN,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_pin&quot; },
    { WSC_SET_SSID,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_ssid&quot; },
    { WSC_SET_BSSID,
      IW_PRIV_TYPE_CHAR | 128, 0, &quot;wsc_bssid&quot; },
    { WSC_START,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, &quot;wsc_start&quot; },
    { WSC_STOP,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, &quot;wsc_stop&quot; },
    { WSC_GEN_PIN_CODE,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, &quot;wsc_gen_pincode&quot; },
    { WSC_AP_BAND,
      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, &quot;wsc_ap_band&quot; },
/* --- sub-ioctls relations --- */
#endif /* WSC_STA_SUPPORT */
};</code></pre>
<p>另外内核相关</p>
<pre><code>const struct iw_handler_def rt28xx_iw_handler_def =
{
#define    N(a)    (sizeof (a) / sizeof (a[0]))
    .standard    = (iw_handler *) rt_handler,
    .num_standard    = sizeof(rt_handler) / sizeof(iw_handler),
    .private    = (iw_handler *) rt_priv_handlers,
    .num_private        = N(rt_priv_handlers),
    .private_args    = (struct iw_priv_args *) privtab,
    .num_private_args    = N(privtab),
#if IW_HANDLER_VERSION &gt;= 7
    .get_wireless_stats = rt28xx_get_wireless_stats,
#endif
};</code></pre><p>在打开设备时会进行注册 <code>rt28xx_open</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>iwpriv</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>how-to-handle-sigsegv-and-generate-coredump</title>
    <url>/2018/09/07/how-to-handle-sigsegv-and-generate-coredump/</url>
    <content><![CDATA[<p>捕捉信号 <code>SIGSEGV</code> 的同时也可以生成 <code>coredump</code> 文件</p>
<a id="more"></a>

<p>当完成 <code>Linux Kernel</code> 设置之后，捕捉到 <code>SIGSEGV</code> 之后会在相应目录生成 <code>coredump</code> 文件</p>
<p>如果对 <code>SIGSEGV</code> 注册了信号函数，有可能导致 <code>coredump</code> 不能生成，需要修改函数如下</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

void sighandler(int signum)
{
    printf(&quot;Process %d got signal %d\n&quot;, getpid(), signum);
    signal(signum, SIG_DFL);
    kill(getpid(), signum);
}

int main()
{
    signal(SIGSEGV, sighandler);
    printf(&quot;Process %d waits for someone to send it SIGSEGV\n&quot;, getpid());
    sleep(1000);
    return 0;
}</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>coredump</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Coredump 调试</title>
    <url>/2018/09/06/linux-core-dump/</url>
    <content><![CDATA[<p><code>Coredump</code> 叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里。</p>
<p>该文件也是二进制文件，可以使用 <code>gdb</code>、 <code>elfdump</code>、 <code>objdump</code> 或者 <code>windows</code> 下的 <code>windebug</code>、 <code>solaris</code> 下的 <code>mdb</code> 进行打开分析里面的具体内容。</p>
<a id="more"></a>

<h2 id="Enable-Coredump"><a href="#Enable-Coredump" class="headerlink" title="Enable Coredump"></a>Enable Coredump</h2><ul>
<li><code>Linux Kernel Config</code> 需要使能 <code>General setup</code> -&gt; <code>configure standard kernel features</code> -&gt; <code>Enable ELF core dumps</code></li>
<li>修改 <code>ulimit -c</code>，在文件 <code>/etc/profile</code> 添加 <code>ulimit -c 1073741824</code></li>
<li>在文件 <code>etc/sysctl.conf</code> 添加 <code>coredump</code> 文件储存位置，必须为可读写分区<pre><code>kernel.core_pattern = /var/core/core_%e_%p
kernel.core_uses_pid = 0</code></pre></li>
<li>创建目录 <code>mkdir -p /var/core</code></li>
</ul>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><pre><code class="c">    char *pStr = &quot;test_content&quot;;
    free(pStr);</code></pre>
<p>添加如上测试代码，程序运行之后产生错误，在 <code>/var/core</code> 下生成文件</p>
<pre><code class="shell">[ /]# ll /var/core/
total 1808
-rw-------    1 root     root      30576640 Jul 28 05:24 core_GuiViewConsoleS_879
[ /]#cp /var/core/core_GuiViewConsoleS_879 /media/sda1;sync</code></pre>
<p>将 <code>coredump</code> 文件复制到 <code>PC</code></p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>修改 <code>.gdbinit</code> 如下</p>
<pre><code>#target remote 192.168.110.56:1245
set print pretty on
handle SIGPIPE nostop
handle SIGUSR1 nostop</code></pre><p>开始调试</p>
<pre><code class="shell">✔ $ &gt; csky-linux-gdb output/out.elf /media/sda1/core_GuiViewConsoleS_879

warning: A handler for the OS ABI &quot;GNU/Linux&quot; is not built into this configuration
of GDB.  Attempting to continue with the default csky settings.

GNU gdb (C-SKY Tools V2.8.01-gx-sp9(UClibc), ABIV1) 7.2 (built on Jul 24 2017)
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;--host=i686-pc-linux-gnu --target=csky-linux&quot;.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
/home/xx/.gdbinit:1: Error in sourced command file:
proxy server broken, please check your server.
connect to host jtag://127.0.0.1:1025 failure.


warning: A handler for the OS ABI &quot;GNU/Linux&quot; is not built into this configuration
of GDB.  Attempting to continue with the default csky settings.

Reading symbols from /home/xx/workspace/Solution-for-debug/base/solution/output/out.elf...done.

warning: A handler for the OS ABI &quot;GNU/Linux&quot; is not built into this configuration
of GDB.  Attempting to continue with the default csky settings.


warning: exec file is newer than core file.
[New Thread 1008]
[New Thread 1007]
[New Thread 985]
[New Thread 990]
[New Thread 992]
[New Thread 993]
[New Thread 939]
[New Thread 995]
[New Thread 997]
[New Thread 996]
[New Thread 999]
[New Thread 991]
[New Thread 998]
[New Thread 879]
[New Thread 1000]
[New Thread 1001]
[New Thread 1002]
[New Thread 1005]
[New Thread 1006]
[New Thread 1009]
[New Thread 1010]
[New Thread 1011]
[New Thread 1012]
[New Thread 984]
[New Thread 1013]
[New Thread 1014]
[New Thread 994]
Core was generated by `/dvb/out.elf&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0x0068d9fa in free ()
(cskygdb) bt
#0  0x0068d9fa in free ()
#1  0x0005ed42 in app_init () at app.c:385
#2  0x0034f078 in GxGuiViewServiceConsole ()
#3  0x00335ae0 in sched_console_thread ()
#4  0x0043a4d8 in default_thread_function (arg=0x9c2140) at os/linux/osapi.c:441
#5  0x0044cfe4 in ?? ()
(cskygdb)</code></pre>
<p>如果没有相关调试信息，需要确认 <code>makefile</code> 中打开 <code>-O0 -g</code></p>
<h2 id="coredump-产生的几种可能情况"><a href="#coredump-产生的几种可能情况" class="headerlink" title="coredump 产生的几种可能情况"></a>coredump 产生的几种可能情况</h2><ul>
<li>内存访问越界</li>
<li>使用 strcpy, strcat, sprintf, strcmp,strcasecmp 等字符串操作函数，将目标字符串读 / 写爆。应该使用 strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp 等函数防止读写越界</li>
<li>多线程程序使用了线程不安全的函数</li>
<li>多线程读写的数据未加锁保护</li>
<li>非法指针</li>
<li>堆栈溢出</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/tenfyguo/article/details/8159176" target="_blank" rel="noopener">详解 coredump</a></li>
<li><a href="https://blog.csdn.net/u014403008/article/details/54174109" target="_blank" rel="noopener">gdb 调试 coredump</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>coredump</tag>
        <tag>segment default</tag>
      </tags>
  </entry>
  <entry>
    <title>静态库链接选项</title>
    <url>/2018/09/05/gnu-ld-options-static-lib/</url>
    <content><![CDATA[<p>本文介绍两对 <code>ld</code> 选项</p>
<ul>
<li>–whole-archive</li>
<li>–no-whole-archive</li>
<li>–start-group</li>
<li>–end-group</li>
</ul>
<a id="more"></a>

<p>这四个都是链接器的选项，所以在编译的时候要用 <code>-Wl,[options]</code> 来传递给链接器，不然编译器会不认得这个选项。</p>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><ul>
<li>–whole-archive</li>
<li>–no-whole-archive</li>
</ul>
<p>参数 <code>--whole-archive</code> 来告诉链接器，将后面库中所有符号都链接进来，参数 <code>-no-whole-archive</code> 则是重置，以避免后面库的所有符号被链接进来。</p>
<pre><code class="makefile">g++ -Wl,--whole-archive -L. -la -Wl,--no-whole-archive main.cpp -o main</code></pre>
<p>将 liba.a 中的所有.o 中的符号都链接进来</p>
<h2 id="II"><a href="#II" class="headerlink" title="II"></a>II</h2><ul>
<li>–start-group</li>
<li>–end-group</li>
</ul>
<blockquote>
<p>The archives should be a list of archive files. They may be either explicit file names, or -l options.</p>
</blockquote>
<p>The specified archives are searched repeatedly until no new undefined references are created. Normally, an archive is searched only once in the order that it is specified on the command line. If a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an archive that appears later on the command line, the linker would not be able to resolve that reference. By grouping the archives, they all be searched repeatedly until all possible references are resolved.</p>
<p>Using this option has a significant performance cost. It is best to use it only when there are unavoidable circular references between two or more archives</p>
<p><code>ld</code> 可能会遇到 <code>循环链接</code>，这样就需要使用 <code>--start-group</code> 和 <code>--end-group</code> 反复在 <code>group</code> 中进行搜索直到所有的未定义字符都被找到为止，而不是默认的只搜索一次。</p>
]]></content>
      <categories>
        <category>C</category>
        <category>Linker</category>
      </categories>
      <tags>
        <tag>ld</tag>
        <tag>--whole-archive</tag>
        <tag>--start-group</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins 权限控制</title>
    <url>/2018/09/05/jenkins-permissions/</url>
    <content><![CDATA[<p><code>Jenkins</code> 本身权限管理比较粗放，无法实现用户指定显示视图或者视图中指定的 jobs。可以通过插件 <code>Role Strategy Plugin</code> 实现不同用户组显示对应视图 views 中不同的 jobs。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>插件名 <code>Role Strategy Plugin</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="策略选择"><a href="#策略选择" class="headerlink" title="策略选择"></a>策略选择</h3><p><code>系统管理</code> -&gt; <code>Configure Global Security</code> -&gt; <code>策略授权选择</code> -&gt; <code>Role-Based Strategy</code></p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><code>系统管理</code> -&gt; <code>Manage and Assign Roles</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.51cto.com/wzlinux/2160778" target="_blank" rel="noopener">Jenkins 配置基于角色的项目权限管理</a></li>
<li><a href="https://my.oschina.net/boltwu/blog/404893" target="_blank" rel="noopener">jenkins 权限管理，实现不同用户组显示对应视图 views 中不同的 jobs</a></li>
<li><a href="https://yq.aliyun.com/articles/611227" target="_blank" rel="noopener">JENKINS 针对不同项目组对用户进行权限分配</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>jenkins</tag>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 配置信息变更历史</title>
    <url>/2018/09/03/jenkins-job-configuration-history/</url>
    <content><![CDATA[<p>使用 Jenkins 插件 <code>Job Configuration History</code> 能够对配置文件的变更进行跟踪管理，将极大的提高系统的可用性。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>Jenkins</code> -&gt; <code>Plugin Manager</code> -&gt; <code>Job Configuration History</code></p>
<h2 id="Job-Configuration-History"><a href="#Job-Configuration-History" class="headerlink" title="Job Configuration History"></a>Job Configuration History</h2><p>安装完成后，主页的菜单项中已经添加了 <code>Job Config History</code> 菜单</p>
<p>可以通过不同的选项过滤 <code>系统配置</code>、 <code>Job 配置</code>、 <code>创建 Job 的配置</code> 以及 <code>删除 Job 的配置</code> 的历史记录。</p>
<p>在不同的版本之间，可以使用 <code>Show Diffs</code> 来查看区别</p>
<p>对于 Job Config，Job Configuration History 插件提供的另一个有用功能是在 Build 的历史记录中显示配置文件的变化记录：</p>
<p><img src="/images/jenkins/job-configuration-history.png" alt="Job Config"></p>
<p>从上图中我们可以清楚的看到具体某次 Build 时配置文件发生了变化，点击小图标还能看到配置文件变化的具体内容</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 配置邮件通知</title>
    <url>/2018/08/24/jenkins-and-email/</url>
    <content><![CDATA[<p>配置 <code>Jenkins</code> 邮件用于通知构建结果</p>
<ul>
<li>Jenkins 内置邮件</li>
<li>插件 <code>Email Extension Plugin</code></li>
</ul>
<a id="more"></a>

<h2 id="Jenkins-设置"><a href="#Jenkins-设置" class="headerlink" title="Jenkins 设置"></a>Jenkins 设置</h2><p><code>Configure System</code> -&gt; <code>Jenkins Location</code> -&gt; <code>System Admin e-mail address</code> 必须要填</p>
<p>然后 <code>E-mail Notification</code> 需要正确填写</p>
<ul>
<li><code>SMTP server</code></li>
<li>勾选 <code>Use SMTP Authentication</code></li>
<li><code>User Name</code></li>
<li><code>Password</code></li>
</ul>
<p>然后填写一个测试邮箱进行测试，以下信息说明邮箱信息出错</p>
<pre><code>com.sun.mail.smtp.SMTPAddressFailedException: 550 5.1.1 &lt;ok&gt;: Recipient address rejected: User unknown in local recipient table</code></pre><h2 id="Email-Extension-Plugin"><a href="#Email-Extension-Plugin" class="headerlink" title="Email Extension Plugin"></a>Email Extension Plugin</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p><code>Configure System</code> -&gt; <code>Extended E-mail Notification</code></p>
<ul>
<li><code>SMTP server</code></li>
<li>勾选 <code>Use SMTP Authentication</code></li>
<li><code>User Name</code></li>
<li><code>Password</code></li>
<li><code>Default Content Type</code> 选择为 <code>HTML</code></li>
<li><code>Default Recipients</code> 增加默认接收邮箱</li>
<li><code>Default Subject</code> 设置为 <code>构建通知：$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS!  Default Content!</code></li>
<li><code>Default Content</code></li>
</ul>
<pre><code>（本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;
项目名称：$PROJECT_NAME&lt;br/&gt;&lt;hr/&gt;
构建编号：$BUILD_NUMBER&lt;br/&gt;&lt;hr/&gt;
svn 版本号：${SVN_REVISION}&lt;br/&gt;&lt;hr/&gt;
构建状态：$BUILD_STATUS&lt;br/&gt;&lt;hr/&gt;
触发原因：${CAUSE}&lt;br/&gt;&lt;hr/&gt;
构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;
构建地址：&lt;a href=&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;
变更集：${JELLY_SCRIPT,template=&quot;html&quot;}&lt;br/&gt;&lt;hr/&gt;</code></pre><p>调整为</p>
<pre><code>&lt;hr/&gt;
(&lt;B&gt;本邮件是程序自动下发的，请勿回复！&lt;B/&gt;)&lt;br/&gt;&lt;hr/&gt;
&lt;font color=&quot;red&quot;&gt;构建状态 - $BUILD_STATUS&lt;/font&gt;&lt;hr/&gt;
&lt;font color=&quot;green&quot;&gt;构建信息&lt;/font&gt;&lt;hr/&gt;
项目名称：$PROJECT_NAME&lt;li/&gt;
源码地址：http://192.168.110.254/git/goxceed/satellite.git&lt;li/&gt;
构建编号：$BUILD_NUMBER&lt;li/&gt;
触发原因：${CAUSE}&lt;li/&gt;
构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;li/&gt;
构建地址：&lt;a href=&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;/a&gt;&lt;li/&gt;
变更集：${JELLY_SCRIPT,template=&quot;html&quot;}</code></pre><h3 id="全局邮件变量"><a href="#全局邮件变量" class="headerlink" title="全局邮件变量"></a>全局邮件变量</h3><p>如果你要查看所有可用的变量，你可以点击配置页的 <code>Content Token Reference</code> 的问号获取详细的信息</p>
<ul>
<li>${BUILD_NUMBER} 显示当前构建的编号。</li>
<li>${JOB_DESCRIPTION} 显示项目描述。</li>
<li>${SVN_REVISION} 显示 svn 版本号。还支持 Subversion 插件出口的 SVN_REVISION_n 版本。</li>
<li>${CAUSE} 显示谁、通过什么渠道触发这次构建。</li>
<li>${CHANGES } - 显示上一次构建之后的变化。<ul>
<li>showPaths 如果为 true, 显示提交修改后的地址。默认 false。</li>
<li>showDependencies 如果为 true，显示项目构建依赖。默认为 false</li>
<li>format 遍历提交信息，一个包含 %X 的字符串，其中 %a 表示作者，%d 表示日期，%m 表示消息，%p 表示路径，%r 表示版本。注意，并不是所有的版本系统都支持 %d 和 %r。如果指定 showPaths 将被忽略。默认“[%a] %m\n”。</li>
<li>pathFormat 一个包含“%p”的字符串，用来标示怎么打印路径。</li>
</ul>
</li>
<li>${BUILD_ID}显示当前构建生成的 ID。</li>
<li>${PROJECT_NAME} 显示项目的全名。（见 AbstractProject.getFullDisplayName）</li>
<li>${PROJECT_DISPLAY_NAME} 显示项目的显示名称。（见 AbstractProject.getDisplayName）</li>
<li>${SCRIPT} 从一个脚本生成自定义消息内容。自定义脚本应该放在”$JENKINS_HOME/email-templates”。当使用自定义脚本时会默认搜索 $JENKINS_HOME/email-templatesdirectory 目录。其他的目录将不会被搜索。<ul>
<li>script 当其使用的时候，仅仅只有最后一个值会被脚本使用（不能同时使用 script 和 template）。</li>
<li>template 常规的 simpletemplateengine 格式模板。</li>
</ul>
</li>
<li>${JENKINS_URL} 显示 Jenkins 服务器的 url 地址（你可以再系统配置页更改）。</li>
<li>${BUILD_LOG_MULTILINE_REGEX}按正则表达式匹配并显示构建日志。<ul>
<li>regex java.util.regex.Pattern 生成正则表达式匹配的构建日志。无默认值，可为空。</li>
<li>maxMatches 匹配的最大数量。如果为 0，将匹配所有。默认为 0。</li>
<li>showTruncatedLines 如果为 true，包含 […truncated ### lines…] 行。默认为 true。</li>
<li>substText 如果非空，就把这部分文字（而不是整行）插入该邮件。默认为空。</li>
<li>escapeHtml 如果为 true，格式化 HTML。默认为 false。</li>
<li>matchedSegmentHtmlStyle 如果非空，输出 HTML。匹配的行数将变为<b style=”your-style-value”> html escaped matched line </b>格式。默认为空。</li>
</ul>
</li>
<li>${BUILD_LOG} 显示最终构建日志。<ul>
<li>maxLines 日志最多显示的行数，默认 250 行。</li>
<li>escapeHtml 如果为 true，格式化 HTML。默认 false。</li>
</ul>
</li>
<li>${PROJECT_URL} 显示项目的 URL 地址。</li>
<li>${BUILD_STATUS} - 显示当前构建的状态（失败、成功等等）</li>
<li>${BUILD_URL} - 显示当前构建的 URL 地址。</li>
<li>${CHANGES_SINCE_LAST_SUCCESS} - 显示上一次成功构建之后的变化。<ul>
<li>reverse 在顶部标示新近的构建。默认 false。</li>
<li>format 遍历构建信息，一个包含 %X 的字符串，其中 %c 为所有的改变，%n 为构建编号。默认”Changes for Build #%n\n%c\n”。</li>
<li>showPaths,changesFormat,pathFormat 分别定义如 ${CHANGES}的 showPaths、format 和 pathFormat 参数。</li>
</ul>
</li>
<li>${CHANGES_SINCE_LAST_UNSTABLE} - 显示显示上一次不稳固或者成功的构建之后的变化。<ul>
<li>reverse 在顶部标示新近的构建。默认 false。</li>
<li>format 遍历构建信息，一个包含 %X 的字符串，其中 %c 为所有的改变，%n 为构建编号。默认”Changes for Build #%n\n%c\n”。</li>
<li>showPaths,changesFormat,pathFormat 分别定义如 ${CHANGES}的 showPaths、format 和 pathFormat 参数。</li>
</ul>
</li>
<li>${ENV} –显示一个环境变量。<ul>
<li>var– 显示该环境变量的名称。如果为空，显示所有，默认为空。</li>
</ul>
</li>
<li>${FAILED_TESTS} - 如果有失败的测试，显示这些失败的单元测试信息。</li>
<li>${JENKINS_URL} - 显示 Jenkins 服务器的地址。（你能在“系统配置”页改变它）。</li>
<li>${HUDSON_URL} - 不推荐，请使用 $JENKINS_URL</li>
<li>${PROJECT_URL} - 显示项目的 URL。</li>
<li>${SVN_REVISION} - 显示 SVN 的版本号。</li>
<li>${JELLY_SCRIPT} - 从一个 Jelly 脚本模板中自定义消息内容。有两种模板可供配置：HTML 和 TEXT。你可以在 $JENKINS_HOME/email-templates 下自定义替换它。当使用自动义模板时，”template”参数的名称不包含“.jelly”。<ul>
<li>template 模板名称，默认”html”。</li>
</ul>
</li>
<li>${TEST_COUNTS} - 显示测试的数量。<ul>
<li>var– 默认“total”。</li>
<li>total - 所有测试的数量。</li>
<li>fail - 失败测试的数量。</li>
<li>skip - 跳过测试的数量。</li>
</ul>
</li>
</ul>
<h3 id="Jelly-脚本"><a href="#Jelly-脚本" class="headerlink" title="Jelly 脚本"></a>Jelly 脚本</h3><p>插件中默认的两个 Jelly 脚本：一个用来设计 HTML 格式邮件，另一个则是定义 TEXT 格式邮件。你能通过使用模板参数指定插件调用哪一个脚本。它们的使用方法如下：</p>
<ul>
<li>文本格式：${JELLY_SCRIPT,template=”text”}</li>
<li>HTML 格式：${JELLY_SCRIPT,template=”html”}</li>
</ul>
<p>值得注意的是，拥有 Hudson 管理员权限是使用自定义 Jelly 脚本（该脚本没有跟 email-ext 打包）的前提。脚本的生成步骤本身其实相对简单：</p>
<ol>
<li>创建 Jelly 脚本。脚本的名称应该是《名称》.jelly。名称以.jelly 结尾是很重要的。</li>
<li>把脚本存放在 JENKINS_HOME\email-templates 文件夹里。</li>
<li>使用 Jelly 变量，让 template 匹配你的脚本名称（不要包含后缀）。比如，脚本的名称为 foobar.jelly，则邮件内容中应该是 ${JELLY_SCRIPT,template=”foobar”}。</li>
</ol>
<h2 id="Email-Template-Testing"><a href="#Email-Template-Testing" class="headerlink" title="Email Template Testing"></a>Email Template Testing</h2><p>在 Job 下存在一个选项 <code>Jelly/Groovy Template File Name</code>，用于测试 <code>Jelly/Groovy</code> 模板</p>
<p>首先下载 <code>Jelly/Groovy</code> 模板，<a href="https://github.com/jenkinsci/email-ext-plugin/tree/master/src/main/resources/hudson/plugins/emailext/te" target="_blank" rel="noopener">地址</a></p>
<p><a href="https://wiki.jenkins.io/display/JENKINS/Email-ext+plugin#Email-extplugin-Jellycontent" target="_blank" rel="noopener">Eamil-ext 文档</a></p>
<p>根据提示需要在 <code>$JENKINS_HOME</code> 目录下建立文件夹 <code>email-templates</code>，然后将下载的模板拷贝进去就可以测试了</p>
<pre><code class="shell">$ ll ~/.jenkins/email-templates
-rw-rw-r--  1 jenkins jenkins  4633 8 月  24 18:18 groovy-html-larry.html
-rw-rw-r--  1 jenkins jenkins  4560 8 月  24 18:18 groovy-html-larry.template
-rw-rw-r--  1 jenkins jenkins  6316 8 月  24 18:18 groovy-html.template
-rw-rw-r--  1 jenkins jenkins   912 8 月  24 18:18 groovy-text.template
-rw-rw-r--  1 jenkins jenkins 13210 8 月  24 18:18 html_gmail.jelly
-rw-rw-r--  1 jenkins jenkins  9477 8 月  24 18:18 html.jelly
-rw-rw-r--  1 jenkins jenkins 14877 8 月  24 18:18 html-with-health-and-console.jelly
-rw-rw-r--  1 jenkins jenkins  1784 8 月  24 18:18 jelly_pynliner.py
-rw-rw-r--  1 jenkins jenkins 10000 8 月  24 18:18 jive-formatter.groovy
-rw-rw-r--  1 jenkins jenkins   980 8 月  24 18:18 Jive-Formatter-README.md
-rw-rw-r--  1 jenkins jenkins   442 8 月  24 18:18 README.TXT
-rw-rw-r--  1 jenkins jenkins 14862 8 月  24 18:18 static-analysis.jelly
-rw-rw-r--  1 jenkins jenkins  3408 8 月  24 18:18 text.jelly</code></pre>
<p>后缀为 <code>.jelly</code> 用法 <code>${JELLY_SCRIPT,template=&quot;html_gmail&quot;}</code></p>
<p>后缀为 <code>.template</code> 用法 <code>${SCRIPT,template=&quot;groovy-html.template&quot;}</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://islocal.cc/arlo/c26ec4ea/" target="_blank" rel="noopener">Jenkins 邮件通知配置</a></li>
<li><a href="https://www.cnblogs.com/huangenai/p/7136093.html" target="_blank" rel="noopener">Jenkins 配置邮件通知</a></li>
<li><a href="https://blog.csdn.net/wangmuming/article/details/22925357" target="_blank" rel="noopener">Jenkins 进阶系列之——01 使用 email-ext 替换 Jenkins 的默认邮件通知</a></li>
<li><a href="https://blog.csdn.net/russ44/article/details/52263454" target="_blank" rel="noopener">jenkins 邮件插件中的内容参数设置详解</a></li>
<li><a href="https://blog.csdn.net/u011655220/article/details/79912553" target="_blank" rel="noopener">jenkins 的可编辑邮件通知 —Jelly 脚本</a></li>
<li><a href="http://www.voidcn.com/article/p-xozkyuwc-brb.html" target="_blank" rel="noopener">jenkins 配置邮件及增强版邮件通知</a></li>
<li><a href="https://github.com/jenkinsci/email-ext-plugin/tree/master/src/main/resources/hudson/plugins/emailext/templates" target="_blank" rel="noopener">email-ext-plugin</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>ci</tag>
        <tag>email</tag>
        <tag>STMP</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 URL 触发 Jenkins 构建</title>
    <url>/2018/08/23/jenkins-build-trigger-by-URL/</url>
    <content><![CDATA[<p>通过 URL 来触发 Jenkins 任务，进一步可以携带参数完成指定工作</p>
<a id="more"></a>

<h2 id="Jenkins-Configure"><a href="#Jenkins-Configure" class="headerlink" title="Jenkins Configure"></a>Jenkins Configure</h2><p>关闭选项 <code>Manage Jenkins</code> -&gt; <code>Configure Global Security</code> -&gt; <code>Prevent Cross Site Request Forgery exploits</code></p>
<p>这样可以使用</p>
<pre><code class="shell">curl --user &#39;USER:PASSWD&#39; -X POST &quot;http://your-jenkins.com/job/Two/build?token=A-Token&quot;
curl --user &#39;USER:USER-API-Token&#39; -X POST http://your-jenkins.com/job/Two/build?token=A-Token</code></pre>
<p>如果不关闭上述选项，则需要先获得一个 <code>CSRF protection token</code>，然后再将这个 <code>token</code> 作为 HTTP 请求的 <code>header</code> 发送过去</p>
<pre><code class="shell">$ curl --user &#39;USER:API-Token&#39; http://your-jenkins.com/crumbIssuer/api/json
{&quot;_class&quot;:&quot;hudson.security.csrf.DefaultCrumbIssuer&quot;,&quot;crumb&quot;:&quot;xxxxxxxxxxxxxxxxxxx&quot;,&quot;crumbRequestField&quot;:&quot;Jenkins-Crumb&quot;}

$ curl --user &#39;USER:API-Token&#39; -H &quot;Jenkins-Crumb:xxxxxxxxxxxxxxxxxxx&quot; -X POST http://your-jenkins.com/job/Two/build?token=A-Token</code></pre>
<p>脚本</p>
<pre><code class="shell">#!/bin/bash

CRUMB=$(curl -s &#39;http://guowei:38e2427ac39d5a5f810c83c6fd39ee80  @your-jenkins.com/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,&quot;:&quot;,//crumb)&#39;)

curl -u guowei:38e2427ac39d5a5f810c83c6fd39ee80 -H &quot;$CRUMB&quot; -X POST &quot;http://your-jenkins.com/job/Two/build&quot; --data token=A-Token --data delay=0sec</code></pre>
<h2 id="不带参数触发-Job"><a href="#不带参数触发-Job" class="headerlink" title="不带参数触发 Job"></a>不带参数触发 Job</h2><p><code>New Item</code> -&gt; <code>Build Trigger</code> -&gt; <code>Trigger builds remotely (e.g., from scripts)</code></p>
<p>其中 <code>Authentication Token</code> 中填写的字符串即 <code>A-Token</code></p>
<p>执行上述脚本即触发指定 <code>Job</code> 构建</p>
<h2 id="带参数触发-Job"><a href="#带参数触发-Job" class="headerlink" title="带参数触发 Job"></a>带参数触发 Job</h2><p><code>New Item</code> -&gt; <code>General</code> -&gt; <code>This project is parameterized</code> -&gt; <code>String Parameter</code></p>
<p>中选择 <code>Name</code> 用于传输参数，例如选择 <code>os</code>，在 <code>shell</code> 中可以使用 <code>${os}</code> 进行引用</p>
<p><code>New Item</code> -&gt; <code>Build Trigger</code> -&gt; <code>Trigger builds remotely (e.g., from scripts)</code></p>
<p>其中 <code>Authentication Token</code> 中填写的字符串即 <code>A-Token</code></p>
<pre><code class="shell">curl -X POST http://&lt;jenkins URL&gt;/jenkins/job/TESTS/job/&lt;Your job&#39;s Name&gt;/buildWithParameters \
  --user &lt;Jenkins account&gt;:&lt;account&#39;s TokenID&gt;  \
  --data token=&lt;job&#39;s token (if required)&gt; \
  --data MessageText=Le%20Texte</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title>在内网服务器搭建 CI(Jenkins + Gerrit)</title>
    <url>/2018/08/22/jenkins-gerrit-in-server/</url>
    <content><![CDATA[<p>在内网服务器搭建 CI 系统，主要实现</p>
<ol>
<li>Gerrit 代码评审</li>
<li>每日构建</li>
<li>指定库发布</li>
</ol>
<a id="more"></a>

<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="gerrit-tigger"><a href="#gerrit-tigger" class="headerlink" title="gerrit tigger"></a>gerrit tigger</h3><p>两种方式启用，一种是 <code>Non-Interactive Users</code>，另一种是 <code>REST Api</code></p>
<h4 id="Non-Interactive-Users"><a href="#Non-Interactive-Users" class="headerlink" title="Non-Interactive Users"></a><code>Non-Interactive Users</code></h4><p><a href="https://wiki.jenkins.io/display/JENKINS/Gerrit+Trigger#GerritTrigger-Gerritaccessrights" target="_blank" rel="noopener">权限要求</a></p>
<h4 id="REST-Api"><a href="#REST-Api" class="headerlink" title="REST Api"></a><code>REST Api</code></h4><p><a href="https://wiki.jenkins.io/display/JENKINS/Gerrit+Trigger#GerritTrigger-MissedEventsPlaybackFeature(Availablefromv.2.14.0)" target="_blank" rel="noopener">教程</a></p>
<p>首先需要在 <code>gerrit</code> 中生成 <code>HTTP Password</code> -&gt; <code>Generate Password</code></p>
<p>然后在 <code>Jenkins</code> -&gt; <code>Gerrit Tigger</code> -&gt; <code>Advanced</code> -&gt; <code>Gerrit HTTP User</code> -&gt; <code>Gerrit HTTP Password</code></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>只允许 <code>Code Review</code>，不允许 <code>Verify</code></p>
<p>因此配置 <code>Code Review</code> 为</p>
<ul>
<li>Started 0</li>
<li>Successful 1</li>
<li>Failed -1</li>
<li>Unstable -1</li>
<li>Not Built 0</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Tigger"><a href="#Tigger" class="headerlink" title="Tigger"></a>Tigger</h4><p>为了实现目的 1，只监控指定工程指定分支下的 <code>Patches Creates</code></p>
<p>使用命令更新 <code>patch</code></p>
<pre><code class="shell">repo download $GERRIT_PROJECT $GERRIT_CHANGE_NUMBER/$GERRIT_PATCHSET_NUMBER</code></pre>
<h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>需要建立用户 <code>jenkins</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Gerrit+Trigger" target="_blank" rel="noopener">Gerrit Trigger</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gerrit</tag>
        <tag>CI</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>僵尸进程和孤儿进程</title>
    <url>/2018/08/21/zombie-process-and-orphaned-process/</url>
    <content><![CDATA[<p>僵尸进程和孤儿进程</p>
<a id="more"></a>

<p>##</p>
<p><code>zombie process</code> 父进程没有退出，只是没有回收子进程结束时的状态信息（需要使用 <code>wait</code> 或 <code>waitpid</code> )，而 <code>orphaned process</code> 父进程已经先于子进程退出，此时 <code>pid = 1 的 init</code> 收养了子进程</p>
<p>而在父进程中显式指明忽略 <code>SIGCHLD</code> 可以将回收 <code>zombie process</code> 的工作交给 <code>init</code></p>
<pre><code class="c">struct sigaction sa;

sigemptyset(&amp;sa.sa_mask);
sa.sa_handler = SIG_IGN;
sa.sa_flags = 0;
sigaction(SIGCHLD, &amp;sa, NULL);</code></pre>
<p>如果已经显式指明忽略 <code>SIGCHLD</code>，但是还有<strong>疑似僵尸进程</strong>存在，需要确认是否为僵尸进程（打印 ppid)</p>
<p>如果是僵尸进程，说明僵尸进程在此系统中通过这种方式回收不干净，在信号处理中调用 <code>waitpid</code> 进行回收</p>
<p>如果是孤儿进程，需要检查逻辑，为什么子进程不退出，或长时间执行</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程『总结』</a></li>
<li><a href="https://blog.csdn.net/wzb56_earl/article/details/6328472" target="_blank" rel="noopener">浅议孤儿进程和僵尸进程（defunc）</a></li>
<li><a href="https://segmentfault.com/q/1010000008713383" target="_blank" rel="noopener">子进程执行完成为僵尸进程，怎么解决</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>zombie process</tag>
        <tag>orphaned process</tag>
        <tag>僵尸进程</tag>
        <tag>孤儿进程</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT-and-CoAP</title>
    <url>/2018/08/21/MQTT-and-CoAP/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/xukai871105/article/details/17734163" target="_blank" rel="noopener">CoAP 协议学习——CoAP 基础</a></li>
<li><a href="https://segmentfault.com/a/1190000002511350" target="_blank" rel="noopener">一步步搭建物联网系统——RESTful 的 CoAP 协议</a></li>
<li><a href="https://www.zhihu.com/question/34767514" target="_blank" rel="noopener">MQTT 和 CoAP 哪个最可能成为未来物联网通信标准协议？</a></li>
</ol>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>CoAP</tag>
      </tags>
  </entry>
  <entry>
    <title>回收 fork() 的子进程</title>
    <url>/2018/08/21/fork-and-zombie-process/</url>
    <content><![CDATA[<p>使用 <code>fork()</code> 函数派生出多个子进程来并行执行程序的不同代码块，是一种常用的编程泛型。但是，在使用 <code>fork()</code> 函数时若处理不当，很容易产生僵尸进程。</p>
<a id="more"></a>

<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><pre><code class="c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    while (1) {
        pid_t pid = fork();
        if (pid &gt; 0) {
            // 主进程
            sleep(5);
        } else if (pid == 0) {
            // 子进程
            return 0;
        } else {
            fprintf(stderr, &quot;fork error\n&quot;);
            return 2;
        }
    }
}</code></pre>
<p>该函数的返回值有三种情况，分别是：</p>
<ul>
<li>大于 0，表示当前进程为父进程，返回值是子进程号；</li>
<li>等于 0，表示当前进程是子进程；</li>
<li>小于 0（确切地说是等于 -1），表示 fork() 调用失败。</li>
</ul>
<p>示例代码每 5 秒创建一个子进程，而且没有等待回收，变成僵尸进程</p>
<pre><code class="shell">$ gcc test.c -o fork
$ ./fork
kk  24336 17551  0 11:16 pts/6    00:00:00 ./fork
kk  24337 24336  0 11:16 pts/6    00:00:00 [fork] &lt;defunct&gt;
kk  24340 24336  0 11:16 pts/6    00:00:00 [fork] &lt;defunct&gt;
kk  24345 24336  0 11:16 pts/6    00:00:00 [fork] &lt;defunct&gt;</code></pre>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p><strong>僵尸进程</strong>是指子进程退出后，它的父进程没有“等待”该子进程，这样的子进程就会成为僵尸进程。</p>
<p>一般父进程需要调用 <code>wait</code> 或 <code>waitpid</code> 来等待子进程进行回收</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><h2 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h2><p>在 <code>SIGCHLD</code> 中调用 <code>wait</code> 或 <code>waitpid</code></p>
<h2 id="SIG-IGN"><a href="#SIG-IGN" class="headerlink" title="SIG_IGN"></a>SIG_IGN</h2><p>除了在 SIGCHLD 信号处理函数中调用 wait() 来避免产生僵尸进程，我们还可以选择忽略 SIGCHLD 信号，告知操作系统父进程不关心子进程的退出状态，可以直接清理。</p>
<pre><code class="c">signal(SIGCHLD, SIG_IGN);</code></pre>
<p>但需要注意的是，在部分 BSD 系统中，这种做法仍会产生僵尸进程。因此更为通用的方法还是使用 wait() 函数。</p>
<p><strong>需要区分僵尸进程和孤儿进程</strong></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.coder4.com/archives/151" target="_blank" rel="noopener">异步回收 fork 出的子进程（僵尸进程）</a></li>
<li><a href="https://blog.csdn.net/oqqHuTu12345678/article/details/75043726" target="_blank" rel="noopener">Linux 进程全解 7——父进程 wait / waitip 回收子进程</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_605f5b4f0100x3wm.html" target="_blank" rel="noopener">父进程非阻塞回收子进程（适用 LINUX 下 C 语言的 client-server 模型）</a></li>
<li><a href="http://shzhangji.com/cnblogs/2013/03/27/fork-and-zombie-process/" target="_blank" rel="noopener">fork() 与僵尸进程</a></li>
<li><a href="https://blog.csdn.net/liyantianmin/article/details/79485923" target="_blank" rel="noopener">僵尸进程的发现与解决</a></li>
<li><a href="https://blog.csdn.net/xingxu0207/article/details/74971529" target="_blank" rel="noopener">SIGCHLD 信号与 SIG_IGN 处理的使用</a></li>
<li><a href="https://www.cnblogs.com/wuchanming/p/4020463.html" target="_blank" rel="noopener">linux 下的僵尸进程处理 SIGCHLD 信号</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>fork</tag>
        <tag>zombie process</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 ubuntu 64 位系统无法运行 32 位程序的问题</title>
    <url>/2018/08/21/ubuntu64-with-32-bin/</url>
    <content><![CDATA[<p>新装主机 <code>ubuntu 64</code> 系统，32 位编译工具链不能正常执行，需要安装支持包</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><pre><code class="shell">$ ldd work
libm.so.6 =&gt; /lib32/libm.so.6 (0xf7714000)
libc.so.6 =&gt; /lib32/libc.so.6 (0xf7569000)
/lib/ld-linux.so.2 (0xf776a000)

$ ./work
-bash: ./work: No such file or direcory

$ file work
work:ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (used shared libs), for GNU/linux 2.2.5, stripped</code></pre>
<p>在 64 位系统上，32 位可执行文件需要安装支持库</p>
<h2 id="安装支持库"><a href="#安装支持库" class="headerlink" title="安装支持库"></a>安装支持库</h2><pre><code class="shell">$ sudo apt-get install libc6-i386</code></pre>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>http-error-code-501</title>
    <url>/2018/08/20/http-error-code-501/</url>
    <content><![CDATA[<p><strong>HTTP 501 错误 – 未实现 (Not implemented)</strong></p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>您的 Web 服务器不理解或不支持它在客户端（如您的浏览器或我们的 CheckUpDown 机器人）发送给它的 HTTP 数据流中找到的 HTTP 方法。 这些在 HTTP 协议中定义的方法如下：</p>
<p>1.</p>
<h2 id="解决-501-错误-–-一般方法"><a href="#解决-501-错误-–-一般方法" class="headerlink" title="解决 501 错误 – 一般方法"></a>解决 501 错误 – 一般方法</h2><p><strong>这个错误在任何浏览器上都应是非常罕见的</strong>。 如果客户端不是一个浏览器则更有可能 – 特别是如果 Web 服务器很旧时。 在这两种情况下， 如果客户端指定了一个有效的请求类型， 那么 Web 服务器不是响应不正确，就是需要升级。</p>
<h2 id="xx"><a href="#xx" class="headerlink" title="xx"></a>xx</h2><h2 id="HTTP-循环中的-501-错误"><a href="#HTTP-循环中的-501-错误" class="headerlink" title="HTTP 循环中的 501 错误"></a>HTTP 循环中的 501 错误</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.checkupdown.com/status/E501_zh.html" target="_blank" rel="noopener">E501</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>501</tag>
      </tags>
  </entry>
  <entry>
    <title>http-cgi</title>
    <url>/2018/08/20/http-cgi/</url>
    <content><![CDATA[<p>CGI 概念</p>
<a id="more"></a>

<h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><p>随着 Internet 技术的兴起，在嵌入式设备的管理与交互中，基于 Web 方式的应用成为目前的主流，这种程序结构也就是大家非常熟悉的 <code>B/S 结构</code>，即在<strong>嵌入式设备上运行一个支持脚本或 CGI 功能的 Web 服务器，能够生成动态页面，在用户端只需要通过 Web 浏览器就可以对嵌入式设备进行管理和监控</strong>，非常方便实用。</p>
<h2 id="CGI-基本概念"><a href="#CGI-基本概念" class="headerlink" title="CGI 基本概念"></a>CGI 基本概念</h2><h2 id="CGI-服务器"><a href="#CGI-服务器" class="headerlink" title="CGI 服务器"></a>CGI 服务器</h2><h2 id="CGI-脚本"><a href="#CGI-脚本" class="headerlink" title="CGI 脚本"></a>CGI 脚本</h2><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    printf(&quot;Contenttype:text/html\n\n&quot;);
    printf(&quot;&lt;html&gt;\n&quot;);
    printf(&quot;&lt;head&gt;&lt;title&gt;An HTML Page From a CGI&lt;/title&gt;&lt;/head&gt;\n&quot;);
    printf(&quot;&lt;body&gt;&lt;br&gt;\n&quot;);
    printf(&quot;&lt;h2&gt; This is an HTML page generated from with in a CGI program..&lt;/h2&gt;\n&quot;);
    printf(&quot;&lt;hr&gt;&lt;p&gt;\n&quot;);
    printf(&quot;&lt;a href=\&quot;output.html#two\&quot;&gt;&lt;b&gt; Go back to out put.html page &lt;/b&gt;&lt;/a&gt;\n&quot;);
    printf(&quot;&lt;/body&gt;\n&quot;);
    printf(&quot;&lt;/html&gt;\n&quot;);
    fflush(stdout);
}</code></pre>
<p>交叉编译为可执行文件，拷贝到嵌入式硬件 <code>/var/www/cgi-bin/</code> 下，<br>输入 <code>http:// 嵌入式板子的 IP 地址 /cgi-bin/test.cgi</code>，显示生成的网页内容</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/tianmohust/article/details/6765757" target="_blank" rel="noopener">嵌入式 Web 服务器 BOA 和 CGI 编程开发</a></li>
<li><a href="https://www.cnblogs.com/xmphoenix/archive/2011/03/22/1991274.html" target="_blank" rel="noopener">嵌入式 Linux 上通过 boa 服务器实现 cgi/html 的 web 上网</a></li>
<li><a href="http://haiyangxu.github.io/posts/2014/2014-05-11-How_web_works_HTTP_and_CGI.html" target="_blank" rel="noopener">Web 是如何运行的：HTTP 和 CGI</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>Web</category>
        <category>Mongoose</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>cgi</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>git-submodule</title>
    <url>/2018/08/14/git-submodule/</url>
    <content><![CDATA[<p>在一个 git 仓库中使用另外一个 git 仓库，而且需要保持独立的提交，可以使用 <code>git submodule</code> 来完成</p>
<a id="more"></a>

<p>##</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://ask.helplib.com/git/post_83132" target="_blank" rel="noopener">Git 的子模块指定一个分支 / 标记</a></li>
<li><a href="https://www.jianshu.com/p/491609b1c426" target="_blank" rel="noopener">子模块：一个仓库包含另一个仓库</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>submodule</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Aria2 下载网盘文件</title>
    <url>/2018/08/10/aria2-baiduyunpan/</url>
    <content><![CDATA[<p>使用 <code>BaiduExporter</code> <code>aria2</code> <code>chrome</code> 以及 <code>YAAW</code> 构建下载系统</p>
<a id="more"></a>

<h2 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h2><p>aria2 是一款轻量且支持多种协议的命令行下载工具，在不同系统环境都可以使用。它占用系统资源很少，内存不超过 10MB；支持 RPC 界面远程控制以及多线程连接下载</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在<a href="https://aria2.github.io/" target="_blank" rel="noopener">官网</a> 下载源码</p>
<pre><code>$ wget https://github.com/aria2/aria2/releases/download/release-1.34.0/aria2-1.34.0.tar.gz
$ tar xvjf aria2-1.34.0.tar.gz
$ cd aria2-1.34.0
$ ./configure
$ make -j 4
$ make install</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>sudo mkdir /etc/aria2    #新建文件夹
sudo touch /etc/aria2/aria2.session    #新建 session 文件
sudo chmod 777 /etc/aria2/aria2.session    #设置 aria2.session 可写
sudo vi /etc/aria2/aria2.conf    #创建并编辑配置文件</code></pre><p><a href="http://aria2c.com/usage.html" target="_blank" rel="noopener">配置说明</a></p>
<pre><code>#允许 rpc
enable-rpc=true
#允许所有来源，web 界面跨域权限需要
rpc-allow-origin-all=true
#允许非外部访问
rpc-listen-all=true
#RPC 端口，仅当默认端口被占用时修改
#rpc-listen-port=6800

#最大同时下载数（任务数）, 路由建议值：3
max-concurrent-downloads=5
#断点续传
continue=true
#同服务器连接数
max-connection-per-server=10
#最小文件分片大小，下载线程数上限取决于能分出多少片，对于小文件重要
min-split-size=1M
#单文件最大线程数，路由建议值：5
split=100
#下载速度限制
max-overall-download-limit=0
#单文件速度限制
max-download-limit=0
#上传速度限制
max-overall-upload-limit=0
#单文件速度限制
max-upload-limit=0
#断开速度过慢的连接
#lowest-speed-limit=0
#验证用，需要 1.16.1 之后的 release 版本
#referer=*

#从会话文件中读取下载任务
input-file=/etc/aria2/aria2.session
#在 Aria2 退出时保存 `错误 / 未完成` 的下载任务到会话文件
save-session=/etc/aria2/aria2.session
#定时保存会话，需要 1.16.1 之后的 release 版
#save-session-interval=60

#文件保存路径，默认为当前启动位置
dir=/home/ 你的用户名 / 下载
禁用 IPv6, 默认：false
disable-ipv6=true
#文件缓存，使用内置的文件缓存，如果你不相信 Linux 内核文件缓存和磁盘内置缓存时使用，需要 1.16 及以上版本
#disk-cache=0
#另一种 Linux 文件缓存方式，使用前确保您使用的内核支持此选项，需要 1.15 及以上版本 (?)
#enable-mmap=true
#文件预分配，能有效降低文件碎片，提高磁盘性能。缺点是预分配时间较长
#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc 和 trunc 需要文件系统和内核支持
file-allocation=prealloc

#启用本地节点查找
bt-enable-lpd=true
#添加额外的 tracker
#bt-tracker=&lt;URI&gt;,…
#单种子最大连接数
#bt-max-peers=55
#强制加密，防迅雷必备
#bt-require-crypto=true
#当下载的文件是一个种子（以.torrent 结尾）时，自动下载 BT
follow-torrent=true
#BT 监听端口，当端口屏蔽时使用
#listen-port=6881-6999

#不确定是否需要，为保险起见，need more test
enable-dht=false
bt-enable-lpd=false
enable-peer-exchange=false
#修改特征
user-agent=uTorrent/2210(25130)
peer-id-prefix=-UT2210-
#修改做种设置，允许做种
seed-ratio=0
#保存会话
force-save=false
bt-hash-check-seed=true
bt-seed-unverified=true
bt-save-metadata=true
#定时保存会话，需要 1.16.1 之后的某个 release 版本（比如 1.16.2）
#save-session-interval=60</code></pre><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><pre><code>sudo aria2c --conf-path=/etc/aria2/aria2.conf</code></pre><p><code>-D</code> 为后台运行命令</p>
<h3 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h3><p>TODO</p>
<h2 id="BaiduExporter"><a href="#BaiduExporter" class="headerlink" title="BaiduExporter"></a><a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">BaiduExporter</a></h2><blockquote>
<p>Chrome : Click Settings -&gt; Extensions, drag BaiduExporter.crx file to the page, install it, or check Developer mode -&gt; Load unpacked extension, navigate to the chrome/release folder.</p>
</blockquote>
<p>安装完成之后，百度云盘多出一个选项 <code>导出下载</code>，其中 <code>ARIA2 RPC</code> 可以搭配 <code>YAAW</code> 用来下载</p>
<h2 id="YAAW"><a href="#YAAW" class="headerlink" title="YAAW"></a><a href="https://chrome.google.com/webstore/detail/yaaw/hbjpfaalboebibgfmedmjijhbjapcnki?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="noopener">YAAW</a></h2><p>安装之后需要设置 <code>JSON-RPC Path</code> 为 <code>http://localhost:6800/jsonrpc</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/crazycui/article/details/52205908" target="_blank" rel="noopener">ubuntu 安装配置 aria2</a></li>
<li><a href="https://medium.com/@xavieris/%E4%BD%BF%E7%94%A8-aria2-%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%96%87%E4%BB%B6-459b52e2802c" target="_blank" rel="noopener">使用 aria2 下载百度网盘文件</a></li>
</ol>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>aria2</tag>
        <tag>BaiduExporter</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 多线程编程和 wait 命令</title>
    <url>/2018/08/07/shell-multithread-and-wait/</url>
    <content><![CDATA[<p>shell 编程也需要考虑多线程编程及线程见同步，如果处理不好会导致一些诡异的问题。</p>
<p><code>wait</code> 命令可以进行 shell 的多线程同步控制。</p>
<a id="more"></a>

<h2 id="子-shell-启动方式"><a href="#子-shell-启动方式" class="headerlink" title="子 shell 启动方式"></a>子 shell 启动方式</h2><p>在执行命令后加 <code>&amp;</code> 操作符，表示将命令放在子 shell 中异步执行。可以达到多线程效果。如下，</p>
<pre><code>sleep 10   #等待 10 秒，再继续下一操作
sleep 10 &amp; #当前 shell 不等待，后台子 shell 等待</code></pre><h2 id="wait-命令"><a href="#wait-命令" class="headerlink" title="wait 命令"></a>wait 命令</h2><pre><code>wait [pid...]</code></pre><ol>
<li>等待作业号或者进程号指定的进程退出，返回最后一个作业或进程的退出状态状态。如果没有指定参数，则等待所有子进程的退出，其退出状态为 0.</li>
<li>如果是 shell 中等待使用 wait，则不会等待调用函数中子任务。在函数中使用 wait，则只等待函数中启动的后台子任务</li>
<li>在 shell 中使用 wait 命令，相当于高级语言里的多线程同步</li>
</ol>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre><code>#!/bin/bash
sleep 10 &amp;
sleep 5&amp;
wait #等待 10 秒后，退出</code></pre><pre><code>#!/bin/bash
sleep 10 &amp;
sleep 5&amp;
wait $! #$! 表示上个子进程的进程号，wait 等待一个子进程，等待 5 秒后，退出</code></pre><pre><code>#!/bin/bash
source ~/.bashrc

fun(){
    echo &quot;fun is begin.timeNum:$timeNum&quot;
    local timeNum=$1
    sleep $timeNum &amp;
    wait #这个只等待 wait 前面 sleep

    echo &quot;fun is end.timeNum:$timeNum&quot;
}

fun 10 &amp;
fun 20 &amp;

wait #如果 fun 里面没有 wait，则整个脚本立刻退出，不会等待 fun 里面的 sleep
echo &quot;all is ending&quot;</code></pre>]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>wait</tag>
      </tags>
  </entry>
  <entry>
    <title>git-moving-subdir-from-one-git-repository-to-another-preserving-history</title>
    <url>/2018/08/02/git-moving-subdir-from-one-git-repository-to-another-preserving-history/</url>
    <content><![CDATA[<p>调整 <code>git</code> 仓库，将一个仓库中的子文件夹一定到另一个仓库中，目录结构层次不变</p>
<a id="more"></a>

<p>Befor</p>
<pre><code>repositoryA/
.........../directoryToKeep
.........../otherDirectory
.........../someFile.ext
repositoryB/
.........../someStuff</code></pre><p>After</p>
<pre><code>repositoryA/
.........../otherDirectory
.........../someFile.ext
repositoryB/
.........../someStuff
.........../directoryToKeep</code></pre><p>流程如下</p>
<p>首先处理源文件，及文件夹 <code>directoryToKeep</code>，查到的资料使用命令：</p>
<pre><code>git filter-branch --subdirectory-filter directoryToKeep -- --all</code></pre><p>进行处理，这样处理会有一个文件，会编程 <code>root</code> 目录，命令解释如下</p>
<pre><code>--subdirectory-filter &lt;directory&gt;
         Only look at the history which touches the given subdirectory. The result will contain that directory (and only
         that) as its project root. Implies the section called “Remap to ancestor”.</code></pre><p>因此如果需要保持目录层次不变，需要从其他方面入手，思路是删除其他文件夹的记录，只保留需要的文件夹</p>
<p><code>repositoryA</code> 操作流程如下</p>
<pre><code>git clone repositoryA
cd repositoryA
git co -b split
git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch otherDirectory someFile.ext -otherDirectory someFile.ext -r-name-filter cat -- --all
git filter-branch --subdirectory-filter . -- --all
git log -p // check log</code></pre><p>经过上述处理之后 <code>log</code> 信息很可能包含了 <code>merge branch</code> 信息，可以使用如下命令进行清除</p>
<pre><code>$ git log --pretty=oneline
dbd56f6187d373c89d7c4f349a9e5cae25a4e9a5 Merge &quot;xxx&quot; into dev
489292e69f4c1f1656dc4f6a54eca5eaf9716d11 Merge &quot;xxx&quot; into dev
a27094a9339d91fd79ae3213f102357b651190df fix: xxx
4d09efa304d993a290c5715094570e03a1f460eb fix: xxx
1cb3890be1052221bfbee6f966f9fb7b68c86890 Merge &quot;xxx&quot; into dev
241a4c004a620cb3eb3c3e63af6c0474b833e255 fix: xxx
85d343a8e6382721c37e856be3a48db813f21c90 Merge &quot;xxx&quot; into dev
a074e53765fa3384a79c9caccca2ab13533de5c6 fix: xxx

$ git filter-branch -f --prune-empty --parent-filter `pwd` /test.rb split
$ cat test.rb
#!/usr/bin/ruby
old_parents = gets.chomp.gsub(&#39;-p &#39;, &#39; &#39;)

if old_parents.empty? then
  new_parents = []
else
  new_parents = `git show-branch --independent #{old_parents}` .split
end

puts new_parents.map{|p| &#39;-p &#39; + p}.join(&#39; &#39;)

$ git log --pretty=oneline
a27094a9339d91fd79ae3213f102357b651190df fix: xxx
4d09efa304d993a290c5715094570e03a1f460eb fix: xxx
241a4c004a620cb3eb3c3e63af6c0474b833e255 fix: xxx
a074e53765fa3384a79c9caccca2ab13533de5c6 fix: xxx</code></pre><p><code>repositoryB</code> 操作如下</p>
<pre><code>$ git clone repositoryB
$ cd repositoryB
$ git co -b work
$ git remote add split PATH/TO/repositoryA
$ git fetch split
    From ../repositoryA
    * [new branch]        split      -&gt; split/split
    * [new branch]        work       -&gt; split/work
$ git co -b split split/split
    Branch split set up to track remote branch split from split.
    Switched to a new branch &#39;split&#39;
$ git log --oneline // check log
$ git co work
$ git merge split --allow-unrelated-histories</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>dvb api `_IOW` 工作不正常</title>
    <url>/2018/07/27/Linux-ioctl/</url>
    <content><![CDATA[<p>Linux DVB API 添加 IOCTL 时使用 <code>_IOW</code> <code>_IOR</code> <code>_IOWR</code> 工作不正常，只有 <code>_IO</code> 正常</p>
<a id="more"></a>

<p>##</p>
<pre><code class="c">static struct file_operations dvb_frontend_fops = {
    .owner      = THIS_MODULE,
    .ioctl      = dvb_generic_ioctl,
    .poll       = dvb_frontend_poll,
    .open       = dvb_frontend_open,
    .release    = dvb_frontend_release
};</code></pre>
<pre><code class="c">int dvb_register_frontend(struct dvb_adapter* dvb,
              struct dvb_frontend* fe)
{
    struct dvb_frontend_private *fepriv;
    static const struct dvb_device dvbdev_template = {
        .users = ~0,
        .writers = 1,
        .readers = (~0)-1,
        .fops = &amp;dvb_frontend_fops,
        .kernel_ioctl = dvb_frontend_ioctl
    };

    printk (&quot;%s\n&quot;, __func__);
    printk (&quot;%x\n&quot;, FE_SET_DEMOD_TS_CONTROL);

    if (mutex_lock_interruptible(&amp;frontend_mutex))
        return -ERESTARTSYS;

    fe-&gt;frontend_priv = kzalloc(sizeof(struct dvb_frontend_private), GFP_KERNEL);
    if (fe-&gt;frontend_priv == NULL) {
        mutex_unlock(&amp;frontend_mutex);
        return -ENOMEM;
    }
    fepriv = fe-&gt;frontend_priv;

    init_MUTEX (&amp;fepriv-&gt;sem);
    init_waitqueue_head (&amp;fepriv-&gt;wait_queue);
    init_waitqueue_head (&amp;fepriv-&gt;events.wait_queue);
    mutex_init(&amp;fepriv-&gt;events.mtx);
    fe-&gt;dvb = dvb;
    fepriv-&gt;inversion = INVERSION_OFF;

    printk (&quot;DVB: registering frontend %i (%s)...\n&quot;,
        fe-&gt;dvb-&gt;num,
        fe-&gt;ops.info.name);

    dvb_register_device (fe-&gt;dvb, &amp;fepriv-&gt;dvbdev, &amp;dvbdev_template,
                 fe, DVB_DEVICE_FRONTEND);

    mutex_unlock(&amp;frontend_mutex);
    return 0;
}
EXPORT_SYMBOL(dvb_register_frontend);</code></pre>
<pre><code class="c">int dvb_generic_ioctl(struct inode *inode, struct file *file,
              unsigned int cmd, unsigned long arg)
{
    struct dvb_device *dvbdev = file-&gt;private_data;

    printk(&quot;%s CMD:%x\n&quot;, __func__, cmd);
    if (!dvbdev)
        return -ENODEV;

    if (!dvbdev-&gt;kernel_ioctl)
        return -EINVAL;

    return dvb_usercopy (inode, file, cmd, arg, dvbdev-&gt;kernel_ioctl);
}
EXPORT_SYMBOL(dvb_generic_ioctl);</code></pre>
<pre><code class="c">int dvb_usercopy(struct inode *inode, struct file *file,
             unsigned int cmd, unsigned long arg,
             int (*func)(struct inode *inode, struct file *file,
             unsigned int cmd, void *arg))
{
    char    sbuf[128];
    void    *mbuf = NULL;
    void    *parg = NULL;
    int     err  = -EINVAL;

    printk(&quot;%s CMD:%x\n&quot;, __func__, cmd);

    /*  Copy arguments into temp kernel buffer  */
    switch (_IOC_DIR(cmd)) {
    case _IOC_NONE:
        /*
         * For this command, the pointer is actually an integer
         * argument.
         */
        parg = (void *) arg;
        break;
    case _IOC_READ: /* some v4l ioctls are marked wrong ... */
    case _IOC_WRITE:
    case (_IOC_WRITE | _IOC_READ):
        if (_IOC_SIZE(cmd) &lt;= sizeof(sbuf)) {
            printk(&quot;%s():%d\n&quot;, __func__, __LINE__);
            parg = sbuf;
        } else {
            /* too big to allocate from stack */
            mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
            if (NULL == mbuf)
                return -ENOMEM;
            parg = mbuf;
        }

        err = -EFAULT;
        printk(&quot;%s():%d %p %d\n&quot;, __func__, __LINE__, (void __user *)arg, _IOC_SIZE(cmd));
        if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
            goto out;
        break;
    }

    printk(&quot;%d\n&quot;, parg);

    /* call driver */
    if ((err = func(inode, file, cmd, parg)) == -ENOIOCTLCMD)
        err = -EINVAL;

    if (err &lt; 0)
        goto out;

  /*  Copy results into user buffer  */
    switch (_IOC_DIR(cmd))
    {
    case _IOC_READ:
    case (_IOC_WRITE | _IOC_READ):
        if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
            err = -EFAULT;
        break;
    }

out:
    kfree(mbuf);
    return err;
}</code></pre>
<p>##</p>
<p>从内核代码可以得出</p>
<pre><code>        err = -EFAULT;
        if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
            goto out;</code></pre><p><code>_IOW</code> <code>_IOWR</code> <code>_IOR</code> 参数传递需要使用指针，如果要直接传递值，只能使用 <code>_IO</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>dvbapi</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 向子进程发送信号</title>
    <url>/2018/07/19/shell-trap/</url>
    <content><![CDATA[<p>处理包含子进程的脚本，假设您希望终止任意子进程，那么还需要停止这些脚本。 <code>trap</code> 命令完成此操作。</p>
<a id="more"></a>

<h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>以 <code>&amp;</code> 运行的子进程，最为后台程序运行，父进程与子进程之间为异步</p>
<p>以直接方式运行子进程，此时子进程在前台运行，父进程与子进程之间为同步</p>
<pre><code>sleep 10   #等待 10 秒，再继续下一操作
sleep 10 &amp; #当前 shell 不等待，后台子 shell 等待</code></pre><h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><blockquote>
<p>Unix system by design doesn’t allow any script/program to trap SIGKILL due to security reasons.</p>
</blockquote>
<blockquote>
<p>Setting a trap for SIGKILL or SIGSTOP produces undefined results.</p>
</blockquote>
<p><code>trap</code> 捕捉到信号之后三种处理方式</p>
<ol>
<li>执行一段代码来处理信号 <code>trap &quot;commands&quot; signal-list</code> or <code>trap &#39;commands&#39; signal-list</code></li>
<li>接受信号的默认操作，即恢复信号默认操作 <code>trap signal-list</code></li>
<li>忽视信号 <code>trap &quot;&quot; signal-list</code></li>
</ol>
<p>注意事项：</p>
<ol>
<li><code>SIGKILL</code> <code>SIGSTOP</code> <code>SIGSEGV</code> <code>SIGCONT</code> 不设置捕捉</li>
<li>在捕捉到 signal-list 中指定的信号并执行完相应的命令之后， 如果这些命令没有将 shell 程序终止的话，shell 程序将继续执行收到信号时所执行的命令后面的命令，这样将很容易导致 shell 程序无法终止。</li>
<li>在 trap 语句中，单引号和双引号是不同的，当 shell 程序第一次碰到 trap 语句时，将把 commands 中的命令扫描一遍。此时若 commands 是用单引号括起来的话，那么 shell 不会对 commands 中的变量和命令进行替换</li>
</ol>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="全部使用同步方式"><a href="#全部使用同步方式" class="headerlink" title="全部使用同步方式"></a>全部使用同步方式</h3><pre><code class="trap.sh">#!/bin/bash
# trapchild

trap &#39;echo &quot;[TRAP]I am going down, so killing off my processes..&quot;; ps -a | grep sleep | xargs kill -9; wait; exit&#39; SIGHUP SIGINT SIGQUIT SIGTERM SIGKILL

./a.sh
err=$?
if [ $err != 0 ]; then
    echo 3 $err
    exit 1
fi

echo &quot;[TRAP]my process pid is: $$&quot;
echo &quot;[TRAP]my child pid list is: $pid&quot;

wait</code></pre>
<pre><code class="a.sh">#!/bin/bash
# trapchild

trap &#39;echo &quot;[a]ash I am going down, so killing off my processes..&quot;; ps -a | grep sleep | xargs kill -9; wait; exit&#39; SIGHUP SIGINT SIGQUIT SIGTERM SIGKILL

sleep 120
echo 1 $?
if [ $? != 0 ]; then
    echo 2 $?
    exit 1
fi

pid=&quot;$!&quot;

echo &quot;[a]my process pid is: $$&quot;
echo &quot;[a]my child pid list is: $pid&quot;

wait</code></pre>
<p>执行 <code>trap.sh</code> 之后会有三个进程</p>
<pre><code>$ ps -a
  PID TTY          TIME CMD
  750 pts/5    00:00:00 trap.sh
  751 pts/5    00:00:00 a.sh
  752 pts/5    00:00:00 sleep</code></pre><p>此时执行 <code>kill -15 750</code> 或 <code>kill-15 751</code> 不会起作用，只有执行 <code>kill -15 752</code> 才会起作用，但是 <code>trap</code> 不会触发</p>
<h3 id="使用异步方式"><a href="#使用异步方式" class="headerlink" title="使用异步方式"></a>使用异步方式</h3><pre><code class="trap.sh">#!/bin/bash
# trapchild

trap &#39;echo &quot;[TRAP]I am going down, so killing off my processes..&quot;; ps -a | grep sleep | xargs kill -9; wait; exit&#39; SIGHUP SIGINT SIGQUIT SIGTERM SIGKILL

./a.sh &amp;
err=$?
if [ $err != 0 ]; then
    echo 3 $err
    exit 1
fi

echo &quot;[TRAP]my process pid is: $$&quot;
echo &quot;[TRAP]my child pid list is: $pid&quot;

wait</code></pre>
<pre><code class="a.sh">#!/bin/bash
# trapchild

trap &#39;echo &quot;[a]ash I am going down, so killing off my processes..&quot;; ps -a | grep sleep | xargs kill -9; wait; exit&#39; SIGHUP SIGINT SIGQUIT SIGTERM SIGKILL

sleep 120 &amp;
echo 1 $?
if [ $? != 0 ]; then
    echo 2 $?
    exit 1
fi

pid=&quot;$!&quot;

echo &quot;[a]my process pid is: $$&quot;
echo &quot;[a]my child pid list is: $pid&quot;

wait</code></pre>
<p>执行 <code>trap.sh</code> 之后会有三个进程</p>
<pre><code>$ ps -a
  PID TTY          TIME CMD
  750 pts/5    00:00:00 trap.sh
  751 pts/5    00:00:00 a.sh
  752 pts/5    00:00:00 sleep</code></pre><p>如果执行 <code>kill -15 752</code>，不会触发 <code>trap</code> 直接退出</p>
<pre><code>$ ./trap.sh
[TRAP]my process pid is: 2163
[TRAP]my child pid list is:
1 0
[a]my process pid is: 2164
[a]my child pid list is: 2165</code></pre><p>如果执行 <code>kill -15 751</code>，触发 <code>a.sh trap</code></p>
<pre><code>$ ./trap.sh
[TRAP]my process pid is: 2324
[TRAP]my child pid list is:
1 0
[a]my process pid is: 2325
[a]my child pid list is: 2326
[a]ash I am going down, so killing off my processes..
kill: failed to parse argument: &#39;pts/5&#39;</code></pre><p>如果执行 <code>kill -15 750</code>，触发 <code>trap.sh trap</code></p>
<pre><code>$ ./trap.sh
[TRAP]my process pid is: 2487
[TRAP]my child pid list is:
1 0
[a]my process pid is: 2488
[a]my child pid list is: 2489
[TRAP]I am going down, so killing off my processes..</code></pre><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>当脚本直接同步、异步混合使用时需要考虑周全，详细测试</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/6cffb6f3d928" target="_blank" rel="noopener">Shell 编程之 trap 命令</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-usingtraps/index.html" target="_blank" rel="noopener">在脚本中使用 trap</a></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>trap</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 flock 保证 shell 单例执行</title>
    <url>/2018/07/19/shell-flock/</url>
    <content><![CDATA[<p>使用 <code>flock</code> 给 <code>shell 脚本</code> 上锁，保证对某些关键数据或设备的访问。</p>
<a id="more"></a>

<h2 id="flock"><a href="#flock" class="headerlink" title="flock"></a>flock</h2><pre><code class="shell">lockit () {
  exec 7&lt;&gt;.lock
  flock -n 7 || {
    echo &quot;Waiting for lock to release...&quot;
    flock 7
  }
}</code></pre>
<p>or</p>
<pre><code class="shell">#!/bin/bash

F_LOCK=&quot;/var/tmp/${0}.lock&quot;
F_PID=&quot;/var/tmp/${0}.pid&quot;

exec 3&gt; ${F_LOCK}

function is_not_running () {
    if ! /usr/bin/flock -xn 3
    then
        local pid=$(cat ${F_PID})
        echo &quot;${0} (PID: ${pid}) already running ...&quot;
        return 1
    else
        echo ${$} &gt; ${F_PID}
        return 0
    fi
}

function clean_up () {
    /usr/bin/flock -u 3
    exec 4&gt;&amp;-
    /bin/rm -f ${F_LOCK}

    /bin/rm -f ${F_PID}
}

if is_not_running
then
    echo &quot;do somthing&quot;
    sleep 30
    echo &quot;done&quot;
fi

clean_up
exit $?</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.guoyb.com/2017/09/16/flock/" target="_blank" rel="noopener">给 shell 脚本加锁</a></li>
<li><a href="https://blog.csdn.net/zhu_tianwei/article/details/40951849" target="_blank" rel="noopener">linux 之 flock 实现 shell 锁</a></li>
<li><a href="https://blog.lilydjwg.me/2013/7/26/flock-file-lock-in-linux.40104.html" target="_blank" rel="noopener">flock——Linux 下的文件锁</a></li>
<li><a href="https://gist.github.com/gotnix/baddd4ab564d3db87626376716ab9501" target="_blank" rel="noopener">利用文件锁保证一个 Shell 脚本只有一个进程在运行</a></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>flock</tag>
      </tags>
  </entry>
  <entry>
    <title>ptrace</title>
    <url>/2018/07/06/ptrace/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.nelhage.com/2010/08/write-yourself-an-strace-in-70-lines-of-code/" target="_blank" rel="noopener">Write yourself an strace in 70 lines of code</a></li>
<li><a href="https://my.oschina.net/mavericsoung/blog/132992" target="_blank" rel="noopener">使用 Ptrace 跟踪进程收到的异常信号</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ptrace</tag>
      </tags>
  </entry>
  <entry>
    <title>linx-kernel-stack</title>
    <url>/2018/07/06/linx-kernel-stack/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.51testing.com/html/56/490256-3711169.html" target="_blank" rel="noopener">通过 /proc 查看 Linux 内核态调用栈来定位问题</a></li>
<li><a href="https://stackoverflow.com/questions/33429376/how-to-understand-proc-pid-stack" target="_blank" rel="noopener">How to understand “/proc/[pid]/stack”?</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 /proc 查看 Linux 线程运行状态</title>
    <url>/2018/07/06/how-to-check-linux-stack-status/</url>
    <content><![CDATA[<p>通过 <code>/proc/PID/status</code> 来判断线程运行状态</p>
<a id="more"></a>

<p><code>voluntaryctxtswitches</code> 及 <code>nonvoluntaryctxtswitches</code> 表明了进程/线程 占用/释放了多少次 CPU</p>
<p>另外在 <code>/proc/PID/sched</code> 中 <code>nr_switches</code> 为 <code>nr_voluntary_switches</code> 及 <code>nr_involuntary_switches</code> 之和</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>stack</tag>
        <tag>proc</tag>
      </tags>
  </entry>
  <entry>
    <title>how-to-get-usb-device-info</title>
    <url>/2018/07/05/how-to-get-usb-device-info/</url>
    <content><![CDATA[<p><code>lsusb</code></p>
<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/qq_25544855/article/details/79313496" target="_blank" rel="noopener">ubuntu 查看 usb 设备</a></li>
<li><a href="https://blog.csdn.net/encourage2011/article/details/53525297" target="_blank" rel="noopener">Linux 查看 usb 设备信息</a></li>
<li><a href="https://blog.csdn.net/shichaog/article/details/42269483" target="_blank" rel="noopener">lsusb、usbfs 查看 usb 拓扑结构</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>USB 3G 讲解</title>
    <url>/2018/07/05/usb-3g/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/baweiyaoji/article/details/77865671" target="_blank" rel="noopener">USB 3G 上网卡讲解之一</a></li>
<li><a href="https://blog.csdn.net/baweiyaoji/article/details/77865970" target="_blank" rel="noopener">USB 3G 上网卡讲解之二</a></li>
<li><a href="https://blog.csdn.net/baweiyaoji/article/details/77868191" target="_blank" rel="noopener">USB 3G 上网卡讲解之三</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>usb</tag>
        <tag>3g dongle</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-usb-device-driver</title>
    <url>/2018/07/05/linux-usb-device-driver/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><pre><code class="shell">$ lsusb
$ lsusb -t
$ sudo lsusb -d xxxx:xxxx -v</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/zqixiao_09/article/details/50984074" target="_blank" rel="noopener">Linux USB 驱动开发（一）—— USB 设备基础概念</a></li>
<li><a href="https://blog.csdn.net/zqixiao_09/article/details/50986864" target="_blank" rel="noopener">Linux USB 驱动开发（二）—— USB 驱动几个重要数据结构</a></li>
<li><a href="https://blog.csdn.net/zqixiao_09/article/details/50986965" target="_blank" rel="noopener">Linux USB 驱动开发（三）—— 编写 USB 驱动程序</a></li>
<li><a href="https://blog.csdn.net/zqixiao_09/article/details/51056903" target="_blank" rel="noopener">Linux USB 驱动开发（四）—— 热插拔那点事</a></li>
<li><a href="https://blog.csdn.net/zqixiao_09/article/details/51057086" target="_blank" rel="noopener">Linux USB 驱动开发（五）—— USB 驱动程序开发过程简单总结</a></li>
<li><a href="https://blog.csdn.net/feng85016578/article/details/52808434" target="_blank" rel="noopener">Linux 下 USB 驱动详解（HOST）</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>usb-modeswitch 使用及代码分析</title>
    <url>/2018/07/04/usb-modeswitch/</url>
    <content><![CDATA[<p><code>usb modeswitch</code> 是一种模式切换工具，用于控制具有 <code>多种模式</code> 的 USB 设备。</p>
<a id="more"></a>

<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>无线网卡首次插入电脑时，它们会被识别为一个闪存设备，然后开始安装存储于其中的驱动程序。在安装完驱动程序之后就会在内部切换 USB 设备的连接模式，存储设备会消失，然后会出现一个新的设备。</p>
<p>目前许多这种设备都可以在 Linux 的驱动下工作，如 <code>usb-storage</code> （存储设备的驱动模块）和 <code>options</code> （高速 Modem 的驱动模块），接下来的事情就是如何从存储设备到 Modem 的切换。</p>
<p>依赖于 <code>libusb</code> 库， <code>usb modeswitch</code> 可以从一个配置文件中获取重要的参数，然后完成全部的初始化和通信工作，这样便使得用户可以轻松地处理这个过程。</p>
<h2 id="源码与安装"><a href="#源码与安装" class="headerlink" title="源码与安装"></a>源码与安装</h2><ul>
<li><a href="http://www.draisberghof.de/usb_modeswitch/#download" target="_blank" rel="noopener">usb modeswitch 2.5.2</a></li>
<li><a href="http://www.draisberghof.de/usb_modeswitch/#download" target="_blank" rel="noopener">usb modeswitch.d</a> 包含设备数据库和规则文件</li>
<li><a href="http://www.draisberghof.de/usb_modeswitch/device_reference.txt" target="_blank" rel="noopener">device_reference.txt</a> 设备的配置集合</li>
<li><a href="https://libusb.info/" target="_blank" rel="noopener">libusb 1.0.22</a></li>
</ul>
<h2 id="标准自动化用法"><a href="#标准自动化用法" class="headerlink" title="标准自动化用法"></a>标准自动化用法</h2><p><strong>通过 udev 事件和规则</strong>，标准自动化用法详见 <a href="https://blog.csdn.net/yang1982_0907/article/details/45969179" target="_blank" rel="noopener">usb_modeswitch 使用详解</a></p>
<h2 id="内核相关问题"><a href="#内核相关问题" class="headerlink" title="内核相关问题"></a>内核相关问题</h2><blockquote>
<p>另一种能够影响内核行为的方法是“usb-storage”的“delay_use”参数，这个参数会设置存储设备插入系统到实际使用（可能会自动挂载）之间的延迟时间，以秒为单位。默认值为 5，这个参数可能会影响某些条件下的切换结果</p>
</blockquote>
<h2 id="嵌入式移植"><a href="#嵌入式移植" class="headerlink" title="嵌入式移植"></a>嵌入式移植</h2><ul>
<li>建立 <code>usb-storage</code> - <code>options</code> 对应表，具体对应关系从 <code>usb modeswitch.d</code> 中获得，例如文件 <code>0421:062c</code></li>
</ul>
<pre><code># Nokia CS-19
TargetVendor=0x0421
TargetProductList=&quot;062d,062f&quot;
StandardEject=1</code></pre><p>获得对应关系 <code>0421:062c</code> - <code>0421:062d 0421:062f</code></p>
<ul>
<li>切换设备<pre><code class="shell">usb_modeswitch -c /etc/usb_modeswitch.d/0421:062c -v 0x0421 -p 0x062c &amp;</code></pre>
</li>
</ul>
<p>此时能从终端看到设备 <code>拔出</code> 和 <code>插入</code> 的信息，示例如下：</p>
<pre><code>[10559.330000] usb 1-1: new high speed USB device using EHCI-NationalChip and address 6
[10559.500000] usb 1-1: configuration #1 chosen from 1 choice
[10559.510000] scsi11 : SCSI emulation for USB Mass Storage devices
[10559.580000] scsi12 : SCSI emulation for USB Mass Storage devices
[Hotplug] dev: 1-1
[Hotplug] action: add
[Hotplug] dev: 1-1:1.0
[Hotplug] action: add
[Hotplug]: usb id stack
1-1+12d1:1446
[Hotplug] dev: 1-1:1.1
[Hotplug] action: add

Look for target devices ...
 No devices in target mode or class found
Look for default devices ...
 Found devices in default mode (1)
Access device 006 on bus 001
Get the current device configuration ...
Current configuration number is 1
Use interface number 0
 with class 8
Use endpoints 0x01 (out) and 0x81 (in)
Using standard Huawei switching message
Looking for active drivers ...
 OK, driver detached
 OK, driver detached
Set up int[10560.320000] usb 1-1: USB disconnect, address 6
erface 0
Use endpoint 0x01 for message sending ...
Trying to send message 1 to endpoint 0x01 ...
 Device seems to have vanished right after sending. Good.
 Device is gone, skip any further commands
-&gt; Run lsusb to note any changes. Bye!

[Hotplug] dev: 1-1:1.0
[Hotplug] action: remove
[Hotplug] dev: 1-1:1.1
[Hotplug] action: remove
[Hotplug] dev: 1-1
[Hotplug] action: remove
[Hotplug]: usb id stack
[10564.390000] usb 1-1: new high speed USB device using EHCI-NationalChip and address 7
[10564.550000] usb 1-1: configuration #1 chosen from 1 choice
[10564.580000] usb-storage: probe of 1-1:1.0 failed with error -5
[10564.590000] option 1-1:1.0: GSM modem (1-port) converter detected
[10564.630000] usb 1-1: GSM modem (1-port) converter now attached to ttyUSB0
[Hotplug] dev: 1-1
[Hotplug] action: add
[10564.710000] usb-storage: probe of 1-1:1.1 failed with error -5
[10564.860000] usb-storage: probe of 1-1:1.2 failed with error -5
[10564.960000] usb-storage: probe of 1-1:1.3 failed with error -5
[10564.970000] option 1-1:1.3: GSM modem (1-port) converter detected
[10565.040000] usb 1-1: GSM modem (1-port) converter now attached to ttyUSB1
[10565.080000] usb-storage: probe of 1-1:1.4 failed with error -5
[10565.090000] option 1-1:1.4: GSM modem (1-port) converter detected
[Hotplug]: usb id stack
1-1+12d1:1436
[10565.250000] usb 1-1: GSM modem (1-port) converter now attached to ttyUSB2
[Hotplug] dev: 1-1:1.0
[Hotplug] action: add
[Hotplug] dev: 1-1:1.2
[Hotplug] action: add
[Hotplug] dev: 1-1:1.1
[Hotplug] action: add
[Hotplug] dev: 1-1:1.3
[Hotplug] action: add
[Hotplug] dev: 1-1:1.5
[Hotplug] action: add
[Hotplug] dev: 1-1:1.4
[Hotplug] action: add

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3G Start!
TIMEOUT 5
ABORT &#39;NO CARRIER&#39;
ABORT &#39;ERROR&#39;
ABORT &#39;NO DIALTONE&#39;
ABORT &#39;BUSY&#39;
ABORT &#39;NO ANSWER&#39;
&#39;&#39; /rAT
OK /rATZ
OK /rAT+CGDCONT=1,&quot;IP&quot;,&quot;3gnet&quot;,,0,0
OK-AT-OK ATDT*99#
CONNECT /d/c

[10575.350000] scsi18 : SCSI emulation for USB Mass Storage devices
[Hotplug] dev: 1-1:1.6
[Hotplug] action: add
[10585.390000] scsi19 : SCSI emulation for USB Mass Storage devices
[10585.400000] scsi 18:0:0:0: CD-ROM            HUAWEI   Mass Storage     2.31 PQ: 0 ANSI: 2
timeout set to 5 seconds
abort on (NO CARRIER)
abort on (ERROR)
abort on (NO DIALTONE)
abort on (BUSY)
abort on (NO ANSWER)
send (/rAT^M)
[10585.460000] scsi 18:0:0:0: Attached scsi generic sg0 type 5
expect (OK)
AT^M^M
OK
 -- got it</code></pre><p><strong>上述打印可以看出基本流程</strong></p>
<ul>
<li>插入设备，识别为 <code>usb-storage</code></li>
<li>检测到对应关系，启动 <code>usb modeswitch</code></li>
<li><code>usb-storage</code> 弹出</li>
<li><code>option</code> 设备</li>
<li><code>3G</code> 连接流程启动</li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>usb modeswitch v2.5.2</code> 为例</p>
<pre><code class="c">/* Detach driver
 */
int detachDriver()
{
    int ret;
    SHOW_PROGRESS(output,&quot;Looking for active driver ...\n&quot;);
    ret = libusb_kernel_driver_active(devh, 0);
    if (ret == LIBUSB_ERROR_NOT_SUPPORTED) {
        fprintf(output,&quot; Can&#39;t do driver detection on this platform.\n&quot;);
        return 2;
    }
    if (ret &lt; 0) {
        fprintf(output,&quot; Driver check failed with error %d. Try to continue\n&quot;, ret);
        return 2;
    }
    if (ret == 0) {
        SHOW_PROGRESS(output,&quot; No active driver found. Detached before or never attached\n&quot;);
        return 1;
    }

    ret = libusb_detach_kernel_driver(devh, Interface);
    if (ret == LIBUSB_ERROR_NOT_SUPPORTED) {
        fprintf(output,&quot; Can&#39;t do driver detaching on this platform.\n&quot;);
        return 2;
    }
    if (ret == 0) {
        SHOW_PROGRESS(output,&quot; OK, driver detached\n&quot;);
    } else
        SHOW_PROGRESS(output,&quot; Driver detach failed (error %d). Try to continue\n&quot;, ret);
    return 1;
}

int main(int argc, char **argv)
{
...
    /* libusb initialization */
    if ((libusbError = libusb_init(&amp;ctx)) != LIBUSB_SUCCESS) {
        fprintf(stderr, &quot;Error: Failed to initialize libusb. %s (%d)\n\n&quot;,
                libusb_error_name(libusbError), libusbError);
        exit(1);
    }
...

    if (dev == NULL) {
        SHOW_PROGRESS(output,&quot; No bus/device match. Is device connected? Abort\n\n&quot;);
        close_all();
        exit(0);
    } else {
        if (devnum == -1) {
            devnum = libusb_get_device_address(dev);
            busnum = libusb_get_bus_number(dev);
            SHOW_PROGRESS(output,&quot;Access device %03d on bus %03d\n&quot;, devnum, busnum);
        }
        libusb_open(dev, &amp;devh);
        if (devh == NULL) {
            SHOW_PROGRESS(output,&quot;Error opening the device. Abort\n\n&quot;);
            abortExit();
        }
    }
...

    } else if (ModeMap &amp; HUAWEINEW_MODE) {
        SHOW_PROGRESS(output,&quot;Using standard Huawei switching message\n&quot;);
        detachDriver();
        strcpy(Messages[0],&quot;55534243123456780000000000000011062000000101000100000000000000&quot;);
        switchSendMessage();
    }
...

    /* No &quot;removal&quot; check if these are set */
    if ((Configuration &gt; 0 || AltSetting &gt; -1) &amp;&amp; !ResetUSB) {
        libusb_close(devh);
        devh = NULL;
    }

    if (ResetUSB) {
        resetUSB();
        devh = NULL;
    }
...
}</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://trick77.com/setting-up-huawei-e3276-150-4g-lte-usb-modem-ubuntu-server-desktop/" target="_blank" rel="noopener">Setting up a Huawei E3276-150 4G/LTE USB modem on Ubuntu Server/Desktop</a></li>
<li><a href="https://blog.csdn.net/yang1982_0907/article/details/45969179" target="_blank" rel="noopener">usb_modeswitch 使用详解</a></li>
<li><a href="http://www.draisberghof.de/usb_modeswitch/#trouble" target="_blank" rel="noopener">USB_ModeSwitch - Handling Mode-Switching USB Devices on Linux</a></li>
<li><a href="https://blog.csdn.net/gaopeiliang/article/details/40108385" target="_blank" rel="noopener">USB_ModeSwitch 介绍</a></li>
<li><a href="https://blog.csdn.net/luckywang1103/article/details/39348447" target="_blank" rel="noopener">libusb API 入门</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>usb modeswitch</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 代码高亮</title>
    <url>/2018/06/26/hexo-code-highlight/</url>
    <content><![CDATA[<p>Hexo NexT 主题添加 google code prettify 代码高亮</p>
<a id="more"></a>

<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><ul>
<li>屏蔽 <code>hexo</code> 自带高亮， <code>_config.yml</code> 中 <code>highlight:</code> <code>enable: false</code></li>
<li>下载 <a href="https://raw.githubusercontent.com/google/code-prettify/master/distrib/prettify-small.zip" target="_blank" rel="noopener">google code prettify</a>，将 <code>distrib</code> 下压缩文件解压到目录 <code>hexo/source/js</code><blockquote>
<p><code>prettify.css</code> 是对应生成代码高亮的样式文件 <code>prettify.js</code> 是对应的语法解析器</p>
</blockquote>
</li>
<li>打开安装 <code>hexo</code> 目录下的 <code>themes/next/layout/_layout.swig</code> 文件，在 <code>&lt;/body&gt;</code> 之前添加语法解析器文件<pre><code class="swig">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/google-code-prettify/prettify.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(window).load(function(){
 $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);
 prettyPrint();
})
&lt;/script&gt;</code></pre>
</li>
<li>打开安装 <code>hexo</code> 目录下的 <code>themes/next/layout/_partials/head.swig</code> 文件，在底部引入 <code>css</code> 样式<pre><code class="swig">&lt;link href=&quot;/js/google-code-prettify/prettify.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;</code></pre>
</li>
<li>切换代码样式，在上文提到的样式地址中，下载你所需的样式文件，然后 copy 到与 <code>prettify.css</code> 同目录中，并且修改相应的引入文件<pre><code class="swig">&lt;link href=&quot;/js/google-code-prettify/tomorrow-night-bright.min.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;</code></pre>
</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://eggsywelsh.github.io/2016/11/10/hexo%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/" target="_blank" rel="noopener">hexo 代码高亮</a></li>
<li><a href="http://suntus.github.io/2017/06/06/hexo%E6%B7%BB%E5%8A%A0google-code-prettify%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/" target="_blank" rel="noopener">hexo 添加 google code prettify 代码高亮</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>highlight</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 /proc/PID/maps 分析进程内存分布</title>
    <url>/2018/06/26/parse-process-memory-by-proc-maps/</url>
    <content><![CDATA[<p>通过分析 <code>/proc/PID/maps</code> 文件来了解程序运行时进程内存分布</p>
<a id="more"></a>

<h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><p>下面是进程 <code>/dvb/out.elf</code> 及相关 <code>maps</code> 文件的一个实例，其中 <code>898</code> 是主进程：</p>
<pre><code>[root@ /proc]# ps -T
PID   USER     TIME   COMMAND
    1 root       0:00 init
    2 root       0:00 [kthreadd]
    3 root       0:00 [ksoftirqd/0]
    4 root       0:00 [events/0]
    5 root       0:00 [khelper]
   57 root       0:00 [kblockd/0]
   70 root       0:00 [khubd]
   96 root       0:00 [pdflush]
   97 root       0:00 [pdflush]
   98 root       0:00 [kswapd0]
   99 root       0:00 [aio/0]
  100 root       0:00 [nfsiod]
  101 root       0:00 [cifsoplockd]
  102 root       0:00 [cifsdnotifyd]
  739 root       0:00 [mtdblockd]
  790 root       0:01 [rpciod/0]
  822 root       0:00 [gx3211_hdmi_thr]
  862 root       0:00 {exe} telnetd
  868 root       7:56 gdbserver 192.168.110.55:1245 /dvb/out.elf
  898 root       0:40 /dvb/out.elf
  915 root       0:00 /dvb/out.elf
  918 root       4:01 {pMonitor} /dvb/out.elf
  919 root       0:00 {PlayerMsgSchedu} /dvb/out.elf
  924 root       0:00 {NetworkMsgSched} /dvb/out.elf
  925 root      10:12 {NetworkConsoleS} /dvb/out.elf
  926 root       0:39 {parse read} /dvb/out.elf
  927 root       0:00 {EpgMsgScheduler} /dvb/out.elf
  928 root       6:09 {EpgConsoleSched} /dvb/out.elf
  929 root       0:00 {SearchMsgSchedu} /dvb/out.elf
  930 root       0:00 {SearchConsoleSc} /dvb/out.elf
  931 root       0:00 {SiMsgScheduler} /dvb/out.elf
  932 root      15:50 {SiConsoleSchedu} /dvb/out.elf
  933 root       0:00 {BookMsgSchedule} /dvb/out.elf
  934 root       0:23 {BookConsoleSche} /dvb/out.elf
  935 root       0:00 {ExtraMsgSchedul} /dvb/out.elf
  936 root       0:01 {ExtraConsoleSch} /dvb/out.elf
  937 root       0:14 {GuiViewMsgSched} /dvb/out.elf
  938 root       4:24 {GuiViewConsoleS} /dvb/out.elf
  941 root       0:00 {FrontendMsgSche} /dvb/out.elf
  942 root     668:52 {FrontendConsole} /dvb/out.elf
  943 root       0:00 {HotPlugConsoleS} /dvb/out.elf
  944 root       0:00 {update msg} /dvb/out.elf
  945 root       0:05 {update console} /dvb/out.elf
  946 root       0:05 {BlindSearchMsgS} /dvb/out.elf
  947 root       0:14 {BlindSearchCons} /dvb/out.elf
  948 root       0:00 {AppDeamonMsgSch} /dvb/out.elf
  972 root       0:00 {app_ecm_proc} /dvb/out.elf
  993 root       2:06 {apps_service} /dvb/out.elf
  996 root       0:02 {VpnConsoleSched} /dvb/out.elf
  997 root       0:00 {VpnMsgScheduler} /dvb/out.elf
  998 root       0:00 {GuiViewConsoleS} /dvb/out.elf
  999 root       0:00 {app_pmt_proc} /dvb/out.elf
 1000 root       0:00 {ttx_demux_threa} /dvb/out.elf
 1001 root       0:00 {ttx_parse_threa} /dvb/out.elf
  913 root       0:00 -/bin/sh
  914 root       0:00 [kpid-ts-out]
  917 root       0:00 [gx3201_jpeg_thr]
  939 root       0:08 [kdvb-fe-0]
  940 root      12:19 [kdvb-fe-0]
12626 root       0:00 {exe} ps -T

# ls /proc/898/task/
1000  915   924   927   930   933   936   941   944   947   993   998
1001  918   925   928   931   934   937   942   945   948   996   999
898   919   926   929   932   935   938   943   946   972   997

# cat /proc/898/maps
00008000-008ee000 r-xp 00000000 00:0b 261675     /dvb/out.elf
008ee000-009ff000 rw-p 008e5000 00:0b 261675     /dvb/out.elf
009ff000-00c7b000 rwxp 009ff000 00:00 0          [heap]
2aaa8000-2aaa9000 r-xp 2aaa8000 00:00 0          [vdso]
2aaaa000-2eaaa000 rw-s 94000000 00:0c 728        /dev/gxav0
2eaaa000-2eaab000 ---p 2eaaa000 00:00 0
2eaab000-2ebaa000 rw-p 2eaab000 00:00 0
2ebaa000-2ebab000 ---p 2ebaa000 00:00 0
2ebab000-2ecaa000 rw-p 2ebab000 00:00 0
2ecaa000-2ecab000 ---p 2ecaa000 00:00 0
2ecab000-2edaa000 rw-p 2ecab000 00:00 0
2edaa000-2edab000 ---p 2edaa000 00:00 0
2edab000-2eeaa000 rw-p 2edab000 00:00 0
2eeaa000-2eeab000 ---p 2eeaa000 00:00 0
2eeab000-2efaa000 rw-p 2eeab000 00:00 0
2efaa000-2efab000 ---p 2efaa000 00:00 0
2efab000-2f0aa000 rw-p 2efab000 00:00 0
2f0aa000-2f0ab000 ---p 2f0aa000 00:00 0
2f0ab000-2f1aa000 rw-p 2f0ab000 00:00 0
2f1aa000-2f1ab000 ---p 2f1aa000 00:00 0
2f1ab000-2f2aa000 rw-p 2f1ab000 00:00 0
2f2aa000-2f2ab000 ---p 2f2aa000 00:00 0
2f2ab000-2f3aa000 rw-p 2f2ab000 00:00 0
2f3aa000-2f3ab000 ---p 2f3aa000 00:00 0
2f3ab000-2f4aa000 rw-p 2f3ab000 00:00 0
2f4aa000-2f4ab000 ---p 2f4aa000 00:00 0
2f4ab000-2f60f000 rw-p 2f4ab000 00:00 0
2f60f000-2f610000 ---p 2f60f000 00:00 0
2f610000-2f70f000 rw-p 2f610000 00:00 0
2f70f000-2f710000 ---p 2f70f000 00:00 0
2f710000-2f80f000 rw-p 2f710000 00:00 0
2f80f000-2f810000 ---p 2f80f000 00:00 0
2f810000-2f90f000 rw-p 2f810000 00:00 0
2f90f000-2f910000 ---p 2f90f000 00:00 0
2f910000-2fa0f000 rw-p 2f910000 00:00 0
2fa0f000-2fa10000 ---p 2fa0f000 00:00 0
2fa10000-2fb0f000 rw-p 2fa10000 00:00 0
2fb0f000-2fb10000 ---p 2fb0f000 00:00 0
2fb10000-2fc0f000 rw-p 2fb10000 00:00 0
2fc0f000-2fc10000 ---p 2fc0f000 00:00 0
2fc10000-2fd0f000 rw-p 2fc10000 00:00 0
2fd0f000-2fd10000 ---p 2fd0f000 00:00 0
2fd10000-2fe0f000 rw-p 2fd10000 00:00 0
2fe0f000-2fe10000 ---p 2fe0f000 00:00 0
2fe10000-2ff0f000 rw-p 2fe10000 00:00 0
2ff0f000-2ff10000 ---p 2ff0f000 00:00 0
2ff10000-3000f000 rw-p 2ff10000 00:00 0
3000f000-30010000 ---p 3000f000 00:00 0
30010000-3010f000 rw-p 30010000 00:00 0
3010f000-30110000 ---p 3010f000 00:00 0
30110000-3020f000 rw-p 30110000 00:00 0
3020f000-30210000 ---p 3020f000 00:00 0
30210000-3030f000 rw-p 30210000 00:00 0
3030f000-30310000 ---p 3030f000 00:00 0
30310000-3040f000 rw-p 30310000 00:00 0
3040f000-30410000 ---p 3040f000 00:00 0
30410000-3050f000 rw-p 30410000 00:00 0
3050f000-30510000 ---p 3050f000 00:00 0
30510000-306ff000 rw-p 30510000 00:00 0
306ff000-30700000 ---p 306ff000 00:00 0
30700000-307ff000 rw-p 30700000 00:00 0
307ff000-30800000 ---p 307ff000 00:00 0
30800000-308ff000 rw-p 30800000 00:00 0
308ff000-30900000 ---p 308ff000 00:00 0
30900000-309ff000 rw-p 30900000 00:00 0
309ff000-30a00000 ---p 309ff000 00:00 0
30a00000-30aff000 rw-p 30a00000 00:00 0
30aff000-30b00000 ---p 30aff000 00:00 0
30b00000-31500000 rw-p 30b00000 00:00 0
31500000-31501000 ---p 31500000 00:00 0
31501000-31600000 rw-p 31501000 00:00 0
31600000-31601000 ---p 31600000 00:00 0
31601000-31700000 rw-p 31601000 00:00 0
31700000-31701000 ---p 31700000 00:00 0
31701000-31800000 rw-p 31701000 00:00 0
7fddc000-7fdf1000 rwxp 7ffe2000 00:00 0          [stack]</code></pre><p>第一列的是一个段的起始地址和结束地址，第二列这个段的权限，第三列段的段内相对偏移量，第六列是这个段所存放的内容所对应的文件。</p>
<p>对于第二列的权限， <code>r</code>：表示可读， <code>w</code>：表示可写， <code>x</code>：表示可执行， <code>p</code>：表示受保护（即只对本进程有效，不共享），与之相对的是 <code>s</code>，意是就是共享。</p>
<p>进程空间从低到高依次是： <code>代码段 (r-xp)</code> , <code>可读写数据段 (rw-p)</code> , <code>堆</code> , <code>mmap 区（文件映射，匿名映射以及线程栈）</code> , <code>进程栈</code></p>
<p>系统创建线程时执行如下代码：</p>
<pre><code class="c">#define GX_PTHREAD_STACK_MIN 0x100000
local_stack_size = stack_size &lt;= GX_PTHREAD_STACK_MIN ? GX_PTHREAD_STACK_MIN : stack_size;
if (pthread_attr_setstacksize(&amp;custom_attr, (size_t)local_stack_size)) {
    printf(&quot;pthread_attr_setstacksize error in GxCore_ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);
    goto gxcore_err;
}</code></pre>
<p>而 <code>pthread</code> 库创建线程时会设置 <code>4k</code> 的 <code>guard</code> 区用于栈溢出检测，因此在 <code>进程 mmap 区</code> 中每两行就是一个 <code>线程栈</code></p>
<pre><code>31500000-31501000 ---p 31500000 00:00 0     // guard size 0x1000
31501000-31600000 rw-p 31501000 00:00 0     // thread size 0x100000
31600000-31601000 ---p 31600000 00:00 0
31601000-31700000 rw-p 31601000 00:00 0
31700000-31701000 ---p 31700000 00:00 0
31701000-31800000 rw-p 31701000 00:00 0</code></pre><p>同时可以计算出进程栈范围为 <code>7fddc000-7fdf1000</code>，大小为 <code>84K</code></p>
<h2 id="out-elf"><a href="#out-elf" class="headerlink" title="out.elf"></a>out.elf</h2><p>分析可执行文件， <code>readelf -a out.elf</code>：</p>
<pre><code>ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           MCORE
  Version:                           0x1
  Entry point address:               0x80e0
  Start of program headers:          52 (bytes into file)
  Start of section headers:          20109200 (bytes into file)
  Flags:                             0x10002002
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         4
  Size of section headers:           40 (bytes)
  Number of section headers:         30
  Section header string table index: 27

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .init             PROGBITS        000080b4 0000b4 000022 00  AX  0   0  4
  [ 2] .text             PROGBITS        000080e0 0000e0 73407e 00  AX  0   0 16
  [ 3] .fini             PROGBITS        0073c160 734160 000016 00  AX  0   0  4
  [ 4] .rodata           PROGBITS        0073c180 734180 18d168 00   A  0   0 16
  [ 5] .eh_frame         PROGBITS        008c92e8 8c12e8 024634 00   A  0   0  4
  [ 6] .gcc_except_table PROGBITS        008ee91c 8e591c 00c780 00  WA  0   0  4
  [ 7] .tdata            PROGBITS        008fb09c 8f209c 000004 00 WAT  0   0  4
  [ 8] .tbss             NOBITS          008fb0a0 8f20a0 000010 00 WAT  0   0  4
  [ 9] .ctors            PROGBITS        008fb0a0 8f20a0 0001d0 00  WA  0   0  4
  [10] .dtors            PROGBITS        008fb270 8f2270 0000b8 00  WA  0   0  4
  [11] .jcr              PROGBITS        008fb328 8f2328 000004 00  WA  0   0  4
  [12] .data.rel.ro      PROGBITS        008fb330 8f2330 000ab8 00  WA  0   0  8
  [13] .got              PROGBITS        008fbde8 8f2de8 0003c8 04  WA  0   0  4
  [14] .data             PROGBITS        008fc1b0 8f31b0 102b24 00  WA  0   0 16
  [15] .bss              NOBITS          009fecd8 9f5cd4 08fe78 00  WA  0   0  8
  [16] .comment          PROGBITS        00000000 9f5cd4 0000c6 01  MS  0   0  1
  [17] .debug_aranges    PROGBITS        00000000 9f5d9a 008db8 00      0   0  1
  [18] .debug_pubnames   PROGBITS        00000000 9feb52 034b26 00      0   0  1
  [19] .debug_info       PROGBITS        00000000 a33678 413c50 00      0   0  1
  [20] .debug_abbrev     PROGBITS        00000000 e472c8 055324 00      0   0  1
  [21] .debug_line       PROGBITS        00000000 e9c5ec 245862 00      0   0  1
  [22] .debug_frame      PROGBITS        00000000 10e1e50 04f8e8 00      0   0  4
  [23] .debug_str        PROGBITS        00000000 1131738 09eea4 01  MS  0   0  1
  [24] .debug_loc        PROGBITS        00000000 11d05dc 0d25b7 00      0   0  1
  [25] .debug_pubtypes   PROGBITS        00000000 12a2b93 0654e5 00      0   0  1
  [26] .debug_ranges     PROGBITS        00000000 1308078 0255f8 00      0   0  1
  [27] .shstrtab         STRTAB          00000000 132d670 00011d 00      0   0  1
  [28] .symtab           SYMTAB          00000000 132dc40 09bb30 10     29 19497  4
  [29] .strtab           STRTAB          00000000 13c9770 0cdb06 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x00008000 0x00008000 0x8e591c 0x8e591c R E 0x1000
  LOAD           0x8e591c 0x008ee91c 0x008ee91c 0x1103b8 0x1a0234 RW  0x1000
  TLS            0x8f209c 0x008fb09c 0x008fb09c 0x00004 0x00014 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4

 Section to Segment mapping:
  Segment Sections...
   00     .init .text .fini .rodata .eh_frame
   01     .gcc_except_table .tdata .ctors .dtors .jcr .data.rel.ro .got .data .bss
   02     .tdata .tbss
   03</code></pre><p>可以看到：</p>
<pre><code>Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x00008000 0x00008000 0x8e591c 0x8e591c R E 0x1000
  LOAD           0x8e591c 0x008ee91c 0x008ee91c 0x1103b8 0x1a0234 RW  0x1000
  TLS            0x8f209c 0x008fb09c 0x008fb09c 0x00004 0x00014 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4

 Section to Segment mapping:
  Segment Sections...
   00     .init .text .fini .rodata .eh_frame
   01     .gcc_except_table .tdata .ctors .dtors .jcr .data.rel.ro .got .data .bss
   02     .tdata .tbss
   03</code></pre><p>对应进程第一、第二段内容及大小， <code>只读数据段</code> 被合并到 <code>text</code> 段</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://laoar.net/blogs/250/" target="_blank" rel="noopener">三言两语聊 kernel：线程栈</a></li>
<li><a href="https://blog.csdn.net/ljianhui/article/details/21666327" target="_blank" rel="noopener">程序运行时的内存空间分布</a></li>
<li><a href="https://blog.csdn.net/lijzheng/article/details/23618365" target="_blank" rel="noopener">linux proc maps 文件分析</a></li>
<li><a href="http://andrew913.iteye.com/blog/426601" target="_blank" rel="noopener">proc 进程信息解析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程栈和线程栈的区别</title>
    <url>/2018/06/26/linux-process-stack-and-thread-stack/</url>
    <content><![CDATA[<p>线程栈的空间是开辟在那里的？<br>线程栈之间可以互访吗？<br>为什么在使用 <code>pthread_attr_setstack</code> 函数时，需要设置栈的大小，而进程 <code>task_struct</code> 的 <code>mm_struct *mm</code> 成员中却并没有却并没有 <code>stack_size</code> 这个成员项，怎么保存的栈大小呢？</p>
<a id="more"></a>

<h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>如图所示，具体可以参照 <a href="/2017/03/10/linux-stacks/" title="Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈">Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</a></p>
<p><img src="/images/linux/spaces.jpg" alt="虚拟地址空间"></p>
<h2 id="进程栈"><a href="#进程栈" class="headerlink" title="进程栈"></a>进程栈</h2><p>进程用户空间的管理在 <code>task_struct</code> 的 <code>mm_struct *mm</code> 成员中体现， <code>mm</code> 中的成员定义了用户空间的布局情况如图。</p>
<p>用户空间的栈起始于 <code>STACK_TOP</code>， 如果设置了 <code>PF_RANDOMIZE</code>，则起始点会减少一个小的随机量，经过随机处理后，进程栈的起始地址将存放在 <code>mm-&gt;start_stack</code> 中，可以通过 <code>cat /proc/xxx/stat</code> 查看。</p>
<p>栈从上而下扩展，而用于内存映射的区域起始于 <code>mm-&gt;mmap_base</code> , <code>mm-&gt;mmap_base</code> 通过调用 <code>mmap_base()</code> 来初始化，<strong>为了确保栈不与 mmap 区域不发生冲突，两者之间设置了一个安全间隙</strong>。 <code>mmap_base</code> 函数源代码如下：</p>
<pre><code class="c">#define MIN_GAP (128*1024*1024)
#define MAX_GAP (TASK_SIZE/6*5)
static inline unsigned long mmap_base(struct mm_struct *mm)
{
  unsigned long gap = current-&gt;signal-&gt;rlim[RLIMIT_STACK].rlim_cur; // rlim_cur 默认为 8388608，及 8M， 可以使用 getrlimit(RLIMIT_STACK, &amp;limit) 查看
  unsigned long random_factor = 0;
  if (current-&gt;flags &amp; PF_RANDOMIZE)
    random_factor = get_random_int() % (1024*1024);
  if (gap &lt; MIN_GAP) // 通过 MIN_GAP 来保证，进程栈的大小至少为 128MB
    gap = MIN_GAP;
  else if (gap &gt; MAX_GAP) // 栈的最大空间为 TASK_SIZE/6*5, 及 2.5G
    gap = MAX_GAP;
  return PAGE_ALIGN(TASK_SIZE - gap - random_factor); // 通过保留 random_factor 空间大小的间隙来防止栈溢出
}</code></pre>
<p><img src="/images/linux/spaces-base.png" alt="进程内存布局"></p>
<p><strong>进程栈位于虚拟地址空间的栈区，可以动态增长，上限为 <code>ulimit -s</code> 值</strong></p>
<h2 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h2><p>线程包含了表示进程内执行环境必需的信息，其中包括进程中标示线程的线程 ID，一组寄存器值，栈，调度优先级和策略， 信号屏蔽字，errno 变量以及线程私有数据。进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本，程序的全局内存和堆内存，栈以及文件描述符，所以线程的 <code>mm_struct *mm</code> 指针变量和所属进程的 <code>mm</code> 指针变量相同。</p>
<p>在创建线程的时候，可以通过 <code>pthread_attr_t</code> 来初始化线程的属性，包括线程的栈布局信息，如栈起始地址 <code>stackaddr</code> , 栈大小 <code>stacksize</code>。 具体需要通过方法：</p>
<pre><code class="c">// stackaddr 指向为该线程开辟的空间，该空间可以使用 malloc 或者 mmap 来开辟，而不能来自进程的栈区。开辟的 stackaddr 所指向的动态空间需要自己负责释放。
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);</code></pre>
<p>当然也可将线程栈的空间管理交给系统，如果想改变系统默认的栈大小 8MB，可以通过</p>
<pre><code class="c">// stacksize 最小值为 16384，单位为字节
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</code></pre>
<p><code>pthread</code> 创建线程流程可以参考 <a href="https://blog.csdn.net/conansonic/article/details/77487925" target="_blank" rel="noopener">pthread_create 源码分析</a></p>
<p>线程栈在 linux 下起始地址跟大小保存在 <code>pthread_attr_t</code> 中</p>
<pre><code class="c">typedef struct __pthread_attr_s
{
    int __detachstate;  // 分离状态
    int __schedpolicy;// 调度策略
    struct __sched_param __schedparam;
    int __inheritsched;
    int __scope;// 线程优先级的有效范围
    size_t __guardsize;//
    int __stackaddr_set;
    void *__stackaddr;// 起始地址
    size_t __stacksize;// 表示堆栈的大小。

}pthread_attr_t;</code></pre>
<p><strong>由此看来线程栈在所属进程的堆区，线程与其所属的进程共享进程的虚拟地址空间，所以线程栈之间可以互访</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>进程栈</tag>
        <tag>线程栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核栈溢出分析</title>
    <url>/2018/06/26/kernel-stack-overflow/</url>
    <content><![CDATA[<p>由于内核栈的大小是有限的，就会有发生溢出的可能，比如调用嵌套太多、参数太多都会导致内核栈的使用超出设定的大小。本文分析内核栈溢出。</p>
<a id="more"></a>

<p><code>Linux</code> 系统进程运行分为 <code>用户态</code> 和 <code>内核态</code>，进入内核态之后使用的是内核栈，作为基本的安全机制，用户程序不能直接访问内核栈，所以尽管内核栈属于进程的地址空间，但与用户栈是分开的。内核栈需要方便快捷的访问用户态进程信息 <code>thread_info</code>，这部分数据就压在内核栈的底部，大小默认为 <code>16Kb</code>。如下图所示：</p>
<p><img src="/images/linux/20160901215111055" alt="内核栈"></p>
<p>内核栈溢出的结果往往是系统崩溃，因为溢出会覆盖掉本不该触碰的数据，首当其冲的就是 thread_info — 它就在内核栈的底部，内核栈是从高地址往低地址生长的，一旦溢出首先就破坏了 thread_info，thread_info 里存放着指向进程的指针等关键数据，迟早会被访问到，那时系统崩溃就是必然的事。</p>
<p><img src="/images/linux/overflow.png" alt="overflow"></p>
<p>内核栈溢出导致的系统崩溃有时会被直接报出来，比如你可能会看到：</p>
<pre><code>...
Call Trace:
[&lt;ffffffff8106e3e7&gt;] ? warn_slowpath_common+0x87/0xc0
BUG: unable to handle kernel NULL pointer dereference at 00000000000009e8
IP: [&lt;ffffffff8100f4dd&gt;] print_context_stack+0xad/0x140
PGD 5fdb8ae067 PUD 5fdbee9067 PMD 0
Thread overran stack, or stack corrupted
Oops: 0000 [#1] SMP
...</code></pre><p>但更多的情况是不直接报错，而是各种奇怪的 panic。在分析 vmcore 的时候，它们的共同点是 thread_info 被破坏了。</p>
<p>以下是一个实例，注意在 task_struct 中 stack 字段直接指向内核栈底部也就是 thread_info 的位置，我们看到 thread_info 显然被破坏了：cpu 的值大得离谱，而且指向 task 的指针与 task_struct 的实际地址不匹配：</p>
<pre><code>crash64&gt; struct task_struct ffff8800374cb540
struct task_struct {
  state = 2,
  stack = 0xffff8800bae2a000,
...

crash64&gt; thread_info 0xffff8800bae2a000
struct thread_info {
  task = 0xffff8800458efba0,
  exec_domain = 0xffffffff,
  flags = 0,
  status = 0,
  cpu = 91904,
  preempt_count = 0,
...</code></pre><p>作为一种分析故障的手段，可以监控内核栈的大小和深度，方法如下：</p>
<pre><code># mount -t debugfs nodev /sys/kernel/debug
# echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled</code></pre><p>然后检查下列数值，可以看到迄今为止内核栈使用的峰值和对应的 backtrace：</p>
<pre><code># cat /sys/kernel/debug/tracing/stack_max_size
# cat /sys/kernel/debug/tracing/stack_trace</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程地址空间和进程内存分布</title>
    <url>/2018/06/25/processes-memory/</url>
    <content><![CDATA[<p>本文介绍 Linux 下进程地址空间及其内存分布</p>
<a id="more"></a>

<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p><strong>对于一个进程</strong>，其空间分布如下图：</p>
<p><img src="/images/linux/process.jpeg" alt="进程内存空间分布"></p>
<h2 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h2><p>Linux 的虚拟地址空间范围为 0～4G，Linux 内核将这 4G 字节的空间分为两部分，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF）供内核使用，称为 <code>内核空间</code>。而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF）供各个进程使用，称为 <code>用户空间</code>。因为每个进程可以通过系统调用进入内核，因此，Linux 内核由系统内的所有进程共享。于是，<strong>从具体进程的角度来看，每个进程可以拥有 4G 字节的虚拟空间</strong>。</p>
<p>Linux 使用两级保护机制：0 级供内核使用，3 级供用户程序使用，<strong>每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的，最高的 1GB 字节虚拟内核空间则为所有进程以及内核所共享</strong>。</p>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 虽然内核空间占据了每个虚拟空间中的最高 1GB 字节，但映射到物理内存却总是从最低地址（0x00000000），另外，使用虚拟地址可以很好的保护内核空间被用户空间破坏，虚拟地址到物理地址转换过程有操作系统和 CPU 共同完成（操作系统为 CPU 设置好页表，CPU 通过 MMU 单元进行地址转换）。</p>
<blockquote>
<p>多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盒中，这个沙盒就是虚拟地址空间（virtual address space），在 32 位模式下，它总是一个 4GB 的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每个进程都拥有一套属于它自己的页表。</p>
</blockquote>
<p>在 Linux 中，<strong>内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存，内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与之相反，用户模式地址空间的映射随着进程切换的发生而不断的变化</strong>，如下图所示：</p>
<p><img src="/images/linux/processes.jpeg" alt="进程切换"></p>
<p>上图中蓝色区域表示映射到物理内存的虚拟地址，而白色区域表示未映射的部分。</p>
<h2 id="进程内存布局"><a href="#进程内存布局" class="headerlink" title="进程内存布局"></a>进程内存布局</h2><p><img src="/images/linux/spaces.jpg" alt="进程内存布局"></p>
<p>随机偏移量是为了防止漏洞攻击，但不幸的是，32 位地址空间相当紧凑，这给随机化所留下的空间不大，削弱了这种技巧的效果。</p>
<h3 id="进程栈"><a href="#进程栈" class="headerlink" title="进程栈"></a>进程栈</h3><p>通过不断向栈中压入数据，超出其容量就会耗尽栈所对应的内存区域，这将触发一个页故障（page fault），而被 Linux 的 expand_stack() 处理，它会调用 acct_stack_growth() 来检查是否还有合适的地方用于栈的增长。如果栈的大小低于 RLIMIT_STACK（通常为 8MB），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情。这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会栈溢出（stack overflow），程序收到一个段错误（segmentation fault）。</p>
<h3 id="内存映射段"><a href="#内存映射段" class="headerlink" title="内存映射段"></a>内存映射段</h3><p>Linux 通过 <code>mmap</code> 系统调用来请求这种映射。在 Linux 中，使用 <code>malloc</code> 申请一块比 <code>MMAP_THRESHOLD</code> 还大的内存时，C 运行库将会创建这样一个匿名映射而不是使用堆内存。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>与栈一样，堆用于运行时内存分配；但不同的是，堆用于存储那些生存期与函数调用无关的数据。</p>
<p>在 C 语言中，堆分配的接口是 malloc() 函数。如果堆中有足够的空间来满足内存请求，它就可以被语言运行时库处理而不需要内核参与，否则，堆会被扩大，通过 brk() 系统调用来分配请求所需的内存块。堆管理是很复杂的，需要精细的算法来应付我们程序中杂乱的分配模式，优化速度和内存使用效率。</p>
<h3 id="BSS-和数据段"><a href="#BSS-和数据段" class="headerlink" title="BSS 和数据段"></a>BSS 和数据段</h3><p>BSS 保存的是未被初始化的静态变量内容</p>
<p>数据段保存在源代码中已经初始化的静态变量的内容。数据段不是匿名的，它映射了一部分的程序二进制镜像，也就是源代码中指定了初始值的静态变量。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="c">#include&lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void print(char *,int);
int main()
{
    char *s1 = &quot;abcde&quot;;  //&quot;abcde&quot;作为字符串常量存储在常量区 s1、s2、s5 拥有相同的地址
    char *s2 = &quot;abcde&quot;;
    char s3[] = &quot;abcd&quot;;
    long int *s4[100];
    char *s5 = &quot;abcde&quot;;
    int a = 5;
    int b = 6;//a,b 在栈上，&amp;a&gt;&amp;b 地址反向增长

    printf(&quot;variables address in main function: s1=%p  s2=%p s3=%p s4=%p s5=%p a=%p b=%p \n&quot;,
            s1,s2,s3,s4,s5,&amp;a,&amp;b);
    printf(&quot;variables address in processcall:n&quot;);
    print(&quot;ddddddddd&quot;,5);// 参数入栈从右至左进行，p 先进栈，str 后进 &amp;p&gt;&amp;str
    printf(&quot;main=%p print=%p \n&quot;,main,print);
    // 打印代码段中主函数和子函数的地址，编译时先编译的地址低，后编译的地址高 main&lt;print
}

void print(char *str,int p)
{
    char *s1 = &quot;abcde&quot;;  //abcde 在常量区，s1 在栈上
    char *s2 = &quot;abcde&quot;;  //abcde 在常量区，s2 在栈上 s2-s1=6 可能等于 0，编译器优化了相同的常量，只在内存保存一份
    // 而 &amp;s1&gt;&amp;s2
    char s3[] = &quot;abcdeee&quot;;//abcdeee 在常量区，s3 在栈上，数组保存的内容为 abcdeee 的一份拷贝
    long int *s4[100];
    char *s5 = &quot;abcde&quot;;
    int a = 5;
    int b =6;
    int c;
    int d;           //a,b,c,d 均在栈上，&amp;a&gt;&amp;b&gt;&amp;c&gt;&amp;d 地址反向增长
    char *q=str;
    int m=p;
    char *r=(char *)malloc(1);
    char *w=(char *)malloc(1) ;  // r&lt;w 堆正向增长

    printf(&quot;s1=%p s2=%p s3=%p s4=%p s5=%p a=%p b=%p c=%p d=%p str=%p q=%p p=%p m=%p r=%p w=%p \n&quot;,
            s1,s2,s3,s4,s5,&amp;a,&amp;b,&amp;c,&amp;d,&amp;str,q,&amp;p,&amp;m,r,w);
    /* 栈和堆是在程序运行时候动态分配的，局部变量均在栈上分配。
       栈是反向增长的，地址递减；malloc 等分配的内存空间在堆空间。堆是正向增长的，地址递增。
       r,w 变量在栈上（则 &amp;r&gt;&amp;w)，r,w 所指内容在堆中（即 r&lt;w)。*/
}</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/yusiguyuan/article/details/45155035" target="_blank" rel="noopener">Linux 进程地址空间 &amp;&amp; 进程内存布局</a></li>
<li><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Anatomy of a Program in Memory</a></li>
<li><a href="https://blog.csdn.net/quanzhongzhao/article/details/45575611" target="_blank" rel="noopener">进程内存分布剖析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程的区别</title>
    <url>/2018/06/22/processes-and-threads/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/zh-cn/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>（process）和<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">线程</a>（thread）是操作系统的基本概念</p>
<a id="more"></a>

<h2 id="一个简单解释"><a href="#一个简单解释" class="headerlink" title="一个简单解释"></a><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">一个简单解释</a></h2><p><a href="http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html" target="_blank" rel="noopener">材料</a></p>
<ol>
<li>计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行</li>
<li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务</li>
<li>进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态</li>
<li>一个车间里，可以有很多工人。他们协同完成一个任务</li>
<li>线程就好比车间里的工人。一个进程可以包括多个线程</li>
<li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存</li>
<li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存</li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域</li>
<li>还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用</li>
<li>这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。不难看出，mutex 是 semaphore 的一种特殊情况（n=1 时）。也就是说，完全可以用后者替代前者。但是，因为 mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计</li>
</ol>
<p>操作系统的设计，因此可以归结为三点：</p>
<ul>
<li>以多进程形式，允许多个任务同时运行；</li>
<li>以多线程形式，允许单个任务分成不同的部分运行；</li>
<li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU 时间、内存等）的基本单位。</p>
<p>线程是进程的一个执行流，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程由几个线程组成（拥有很多相对独立的执行流的用户程序共享应用程序的大部分数据结构），线程与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>进程——资源分配的最小单位，线程——程序执行的最小单位</strong></p>
<p>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>总的来说就是：进程有独立的地址空间，线程没有单独的地址空间（同一进程内的线程共享进程的地址空间）。</p>
<p>另一段解释：</p>
<p>进程，是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。它的执行需要系统分配资源创建实体之后，才能进行。</p>
<p>随着技术发展，在执行一些细小任务时，本身无需分配单独资源时（多个任务共享同一组资源即可，比如所有子进程共享父进程的资源），进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间。后来就有了专门的多任务技术被创造出来——线程。</p>
<p>线程的特点就是在不需要独立资源的情况下就可以运行。如此一来会极大节省资源开销，以及处理时间。</p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>进程（process）常常被定义为程序的执行。可以把一个进程看成是一个独立的程序，在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。</p>
<h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>线程（thread）则是某一进程中一路单独运行的程序。也就是说，线程存在于进程之中。一个进程由一个或多个线程构成，各线程共享相同的代码和全局数据，但各有其自己的堆栈。由于堆栈是每个线程一个，所以局部变量对每一线程来说是私有的。由于所有线程共享同样的代码和全局数据，它们比进程更紧密，比单独的进程间更趋向于相互作用，线程间的相互作用更容易些，因为<strong>它们本身就有某些供通信用的共享内存：进程的全局数据</strong>。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/yusiguyuan/article/details/12154823" target="_blank" rel="noopener">linux 内核 – 进程与线程</a></li>
<li><a href="https://www.jianshu.com/p/7ce30a806c51" target="_blank" rel="noopener">进程和线程的区别</a></li>
<li><a href="https://blog.csdn.net/forrest2009/article/details/6413756" target="_blank" rel="noopener">linux 下进程和线程的区别</a></li>
<li><a href="https://my.oschina.net/cnyinlinux/blog/422207" target="_blank" rel="noopener">Linux 进程与线程的区别</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>thread</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>MPEG-TS adaptation field 分析</title>
    <url>/2018/06/15/Transport-Stream-packet-layer/</url>
    <content><![CDATA[<p>分析 <code>MPEG-TS</code> 格式，涉及协议 <code>ISO13818-1</code></p>
<a id="more"></a>

<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><pre><code>47 40 8E 17 00 3C BF FD 02 00 C1 F7 FF 11 03 10
47 00 8E 18 48 7B 71 A1 AA DF F0 17 C5 70 16 78</code></pre><h2 id="Transport-Stream-packet-layer"><a href="#Transport-Stream-packet-layer" class="headerlink" title="Transport Stream packet layer"></a>Transport Stream packet layer</h2><p>Table 2-2 – Transport packet of this Recommendation | International Standard</p>
<pre><code>transport_packet(){
    sync_byte                                   8bits
    transport_error_indicator                   1bit
    payload_unit_start_indicator                1bit
    transport_priority                          1bit
    PID                                         13bits
    transport_scrambling_control                2bits
    adaptation_field_control                    2bits
    continuity_counter                          4bits
    if(adaptation_field_control = = &#39;10&#39; || adaptation_field_control = = &#39;11&#39;){
        adaptation_field()
    }
    if(adaptation_field_control = = &#39;01&#39; || adaptation_field_control = = &#39;11&#39;) {
        for (i = 0; i &lt; N; i++){
            data_byte                           8bits
        }
    }
}</code></pre><ul>
<li><code>sync_byte</code> 0x47</li>
<li><code>transport_error_indicator</code> When set to ‘1’ it indicates that at least 1 uncorrectable bit error exists in the associated Transport Stream packet.</li>
<li><code>payload_unit_start_indicator</code> which has normative meaning for Transport Stream packets that carry PES packets (refer to 2.4.3.6) or PSI data (refer to 2.4.4).</li>
<li><code>transport_priority</code></li>
</ul>
<h3 id="payload-unit-start-indicator"><a href="#payload-unit-start-indicator" class="headerlink" title="payload unit start indicator"></a>payload unit start indicator</h3><p><code>ts</code> 中携带的 <code>payload</code> 是 <code>PSI</code> or <code>PES</code> 是由如下规则来判断</p>
<p><code>TS</code> 根据 <code>payload unit start indicator</code> 来判断这个包中是否有 PES、PSI 分组</p>
<p>然后再去看 <code>data_byte</code> 前 24 位，是否为 <code>0x000001</code> 即 <code>pes_packet_start_code_prefix</code>，如果不是，那就是 psi 包</p>
<h4 id="PSI"><a href="#PSI" class="headerlink" title="PSI"></a>PSI</h4><p><code>payload_unit_start_indicator</code></p>
<ul>
<li><code>1</code> 表示这个 ts 包携带 psi section 头，表明这个传输流数据包的有效载荷的第一个字节携带 pointer_field</li>
<li><code>0</code></li>
</ul>
<blockquote>
<p>When the payload of the Transport Stream packet contains PSI data, the payload_unit_start_indicator has the following<br>significance: if the Transport Stream packet carries the first byte of a PSI section, the payload_unit_start_indicator value<br>shall be ‘1’, indicating that the first byte of the payload of this Transport Stream packet carries the pointer_field. If the<br>Transport Stream packet does not carry the first byte of a PSI section, the payload_unit_start_indicator value shall be ‘0’,<br>indicating that there is no pointer_field in the payload. Refer to 2.4.4.1 and 2.4.4.2. This also applies to private streams of<br>stream_type 5 (refer to Table 2-29).</p>
</blockquote>
<p><strong>pointer_field</strong></p>
<p>pointer_field – This is an 8-bit field whose value shall be the number of bytes, immediately following the pointer_field<br>until the first byte of the first section that is present in the payload of the Transport Stream packet (so a value of 0x00 in<br>the pointer_field indicates that the section starts immediately after the pointer_field).</p>
<h4 id="PES"><a href="#PES" class="headerlink" title="PES"></a>PES</h4><p>2.4.3.6 PES packet</p>
<p><code>packet_start_code_prefix</code> 0x000001</p>
<p><code>payload_unit_start_indicator</code></p>
<ul>
<li><code>1</code> 指示该传输流数据包的有效载荷将从第一个字节开始一个 PES 数据包</li>
<li><code>0</code> 表示在该传输流分组中不应该开始 PES 分组</li>
</ul>
<blockquote>
<p>When the payload of the Transport Stream packet contains PES packet data, the payload_unit_start_indicator has the<br>following significance: a ‘1’ indicates that the payload of this Transport Stream packet will commence with the first byte<br>of a PES packet and a ‘0’ indicates no PES packet shall start in this Transport Stream packet. If the<br>payload_unit_start_indicator is set to ‘1’, then one and only one PES packet starts in this Transport Stream packet. This<br>also applies to private streams of stream_type 6 (refer to Table 2-29).</p>
</blockquote>
<h2 id="Analyser"><a href="#Analyser" class="headerlink" title="Analyser"></a>Analyser</h2><pre><code>47 40 8E 17 00 3C BF FD 02 00 C1 F7 FF 11 03 10
47 00 8E 18 48 7B 71 A1 AA DF F0 17 C5 70 16 78</code></pre><p>第一个 ts， <code>payload_unit_start_indicator</code> 为 1, 判断为 <code>PSI</code>， <code>adaptation_field_control</code> 为 <code>0x1</code>， <code>data_bytes</code> 第一个字节为 <code>pointer_field</code></p>
<p>第二个 ts， <code>payload_unit_start_indicator</code> 为 0</p>
]]></content>
      <categories>
        <category>DVB</category>
      </categories>
      <tags>
        <tag>ISO13818</tag>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>kill pppd 之后串口不能正常工作</title>
    <url>/2018/06/15/gprs-can-not-work-with-pppd/</url>
    <content><![CDATA[<p>本文介绍 <code>pppd</code> 对信号 <code>SIGTERM</code> 的处理，以及错误方式关闭 pppd 带来的问题</p>
<a id="more"></a>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><code>GPRS</code> 模块正常工作之后需要关闭来使用串口 <code>/dev/ttyS0</code>，此时串口工作不正常</p>
<p>关闭方式为</p>
<pre><code>kill -9 pppd call wcdma</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将关闭方式修改为 <code>pppd</code> 提供的 <code>ppp-off</code></p>
<pre><code>#!/bin/sh
######################################################################
#
# Determine the device to be terminated.
#
if [ &quot;$1&quot; = &quot;&quot; ]; then
    DEVICE=ppp0
else
    DEVICE=$1
fi

######################################################################
#
# If the ppp0 pid file is present then the program is running. Stop it.
if [ -r /var/run/$DEVICE.pid ]; then
        kill -INT `cat /var/run/$DEVICE.pid`
#
# If the kill did not work then there is no process running for this
# pid. It may also mean that the lock file will be left. You may wish
# to delete the lock file at the same time.
        if [ ! &quot;$?&quot; = &quot;0&quot; ]; then
                rm -f /var/run/$DEVICE.pid
                echo &quot;ERROR: Removed stale pid file&quot;
                exit 1
        fi
#
# Success. Let pppd clean up its own junk.
        echo &quot;PPP link to $DEVICE terminated.&quot;
        exit 0
fi
#
# The ppp process is not running for ppp0
echo &quot;ERROR: PPP link is not active on $DEVICE&quot;
exit 1</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>kill</code> 发送的信号存在差异 <code>SIGKILL</code> 或 <code>SIGTERM</code></p>
<p><code>man pppd</code> 得到如下信息：</p>
<pre><code>SIGINT, SIGTERM
    These  signals  cause  pppd  to terminate the link (by closing LCP), restore the serial device settings, and exit.  If a connector or disconnector process is currently
    running, pppd will send the same signal to its process group, so as to terminate the connector or disconnector process.</code></pre><p>因此需要使用 <code>kill</code> 来发送信号 <code>SIGTERM</code> 来完成回收操作</p>
<h3 id="sourcecode"><a href="#sourcecode" class="headerlink" title="sourcecode"></a>sourcecode</h3><pre><code class="c">static void setup_signals()
{
    struct sigaction sa;

    /*
     * Compute mask of all interesting signals and install signal handlers
     * for each.  Only one signal handler may be active at a time.  Therefore,
     * all other signals should be masked when any handler is executing.
     */
    sigemptyset(&amp;signals_handled);
    sigaddset(&amp;signals_handled, SIGHUP);
    sigaddset(&amp;signals_handled, SIGINT);
    sigaddset(&amp;signals_handled, SIGTERM);
    sigaddset(&amp;signals_handled, SIGCHLD);
    sigaddset(&amp;signals_handled, SIGUSR2);

#define SIGNAL(s, handler)  do { \
    sa.sa_handler = handler; \
    if (sigaction(s, &amp;sa, NULL) &lt; 0) \
        fatal(&quot;Couldn&#39;t establish signal handler (%d): %m&quot;, s); \
    } while (0)

    sa.sa_mask = signals_handled;
    sa.sa_flags = 0;
    SIGNAL(SIGHUP, hup);        /* Hangup */
    SIGNAL(SIGINT, term);       /* Interrupt */
    SIGNAL(SIGTERM, term);      /* Terminate */
    SIGNAL(SIGCHLD, chld);

    SIGNAL(SIGUSR1, toggle_debug);  /* Toggle debug flag */
    SIGNAL(SIGUSR2, open_ccp);      /* Reopen CCP */

    ...
}</code></pre>
<pre><code class="pppd/main.c:">/*
 * term - Catch SIGTERM signal and SIGINT signal (^C/del).
 *
 * Indicates that we should initiate a graceful disconnect and exit.
 */
/*ARGSUSED*/
static void
term(sig)
    int sig;
{
    /* can&#39;t log a message here, it can deadlock */
    got_sigterm = sig;
    if (conn_running)
    /* Send the signal to the [dis]connector process(es) also */
    kill_my_pg(sig);
    notify(sigreceived, sig);
    if (waiting)
    siglongjmp(sigjmp, 1);
}</code></pre>
<p>最终通过 <code>asked_to_quit</code> 完成</p>
<pre><code>if (asked_to_quit) {
    bundle_terminating = 1;
    if (phase == PHASE_MASTER)
        mp_bundle_terminated();
}</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
        <tag>gprs</tag>
        <tag>pppd</tag>
        <tag>SIGKILL</tag>
        <tag>SIGTERM</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake-check-include-files</title>
    <url>/2018/06/12/cmake-check-include-files/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>Linux 图形编程简介</title>
    <url>/2018/06/11/linux-ui/</url>
    <content><![CDATA[<p>简单介绍 Linux 图形编程概念、协议及库</p>
<ul>
<li>SDL</li>
<li>OpenGL</li>
<li>DirectFB</li>
<li>FrameBuffer</li>
</ul>
<a id="more"></a>

<h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a><a href="https://en.wikipedia.org/wiki/OpenGL" target="_blank" rel="noopener">OpenGL</a></h2><p><code>OpenGL</code> is a standard specification defining a cross-language, cross-platform API for writing applications that produce 2D and 3D computer graphics. The interface consists of over 250 different function calls which can be used to draw complex three-dimensional scenes from simple primitives. OpenGL was developed by Silicon Graphics Inc. (SGI) in 1992[4] and is widely used in CAD, virtual reality, scientific visualization, information visualization, and flight simulation. It is also used in video games, where it competes with Direct3D on Microsoft Windows platforms (see OpenGL vs. Direct3D).</p>
<p><code>OpenGL</code> 是一套规范 (Specification)，由 <code>Khronos Group</code> 开发维护。<br>它主要为我们定义了用来操作图形和图片的一系列函数的 API，需要注意的是 OpenGL 本身并非 API。<br>GPU 的硬件开发商则需要提供满足 OpenGL 规范的实现，这些实现通常被称为“驱动”，它们负责将 OpenGL 定义的 API 命令翻译为 GPU 指令。</p>
<p>OpenGL 仅仅是标准，而如果你要使用 OpenGL，则需要找到可以实现这些 OpenGL 标准函数的程序库或源代码。<br>主要的 OpenGL|ES 程序库有：Klimt，Vincent (ogles)，TinyGL 等</p>
<h2 id="DirectX"><a href="#DirectX" class="headerlink" title="DirectX"></a>DirectX</h2><p>linux 不支持对于游戏来说非常重要的驱动——DirectX。</p>
<p>游戏驱动一般来说有两种——OpenGL 和 DirectX。<br>OpenGL 驱动不仅在游戏方面很重要，还在图形处理方面有举足轻重的作用。所以大家在装显卡驱动后都可以看到 OpenGL 的设置选项。几乎所有的操作系统（windows，linux，MacOS）都支持 OpenGL。<br><strong>DirectX 是微软专门 为游戏设计的一套驱动（程序接口）</strong></p>
<h2 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h2><p>SDL 是一个跨平台的多媒体库，它通过 OpenGL 和 2D 视频帧缓冲，提供了针对音频、视频、键盘、鼠标、控制杆及 3D 硬件的低级别的访问接口。</p>
<p><a href="http://www.libsdl.org/" target="_blank" rel="noopener">SDL</a> is a cross-platform multimedia library designed to provide low level access to audio, keyboard, mouse, joystick, etc. <strong>It also supports 3D hardware via OpenGL.</strong></p>
<p>SDL uses OpenGL as a hardware renderer for content that wants hardware rendering on some platforms. If you have such a platform, then OpenGL is the underlying API over which SDL is an abstraction.</p>
<p>SDL（Simple DirectMedia Layer）作为免费的跨平台多媒体应用编程接口，已经被人们广泛用于开发二维游戏，其优秀的消息框架支持、文件支持和声音支持都使得它能与微软 DirectX 匹敌。</p>
<p>现在很多 game 游戏里面，都采用 SDL+OpenGL ES 的模式来绘制 3D 界面。 可以让 SDL 使用 OpenGL ES 的函数接口来渲染 3D。</p>
<p>SDL 在结构上是将不同操作系统的库再包装成相同的函数，例如 SDL 在 Windows 平台上其实是 DirectX 的再包装。而在使用 X11 的平台上（包括 Linux），SDL 则是与 Xlib 库沟通来输出图像。</p>
<p><img src="/images/SDL/SDL.jpeg" alt="SDL Modules"></p>
<p>从图中可以看到 <code>SDL</code> 是平台性质，可以基于 <code>FB</code> 或 <code>OpenGL</code> 等</p>
<p>SDL 库分为 Video、Audio、CD-ROM、Joystick 和 Timer 等若干子系统，除此之外，还有一些单独的官方扩充函数库。这些库由官方网站提供，并包含在官方文档中，共同组成了 SDL 的“标准库”：</p>
<ul>
<li>SDL_image—支持时下流行的图像格式：BMP、PPM、XPM、 PCX、GIF、JPEG、PNG、TGA。</li>
<li>SDL_mixer—更多的声音输出函数以及更多的声音格式支持。</li>
<li>SDL_net—网络支持。</li>
<li>SDL_ttf—TrueType 字体渲染支持。</li>
<li>SDL_rtf—简单的 RTF 渲染支持。</li>
</ul>
<h2 id="Linux-FrameBuffer"><a href="#Linux-FrameBuffer" class="headerlink" title="Linux FrameBuffer"></a>Linux FrameBuffer</h2><p>Linux 下的 framebuffer 是用于在显示器上显示图像的硬件无关抽象层，意味着包含当前视频帧的一块内存区域</p>
<p>Framebuffer 看成是显示内存的一个映像，将其映射到进程地址空间之后，可以直接进行读写操作，写操作可以立即反应在屏幕上，这种操作是抽象统一的，用户态进程不必关心物理显存的位置、换页机制等等具体细节（由 Framebuffer 设备驱动来完成）</p>
<p><code>Framebuffer</code> 对应的设备文件一般是 <code>/dev/fb0</code>、 <code>/dev/fb1</code> 等</p>
<p>使用方法：</p>
<ul>
<li>打开 framebuffer 设备 (/dev/fbX)</li>
<li>通过 ioctl FBIOGET_VSCREENINFO 命令获取当前 fb_var_screeninfo 信息</li>
<li>设置需要修改的 fb_var_screeninfo 参数，并通过 ioctl FBIOPUT_VSCREENINFO 设置这些信息（可选）</li>
<li>设置 global alpha 和 blank/unblank 参数，通过用于多个 fb 的情况（可选）</li>
<li>计算屏幕的总大小（占用字节数）: xres * yres * bits_per_pixel / 8</li>
<li>映射到用户进程地址空间：mmap</li>
<li>往映射的地址空间写入数据</li>
<li>删除映射 (munmap), 关闭 framebuffer 设备</li>
</ul>
<h2 id="DirectFB"><a href="#DirectFB" class="headerlink" title="DirectFB"></a>DirectFB</h2><p>DirectFB 项目是由德国 Convergence 公司推动的 Open source 计划的一部分，它是专门为满足嵌入式设备要求而开发的小巧、强大、灵活和易于使用的图形系统，并且试图成为一个建构于 Linux Framebuffer Device 之上的新图形标准。它在 FrameBuffer 的基础上提供了图形加速、输入设备处理提取、透明窗口和多重显示层的功能，能够对嵌入式系统 GUI 有较好的支持。与那些通用的嵌入式 GUI 系统相比，它具有非常简洁、高效的体系结构和硬件图形加速功能。</p>
<p>DirectFB 是一个轻量级的提供硬件图形加速，输入设备处理和抽象的图形库，它集成了支持半透明的视窗系统以及在 LinuxFramebuffer 驱动之上的多层显示。它是一个用软件封装当前硬件无法支持的图形算法来完成硬件加速的层。DirectFB 是为嵌入式系统而设计。它是以最小的资源开销来实现最高的硬件加速性能。</p>
<p>DirectFB 是图形 API 存在于 Frame Buffer 层之上与高级图形管理层如 GTK+ 等之下的。它可以以很小的系统资源占用来提供图形硬件加速功能，提供类如多路 a 通道渲染模型等高级图像操作。它不修改 Linux 内核，除了标准 C 库没有其他库的依赖。应用在了基于 Linux 系统的 DTV 显示系统的研发和其他有关 Linux 显示界面的项目上。支持市面上绝大多数显示卡，支持键盘、鼠标、遥控器、游戏手柄、触摸屏等输入设备。支持 JPEG、PNG、GIF、mpeg1/2、AVI、MOV、Flash、Video4Linux、DirectFB bitmap font 和 TrueType 等音视频文件和字体。</p>
<p><code>DirectFB</code> 在系统中的位置</p>
<p><img src="/images/SDL/DFB.jpeg" alt="DFB"></p>
<p><code>DirectFB GUI</code> 架构</p>
<p><img src="/images/SDL/DFBS.jpeg" alt="DFB Modules"></p>
<p>对于底层的驱动来说，DirectFB 里面负责和硬件打交道的显卡的驱动（gfxdriver）和显示系统（system），这里面 gfxdriver 是和各个硬件平台相关的，有可能需要自己写。 为了更易于理解 DirectFB，需要先介绍几个 DirectFB 里面的概念：</p>
<ul>
<li>Layers：代表互相独立的图形缓存。大多数嵌入式设备都有多个 layer。多个 layer 根据对应的 alpha 值混合 在一起，从而显示出来。</li>
<li>Surface：代表一块预留的内存，来保存像素数据。DirectFB 中的 Drawing，Bilitting 操作就是基于 surface 的。Surface 的内存根据设定，可以从系统中分配，也可以从显卡的内存中分配。</li>
<li>Primary Surface：代表一个特殊 layer 的特殊 surface。如果 primary surface 是单缓冲的，任何对于 primary surface 的操作都会直接反应到显示屏上。</li>
<li>Subsurface：是一个 surfac 的子集，但是自身并不占有任何内存。</li>
<li>Window/Windowstack：控制一个 layer 中的 surface 该显示什么。Window 属于某个背景可以设定的 layer。 每个 window 有自己的 surface，window 用这个 surface 来组合图像。</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.zhihu.com/question/51867884" target="_blank" rel="noopener">OpenGL 是什么？</a></li>
<li><a href="http://tiankefeng0520.iteye.com/blog/2010741" target="_blank" rel="noopener">OpenGL 与 DirectX 比较</a></li>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/11954039" target="_blank" rel="noopener">SDL 介绍</a></li>
<li><a href="http://www.cnblogs.com/hzl6255/p/5476012.html" target="_blank" rel="noopener">Linux framebuffer 的介绍和使用</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux FB</tag>
        <tag>SDL</tag>
        <tag>OpenGL</tag>
        <tag>DirectFB</tag>
      </tags>
  </entry>
  <entry>
    <title>更新 NexT 主题并集成站内搜索</title>
    <url>/2018/06/07/hexo-update-theme-next/</url>
    <content><![CDATA[<p>Hexo 更新 NexT 主题并添加搜索功能</p>
<a id="more"></a>

<h2 id="更新-NexT"><a href="#更新-NexT" class="headerlink" title="更新 NexT"></a>更新 NexT</h2><p>更新 <code>NexT</code> 到最新的 <code>5.1.4</code> 版本</p>
<pre><code>git clone --branch v5.1.4 https://github.com/iissnan/hexo-theme-next themes/next5</code></pre><p>修改 <code>_config.yml</code></p>
<pre><code>theme: next5</code></pre><p>对照之前 <code>next</code> 中的配置文件修改</p>
<ul>
<li>menu</li>
<li>scheme</li>
<li>social</li>
<li>sidebar</li>
<li>highlight_theme</li>
<li>since</li>
</ul>
<p><code>hexo c</code> <code>hexo s</code> 打开浏览器检查是否更新完毕</p>
<h2 id="NexT-第三方服务集成"><a href="#NexT-第三方服务集成" class="headerlink" title="NexT 第三方服务集成"></a><a href="http://theme-next.iissnan.com/third-party-services.html#search-system" target="_blank" rel="noopener">NexT 第三方服务集成</a></h2><p><a href="http://theme-next.iissnan.com/third-party-services.html#search-system" target="_blank" rel="noopener">搜索服务</a></p>
<p>NexT 支持集成 Swiftype、微搜索、Local Search 和 Algolia。</p>
<h3 id="Local-Search"><a href="#Local-Search" class="headerlink" title="Local Search"></a>Local Search</h3><h4 id="安装-hexo-generator-searchdb"><a href="#安装-hexo-generator-searchdb" class="headerlink" title="安装 hexo-generator-searchdb"></a>安装 <code>hexo-generator-searchdb</code></h4><pre><code>npm install hexo-generator-searchdb --save</code></pre><h4 id="编辑-站点配置文件"><a href="#编辑-站点配置文件" class="headerlink" title="编辑 站点配置文件"></a>编辑 <code>站点配置文件</code></h4><p>新增以下内容到任意位置：</p>
<pre><code>search:
  path: search.xml
  field: post
  format: html
  limit: 10000</code></pre><h4 id="编辑-主题配置文件，启用本地搜索功能"><a href="#编辑-主题配置文件，启用本地搜索功能" class="headerlink" title="编辑 主题配置文件，启用本地搜索功能"></a>编辑 <code>主题配置文件</code>，启用本地搜索功能</h4><pre><code># Local search
local_search:
  enable: true</code></pre><h3 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h3><p><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">Algolia – Next 文档</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 开启字数统计</title>
    <url>/2018/06/07/hexo-wordcount/</url>
    <content><![CDATA[<p>Hexo NexT 主题开启字数统计及阅读时长功能</p>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>NexT 主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，只需要在主题配置文件 <code>_config.yml</code> 中打开 <code>wordcount</code> 统计功能即可。如下所示：</p>
<pre><code># Post wordcount display settings
# Dependencies: https://github.com/willin/hexo-wordcount
post_wordcount:
  item_text: true
  wordcount: true         # 单篇 字数统计
  min2read: true          # 单篇 阅读时长
  totalcount: false       # 网站 字数统计
  separated_meta: true</code></pre><p>PS: 如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm i --save hexo-wordcount</code></pre><p>##</p>
<p>修改完成后，重新执行启动服务预览就可以了</p>
<pre><code>hexo clean
hexo s</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>upnp</title>
    <url>/2018/06/06/upnp/</url>
    <content><![CDATA[<p>UPnP 是针对智能家电、无线设备以及各种外观尺寸的个人电脑的普遍对等<br>(peer-to-peer) 网络连接而设计的一种架构。它旨在为家庭、小型企业、公共<br>场所中或连接到互联网的 ad-hoc 网或未管理网络提供易于使用、灵活且基于标<br>准的连接。UPnP 是一个充分利用 TCP/IP 和 Web 技术的分布式开放型网络体<br>系结构，除能够在家中、办公室和公共场所联网设备之间的完整控制和数据传输<br>之外，还可建立无缝紧密的连接网络。</p>
<p>何为 UPnP 的“通用性”? 不使用设备驱动程序；取而代之的是通用协议。<br>UPnP 网络不依赖于任意媒体。UPnP 设备可以在任何操作系统上采用任何编程<br>语言来实现。UPnP 并未针对运行于控制点上的应用而指明或限制 API 的设计；<br>操作系统厂商可以创建满足其客户需求的 API。UPnP 通过使用浏览器和传统应<br>用程序控制来使厂商能够控制设备的用户界面 (UI) 并实现交互。</p>
<a id="more"></a>

<h2 id="UPnP-设备框架"><a href="#UPnP-设备框架" class="headerlink" title="UPnP 设备框架"></a>UPnP 设备框架</h2><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/other/UPnP/part1/index.html" target="_blank" rel="noopener">UPnP 协议编程实践 I</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/other/UPnP/part2/index.html" target="_blank" rel="noopener">UPnP 协议编程实践 II</a></li>
<li>[UPNP1.0 中文版』</li>
<li><a href="https://www.jianshu.com/p/91b508b0260b" target="_blank" rel="noopener">DLNA 与 UPnP 初探</a></li>
<li><a href="https://blog.csdn.net/white_cloth/article/details/52870233" target="_blank" rel="noopener">DLNA 协议总结</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>upnp</tag>
      </tags>
  </entry>
  <entry>
    <title>op-tee</title>
    <url>/2018/05/24/op-tee/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/shuaifengyun/article/details/73716352" target="_blank" rel="noopener">trustzone 与 OP-TEE 介绍导读</a></li>
<li><a href="https://blog.csdn.net/shuaifengyun" target="_blank" rel="noopener">shuaifengyun 的专栏</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>TrustZone</title>
    <url>/2018/05/23/TrustZone/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/guyongqiangx/article/details/78020257" target="_blank" rel="noopener">一篇了解 TrustZone</a></li>
<li><a href="https://blog.csdn.net/forestcell/article/list/2" target="_blank" rel="noopener">TrustZone 领域先行者</a></li>
<li><a href="https://blog.csdn.net/braveheart95/article/details/8878319" target="_blank" rel="noopener">TrustZone 技术简介</a></li>
<li><a href="https://blog.csdn.net/hovan/article/details/42520879" target="_blank" rel="noopener">trust zone 之我见</a></li>
<li><a href="https://blog.csdn.net/guoqun01/article/details/51425091" target="_blank" rel="noopener">简谈高通 Trustzone 的实现</a></li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.prd29-genc-009492c/PRD29-GENC-009492C_trustzone_security_whitepaper.pdf" target="_blank" rel="noopener">ARM Security Technology</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>indent 选项</title>
    <url>/2018/04/28/indent-options/</url>
    <content><![CDATA[<p>本文介绍 <code>Indent</code> 各个选项，用来格式化代码</p>
<a id="more"></a>

<h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><ul>
<li>–blank-lines-after-declarations    bad   变量声明后加空行</li>
<li>–blank-lines-after-procedures      bap   函数结束后加空行</li>
<li>–blank-lines-before-block-comments bbb   块注释前加空行</li>
<li>–break-before-boolean-operator     bbo   较长的行，在逻辑运算符前分行</li>
<li>–blank-lines-after-commas          nbc   变量声明中，逗号分隔的变量不分行</li>
<li>–braces-after-if-line              bl    “if”和”{“分做两行</li>
<li>–brace-indent 0                    bli0  “{“不继续缩进</li>
<li>–braces-after-struct-decl-line     bls   定义结构，”struct”和”{“分行</li>
<li>–comment-indentationn              c33   语句后注释开始于行 33</li>
<li>–declaration-comment-columnn       cd33  变量声明后注释开始于行 33</li>
<li>–comment-delimiters-on-blank-lines ncdb  不将单行注释变为块注释</li>
<li>–cuddle-do-while                   ncdw  “do    — while”的”while”和其前面的”}”另起一行</li>
<li>–cuddle-else                       nce   “else”和其前面的”}”另起一行</li>
<li>–case-indentation 0                cli0  switch 中的 case 语句所进 0 个空格</li>
<li>–else-endif-columnn                cp33  #else, #endif 后面的注释开始于行 33</li>
<li>–space-after-cast                  cs    在类型转换后面加空格</li>
<li>–line-comments-indentation n       d0    单行注释（不从 1 列开始的），不向左缩进</li>
<li>–break-function-decl-args          nbfda 关闭：函数的参数一个一行</li>
<li>–declaration-indentationn          di2   变量声明，变量开始于 2 行，即不必对齐</li>
<li>–format-first-column-comments      nfc1  不格式化起于第一行的注释</li>
<li>–format-all-comments               nfca  不开启全部格式化注释的开关</li>
<li>–honour-newlines                   hnl   Prefer to  break long lines at the position of newlines in the input.</li>
<li>–indent-leveln                     i4    设置缩进多少字符，如果为 tab 的整数倍，用 tab 来缩进，否则用空格填充。</li>
<li>–parameter-indentationn            ip5   旧风格的函数定义中参数说明缩进 5 个空格</li>
<li>–line-length 75                    l75   非注释行最长 75</li>
<li>–continue-at-parentheses           lp    续行从上一行出现的括号开始</li>
<li>–space-after-procedure-calls       pcs   函数和”(“之间插入一个空格</li>
<li>–space-after-parentheses           nprs  在”（”后”）”前不插入空格</li>
<li>–procnames-start-lines             psl   将函数名和返回类型放在两行定义</li>
<li>–space-after-for                   saf   for 后面有空格</li>
<li>–space-after-if                    sai   if 后面有空格</li>
<li>–space-after-while                 saw   while 后面有空格</li>
<li>–start-left-side-of-comments       nsc   不在生成的块注释中加*</li>
<li>–swallow-optional-blank-lines      nsob  不去掉可添加的空行</li>
<li>–space-special-semicolon           nss   一行的 for 或 while 语句，在”;”前不加空。</li>
<li>–tab-size                          ts4   一个 tab 为 4 个空格（要能整除”-in”）</li>
<li>–use-tabs                          ut    使用 tab 来缩进</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.gnu.org/software/indent/manual/indent.pdf" target="_blank" rel="noopener">Indent</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds3/indent.htm" target="_blank" rel="noopener">indent 命令</a></li>
<li><a href="http://www.cnblogs.com/haippy/archive/2012/08/29/2662772.html" target="_blank" rel="noopener">如何使用 indent 美化你的代码</a></li>
<li><a href="https://www.gnu.org/software/indent/manual/html_section/indent_4.html#SEC4" target="_blank" rel="noopener">Common styles</a></li>
<li><a href="http://www.worldhello.net/doc/program_rules/indent.html" target="_blank" rel="noopener">用 indent 进行代码格式化</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>style</tag>
        <tag>indent</tag>
      </tags>
  </entry>
  <entry>
    <title>clang-format 格式化代码</title>
    <url>/2018/04/28/clang-format-options/</url>
    <content><![CDATA[<p>Clang-Format 可用于格式化（排版）多种不同语言的代码，其自带的排版格式主要有：LLVM, Google, Chromium, Mozilla, WebKit。</p>
<p>但是自带的这几种排版格式可能并不满足个人编码习惯的全部要求，Clang-Format 也提供了使用自定义排版格式的功能。</p>
<p>如果在 Ubuntu 中安装了 Clang-Format，则可以使用以下命令导出上述 5 种自带的排版格式，并且可以对其中某一个导出的文件进行修改，实现自定义格式化：</p>
<pre><code>clang-format -style= 格式名 -dump-config &gt; 文件名</code></pre><a id="more"></a>

<h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><pre><code>---
# 语言：None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto
Language:   Cpp
# BasedOnStyle: LLVM
# 访问说明符 (public、private 等）的偏移
AccessModifierOffset:   -4
# 开括号（开圆括号、开尖括号、开方括号）后的对齐：Align, DontAlign, AlwaysBreak（总是在开括号后换行）
AlignAfterOpenBracket:  Align
# 连续赋值时，对齐所有等号
AlignConsecutiveAssignments:    true
# 连续声明时，对齐所有声明的变量名
AlignConsecutiveDeclarations:   true
# 左对齐逃脱换行（使用反斜杠换行）的反斜杠
AlignEscapedNewlinesLeft:   true
# 水平对齐二元和三元表达式的操作数
AlignOperands:  true
# 对齐连续的尾随的注释
AlignTrailingComments:  true
# 允许函数声明的所有参数在放在下一行
AllowAllParametersOfDeclarationOnNextLine:  true
# 允许短的块放在同一行
AllowShortBlocksOnASingleLine:  false
# 允许短的 case 标签放在同一行
AllowShortCaseLabelsOnASingleLine:  false
# 允许短的函数放在同一行：None, InlineOnly（定义在类中）, Empty（空函数）, Inline（定义在类中，空函数）, All
AllowShortFunctionsOnASingleLine:   Empty
# 允许短的 if 语句保持在同一行
AllowShortIfStatementsOnASingleLine:    false
# 允许短的循环保持在同一行
AllowShortLoopsOnASingleLine:   false
# 总是在定义返回类型后换行 (deprecated)
AlwaysBreakAfterDefinitionReturnType:   None
# 总是在返回类型后换行：None, All, TopLevel（顶级函数，不包括在类中的函数）,
#   AllDefinitions（所有的定义，不包括声明）, TopLevelDefinitions（所有的顶级函数的定义）
AlwaysBreakAfterReturnType: None
# 总是在多行 string 字面量前换行
AlwaysBreakBeforeMultilineStrings:  false
# 总是在 template 声明后换行
AlwaysBreakTemplateDeclarations:    false
# false 表示函数实参要么都在同一行，要么都各自一行
BinPackArguments:   true
# false 表示所有形参要么都在同一行，要么都各自一行
BinPackParameters:  true
# 大括号换行，只有当 BreakBeforeBraces 设置为 Custom 时才有效
BraceWrapping:
  # class 定义后面
  AfterClass:   false
  # 控制语句后面
  AfterControlStatement:    false
  # enum 定义后面
  AfterEnum:    false
  # 函数定义后面
  AfterFunction:    false
  # 命名空间定义后面
  AfterNamespace:   false
  # ObjC 定义后面
  AfterObjCDeclaration: false
  # struct 定义后面
  AfterStruct:  false
  # union 定义后面
  AfterUnion:   false
  # catch 之前
  BeforeCatch:  true
  # else 之前
  BeforeElse:   true
  # 缩进大括号
  IndentBraces: false
# 在二元运算符前换行：None（在操作符后换行）, NonAssignment（在非赋值的操作符前换行）, All（在操作符前换行）
BreakBeforeBinaryOperators: NonAssignment
# 在大括号前换行：Attach（始终将大括号附加到周围的上下文）, Linux（除函数、命名空间和类定义，与 Attach 类似）,
#   Mozilla（除枚举、函数、记录定义，与 Attach 类似）, Stroustrup（除函数定义、catch、else，与 Attach 类似）,
#   Allman（总是在大括号前换行）, GNU（总是在大括号前换行，并对于控制语句的大括号增加额外的缩进）, WebKit（在函数前换行）, Custom
#   注：这里认为语句块也属于函数
BreakBeforeBraces:  Custom
# 在三元运算符前换行
BreakBeforeTernaryOperators:    true
# 在构造函数的初始化列表的逗号前换行
BreakConstructorInitializersBeforeComma:    false
# 每行字符的限制，0 表示没有限制
ColumnLimit:    200
# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变
CommentPragmas: &#39;^ IWYU pragma:&#39;
# 构造函数的初始化列表要么都在同一行，要么都各自一行
ConstructorInitializerAllOnOneLineOrOnePerLine: false
# 构造函数的初始化列表的缩进宽度
ConstructorInitializerIndentWidth:  4
# 延续的行的缩进宽度
ContinuationIndentWidth:    4
# 去除 C++11 的列表初始化的大括号{后和}前的空格
Cpp11BracedListStyle:   false
# 继承最常用的指针和引用的对齐方式
DerivePointerAlignment: false
# 关闭格式化
DisableFormat:  false
# 自动检测函数的调用和定义是否被格式为每行一个参数 (Experimental)
ExperimentalAutoDetectBinPacking:   false
# 需要被解读为 foreach 循环而不是函数调用的宏
ForEachMacros:  [ foreach, Q_FOREACH, BOOST_FOREACH ]
# 对#include 进行排序，匹配了某正则表达式的#include 拥有对应的优先级，匹配不到的则默认优先级为 INT_MAX（优先级越小排序越靠前），
#   可以定义负数优先级从而保证某些#include 永远在最前面
IncludeCategories:
  - Regex:  &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;
    Priority:   2
  - Regex:  &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;
    Priority:   3
  - Regex:  &#39;.*&#39;
    Priority:   1
# 缩进 case 标签
IndentCaseLabels:   false
# 缩进宽度
IndentWidth:    4
# 函数返回类型换行时，缩进函数声明或函数定义的函数名
IndentWrappedFunctionNames: false
# 保留在块开始处的空行
KeepEmptyLinesAtTheStartOfBlocks:   true
# 开始一个块的宏的正则表达式
MacroBlockBegin:    &#39;&#39;
# 结束一个块的宏的正则表达式
MacroBlockEnd:  &#39;&#39;
# 连续空行的最大数量
MaxEmptyLinesToKeep:    1
# 命名空间的缩进：None, Inner（缩进嵌套的命名空间中的内容）, All
NamespaceIndentation:   Inner
# 使用 ObjC 块时缩进宽度
ObjCBlockIndentWidth:   4
# 在 ObjC 的 @property 后添加一个空格
ObjCSpaceAfterProperty: false
# 在 ObjC 的 protocol 列表前添加一个空格
ObjCSpaceBeforeProtocolList:    true
# 在 call（后对函数调用换行的 penalty
PenaltyBreakBeforeFirstCallParameter:   19
# 在一个注释中引入换行的 penalty
PenaltyBreakComment:    300
# 第一次在&lt;《前换行的 penalty
PenaltyBreakFirstLessLess:  120
# 在一个字符串字面量中引入换行的 penalty
PenaltyBreakString: 1000
# 对于每个在行字符数限制之外的字符的 penalty
PenaltyExcessCharacter: 1000000
# 将函数的返回类型放到它自己的行的 penalty
PenaltyReturnTypeOnItsOwnLine:  60
# 指针和引用的对齐：Left, Right, Middle
PointerAlignment:   Left
# 允许重新排版注释
ReflowComments: true
# 允许排序#include
SortIncludes:   true
# 在 C 风格类型转换后添加空格
SpaceAfterCStyleCast:   false
# 在赋值运算符之前添加空格
SpaceBeforeAssignmentOperators: true
# 开圆括号之前添加一个空格：Never, ControlStatements, Always
SpaceBeforeParens:  ControlStatements
# 在空的圆括号中添加空格
SpaceInEmptyParentheses:    false
# 在尾随的评论前添加的空格数（只适用于 //)
SpacesBeforeTrailingComments:   2
# 在尖括号的《后和》前添加空格
SpacesInAngles: true
# 在容器 (ObjC 和 JavaScript 的数组和字典等）字面量中添加空格
SpacesInContainerLiterals:  true
# 在 C 风格类型转换的括号中添加空格
SpacesInCStyleCastParentheses:  true
# 在圆括号的（后和）前添加空格
SpacesInParentheses:    true
# 在方括号的『后和』前添加空格，lamda 表达式和未指明大小的数组的声明不受影响
SpacesInSquareBrackets: true
# 标准：Cpp03, Cpp11, Auto
Standard:   Cpp11
# tab 宽度
TabWidth:   4
# 使用 tab 字符：Never, ForIndentation, ForContinuationAndIndentation, Always
UseTab: Never
...</code></pre><h2 id="how-to-use"><a href="#how-to-use" class="headerlink" title="how to use"></a>how to use</h2><pre><code>clang-format -style=file in.c &gt; out.c</code></pre><ol>
<li><a href="https://blog.csdn.net/softimite_zifeng/article/details/78357898" target="_blank" rel="noopener">Clang-Format 格式化选项介绍</a></li>
<li><a href="https://github.com/KratosMultiphysics/Kratos/wiki/How-to-configure-clang%E2%80%90format" target="_blank" rel="noopener">How to configure clang‐format</a></li>
<li><a href="http://clang.llvm.org/docs/ClangFormat.html" target="_blank" rel="noopener">Clang 7 documentation</a></li>
<li><a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">Clang-Format Style Options</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>style</tag>
        <tag>clang-format</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp sack 选项对网络性能的影响</title>
    <url>/2018/04/17/tcp-sack/</url>
    <content><![CDATA[<p><strong>SACK(Selective Acknowledgment)</strong> 是一个 TCP 的选项，来允许 TCP 单独确认非连续的片段，用于告知真正丢失的包，只重传丢失的片段。</p>
<a id="more"></a>

<h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p>SACK 是一个 TCP 的选项，来允许 TCP 单独确认非连续的片段，用于告知真正丢失的包，只重传丢失的片段。要使用 SACK，2 个设备必须同时支持 SACK 才可以，建立连接的时候需要使用 SACK Permitted 的 option，如果允许，后续的传输过程中 TCP segment 中的可以携带 SACK option，这个 option 内容包含一系列的非连续的没有确认的数据的 seq range，这些 SYN 包中 SACK Permitted 选项，双方都支持才对</p>
<h2 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h2><p>最大报文传输段，MAX Segment Size</p>
<h2 id="Window-Scaling"><a href="#Window-Scaling" class="headerlink" title="Window Scaling"></a>Window Scaling</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.csdn.net/wdscq1234/article/details/52503315" target="_blank" rel="noopener">TCP-IP 详解：SACK 选项（Selective Acknowledgment）</a></li>
<li><a href="https://tools.ietf.org/html/rfc2018" target="_blank" rel="noopener">TCP Selective Acknowledgment Options</a></li>
<li><a href="https://blog.csdn.net/u011130578/article/details/44925903" target="_blank" rel="noopener">选择确认（SACK）选项</a></li>
<li><a href="http://www.lovemytool.com/blog/2017/04/what-do-tcpip-selective-acknowledgments-sacks-look-like-by-phillip-storey.html" target="_blank" rel="noopener">What Do TCP/IP Selective Acknowledgments (SACKs) Look Like? (by Phillip Storey)</a></li>
<li><a href="http://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/" target="_blank" rel="noopener">TCP Selective Acknowledgments (SACK)</a></li>
<li><a href="https://wenku.baidu.com/view/f1dbf97390c69ec3d5bb75d9.html" target="_blank" rel="noopener">结合 Wireshark 捕获分组深入理解 TCPIP 协议栈之 TCP 协议</a></li>
<li><a href="http://www.bkjia.com/fwqyj/1210923.html" target="_blank" rel="noopener">TCP 接收窗口 – 确定 Window Scaling</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>Tools</category>
        <category>TCP</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>sack</tag>
      </tags>
  </entry>
  <entry>
    <title>将一个仓库中的子目录保留记录移动到另外一个仓库</title>
    <url>/2018/03/13/moving-subdir-from-one-git-repository-to-another-preserving-history/</url>
    <content><![CDATA[<p>使用 <code>git</code> 将一个仓库中的子目录移动到另一个仓库中，同时保留所有的上传历史记录</p>
<a id="more"></a>

<p>Before:</p>
<pre><code>repositoryA/
.........../directoryToKeep
.........../otherDirectory
.........../someFile.ext

repositoryB/
.........../someStuff</code></pre><p>After:</p>
<pre><code>repositoryA/
.........../otherDirectory
.........../someFile.ext

repositoryB/
.........../someStuff
.........../directoryToKeep</code></pre><h2 id="delete-commits"><a href="#delete-commits" class="headerlink" title="delete commits"></a>delete commits</h2><p>回滚仓库</p>
<pre><code>git reset --hard &lt;sha1-commit-id&gt;
git push origin HEAD --force</code></pre><p>使用 <code>patch</code></p>
<pre><code>$ git apply --check my_pcc_branch.patch
warning: src/main/java/.../AbstractedPanel.java has type 100644, expected 100755
error: patch failed: src/main/java/.../AbstractedPanel.java:13
error: src/main/java/.../AbstractedPanel.java: patch does not apply</code></pre><pre><code>git am --ignore-space-change --ignore-whitespace *.patch</code></pre><h2 id="Prepare-the-source-repository"><a href="#Prepare-the-source-repository" class="headerlink" title="Prepare the source repository"></a>Prepare the source repository</h2><pre><code>$ tree package/devfe
├── demod               //we need this dir
├── Makefile
└── S04frontend</code></pre><pre><code>git clone &lt;git repository A url&gt; -b dev
cd &lt;git repository A directory&gt;
git remote rm origin
git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch package/devfe/Makefile&#39; --prune-empty --tag-name-filter cat -- --all
git filter-branch --subdirectory-filter package/devfe/ -- --all //Notice: devfe NOT devfe/demod
git add .
git commit --amend
git log . // check</code></pre><h2 id="Merge-into-target-repository"><a href="#Merge-into-target-repository" class="headerlink" title="Merge into target repository"></a>Merge into target repository</h2><p><strong>example 1</strong></p>
<pre><code>git clone &lt;git repository B url&gt;
cd &lt;git repository B directory&gt;
git remote add repo-A-branch &lt;git repository A directory&gt;
git pull repo-A-branch master --allow-unrelated-histories
git remote rm repo-A-branch</code></pre><p><strong>example 2</strong></p>
<pre><code># based on the following:
# http://saintgimp.org/2013/01/22/merging-two-git-repositories-into-one-repository-without-losing-file-history/
# http://blog.caplin.com/2013/09/18/merging-two-git-repositories/

git clone repo_main
git clone repo_sub
cd repo_main

git remote add repo_sub ../repo_sub
git fetch repo_sub

git checkout -b repo_sub repo_sub/master
mkdir dir_repo_sub

# &#39;*&#39; will cause git mv to fail because it cannot move dir_repo_sub into itself
git mv &lt;list all files&gt;
git commit -m&quot;Moves all repo_sub files into a single directory for merging back into repo_main&quot;

git checkout master
git merge repo_sub

# commit and push, and you&#39;re finished</code></pre><pre><code>git clone &lt;git respository B directory&gt;</code></pre><p>After:</p>
<pre><code>repositoryA/
.........../demod
.........../.git

repositoryB/
.........../someStuff
.........../.git</code></pre><pre><code>cd B
git remote add demod ../repositoryA
git fetch demod
git checkout -b demod demod/dev
git checkout dev
git merge demod --allow-unrelated-histories
git commit --amend //commit log
git push / repo upload .</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://gbayer.com/development/moving-files-from-one-git-repository-to-another-preserving-history/" target="_blank" rel="noopener">1</a></li>
<li><a href="https://gist.github.com/smdabdoub/17065c348289158277b5" target="_blank" rel="noopener">merge_git_repo_as_subdir</a></li>
<li><a href="https://mattsch.com/2015/06/19/move-directory-from-one-repository-to-another-preserving-history/" target="_blank" rel="noopener">Move directory from one repository to another, preserving history</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title>iperf</title>
    <url>/2018/03/05/iperf/</url>
    <content><![CDATA[<p><code>iperf</code> 命令是一个网络性能测试工具。 <code>iperf</code> 可以测试 TCP 和 UDP 带宽质量。 <code>iperf</code> 可以测量最大 TCP 带宽，具有多种参数和 UDP 特性。 <code>iperf</code> 可以报告带宽，延迟抖动和数据包丢失。利用 <code>iperf</code> 这一特性，可以用来测试一些网络设备如路由器，防火墙，交换机等的性能。</p>
<a id="more"></a>

<h2 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h2><p><a href="http://man.linuxde.net/iperf" target="_blank" rel="noopener">命令</a></p>
<p>Transfer 列输出每秒的数量量在 370MB 左右，Bandwidth 列显示网卡的速率</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>在 udp 模式下，以 100Mbps 为数据发送速率，客户端到服务器 192.168.1.1 上传带宽测试，测试时间为 60 秒。</p>
<pre><code>iperf -u -c 192.168.1.1 -b 100M -t 60</code></pre><p>以 100M 为数据发送速率，进行上下行带宽测试。</p>
<pre><code>iperf -u -c 192.168.1.1 -b 100M -d -t 60</code></pre><p>测试 UDP 丢包和延迟，使用 -u 参数指定 UDP 协议，-b（K|M|G）参数指定 UD 式使用的带宽模式</p>
<pre><code>[root@web2 ~]# iperf3 -c 192.168.1.250 -u -b 1G -f M -i 2
Connecting to host 192.168.1.250, port 5201
[  4] local 192.168.1.209 port 45424 connected to 192.168.1.250 port 5201
[ ID] Interval           Transfer     Bandwidth       Total Datagrams
[  4]   0.00-2.00   sec  81.1 MBytes  40.5 MBytes/sec  10377
[  4]   2.00-4.00   sec  94.5 MBytes  47.3 MBytes/sec  12102
[  4]   4.00-6.00   sec  94.6 MBytes  47.3 MBytes/sec  12107
[  4]   6.00-8.00   sec   103 MBytes  51.5 MBytes/sec  13192
[  4]   8.00-10.00  sec  93.6 MBytes  46.8 MBytes/sec  11983
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams
[  4]   0.00-10.00  sec   467 MBytes  46.7 MBytes/sec  0.037 ms  435/59760 (0.73%)
[  4] Sent 59760 datagrams

iperf Done.</code></pre><p>由输出结果显示，Jitter 表示抖动时间，或者称为传输延迟，Lost/Total 表示丢失的数据包和总的数据包数量，Datagrams 表示总共传输数据包的数量</p>
<pre><code>#在服务端的输出
Accepted connection from 192.168.1.209, port 58179
[  5] local 192.168.1.250 port 5201 connected to 192.168.1.209 port 45424
[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams
[  5]   0.00-1.00   sec  35.6 MBytes   299 Mbits/sec  0.054 ms  29/4590 (0.63%)
[  5]   1.00-2.00   sec  43.0 MBytes   361 Mbits/sec  0.071 ms  30/5533 (0.54%)
[  5]   2.00-3.00   sec  48.4 MBytes   406 Mbits/sec  0.154 ms  29/6225 (0.47%)
[  5]   3.00-4.00   sec  45.6 MBytes   382 Mbits/sec  0.026 ms  6/5837 (0.1%)
[  5]   4.00-5.00   sec  47.3 MBytes   397 Mbits/sec  0.168 ms  124/6183 (2%)
[  5]   5.00-6.00   sec  46.1 MBytes   387 Mbits/sec  0.023 ms  40/5941 (0.67%)
[  5]   6.00-7.00   sec  49.0 MBytes   411 Mbits/sec  0.022 ms  48/6322 (0.76%)
[  5]   7.00-8.00   sec  53.1 MBytes   446 Mbits/sec  0.037 ms  67/6867 (0.98%)
[  5]   8.00-9.00   sec  44.9 MBytes   376 Mbits/sec  0.163 ms  26/5769 (0.45%)
[  5]   9.00-10.00  sec  48.4 MBytes   406 Mbits/sec  0.015 ms  36/6232 (0.58%)
[  5]  10.00-10.04  sec  2.04 MBytes   426 Mbits/sec  0.037 ms  0/261 (0%)
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams
[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec  0.037 ms  435/59760 (0.73%)
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://man.linuxde.net/iperf" target="_blank" rel="noopener">iperf 命令</a></li>
<li><a href="http://blog.csdn.net/u011006622/article/details/78394496" target="_blank" rel="noopener"> Linux 网络性能评估工具 iperf</a></li>
<li><a href="https://www.intel.cn/content/www/cn/zh/support/articles/000006215/boards-and-kits/intel-edison-boards.html" target="_blank" rel="noopener">使用两种方法测量 wi-fi 带宽英特尔® Edison 主板</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iperf</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 libtool 编译静态库</title>
    <url>/2018/03/05/How-to-use-libtool-to-create-a-static-library/</url>
    <content><![CDATA[<h2 id="libtool"><a href="#libtool" class="headerlink" title="libtool"></a>libtool</h2><pre><code>iperf3_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
    $(LIBTOOLFLAGS) --mode=link $(CCLD) $(iperf3_CFLAGS) $(CFLAGS) \
    $(iperf3_LDFLAGS) $(LDFLAGS) -o $@</code></pre><pre><code>LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
    $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
    $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
    $(AM_CFLAGS) $(CFLAGS)</code></pre><p>模式为 <code>libtool --tag=CC xxx --mode=xx $(CC)</code>，在 <code>$(CC)</code> 后添加 Flag</p>
<pre><code>iperf3_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
    $(LIBTOOLFLAGS) --mode=link $(CCLD) -all-static $(iperf3_CFLAGS) $(CFLAGS) \
    $(iperf3_LDFLAGS) $(LDFLAGS) -o $@</code></pre><pre><code>LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
    $(LIBTOOLFLAGS) --mode=compile $(CC) -static $(DEFS) \
    $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
    $(AM_CFLAGS) $(CFLAGS)</code></pre><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre><code>libtool looks at the parameters of gcc, so you should have something like below

$ cat Makefile
all: libone libtwo
        rm *.o
        @libtool --mode=link gcc -all-static -o libcombo.a libone.a libtwo.a

libone: one.c
        @libtool --mode=compile gcc -c one.c -o one.lo
        @libtool --mode=link gcc -static -o libone.a one.lo

libtwo: two.c
        @libtool --mode=compile gcc -c two.c -o two.lo
        @libtool --mode=link gcc -static -o libtwo.a two.lo</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://stackoverflow.com/questions/24954747/how-to-use-libtool-to-create-a-static-library-from-a-bunch-of-static-libraries" target="_blank" rel="noopener">How to use libtool to create a static library from a bunch of static libraries</a></li>
<li><a href="https://www.gnu.org/software/libtool/manual/html_node/Linking-libraries.html" target="_blank" rel="noopener">3.2 Linking libraries</a></li>
<li><a href="https://www.gnu.org/software/libtool/manual/html_node/Link-mode.html" target="_blank" rel="noopener">4.2 Link mode</a></li>
<li><a href="https://lists.gnu.org/archive/html/libtool/2004-11/msg00017.html" target="_blank" rel="noopener">Building all static</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>libtool</tag>
        <tag>iperf</tag>
        <tag>cross compile</tag>
      </tags>
  </entry>
  <entry>
    <title>autoconf-and-automake</title>
    <url>/2018/02/28/autoconf-and-automake/</url>
    <content><![CDATA[<blockquote>
<p>automake 生成 Makefile 文件所需的工具： <code>GUN Automake</code>、 <code>GNU Autoconf</code>、 <code>GNU m4</code>、 <code>PERL</code>、 <code>GNU Libtool</code><br>automake 生成 Makefile 文件所需的文件：需要编译的 <code>源文件</code>、 <code>configure.ac</code> 或者 <code>configure.in</code>、 <code>Makefile.am</code></p>
</blockquote>
<ul>
<li>运行 autoscan 命令</li>
<li>然后手动修改 <code>configure.scan</code> 为 <code>configure.in</code> 有的平台为 <code>configure.ac</code></li>
<li>修改 <code>configure.in</code> 里面的内容。</li>
<li>autoheader（可选，生成 config.h.in)</li>
<li>运行 aclocal 命令，生成 aclocal.m4 文件</li>
<li>运行 autoconf 命令，生成 configure 文件</li>
<li>手动写 makefile.am</li>
<li>执行 automake –a 将 makefile.am 生成 Makefile.in 同时生成选项可以补齐文件 config.guess，config.sub，install-sh，missing，depcomp</li>
<li>运行./confiugre 脚本</li>
</ul>
<a id="more"></a>

<h2 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h2><p>configure 脚本为了让一个程序能够在各种不同类型的机器上运行而设计的。在使用 make 编译源代码之前，configure 会根据自己所依赖的库而在目标机器上进行匹配。</p>
<p>约定俗成的，所有的 configure 脚本都把脚本文件名起为 configure，一般来讲都是 shell 脚本，根据所在的系统环境生成 makefile 文件。有时候看到一些程序的 configure 内容超级之多，让人难以看下去。</p>
<p>configure 脚本运行时扫描当前环境，生成一个名为 config.status 的子脚本。子脚本将 Makefile.in 文件转换为适应于当前系统环境的 Makefile 文件。</p>
<h2 id="automake"><a href="#automake" class="headerlink" title="automake"></a>automake</h2><p><img src="/images/autotools/autotools.jpeg" alt="autoMake"></p>
<h2 id="autoscan"><a href="#autoscan" class="headerlink" title="autoscan"></a>autoscan</h2><p>autoscan 是用来扫描源代码目录生成 configure.scan 文件的.autoscan 可以用目录名做为参数，但如果你不使用参数的话，那么 autoscan 将认为使用的是当前目录.autoscan 将扫描你所指定目录中的源文件，并创建 configure.scan 文件。</p>
<p>过程：源代码文件 –&gt;autoscan–&gt;configure.scan–&gt;configure.ac（或 configure.in)</p>
<h2 id="configure-scan"><a href="#configure-scan" class="headerlink" title="configure.scan"></a>configure.scan</h2><p>configure.scan 包含了系统配置的 基本选项，里面都是 一些宏定义。我们需要将它改名为 configure.in</p>
<h2 id="aclocal"><a href="#aclocal" class="headerlink" title="aclocal"></a>aclocal</h2><p>aclocal 是 一个 perl 脚本程序.aclocal 根据 configure.in 文件的 内容，自动生成 aclocal.m4 文件.aclocal 的定义是 ：aclocal -create aclocal.m4 by scanning configure.ac.</p>
<p>过程：configure.ac、acinclude.m4（可选）、用户宏文件（可选）–&gt;aclocal–&gt;aclocal.m4</p>
<h2 id="autoheader"><a href="#autoheader" class="headerlink" title="autoheader"></a>autoheader</h2><p>用于生成一个 configure 的模版头文件 config.h.in</p>
<p>通过扫描 configure.ac（或 configure.in），根据其中的某些宏（比如 cpp 宏定义）产生宏定义的模板文件 config.h.in，configure 脚本可以用这个文件生成一个由”#define”语句构成的宏定义文件 config.h。</p>
<p>当我们的程序要使用一些与平台相关的库时，由于在不同的平台上同样功能的库名字、函数、头文件的不同等，为了使程序具有可移植性，我们经常会在程序中使用一大堆的#ifdef 或#ifndef 预编译指令，这样非常地不方便。而 autoheader 就是解决这个问题的，在它生成的模板文件 config.h.in 中，为这些库、函数、头文件等定义了#undef 宏标志，configure 脚本把它转换成 config.h 后，就会变成#define 宏标志，用作这些库、函数、头文件的保护符。这样，你可以在程序里包含这个 config.h，然后使用其中的某些定义好的常量。</p>
<p>过程：configure.ac、aclocal.m4（可选）–&gt;autoheader–&gt;config.h.in</p>
<h2 id="autoconf"><a href="#autoconf" class="headerlink" title="autoconf"></a>autoconf</h2><p>autoconf 是用来产生 configure 文件的 .configure 是 一个脚本，它能设置源程序来适应各种不同的操作系统平台，并且根据不同的 系统来产生合适的 Makefile, 从而可以使你的源代码能在不同的操作系统平台上被编译出来。<br>configure.in 文件的内容是 一些宏，这些宏经过 autoconf 处理后会变成检查系统特性。环境变量。软件必须的参数的 shell 脚本.configure.in 文件中的宏的顺序并没有规定，但是你必须在所有宏的最前面和最后面分别加上 AC_INIT 宏和 AC_OUTPUT 宏。<br>我们在使用 automake 时，实际上还需要用到其他的一些宏，但我们可以用 aclocal 来帮我们自动产生。执行 aclocal 后我们会得到 aclocal.m4 文件。<br>产生了 configure.in 和 aclocal.m4 两个宏文件后，我们就可以使用 autoconf 来产生 configure 文件了。</p>
<p>过程：configure.ac、aclocal.m4（可选）、config.h.in（可选）–&gt;autoconf–&gt;configure</p>
<h2 id="Makefile-am"><a href="#Makefile-am" class="headerlink" title="Makefile.am"></a>Makefile.am</h2><p>Makefile.am 是用来生成 Makefile.in 的，需要你手工书写.Makefile.am 中定义了一些内容</p>
<p>Makefile.am 是一种比 Makefile 更高层次的规则。只需指定要生成什么目标，它由什么源文件生成，要安装到什么目录等构成</p>
<h2 id="automake-1"><a href="#automake-1" class="headerlink" title="automake"></a>automake</h2><p>我们使用 automake –add-missing 来产生 Makefile.in.<br>选项 –add-missing 的 定义是 “add missing standard files to package”, 它会让 automake 加入一个标准的软件包所必须的一些文件。<br>我们用 automake 产生出来的 Makefile.in 文件是 符合 GNU Makefile 惯例的 , 接下来我们只要执行 configure 这个 shell 脚本就可以产生合适的 Makefile 文件了。</p>
<p>选要自己写一个 Makefile.am 文件，然后 automake 根据 configure.ac 和 Makefile.am 中定义的结构，生成 Makefile.in 文件。如果在 configure.ac 中定义了一些特殊的宏，比如 AC_PROG_LIBTOOL，它会调用 libtoolize 并产生 config.guess、config.sub、ltmain.sh 等文件。</p>
<p>automake 提供了三种软件等级 foreign、gnu 和 gnits，让用户选择采用，默认等级为 gnu。使用 gnu 等级时，automake 还要求你必须有一些额外的文件，它们是 install-sh、missing、depcomp、INSTALL、NEWS、 README、AUTHORS、ChangeLog、COPYING 共 9 个文件，它们是一个符合 GNU 规范的代码文件结构所必须的文件。automake 可以通过附加 –add-missing 参数（或 -a）自动生成其中的一些文件（install-sh、missing、depcomp、INSTALL、COPYING），剩下的 NEWS、README、AUTHORS、ChangeLog 要自己创建。</p>
<p>config.guess：GNU 构建系统区分三类机器，运行构建用的编译器的“构建”机器、运行构建的软件包的“主机”机器、编译器用来产生代码的“目标”机器。这个脚本用来猜测“构建”机器的类型，并输出脚本所运行的系统的配置名 (configure name)。</p>
<p>config.sub：使配置名规范化。</p>
<p>过程：Makefile.am、configure.ac–&gt;automake(-a)–&gt;Makefile.in、install-sh、missing、depcomp、INSTALL、COPYING。若调用了 libtoolize，则另外产生的还有 config.guess、config.sub、ltmain.sh 等。</p>
<h2 id="configure-1"><a href="#configure-1" class="headerlink" title="./configure"></a>./configure</h2><p>configure 脚本会收集系统的信息，创建 config.status（这个文件可用来重新创建 configure 脚本），使用 Makefile.in 来创建 Makefile 文件，使用 config.h.in（如果有的话）来创建 config.h 文件，并生成一个日志文件 config.log（记录一些创建时的调试信息等），ltmain.sh 会产生 libtool 文件，有时还会产生文件 config.cache，stamp-h1（config.h 的时间戳文件）等。这样就完成了 Makefile 文件的制作，并且常常具有以下的功能：make、make install、make uninstall、make clean、make distclean、make dist。</p>
<h2 id="libtool"><a href="#libtool" class="headerlink" title="libtool"></a>libtool</h2><p>提供一种标准的方法来创建静态库或共享库。它把特定于平台的库的产生过程的复杂性隐藏在一个统一的接口后面，这个接口通过 libtool 被所有的平台支持。</p>
<p>过程：Makefile.in、config.h.in–&gt;configure–&gt;config.status、Makefile、config.h</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.jianshu.com/p/c44d1dc9e837" target="_blank" rel="noopener">autoconf 和 automake 流程</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-makefile/" target="_blank" rel="noopener">例解 autoconf 和 automake 生成 Makefile 文件</a></li>
<li><a href="http://blog.csdn.net/yihongxiaoxiang/article/details/52821855" target="_blank" rel="noopener">automake 的理解和实践总结</a></li>
<li><a href="http://public0821.iteye.com/blog/665786" target="_blank" rel="noopener">AutoMake 相关流程介绍</a></li>
<li><a href="https://geesun.github.io/posts/2015/02/autotool.html" target="_blank" rel="noopener">使用 autotools 生成 Makefile 学习笔记</a></li>
<li><a href="http://lucky521.github.io/blog/design/2015/12/24/configure-script.html#configure" target="_blank" rel="noopener">理解 configure 脚本</a></li>
<li><a href="http://blog.csdn.net/zhoudaxia/article/details/4361194" target="_blank" rel="noopener">GNU Autotools 的研究</a></li>
<li><a href="http://www.cnblogs.com/pysery/archive/2012/06/17/2552680.html" target="_blank" rel="noopener">configure 原理</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>How-to-use-getaddrinfo-instead-of-gethostbyname</title>
    <url>/2018/02/28/How-to-use-getaddrinfo-instead-of-gethostbyname/</url>
    <content><![CDATA[<p><code>gethostbyname</code> 与 <code>getaddrinfo</code></p>
<a id="more"></a>

<h2 id="IPV4-与-IPV6-区别"><a href="#IPV4-与-IPV6-区别" class="headerlink" title="IPV4 与 IPV6 区别"></a>IPV4 与 IPV6 区别</h2><table>
<thead>
<tr>
<th></th>
<th align="center">IPV4</th>
<th align="center">IPV6</th>
</tr>
</thead>
<tbody><tr>
<td>协议族</td>
<td align="center">PF_INET</td>
<td align="center">PF_INET6</td>
</tr>
<tr>
<td>地址族</td>
<td align="center">AF_INET</td>
<td align="center">AF_INET6</td>
</tr>
<tr>
<td>数据结构</td>
<td align="center">in_addr_sockaddr_in</td>
<td align="center">in6_addr_sockaddr_in6</td>
</tr>
<tr>
<td>网络地址转换函数</td>
<td align="center">inet_aton/inet_addr</td>
<td align="center">inet_pton</td>
</tr>
<tr>
<td>网络地址转换函数</td>
<td align="center">inet_ntoa</td>
<td align="center">inet_ntop</td>
</tr>
<tr>
<td>地址转换函数</td>
<td align="center">gethostbyname</td>
<td align="center">getaddrinfo</td>
</tr>
<tr>
<td>地址转换函数</td>
<td align="center">gethostbyaddr</td>
<td align="center">getnameinfo</td>
</tr>
</tbody></table>
<h2 id="网络地址转换函数"><a href="#网络地址转换函数" class="headerlink" title="网络地址转换函数"></a>网络地址转换函数</h2><p>网络地址函数用于在 ASCII 字符串（点分十进制数串 “192.168.110.1”) 与网络字节序的二进制（存放在 socket 地址结构中）之间转换网络地址。</p>
<pre><code class="man">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int inet_aton(const char *cp, struct in_addr *inp);

in_addr_t inet_addr(const char *cp); // 已废弃

char *inet_ntoa(struct in_addr in);</code></pre>
<p>上述函数只能处理 <code>IPV4</code>，下面的函数 <code>IPV4</code> <code>IPV6</code> 通用</p>
<pre><code class="man">#include &lt;arpa/inet.h&gt;

//inet_ntop - convert IPv4 and IPv6 addresses from binary to text form
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);

//inet_pton - convert IPv4 and IPv6 addresses from text to binary form
int inet_pton(int af, const char *src, void *dst);</code></pre>
<h2 id="查找主机名"><a href="#查找主机名" class="headerlink" title="查找主机名"></a>查找主机名</h2><p><code>gethostbyname</code> 和 <code>gethostbyaddr</code> 仅支持 <code>IPV4</code>，替换接口为 <code>getaddrinfo</code> 和 <code>getnameinfo</code></p>
<p><code>name</code> -&gt; <code>IP</code> : <code>gethostbyname</code> <code>getaddrinfo</code></p>
<p><code>IP</code> -&gt; <code>name</code> : <code>gethostbyaddr</code> <code>getnameinfo</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>kmalloc</title>
    <url>/2018/02/08/kmalloc/</url>
    <content><![CDATA[<p><code>kmalloc</code> 与 <code>__get_free_pages</code></p>
<a id="more"></a>

<h2 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h2><p><code>kmalloc</code> 可以申请的内存上限由头文件 <code>linxu/kmalloc_sizes.h</code> 来定义</p>
<p>一般情况下上限为 <code>128k</code>，如果打开宏 <code>KMALLOC_MAX_SIZE</code> 可以申请更大的内存</p>
<p><code>kmalloc</code> 申请的内存位于物理内存映射范围，而且在物理上是连续的，它们与真实的物理地址只有一个固定的偏移，因此存在简单的转换关系，对申请的内存大小有限制</p>
<p>常用的 <code>flags</code>：</p>
<ul>
<li>GFP_ATOMIC 分配内存的过程是一个原子过程，分配内存的过程不会被（高优先级进程或中断）打断</li>
<li>GFP_KERNEL 正常分配内存</li>
<li>GFP_DMA 给 DMA 控制器分配内存，需要使用该标志（DMA 要求分配虚拟地址和物理地址连续）</li>
</ul>
<p><code>flags</code> 参考用法：</p>
<p>|– 进程上下文，可以睡眠　　　　　GFP_KERNEL<br>|– 进程上下文，不可以睡眠　　　　GFP_ATOMIC<br>|　　|– 中断处理程序　　　　　　　GFP_ATOMIC<br>|　　|– 软中断　　　　　　　　　　GFP_ATOMIC<br>|　　|– Tasklet　　　　　　　　　GFP_ATOMIC<br>|– 用于 DMA 的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL<br>|– 用于 DMA 的内存，不可以睡眠　　GFP_DMA |GFP_ATOMIC</p>
<h2 id="get-free-pages"><a href="#get-free-pages" class="headerlink" title="__get_free_pages"></a>__get_free_pages</h2><p><code>__get_free_pages</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存映射</title>
    <url>/2018/02/02/linux-memory-map/</url>
    <content><![CDATA[<p><code>mmap</code> 和 <code>phys_to_virt</code></p>
<a id="more"></a>

<p>##</p>
<p>一般情况下，Linux 系统中，进程的 4GB 内存空间被划分成为两个部分 —— 用户空间和内核空间，大小分别为 0<del>3G，3</del>4G。</p>
<p>用户进程通常情况下，只能访问用户空间的虚拟地址，不能访问到内核空间。</p>
<p>每个进程的用户空间都是完全独立、互不相干的，用户进程各自有不同的页表。而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间地址有自己对应的页表，内核的虚拟空间独立于其他程序。</p>
<p>3~4G 之间的内核空间中，从低地址到高地址依次为：物理内存映射区—隔离带—vmalloc 虚拟内存分配区—隔离带—高端内存映射区—专用页面映射区—保留区。</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>内存映射函数 mmap 负责把文件内容映射到进程的虚拟内存空间，通过对这段内存的读取和修改，来实现对文件的读取和修改，而不需要再调用 read,write 等操作。</p>
<p>mmap 设备操作<br>映射一个设备是指把用户空间的一段地址关联到设备内存上，当程序读写这段用户空间的地址时，它实际上是在访问设备。这里需要做的两个操作：</p>
<ol>
<li>找到可以用来关联的虚拟地址区间</li>
<li>关联</li>
</ol>
<h2 id="phys-to-virt"><a href="#phys-to-virt" class="headerlink" title="phys_to_virt"></a>phys_to_virt</h2><p>phys_to_virt 是将已经映射的物理内存的地址转换为虚拟地址</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/u013920085/article/details/50856217" target="_blank" rel="noopener">linux 内核之 phys_to_virt</a></li>
<li><a href="http://blog.csdn.net/angle_birds/article/details/8804033" target="_blank" rel="noopener">Linux 驱动修炼之道 - 内存映射 mmap()/phys_to_virt()</a></li>
<li><a href="http://lxiaogao.lofter.com/post/1cc6a101_4f92aa8" target="_blank" rel="noopener">inux 驱动虚拟地址和物理地址的映射</a></li>
<li><a href="http://happyseeker.github.io/kernel/2016/05/03/sharing-memory-by-mmap.html" target="_blank" rel="noopener">使用 mmap 来共享内存</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-memory-manager</title>
    <url>/2018/02/02/linux-memory-manager/</url>
    <content><![CDATA[<p><code>kmalloc</code> 与 <code>__get_free_page</code></p>
<p>物理内存与虚拟内存</p>
<a id="more"></a>

<h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><h3 id="virt-to-phys-与-phys-to-virt"><a href="#virt-to-phys-与-phys-to-virt" class="headerlink" title="virt_to_phys 与 phys_to_virt"></a>virt_to_phys 与 phys_to_virt</h3><h2 id="kmalloc-与-get-free-page"><a href="#kmalloc-与-get-free-page" class="headerlink" title="kmalloc 与 __get_free_page"></a><code>kmalloc</code> 与 <code>__get_free_page</code></h2><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><h2 id="ioremap"><a href="#ioremap" class="headerlink" title="ioremap"></a>ioremap</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://lib.csdn.net/article/linux/46582" target="_blank" rel="noopener">Linux 内存管理之 kmalloc 与__get_free_page()</a></li>
<li><a href="http://www.cppblog.com/coloerful/articles/85421.html" target="_blank" rel="noopener">Linux 设备驱动编程之内存与 I/O 操作</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>uninstall-wine</title>
    <url>/2018/01/30/uninstall-wine/</url>
    <content><![CDATA[<p>ubuntu 下完全卸载 wine 项目</p>
<a id="more"></a>

<p><a href="http://blog.csdn.net/zhongwcool/article/details/38709599" target="_blank" rel="noopener">ubuntu 清理卸载 wine 的残余项目</a></p>
<p>涉及到的目录如下</p>
<pre><code>~/.wine/drive_c/Program Files
~/.wine/drive_c/users/Public/Start Menu/Programs
~/.config/menus/applications-merged
~/.local/share/applications/wine/Programs</code></pre>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>tlsf 内存分配算法</title>
    <url>/2018/01/26/tlsf/</url>
    <content><![CDATA[<p>tlsf 内存分配算法</p>
<a id="more"></a>

<h2 id="TLSF"><a href="#TLSF" class="headerlink" title="TLSF"></a>TLSF</h2><p>它用 2 层链接记录空闲块，第一层是 2 的幂次方，如 16，32，64，128。如果只用这个，内存浪费会比较严重，如分配 65 字节需要分配 128 字节。因此引入第二层链表，比如 64 这级，再分为 4 个区间，64-80，80-96，96-112，112-128，这样保证效率的同时提高内存利用率。这个算法的好处是稳定，无论申请多少空间的内存，分配所消耗的时间是差不多的，因此可以预估分配内存需要多少时间，多用于实时要求高的系统。其他内存算法则不一定，可能有时候很快，有时候运行久了空闲内存块很多时需要较长时间遍历。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/OlegHahm/tlsf" target="_blank" rel="noopener">tlsf</a></li>
<li><a href="https://www.zhihu.com/question/58028004" target="_blank" rel="noopener">什么是 tlsf 内存分配算法？它和普通的内存分配算法有什么区别？</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>tlsf</tag>
      </tags>
  </entry>
  <entry>
    <title>mprotect 内存保护</title>
    <url>/2018/01/26/linux-mprotect/</url>
    <content><![CDATA[<pre><code>NAME
       mprotect — set protection of memory mapping

SYNOPSIS
       #include &lt;sys/mman.h&gt;

       int mprotect(void *addr, size_t len, int prot);</code></pre><p><code>mprotect</code> 将从 <code>addr</code> 开始，长度为 <code>len</code> 的内存区修改为 <code>prot</code> 指定的保护属性</p>
<p>其中， <code>addr</code> 必须是一个内存页的起始地址， <code>len</code> 必须是页的整数倍</p>
<p><code>prot</code> 可以取值</p>
<ul>
<li>PROT_READ, 内存中内容可读</li>
<li>PROT_WRITE，内存中内容可写</li>
<li>PROT_EXEC，内存中内容可执行</li>
<li>PROT_NONE，内存中内容无法访问</li>
</ul>
<p><strong>如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV</strong></p>
<a id="more"></a>

<h2 id="guard-page"><a href="#guard-page" class="headerlink" title="guard page"></a>guard page</h2><h3 id="posix-threads"><a href="#posix-threads" class="headerlink" title="posix threads"></a>posix threads</h3><p>While using <strong>posix threads</strong> in Linux it is done automatically with <strong>the guard size attribute</strong> that is one page by default</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;
#include &lt;sys/mman.h&gt;

void *threadfn(void *p)
{
    int val=100;
    printf(&quot;thread val address=%lx\n&quot;,&amp;val);
    sleep(100);
    return NULL;
}

int main()
{
    int val=100;
    printf(&quot;main val address=%lx\n&quot;,&amp;val);
    pthread_t t1,t2,t3;
    pthread_create(&amp;t1,NULL,threadfn,NULL);
    pthread_create(&amp;t2,NULL,threadfn,NULL);
    pthread_create(&amp;t3,NULL,threadfn,NULL);
    sleep(100);
    pthread_exit(NULL);
    return 0;
}

/* Output:
main val address=7ffe2438515c
thread val address=7fdba3989f44
thread val address=7fdba3a8af44
thread val address=7fdba4274f44
*/</code></pre><p>文件 <code>/proc/[pid]/maps</code></p>
<pre><code>2eaaa000-2eaab000 ---p 2eaaa000 00:00 0     //one page(4k) guard page
2eaab000-2ebaa000 rw-p 2eaab000 00:00 0
2ebaa000-2ebab000 ---p 2ebaa000 00:00 0     //one page(4k) guard page
2ebab000-2ecaa000 rw-p 2ebab000 00:00 0
2ecaa000-2ecab000 ---p 2ecaa000 00:00 0     //one page(4k) guard page
2ecab000-2edaa000 rw-p 2ecab000 00:00 0
2edaa000-2edab000 ---p 2edaa000 00:00 0     //one page(4k) guard page
2edab000-2eeaa000 rw-p 2edab000 00:00 0
2eeaa000-2eeab000 ---p 2eeaa000 00:00 0     //one page(4k) guard page
2eeab000-2efaa000 rw-p 2eeab000 00:00 0
2efaa000-2efab000 ---p 2efaa000 00:00 0     //one page(4k) guard page</code></pre><p><code>posix threads</code> 提供一组接口</p>
<pre><code>NAME
       pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size attribute in thread attributes object

SYNOPSIS
       #include &lt;pthread.h&gt;

       int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
       int pthread_attr_getguardsize(const pthread_attr_t *attr, size_t *guardsize);

       Compile and link with -pthread.
NOTES
       A guard area consists of virtual memory pages that are protected to prevent read and write  access.   If  a  thread
       overflows its stack into the guard area, then, on most hard architectures, it receives a SIGSEGV signal, thus noti‐
       fying it of the overflow.</code></pre><p><code>stack overflow</code> 时会触发 <code>SIGSEGV</code></p>
<h2 id="others-memory"><a href="#others-memory" class="headerlink" title="others memory"></a>others memory</h2><p>But what about memory that is not located in the stack like <strong>dynamic allocation or buffers in BSS/DATA sections</strong>? here you can use mprotect to create that guard area</p>
<p><strong>mprotect can be used to change MMU permissions on any mapped memory</strong></p>
<p>One point to notice is that the buffer must be aligned to a page boundary so we can’t allocate it using malloc. we can use memalign or aligned_alloc but the best way in this case is to call mmap directly and not use any heap. mmap returns page(s) and if we use it with MAP_ANONYMOUS we get memory from the kernel</p>
<pre><code>p1=mmap(0,0x20000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
mprotect(p1+page_size,page_size,PROT_NONE);
mprotect(p1+0x1f000,0x1000,PROT_NONE);
pthread_attr_setstack(&amp;attr,p1+0x1000,0x1e000);
pthread_create(&amp;t1,&amp;attr,threadfn1,NULL);</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://devarea.com/using-mprotect-system-call-to-debug-memory-problems/#.WmqRCXWWa00" target="_blank" rel="noopener">Using mprotect system call to debug memory problems</a></li>
<li><a href="https://stackoverflow.com/questions/35239300/mprotect-on-heap-aligned-memory-works-mysteriously" target="_blank" rel="noopener">mprotect on heap aligned memory works mysteriously</a></li>
<li><a href="http://www.linuxdiyf.com/linux/21096.html" target="_blank" rel="noopener">linux c 之使用 mprotect 检测内存访问</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread_mutex_t 属性</title>
    <url>/2018/01/25/pthread-mutex-types/</url>
    <content><![CDATA[<pre><code>/* Mutex types.  */
enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP
#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
#endif
#ifdef __USE_GNU
  /* For compatibility.  */
  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
#endif
};</code></pre><a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/c/POS04-C.+Avoid+using+PTHREAD_MUTEX_NORMAL+type+mutex+locks" target="_blank" rel="noopener">POS04-C. Avoid using PTHREAD_MUTEX_NORMAL type mutex locks</a></li>
<li><a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_mutex_lock.html" target="_blank" rel="noopener">pthread_mutex_lock</a></li>
<li><a href="http://blog.csdn.net/jasmineal/article/details/8807635" target="_blank" rel="noopener">POSIX 设置锁的属性</a></li>
<li><a href="https://linux.die.net/man/3/pthread_mutexattr_settype" target="_blank" rel="noopener">pthread_mutexattr_settype(3) - Linux man page</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-man</title>
    <url>/2018/01/25/linux-man/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>###</p>
<pre><code>apt-get install manpages-de  manpages-de-dev  manpages-dev glibc-doc manpages-posix-dev manpages-posix
sudo apt-get install  manpages-zh</code></pre><p>###</p>
<p><a href="http://www.kernel.org/pub/linux/docs/man-pages/" target="_blank" rel="noopener">man source</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/gatieme/article/details/51656707" target="_blank" rel="noopener">linux 下 man 手册的安装和使用</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>man</tag>
      </tags>
  </entry>
  <entry>
    <title>How-to-Write-Advanced-Signal-Handlers-in-UNIX</title>
    <url>/2018/01/25/How-to-Write-Advanced-Signal-Handlers-in-UNIX/</url>
    <content><![CDATA[<p>使用 <code>sigaction</code> 来完成信号量触发的分析</p>
<a id="more"></a>

<h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h2><p>注册普通 <code>signal handler</code> 使用的是 <code>sa_handler</code>，此时参数只有一个 <code>signo</code></p>
<p>使用 Flag <code>SA_SIGINFO</code> 需要使用 <code>sa_sigaction</code>，此时参数有三个</p>
<ul>
<li>An int, for the signal number (just like signal)</li>
<li>A siginfo_t *, which is a structure containing all sorts of information about the source of the signal, including the pid of the sender if applicable. (It also includes some information about the cause of the signal for automatic signals like SIGSEGV.)</li>
<li>A ucontext_t *, which has to do with which thread got the signal. Mostly ignorable.</li>
</ul>
<pre><code>void (*sa_sigaction)(int, siginfo_t *, void *)</code></pre><p>相关结构体</p>
<pre><code>struct sigaction {
    void     (*sa_handler)(int);
    void     (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t   sa_mask;
    int        sa_flags;
    void     (*sa_restorer)(void);
};

siginfo_t {
    int      si_signo;    /* Signal number */
    int      si_errno;    /* An errno value */
    int      si_code;     /* Signal code */
    int      si_trapno;   /* Trap number that caused
                             hardware-generated signal
                             (unused on most architectures) */
    pid_t    si_pid;      /* Sending process ID */
    uid_t    si_uid;      /* Real user ID of sending process */
    int      si_status;   /* Exit value or signal */
    clock_t  si_utime;    /* User time consumed */
    clock_t  si_stime;    /* System time consumed */
    sigval_t si_value;    /* Signal value */
    int      si_int;      /* POSIX.1b signal */
    void    *si_ptr;      /* POSIX.1b signal */
    int      si_overrun;  /* Timer overrun count; POSIX.1b timers */
    int      si_timerid;  /* Timer ID; POSIX.1b timers */
    void    *si_addr;     /* Memory location which caused fault */
    int      si_band;     /* Band event */
    int      si_fd;       /* File descriptor */
}</code></pre><p>注册</p>
<pre><code class="example">struct sigaction pipe_act;
pipe_act.sa_flags = SA_SIGINFO;
pipe_act.sa_sigaction = sigpipehandler
sigaction(SIGPIPE, &amp;pipe_act, NULL);</code></pre>
<h2 id="Example-of-using-sigaction"><a href="#Example-of-using-sigaction" class="headerlink" title="Example of using sigaction"></a>Example of using sigaction</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;

static void hdl (int sig, siginfo_t *siginfo, void *context)
{
    printf (&quot;Sending PID: %ld, UID: %ld\n&quot;,
            (long)siginfo-&gt;si_pid, (long)siginfo-&gt;si_uid);
}

int main (int argc, char *argv[])
{
    struct sigaction act;

    memset (&amp;act, &#39;\0&#39;, sizeof(act));

    /* Use the sa_sigaction field because the handles has two additional parameters */
    act.sa_sigaction = &amp;hdl;

    /* The SA_SIGINFO flag tells sigaction() to use the sa_sigaction field, not sa_handler. */
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGTERM, &amp;act, NULL) &lt; 0) {
        perror (&quot;sigaction&quot;);
        return 1;
    }

    while (1)
        sleep (10);

    return 0;
}</code></pre><h2 id="Using-Extended-Information"><a href="#Using-Extended-Information" class="headerlink" title="Using Extended Information"></a>Using Extended Information</h2><blockquote>
<p>The context information contains details about the machine state: the values of current registers, pointers to the stack, and so on. So it is possible to produce a rudimentary profiling infrastructure using the timers and the machine context information.</p>
</blockquote>
<p>第三个参数为 <code>ucontext_t *context = (ucontext_t*)vcontext;</code></p>
<blockquote>
<p>Contexts may be used via the makecontext()/setcontext()/getcontext()/swapcontext() functions to implement user-space threads.</p>
</blockquote>
<pre><code>#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ucontext.h&gt;

struct itimerval timeout={0};

static void handle_prof_signal(int sig_no, siginfo_t* info, void *vcontext)
{
  char output[100];
  ucontext_t *context = (ucontext_t*)vcontext;
  unsigned long pc = context-&gt;uc_mcontext.gregs[REG_PC];

  snprintf(output,100,&quot;Sample at %lx\n&quot;,pc);
  write(1,output,strlen(output)+1);
  setitimer(ITIMER_PROF, &amp;timeout, 0);
}


void main()
{
  struct sigaction sig_action;
  memset(&amp;sig_action, 0, sizeof(sig_action));
  sig_action.sa_sigaction = handle_prof_signal;
  sig_action.sa_flags = SA_RESTART | SA_SIGINFO;
  sigemptyset(&amp;sig_action.sa_mask);
  sigaction(SIGPROF, &amp;sig_action, 0);

  timeout.it_value.tv_sec=1;
  setitimer(ITIMER_PROF, &amp;timeout, 0);
  volatile int i=0;
  do { i++; } while(1);
}</code></pre><h2 id="kernel-support"><a href="#kernel-support" class="headerlink" title="kernel support"></a>kernel support</h2><p>主要的结构体为 <code>struct sigframe</code></p>
<p>需要内核支持，例如在内核 2.6 中</p>
<p><code>i386</code> ，文件 <code>arch/um/sys-i386/signal.c</code>，函数 <code>setup_signal_stack_si</code></p>
<pre><code>   stack_top &amp;= -8UL;
   frame = (struct rt_sigframe __user *) stack_top - 1;
   if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
       return 1;

   restorer = frame-&gt;retcode;
   if (ka-&gt;sa.sa_flags &amp; SA_RESTORER)
       restorer = ka-&gt;sa.sa_restorer;

   /* See comment above about why this is here */
   PT_REGS_SP(regs) = (unsigned long) frame;

   err |= __put_user(restorer, &amp;frame-&gt;pretcode);
   err |= __put_user(sig, &amp;frame-&gt;sig);
   err |= __put_user(&amp;frame-&gt;info, &amp;frame-&gt;pinfo);
   err |= __put_user(&amp;frame-&gt;uc, &amp;frame-&gt;puc);
   err |= copy_siginfo_to_user(&amp;frame-&gt;info, info);
   err |= copy_ucontext_to_user(&amp;frame-&gt;uc, &amp;frame-&gt;fpstate, mask,
                    save_sp);</code></pre><p><code>arm</code> ，文件 <code>arch/arm/kernel/signal.c</code>，函数 <code>setup_sigframe</code></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://serverfault.com/questions/94956/how-to-find-out-the-source-of-a-posix-signal" target="_blank" rel="noopener">How to find out the source of a POSIX signal</a></li>
<li><a href="https://stackoverflow.com/questions/11508427/linux-c-upon-receiving-a-signal-is-it-possible-to-know-the-pid-of-the-sender" target="_blank" rel="noopener">Linux C: upon receiving a signal, is it possible to know the PID of the sender?</a></li>
<li><a href="https://stackoverflow.com/questions/15665329/using-the-third-parameter-void-context-of-a-sigaction-handler-with-sig-info-r" target="_blank" rel="noopener">Using the third parameter context of a sigaction handler with SIG_INFO results in a Segmentation Fault</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/servers-storage-dev/signal-handlers-studio-2282526.html" target="_blank" rel="noopener">How to Write Advanced Signal Handlers in UNIX</a></li>
<li><a href="https://unix.stackexchange.com/questions/71240/sigaction7-semantics-of-siginfo-ts-si-code-member" target="_blank" rel="noopener">sigaction(7): semantics of siginfo_t’s si_code member</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>Debugging-A-Running-Process</title>
    <url>/2018/01/23/Debugging-A-Running-Process/</url>
    <content><![CDATA[<p>we can debug a process that has already been started outside the debugger. There are two ways of doing this:</p>
<ul>
<li>Using command line arguments</li>
<li>Using the attach command.</li>
</ul>
<a id="more"></a>

<h2 id="command-line-arguments"><a href="#command-line-arguments" class="headerlink" title="command line arguments"></a>command line arguments</h2><p>start GDB in another console with an argument list of the executable and the process ID.</p>
<pre><code>$ gdb beer-process 17399
Attaching to program: code/running_process/beer-process, process 17399
0x410c64fb in nanosleep () from /lib/tls/libc.so.6
(gdb)</code></pre><p>Whenever GDB attaches to a running process, the process is paused so you can get a handle on what the call stack looks like. Let’s do some interesting things.</p>
<p>When GDB detaches from the process, the process will continue along its merry way. We could also use the <code>detach</code> command to detach from the process without quiting GDB.</p>
<h2 id="the-attach-command"><a href="#the-attach-command" class="headerlink" title="the attach command"></a>the attach command</h2><p>We can also debug an already running process using GDB’s <code>attach</code> command to attach to a running process. Again, once attached, we can use the <code>detach</code> command to detach from the process.</p>
<p>Start GDB with no command line arguments. But use the attach command to attach to the running process.</p>
<pre><code>$ gdb
(gdb) attach 17399
Attaching to process 17399
Reading symbols from code/running_process/beer-process...done.
0x410c64fb in nanosleep () from /lib/tls/libc.so.6
(gdb)</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol start="0">
<li><a href="http://dirac.org/linux/gdb/06-Debugging_A_Running_Process.php" target="_blank" rel="noopener">Debugging A Running Process</a></li>
<li><a href="https://stackoverflow.com/questions/2152582/start-gdb-using-a-pid" target="_blank" rel="noopener">start gdb using a pid</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/problem_determination/linux_gdb.html" target="_blank" rel="noopener">Debugging with gdb</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>movian-sqldb</title>
    <url>/2018/01/16/movian-sqldb/</url>
    <content><![CDATA[<p><code>Movian</code> 使用 <code>Sqlite3</code> 来管理 <code>metadata</code> 和 <code>kvstore</code></p>
<a id="more"></a>

<h2 id="Sqlite"><a href="#Sqlite" class="headerlink" title="Sqlite"></a>Sqlite</h2><p><a href="https://www.jianshu.com/p/1814c913a168" target="_blank" rel="noopener">常用 SQLite 语句 及 SQLite3 的使用</a></p>
<h2 id="kvstore"><a href="#kvstore" class="headerlink" title="kvstore"></a>kvstore</h2><p><code>kvstore</code> 初始化过程，路径为 <code>res/kvstore</code>，文件列表</p>
<pre><code>kvstore
├── 001.sql
└── 002.sql</code></pre><p><code>main_init</code> -&gt;<br><code>kvstore_init</code> -&gt;<br><code>int r = db_upgrade_schema(db, buf, &quot;metadb&quot;, &quot;kvstore&quot;, buf2);</code></p>
<p>核心代码，通过循环加载 <code>sql</code> 模式</p>
<pre><code>while(1) {

  if(ver == tgtver) {
    TRACE(TRACE_DEBUG, &quot;DB&quot;, &quot;%s: At current version %d&quot;, dbname, ver);
    if(detach[0]) db_one_statement(db, detach, NULL);
    return 0;
  }

  ver++;
  snprintf(path, sizeof(path), &quot;%s/%03d.sql&quot;, schemadir, ver);

  buf_t *sql = fa_load(path,
                        FA_LOAD_ERRBUF(buf, sizeof(buf)),
                        NULL);
  if(sql == NULL) {
    TRACE(TRACE_ERROR, &quot;DB&quot;,
      &quot;%s: Unable to upgrade db schema to version %d using %s -- %s&quot;,
      dbname, ver, path, buf);
    if(detach[0]) db_one_statement(db, detach, NULL);
    return -1;
  }


  if(strstr(buf_cstr(sql), &quot;-- schema-upgrade:disable-fk&quot;)) {
    db_one_statement(db, &quot;PRAGMA foreign_keys=OFF;&quot;, NULL);
    enable_fk = 1;
  }
  db_begin(db);
  snprintf(buf, sizeof(buf), &quot;PRAGMA user_version=%d&quot;, ver);
  if(db_one_statement(db, buf, NULL)) {
    free(sql);
    break;
  }

  const char *s = buf_cstr(sql);

  while(strchr(s, &#39;;&#39;) != NULL) {
    sqlite3_stmt *stmt;

    int rc = sqlite3_prepare_v2(db, s, -1, &amp;stmt, &amp;s);
    if(rc != SQLITE_OK) {
  TRACE(TRACE_ERROR, &quot;DB&quot;,
        &quot;%s: Unable to prepare statement in upgrade %d\n%s&quot;, dbname, ver, s);
  goto fail;
    }

    rc = sqlite3_step(stmt);
    if(rc != SQLITE_DONE) {
  TRACE(TRACE_ERROR, &quot;DB&quot;,
        &quot;%s: Unable to execute statement error %d\n%s&quot;, dbname, rc,
        sqlite3_sql(stmt));
  goto fail;
    }
    sqlite3_finalize(stmt);
  }

  db_commit(db);
  if(enable_fk) {
    db_one_statement(db, &quot;PRAGMA foreign_keys=ON;&quot;, NULL);
    enable_fk = 0;
  }
  TRACE(TRACE_INFO, &quot;DB&quot;, &quot;%s: Upgraded to version %d&quot;, dbname, ver);
  buf_release(sql);
}</code></pre><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><pre><code>sqlite&gt; .dump url
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE url (
       id INTEGER PRIMARY KEY,
       url TEXT NOT NULL UNIQUE
       );
INSERT INTO &quot;url&quot; VALUES(1,&#39;plugin:start&#39;);
INSERT INTO &quot;url&quot; VALUES(2,&#39;plugin:repo:categories&#39;);
INSERT INTO &quot;url&quot; VALUES(3,&#39;plugin:repo:tv&#39;);
INSERT INTO &quot;url&quot; VALUES(4,&#39;discovered:&#39;);
INSERT INTO &quot;url&quot; VALUES(5,&#39;upnp:uuid:4e4e2d48-3130-3233-4e4e-2d4831303233:urn:upnp-org:serviceId:ContentDirectory:0&#39;);
INSERT INTO &quot;url&quot; VALUES(6,&#39;settings:&#39;);
INSERT INTO &quot;url&quot; VALUES(7,&#39;/home/cell/ 音乐&#39;);
INSERT INTO &quot;url&quot; VALUES(8,&#39;/home/cell/ 视频&#39;);
INSERT INTO &quot;url&quot; VALUES(9,&#39;/home/cell/ 图片&#39;);
INSERT INTO &quot;url&quot; VALUES(10,&#39;file:///home/cell/ 图片 /Screenshots&#39;);
INSERT INTO &quot;url&quot; VALUES(11,&#39;settings:general&#39;);
INSERT INTO &quot;url&quot; VALUES(12,&#39;plugin:repo:subtitles&#39;);
INSERT INTO &quot;url&quot; VALUES(13,&#39;plugin:repo:glwosk&#39;);
INSERT INTO &quot;url&quot; VALUES(14,&#39;plugin:repo:music&#39;);
INSERT INTO &quot;url&quot; VALUES(15,&#39;plugin:repo:audioengine&#39;);
INSERT INTO &quot;url&quot; VALUES(16,&#39;example:music:&#39;);
INSERT INTO &quot;url&quot; VALUES(17,&#39;http://www.lonelycoder.com/music/Hybris_Intro-remake.mp3&#39;);
INSERT INTO &quot;url&quot; VALUES(18,&#39;settings:lookandfeel&#39;);
INSERT INTO &quot;url&quot; VALUES(19,&#39;settings:network&#39;);

sqlite&gt; .dump url_kv
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE url_kv (
       url_id INTEGER REFERENCES url(id) ON DELETE CASCADE,
       domain INTEGER NOT NULL,
       key TEXT NOT NULL,
       value,
       UNIQUE (url_id, domain, key));
INSERT INTO &quot;url_kv&quot; VALUES(17,1,&#39;lastplayed&#39;,1507880885);
INSERT INTO &quot;url_kv&quot; VALUES(17,1,&#39;playcount&#39;,1);
INSERT INTO &quot;url_kv&quot; VALUES(49,2,&#39;glwUserView&#39;,&#39;list.view&#39;);
INSERT INTO &quot;url_kv&quot; VALUES(49,3,&#39;order&#39;,&#39;relevance&#39;);
INSERT INTO &quot;url_kv&quot; VALUES(69,1,&#39;lastplayed&#39;,1516080607);
INSERT INTO &quot;url_kv&quot; VALUES(69,1,&#39;playcount&#39;,1);
INSERT INTO &quot;url_kv&quot; VALUES(70,1,&#39;lastplayed&#39;,1516080693);
INSERT INTO &quot;url_kv&quot; VALUES(70,1,&#39;playcount&#39;,1);
INSERT INTO &quot;url_kv&quot; VALUES(72,1,&#39;lastplayed&#39;,1516081838);
INSERT INTO &quot;url_kv&quot; VALUES(72,1,&#39;playcount&#39;,1);
CREATE INDEX url_kv_url_id_idx ON url_kv(url_id);
COMMIT;</code></pre><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><pre><code class="url">CREATE TABLE url (
       id INTEGER PRIMARY KEY,
       url TEXT NOT NULL UNIQUE
       );

CREATE INDEX url_url_idx ON url(url);</code></pre>
<h4 id="set-amp-get"><a href="#set-amp-get" class="headerlink" title="set &amp; get"></a>set &amp; get</h4><pre><code>static int get_url(void *db, const char *url, uint64_t *id)</code></pre><h3 id="url-kv"><a href="#url-kv" class="headerlink" title="url_kv"></a>url_kv</h3><pre><code class="url_kv">CREATE TABLE url_kv (
       url_id INTEGER REFERENCES url(id) ON DELETE CASCADE,
       domain INTEGER NOT NULL,
       key TEXT NOT NULL,
       value,
       UNIQUE (url_id, domain, key));</code></pre>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>kv_url_opt_set</code> -&gt;<br><code>deferred_callout_fire</code> -&gt;<br><code>kvstore_deferred_flush</code> -&gt;<br><code>kv_write_db</code> -&gt;</p>
<pre><code class="kv_write_db">if(kw-&gt;kw_type == KVSTORE_SET_VOID) {
  rc = db_prepare(db, &amp;stmt,
                  &quot;DELETE FROM url_kv &quot;
                  &quot;WHERE url_id = ?1 &quot;
                  &quot;AND key = ?2 &quot;
                  &quot;AND domain = ?3&quot;);

  if(rc != SQLITE_OK)
    return rc;

  value = &quot;[DELETED]&quot;;

} else {

  rc = db_prepare(db, &amp;stmt,
                  &quot;INSERT OR REPLACE INTO url_kv &quot;
                  &quot;(url_id, key, domain, value) &quot;
                  &quot;VALUES &quot;
                  &quot;(?1, ?2, ?3, ?4)&quot;
                  );

  if(rc != SQLITE_OK)
    return rc;

  switch(kw-&gt;kw_type) {
  case KVSTORE_SET_INT:
    sqlite3_bind_int(stmt, 4, kw-&gt;kw_int);
    snprintf(vtmp, sizeof(vtmp), &quot;%d&quot;, kw-&gt;kw_int);
    break;

  case KVSTORE_SET_INT64:
    sqlite3_bind_int(stmt, 4, kw-&gt;kw_int64);
    snprintf(vtmp, sizeof(vtmp), &quot;%&quot;PRId64, kw-&gt;kw_int64);
    break;

  case KVSTORE_SET_STRING:
    sqlite3_bind_text(stmt, 4, kw-&gt;kw_string, -1, SQLITE_STATIC);
    value = kw-&gt;kw_string;
    break;

  default:
    break;
  }
}
sqlite3_bind_int64(stmt, 1, id);
sqlite3_bind_text(stmt, 2, kw-&gt;kw_key, -1, SQLITE_STATIC);
sqlite3_bind_int(stmt, 3, kw-&gt;kw_domain);

rc = sqlite3_step(stmt);
sqlite3_finalize(stmt);</code></pre>
<p><code>db_prepare</code> 中的 <code>?1</code> <code>?2</code>，为 <code>sqlite3_bind_</code> 传入的参数</p>
<p><code>DOMAIN</code> 有四种</p>
<pre><code>#define KVSTORE_DOMAIN_SYS     1
#define KVSTORE_DOMAIN_PROP    2
#define KVSTORE_DOMAIN_PLUGIN  3
#define KVSTORE_DOMAIN_SETTING 4</code></pre><p><code>id</code> 从 <code>url</code> 中获取</p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p><code>playinfo_register_play</code> -&gt;<br><code>kv_url_opt_get_int/int64/rstr</code> -&gt;<br><code>kv_url_opt_get</code> -&gt;<br><code>SELECT value</code></p>
<pre><code>int cur = kv_url_opt_get_int(url, KVSTORE_DOMAIN_SYS, &quot;playcount&quot;, 0);</code></pre><h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p><code>metadata</code> 初始化过程，路径为 <code>res/metadata</code>，文件列表</p>
<pre><code>metadb
├── 001.sql
├── 002.sql
├── 003.sql
├── 004.sql
├── 005.sql
├── 006.sql
├── 007.sql
├── 008.sql
├── 009.sql
├── 010.sql
├── 011.sql
├── 012.sql
├── 013.sql
├── 014.sql
├── 015.sql
├── 016.sql
├── 017.sql
└── 018.sql</code></pre><p><code>main_init</code> -&gt;<br><code>metadb_init</code> -&gt;<br><code>int r = db_upgrade_schema(db, buf, &quot;metadb&quot;, &quot;kvstore&quot;, buf2);</code> -&gt;<br><code>snprintf(path, sizeof(path), &quot;%s/%03d.sql&quot;, schemadir, ver);</code></p>
]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
        <tag>sql3</tag>
      </tags>
  </entry>
  <entry>
    <title>movian-backend</title>
    <url>/2018/01/16/movian-backend/</url>
    <content><![CDATA[<p><code>Movian</code> 中使用了大量的 <code>backend</code> 服务，本文来分析 <code>backend</code> 实现流程</p>
<a id="more"></a>

<h2 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h2><p>以 <code>Search</code> 为例</p>
<pre><code>static inr
search_canhandle(const char *url)
{
  return !strncmp(url, &quot;search:&quot;, strlen(&quot;search:&quot;));
}

static int
search_open(prop_t *page, const char *url0, int sync)
{

}

static backend_t be_search = {
  .be_canhandle = search_canhandle,
  .be_open = search_open,
};

BE_REGISTER(search);</code></pre><p><code>BE_REGISTER</code> 宏定义</p>
<pre><code>#define BE_REGISTER(name)
  INITIALIZER(backend_init_ ## name) {                                 \
    backend_register(&amp;be_ ## name);                                    \
  }</code></pre><p><code>INITIALIZER</code> 宏定义在 <code>src/compiler.h</code></p>
<pre><code>#elif defined(__GNUC__)

#define INITIALIZER(f) \
   static void f(void) __attribute__((constructor)); \
   static void f(void)

#endif</code></pre><p>其中 <code>__attribute__ constructor</code> 被修饰的函数作为构造函数执行</p>
<p>其中 <code>backend_register</code> 将 <code>be_search</code> 插入到链表 <code>backends</code> 中</p>
<pre><code>void
backend_register(backend_t *be)
{
  LIST_INSERT_HEAD(&amp;backends, be, be_global_link);
}</code></pre><p>因此在执行到 <code>main</code> 之前已经调用 <code>backend_register</code>，完成 <code>backend</code> 注册</p>
<h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p><code>src/arch/linux/linux_main.c</code></p>
<p><code>main</code> -&gt;<br><code>main_init</code> -&gt;<br><code>backend_init</code></p>
<pre><code class="backend_init">void
backend_init(void)
{
  backend_t *be;
  hts_lwmutex_init(&amp;dyanamic_backends_mutex);
  hts_mutex_init(&amp;imageloader_mutex);
  hts_cond_init(&amp;imageloader_cond, &amp;imageloader_mutex);

  TAILQ_INIT(&amp;cached_images);

  LIST_FOREACH(be, &amp;backends, be_global_link)
    if(be-&gt;be_init != NULL)
      be-&gt;be_init();
}</code></pre>
<h2 id="play-video"><a href="#play-video" class="headerlink" title="play video"></a>play video</h2><p><code>UI</code> -&gt;<br><code>glw_create</code> -&gt;<br><code>class-&gt;gc_ctor</code> -&gt;<br><code>glw_video_ctor</code> -&gt;<br><code>video_playback_create</code> -&gt;<br><code>video_player_idle</code> -&gt;<br><code>play_video</code> -&gt;<br><code>backend_play_video</code></p>
<h2 id="play-audio"><a href="#play-audio" class="headerlink" title="play audio"></a>play audio</h2><p>与 <code>video</code> 流程不一样</p>
<p><code>be_playqueue</code> 注册</p>
<pre><code>static backend_t be_playqueue = {
  .be_init = playqueue_init,
  .be_canhandle = be_playqueue_canhandle,
  .be_open = be_playqueue_open,
};

BE_REGISTER(playqueue);</code></pre><p><code>playqueue_init</code> -&gt;<br><code>player_thread</code> -&gt;<br><code>backend_play_audio</code></p>
<h2 id="page-open"><a href="#page-open" class="headerlink" title="page open"></a>page open</h2><p><code>backend_page_open</code> 注册为 <code>backend</code>，除此之外只给 <code>upgrade</code> 调用</p>
<pre><code class="upgrade_open_url">static int
upgrade_open_url(prop_t *page, const char *url, int sync)
{
  if(!strcmp(url, &quot;showtime:upgrade&quot;)) {
    usage_page_open(sync, &quot;Upgrade&quot;);
    backend_page_open(page, &quot;page:upgrade&quot;, sync);
    upgrade_refresh();
    prop_set(page, &quot;directClose&quot;, PROP_SET_INT, 1);
  } else {
    nav_open_error(page, &quot;Invalid URI&quot;);
  }
  return 0;
}</code></pre>
<pre><code>static backend_t be_page = {
  .be_canhandle = be_page_canhandle,
  .be_open = backend_page_open,
};

BE_REGISTER(page);</code></pre><h2 id="backend-probe"><a href="#backend-probe" class="headerlink" title="backend probe"></a>backend probe</h2><p><code>main_init</code> -&gt;<br><code>service_int</code> -&gt;<br><code>service_probe_loop</code> -&gt;<br><code>backend_probe</code></p>
<pre><code class="backend_probe">backend_probe_result_t
backend_probe(const char *url, char *errbuf, size_t errlen, int timeout_ms)
{
  if(timeout_ms &lt;= 0)
    timeout_ms = 5000;

  // 匹配 URL
  backend_t *be = backend_canhandle(url);
  if(be == NULL) {
    snprintf(errbuf, errlen, &quot;No handler for URL&quot;);
    return BACKEND_PROBE_NO_HANDLER;
  }

  if(be-&gt;be_probe == NULL)
    return BACKEND_PROBE_OK;

  // Example: .be_probe = fa_check_url
  return be-&gt;be_probe(url, errbuf, errlen, timeout_ms);
}</code></pre>
<h2 id="backend-open"><a href="#backend-open" class="headerlink" title="backend open"></a>backend open</h2><p><code>search_open</code> -&gt;<br><code>backend_open</code> -&gt; <code>backend_search</code></p>
<p>可以匹配到 <code>.be_search = plugin_search</code> <code>.be_search = ecmascript_search</code></p>
<p>通用 <code>src/arch/linux/linux_main.c</code></p>
<p><code>main</code> -&gt;<br><code>linux_global_eventsink</code> -&gt;<br><code>switch_ui</code></p>
<p>将 <code>ui_current</code> 设置为 <code>ui_glw</code>，然后</p>
<p><code>main_loop</code> -&gt;<br><code>ui_glw-&gt;start</code> -&gt;<br><code>glw_x11_start</code> -&gt;<br><code>nav_spawn</code> -&gt;<br><code>nav_create</code> -&gt;<br><code>nav_open0</code> -&gt;<br><code>nav_open_backend</code> -&gt;<br><code>nav_open_thread</code> -&gt;<br><code>back_open</code></p>
]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>movian-metadata</title>
    <url>/2018/01/16/movian-metadata/</url>
    <content><![CDATA[<p><a href="https://movian.tv/projects/movian/wiki/JSAPI_page" target="_blank" rel="noopener">API</a></p>
<a id="more"></a>

<h2 id="appendItem-String-URI-String-type-Object-metadata"><a href="#appendItem-String-URI-String-type-Object-metadata" class="headerlink" title="appendItem(String URI, [String type], [Object metadata])"></a>appendItem(String URI, [String type], [Object metadata])</h2><blockquote>
<p>Append an item to the page. This should be used to populate data when page.type == ‘directory’</p>
</blockquote>
<ul>
<li><p>URI - URI to be opened when the item is activated (clicked)</p>
</li>
<li><p>type - Type of the item</p>
<blockquote>
<ul>
<li>directory - Directory that can be browsed</li>
<li>file - Any type of file or unknown file format</li>
<li>video - Video file</li>
<li>audio - Audio track</li>
<li>image - Image that can be displayed</li>
<li>album - Collection of audio tracks</li>
<li>station - Icecast/shoutcast music station (see di.fm plugin for example)</li>
</ul>
</blockquote>
</li>
<li><p>metadata - Additional information about the item</p>
<blockquote>
<p>Depending on the type of item, different information will be visible:</p>
<blockquote>
<ul>
<li>video : following properties are displayed<ul>
<li>title</li>
<li>icon</li>
<li>description</li>
<li>duration</li>
<li>rating</li>
<li>year</li>
<li>genre</li>
</ul>
</li>
<li>directory : following properties are displayed<ul>
<li>title</li>
<li>icon</li>
</ul>
</li>
<li>item : following properties are displayed<ul>
<li>title</li>
<li>description</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="metadata-visible"><a href="#metadata-visible" class="headerlink" title="metadata visible"></a>metadata visible</h2><p><code>movian</code> 显示使用的是 <code>glw ui</code>，布局文件为 <code>.view</code>，默认为 <code>showtime/glwskins/flat</code></p>
<p>以 <code>type:video</code> 为例来说明显示</p>
<p><code>pages/video.view</code> 中搜索 <code>metadata</code> 可以搜索到使用了</p>
<pre><code>max: $self.media.metadata.duration;
caption: $self.media.metadata.title;
source: $self.media.metadata.icon;</code></pre><p>因此 <code>metadata</code> 是携带数据给 <code>UI</code> 用于显示，部分数据是在默认结构中使用到的，这部分可以直接使用对应的 <code>key</code>。<br>也可以进行扩展，同时使用自行设计的 UI，例如插件 <code>somafm</code></p>
<pre><code class="js">  page.options.createInt(&#39;childTilesX&#39;, &#39;Tiles by X&#39;, 6, 1, 10, 1, &#39;&#39;, function(v) {
      page.metadata.childTilesX = v;
  }, true);

  page.options.createInt(&#39;childTilesY&#39;, &#39;Tiles by Y&#39;, 2, 1, 4, 1, &#39;&#39;, function(v) {
      page.metadata.childTilesY = v;
  }, true);

  page.options.createBool(&#39;informationBar&#39;, &#39;Information Bar&#39;, 1, function(v) {
      page.metadata.informationBar = v;
  }, true);</code></pre>
<p>在 <code>view</code> 中使用</p>
<pre><code class="view">  .childTilesX = $page.model.metadata.childTilesX ?? 6;
  .childTilesY = $page.model.metadata.childTilesY ?? 2;</code></pre>
<p><code>metadata</code> 沟通 <code>js</code> 和 <code>ui</code></p>
]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
        <tag>metadata</tag>
      </tags>
  </entry>
  <entry>
    <title>XMLHttpRequest</title>
    <url>/2018/01/12/XMLHttpRequest/</url>
    <content><![CDATA[<blockquote>
<p>Level 1 XMLHttpRequest</p>
</blockquote>
<a id="more"></a>

<h2 id="Ajax-和-XMLHttpRequest"><a href="#Ajax-和-XMLHttpRequest" class="headerlink" title="Ajax 和 XMLHttpRequest"></a>Ajax 和 XMLHttpRequest</h2><p><code>Ajax</code> <code>XMLHttpRequest</code>，细究起来它们两个是属于不同维度的 2 个概念</p>
<p><a href="http://www.tutorialspoint.com/ajax/what_is_ajax.htm" target="_blank" rel="noopener">what is ajax?</a></p>
<blockquote>
<p>AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script.<br>AJAX is based on the following open standards:</p>
</blockquote>
<blockquote>
<ul>
<li>Browser-based presentation using HTML and Cascading Style Sheets (CSS).</li>
<li>Data is stored in XML format and fetched from the server.</li>
<li>Behind-the-scenes data fetches using XMLHttpRequest objects in the browser.</li>
<li>JavaScript to make everything happen.</li>
</ul>
</blockquote>
<p><code>ajax</code> 是一种技术方案，但并不是一种新技术。它依赖的是现有的 <code>CSS/HTML/Javascript</code>，而其中最核心的依赖是浏览器提供的 <code>XMLHttpRequest</code> 对象，是这个对象使得浏览器可以发出 <code>HTTP 请求</code> 与 <code>接收 HTTP 响应</code>。</p>
<p>用一句话来总结两者的关系：<strong>使用 XMLHttpRequest 对象来发送一个 Ajax 请求</strong>。</p>
<h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><p>所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 <code>XMLHttpRequest</code> 对象。</p>
<p>老版本的 Internet Explorer （IE5 和 IE6）使用 <code>ActiveX</code> 对象：</p>
<pre><code class="js">var xmlhttp;

if (window.XMLHttpRequest)
    // code for all new browsers
    xmlhttp = new XMLHttpRequest();
else
    // code for IE5 and IE6
    xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></pre>
<h2 id="指定回调函数"><a href="#指定回调函数" class="headerlink" title="指定回调函数"></a>指定回调函数</h2><pre><code>xmlhttp.onreadystatechange = flushlist;</code></pre><h2 id="向主机发送请求"><a href="#向主机发送请求" class="headerlink" title="向主机发送请求"></a>向主机发送请求</h2><pre><code>xmlhttp.open(&quot;GET&quot;, &quot;/programmes&quot;, true);
xmlhttp.send();</code></pre><h2 id="等待主机应答"><a href="#等待主机应答" class="headerlink" title="等待主机应答"></a>等待主机应答</h2><p>监控 XMLHttpRequest 对象的状态变化</p>
<pre><code class="js">function flushlist() {
　　if ( this.readyState == 4 &amp;&amp; this.status == 200 ) {
　　　　alert( this.responseText );
　　} else {
　　　　alert( this.statusText );
　　}
};</code></pre>
<ul>
<li>xhr.readyState：XMLHttpRequest 对象的状态，等于 4 表示数据已经接收完毕。</li>
<li>xhr.status：服务器返回的状态码，等于 200 表示一切正常。</li>
<li>xhr.responseText：服务器返回的文本数据</li>
<li>xhr.responseXML：服务器返回的 XML 格式的数据</li>
<li>xhr.statusText：服务器返回的状态文本。</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://segmentfault.com/a/1190000004322487" target="_blank" rel="noopener">你真的会使用 XMLHttpRequest 吗？</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">XMLHttpRequest Level 2 使用指南</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>Web</category>
        <category>Mongoose</category>
      </categories>
      <tags>
        <tag>www</tag>
        <tag>xml</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>movian-plugin-tips</title>
    <url>/2018/01/11/movian-plugin-uri/</url>
    <content><![CDATA[<p><code>URI</code> 是 <code>Movian Plugin</code> 的入口，本篇文章分析 <code>URI</code> 的实现</p>
<a id="more"></a>

<h2 id="addURI"><a href="#addURI" class="headerlink" title="addURI"></a>addURI</h2><p><code>plugin object</code></p>
<pre><code class="api-v1.js">addURI: function(re, callback) {
  var page = require(&#39;movian/page&#39;);
  return new page.Route(re, callback);
},</code></pre>
<p><code>page</code></p>
<pre><code class="page.js">exports.Route = function(re, callback) {

  this.route = require(&#39;native/route&#39;).create(re, function(pageprop, sync, args) {

    try {

      // First, convert the raw page prop object into a proxied one
      pageprop = prop.makeProp(pageprop);

      // 将参数拆分出来，传入 fun 中执行
      // Prepend a Page object as first argument to callback
      args.unshift(new Page(pageprop, sync, false));


      callback.apply(null, args);
    } catch(e) {

      if(!prop.isZombie(pageprop)) {
        throw e;
      } else {
        console.log(&quot;Page at route &quot; + re + &quot; was closed, error supressed&quot;);
      }
    }
  });
}</code></pre>
<h2 id="URI-执行流程"><a href="#URI-执行流程" class="headerlink" title="URI 执行流程"></a>URI 执行流程</h2><p>在 <code>Movian</code> 输入 <code>ted:start</code> 之后的流程</p>
<pre><code>11:15:19.974: navigator       [INFO ]: Opening search:ted:start
11:15:19.975: ted             [DEBUG]: Opening route ^ted:start
[prop directory {&quot;persistent&quot;, &quot;previous&quot;, &quot;how&quot;, &quot;close&quot;, &quot;url&quot;, &quot;parentUrl&quot;, &quot;directClose&quot;, &quot;eventSink&quot;, &quot;bookmarked&quot;, &quot;model&quot;, &quot;glw&quot;}]
false
[object Object]
11:15:19.975: HTTP            [INFO ]: Connect to www.ted.com:443
newest
Newest


11:30:06.881: navigator       [INFO ]: Opening ted:index:funny:Funny
11:30:06.881: ted             [DEBUG]: Opening route ^ted:index:(.*):(.*)
11:30:06.881: ted             [DEBUG]:   Page argument 1 : funny
11:30:06.881: ted             [DEBUG]:   Page argument 2 : Funny
[prop directory {&quot;persistent&quot;, &quot;previous&quot;, &quot;how&quot;, &quot;close&quot;, &quot;url&quot;, &quot;parentUrl&quot;, &quot;directClose&quot;, &quot;eventSink&quot;, &quot;bookmarked&quot;, &quot;model&quot;, &quot;glw&quot;}]
false
[object Object],funny,Funny</code></pre><p><code>nav_open0</code> -&gt;<br><code>nav_open_backend</code> -&gt;<br><code>nav_open_thread</code> -&gt;<br><code>backend_open</code> -&gt;<br><code>be_open</code> -&gt;<br><code>ecmascript_openuri</code> 完成参数的解析，传入函数中执行</p>
<pre><code class="ecmascript.c">static backend_t be_ecmascript = {
  .be_flags  = BACKEND_OPEN_CHECKS_URI,
  .be_open   = ecmascript_openuri,
  .be_search = ecmascript_search,
};

BE_REGISTER(ecmascript);</code></pre>
<pre><code class="other">void backend_register(backend_t *be)
{
  LIST_INSERT_HEAD(&amp;backends, be, be_global_link);
}

#define BE_REGISTER(name)                                              \
INITIALIZER(backend_init_ ## name) {                                 \
  backend_register(&amp;be_ ## name);                                    \
}</code></pre>
<p>因此 <code>be_ecmascript</code> 注册到链表 <code>be</code> 中</p>
<p>搜索 <code>URI ted:no</code> <code>locatedb_search</code></p>
<pre><code>12:45:04.096: navigator       [INFO ]: Opening search:ted:nouri
12:45:04.097: FA              [DEBUG]: Searcher: ted:nouri: executing &quot;locate -i -L -q -b &#39;ted:nouri&#39;&quot;
12:45:06.085: FA              [DEBUG]: Searcher: ted:nouri: Done
12:45:22.445: Callout         [DEBUG]: /data/OpenSourceCode/movian/src/upnp/upnp_event.c:150 executed for 1497161us
12:45:24.057: Callout         [DEBUG]: /data/OpenSourceCode/movian/src/upnp/upnp_event.c:150 executed for 1405651us
12:45:31.823: ted             [DEBUG]: Search for ted:no was closed, error supressed
12:45:31.823: rutracker       [DEBUG]: Search for ted:no was closed, error supressed</code></pre><p><code>nav_open0</code> -&gt;<br><code>nav_open_backend</code> -&gt;<br><code>nav_open_thread</code> -&gt;<br><code>backend_open</code> -&gt;<br><code>be_open</code> -&gt;<br><code>locatedb_search</code> -&gt;<br><code>fa_searcher</code> -&gt;</p>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><pre><code>plugin.addURI(plugin.getDescriptor().id + &quot;:index:(.*):(.*)&quot;, function(page, sort, title) {
    setPageHeader(page, plugin.getDescriptor().title + &#39; - Sorted by: &#39; + decodeURIComponent(title));
    scraper(page, BASE_URL + &#39;/talks?sort=&#39; + sort);
});

plugin.addURI(plugin.getDescriptor().id + &quot;:start&quot;, function(page) {
    setPageHeader(page, plugin.getDescriptor().title + &#39; - Sort by:&#39;);
    page.loading = true;
    var doc = showtime.httpReq(BASE_URL + &#39;/talks&#39;).toString();
    page.loading = false;
    var sort = doc.match(/&lt;optgroup label=&quot;Sort by([\s\S]*?)&lt;\/optgroup&gt;/)[1];
    // 1-uri component, 2-title
    var re = /&lt;option value=&quot;([\s\S]*?)&quot;&gt;([\s\S]*?)&lt;\/option&gt;/g;
    var match = re.exec(sort);
    while (match) {
        // sort: match[1]  title: encodeURIComponent(match[2])
        // 与上面的 URI re 是对应的 plugin.getDescriptor().id + &quot;:index:(.*):(.*)&quot;
        page.appendItem(plugin.getDescriptor().id + &#39;:index:&#39; + match[1] + &#39;:&#39; + encodeURIComponent(match[2]), &quot;directory&quot;, {
            title: match[2]
        });
        match = re.exec(sort);
    }
});</code></pre>]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
      </tags>
  </entry>
  <entry>
    <title>movian-plugin-somafm</title>
    <url>/2018/01/10/movian-plugin-somafm/</url>
    <content><![CDATA[<p>分析 Movian 插件 somafm</p>
<a id="more"></a>

<h2 id="native"><a href="#native" class="headerlink" title="native"></a>native</h2><p><code>fs.js</code> 中对文件的操作是通过 <code>var fs = require(&#39;native/fs&#39;);</code> 来实现的，而 <code>native</code> 通过 <code>duktape</code> 来实现</p>
<p>目录</p>
<pre><code>movian &gt; ll src/ecmascript/es_*
1.9K 10 月 13 15:20 src/ecmascript/es_console.c
3.5K 10 月 13 15:20 src/ecmascript/es_crypto.c
 15K 10 月 13 15:20 src/ecmascript/es_faprovider.c
8.0K 10 月 13 15:20 src/ecmascript/es_fs.c
9.7K 10 月 13 15:20 src/ecmascript/es_gumbo.c
3.3K 10 月 13 15:20 src/ecmascript/es_hook.c
4.5K 10 月 13 15:20 src/ecmascript/es_htsmsg.c
 21K 10 月 13 15:20 src/ecmascript/es_io.c
3.3K 10 月 13 15:20 src/ecmascript/es_kvstore.c
3.0K 10 月 13 15:20 src/ecmascript/es_metadata.c
7.1K 10 月 13 15:20 src/ecmascript/es_misc.c
3.6K 10 月 13 15:20 src/ecmascript/es_native_obj.c
 24K 10 月 13 15:20 src/ecmascript/es_prop.c
1.9K 10 月 13 15:20 src/ecmascript/es_root.c
5.4K 10 月 13 15:20 src/ecmascript/es_route.c
2.3K 10 月 13 15:20 src/ecmascript/es_scrobble.c
1.4K 10 月 13 15:20 src/ecmascript/es_searcher.c
3.9K 10 月 13 15:20 src/ecmascript/es_service.c
7.3K 10 月 13 15:20 src/ecmascript/es_sqlite.c
3.8K 10 月 13 15:20 src/ecmascript/es_stats.c
8.2K 10 月 13 15:20 src/ecmascript/es_string.c
6.2K 10 月 13 15:20 src/ecmascript/es_subtitles.c
4.9K 10 月 13 15:20 src/ecmascript/es_timer.c
 24K 10 月 13 15:20 src/ecmascript/es_websocket.c</code></pre><p>例如 <code>es_fs.c</code> 实现模块 <code>native/fs</code></p>
<pre><code>static const duk_function_list_entry fnlist_fs[] = {
  { &quot;open&quot;,             es_file_open,             3 },
  { &quot;read&quot;,             es_file_read,             5 },
  { &quot;write&quot;,            es_file_write,            5 },
  { &quot;fsize&quot;,            es_file_fsize,            1 },
  { &quot;ftrunctae&quot;,        es_file_ftruncate,        2 },
  { &quot;rename&quot;,           es_file_rename,           2 },
  { &quot;mkdirs&quot;,           es_file_mkdirs,           2 },
  { &quot;dirname&quot;,          es_file_dirname,          1 },
  { &quot;basename&quot;,         es_file_basename,         1 },
  { &quot;copyfile&quot;,         es_file_copy,             2 },
  { NULL, NULL, 0}
};

ES_MODULE(&quot;fs&quot;, fnlist_fs);</code></pre><p>Link <code>es_modsearch</code></p>
<h2 id="Duktape"><a href="#Duktape" class="headerlink" title="Duktape"></a>Duktape</h2><p><strong><a href="http://duktape.org/guide.html#builtin-duktape" target="_blank" rel="noopener">The Duktape object</a></strong></p>
<ul>
<li>Property    Description</li>
<li>version    Duktape version number: (major * 10000) + (minor * 100) + patch.</li>
<li>env    Cryptic, version dependent summary of most important effective options like endianness and architecture.</li>
<li>fin    Set or get finalizer of an object.</li>
<li>enc    Encode a value (hex, base-64, JX, JC): Duktape.enc(‘hex’, ‘foo’).</li>
<li>dec    Decode a value (hex, base-64, JX, JC): Duktape.dec(‘base64’, ‘Zm9v’).</li>
<li>info    Get internal information (such as heap address and alloc size) of a value in a version specific format. The C API equivalent is duk_inspect_value().</li>
<li>act    Get information about call stack entry.</li>
<li>gc    Trigger mark-and-sweep garbage collection.</li>
<li>compact    Compact the memory allocated for a value (object).</li>
<li>errCreate    Callback to modify/replace a created error.</li>
<li>errThrow    Callback to modify/replace an error about to be thrown.</li>
<li>Pointer    Pointer constructor (function).</li>
<li>Thread    Thread constructor (function).</li>
</ul>
<p><code>static void es_create_env(es_context_t *ec, const char *loaddir, const char *storage)</code></p>
<pre><code>if(storage != NULL) {
  duk_push_string(ctx, storage);
  duk_put_prop_string(ctx, obj_idx, &quot;storagePath&quot;);
}

duk_put_function_list(ctx, obj_idx, fnlist_core);
duk_put_prop_string(ctx, -2, &quot;Core&quot;);

// Initialize modSearch helper

duk_get_prop_string(ctx, -1, &quot;Duktape&quot;);
duk_push_c_function(ctx, es_modsearch, 4);
duk_put_prop_string(ctx, -2, &quot;modSearch&quot;);
duk_pop(ctx);

duk_put_function_list(ctx, -1, es_fnlist_timer);

duk_push_object(ctx);
duk_put_function_list(ctx, -1, es_fnlist_console);
duk_put_prop_string(ctx, -2, &quot;console&quot;);</code></pre><h2 id="api-v1-js"><a href="#api-v1-js" class="headerlink" title="api-v1.js"></a>api-v1.js</h2><pre><code>var prop = require(&#39;movian/prop&#39;);

var cryptodigest = function(algo, str) {
  var crypto = require(&#39;native/crypto&#39;);
  var hash = crypto.hashCreate(algo);
  crypto.hashUpdate(hash, str);
  var digest = crypto.hashFinalize(hash);
  return Duktape.enc(&#39;hex&#39;, digest);
}

var misc = require(&#39;native/misc&#39;);
var string = require(&#39;native/string&#39;);
var popup = require(&#39;native/popup&#39;);</code></pre><h3 id="showtime"><a href="#showtime" class="headerlink" title="showtime"></a>showtime</h3><pre><code class="showtime">showtime = {

  // 打印
  print: print,

  // JSON 解码与编码
  JSONDecode: JSON.parse,
  JSONEncode: JSON.stringify,

  // http Get from URL
  httpGet: function(url, args, headers, ctrl) {

    var c = {
      args: args,
      headers: headers
    };

    for(var p in ctrl)
      c[p] = ctrl[p];

    return require(&#39;movian/http&#39;).request(url, c);
  },

  // Core object from Fun:es_create_env
  currentVersionInt: Core.currentVersionInt,
  currentVersionString: Core.currentVersionString,
  deviceId: Core.deviceId,

  httpReq: function(url, ctrl, cb) {
    return require(&#39;movian/http&#39;).request(url, ctrl, cb);
  },

  entityDecode: string.entityDecode,
  queryStringSplit: string.queryStringSplit,
  pathEscape: string.pathEscape,
  paramEscape: string.paramEscape,
  durationToString: string.durationToString,

  message: popup.message,
  textDialog: popup.textDialog,
  notify: popup.notify,

  probe: require(&#39;native/io&#39;).probe,

  print: print,
  trace: console.log,
  basename: require(&#39;native/fs&#39;).basename,

  // sha1
  sha1digest: function(str) {
    return cryptodigest(&#39;sha1&#39;, str);
  },

  // md5
  md5digest: function(str) {
    return cryptodigest(&#39;md5&#39;, str);
  },

  RichText: function(x) {
    this.str = x.toString();
  },

  systemIpAddress: function() {
      return misc.systemIpAddress();
  },

  getSubtitleLanguages: require(&#39;native/subtitle&#39;).getLanguages,

  xmlrpc: function() {
    var a = [];
    for(var i = 2; i &lt; arguments.length; i++)
      a.push(arguments[i]);
    var json = JSON.stringify(a);
    var x = require(&#39;native/io&#39;).xmlrpc(arguments[0], arguments[1], json);
    return require(&#39;movian/xml&#39;).htsmsg(x);
  },

  sleep: function(x) {
      return Core.sleep(x);
  }
};</code></pre>
<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><pre><code>var plugin = {

  // Fun: es_service_create
  createService: function(title, url, type, enabled, icon) {
    return require(&#39;movian/service&#39;).create(title, url, type, enabled, icon);
  },

  // Fun: es_file_mkdirs
  createStore: function(name) {
    return require(&#39;movian/store&#39;).create(name);
  },

  // page.js Route Fun: es_route_create
  addURI: function(re, callback) {
    var page = require(&#39;movian/page&#39;);
    return new page.Route(re, callback);
  },

  // page.js Searcher Fun: es_hook_register
  addSearcher: function(title, icon, cb) {
    var page = require(&#39;movian/page&#39;);
    return new page.Searcher(title, icon,cb);
  },

  // Plugin object from Fun: ecmascript_plugin_load
  path: Plugin.path,

  // parse JSON from Plugin.manifest
  getDescriptor: function() {
    if(this.descriptor === undefined)
      this.descriptor = JSON.parse(Plugin.manifest);

    return this.descriptor;
  },

  //popup object Fun: es_getAuthCredentials [fnlist_popup] file: es_misc.c
  getAuthCredentials: popup.getAuthCredentials,

  // Fun: es_http_inspector_create file: es_io.c
  addHTTPAuth: require(&#39;native/io&#39;).httpInspectorCreate,

  // Fun: es_file_copy file: es_fs.c
  copyFile: require(&#39;native/fs&#39;).copyfile,

  // Fun: es_select_view file: es_misc.c
  selectView: misc.selectView,

  // settings.js
  createSettings: function(title, icon, description) {
    var settings = require(&#39;movian/settings&#39;);
    return new settings.globalSettings(Plugin.id, title, icon, description);
  },

  // Fun: es_cachePut
  cachePut: function(stash, key, obj, maxage) {
    misc.cachePut(&#39;plugin/&#39; + Plugin.id + &#39;/&#39; + stash,
                      key, JSON.stringify(obj), maxage);
  },

  // Fun: es_cacheGet
  cacheGet: function(stash, key) {
    var v = misc.cacheGet(&#39;plugin/&#39; + Plugin.id + &#39;/&#39; + stash, key);
    return v ? JSON.parse(v) : null;
  },

  config: {},

  properties: prop.global.plugin[Plugin.id],

  // itemhook.js
  addItemHook: function(conf) {
    require(&#39;movian/itemhook&#39;).create(conf);
  },

  // Fun: es_subtitleprovideradd
  addSubtitleProvider: function(fn) {
    require(&#39;native/subtitle&#39;).addProvider(function(root, query, basescore, autosel) {
      var req = Object.create(query);
      req.addSubtitle = function(url, title, language, format,
                                 source, score) {
        require(&#39;native/subtitle&#39;).addItem(root, url, title, language, format, source,
                                 basescore + score, autosel);
      }
      fn(req);
    }, Plugin.id, Plugin.id);
  }

};

// This is the return value
plugin;</code></pre><h3 id="somafm-js"><a href="#somafm-js" class="headerlink" title="somafm.js"></a>somafm.js</h3><p>可以使用 <code>showtime.print(Plugin.manifest);</code> 在 <code>shell</code> 输出信息</p>
<pre><code>(function(plugin) {
    var BASE_URL = &quot;http://www.somafm.com&quot;;
    var logo = plugin.path + &quot;somafm.png&quot;;

    // Create Service for Plugin somafm
    plugin.createService(plugin.getDescriptor().title, plugin.getDescriptor().id + &quot;:start&quot;, &quot;music&quot;, true, logo);

    function descr(s) {
        var tmp = s.match(/&lt;p class=&quot;descr&quot;&gt;([\S\s]*?)&lt;dl&gt;/);
        if (tmp) return tmp[1].replace(&quot;&lt;!--&quot;,&quot;&quot;).replace(&quot;--&gt;&quot;,&quot;&quot;).replace(&quot;&lt;/p&gt;&quot;,&quot;&quot;).replace(/^\s+|\s+$/g, &#39;&#39;);
        tmp = s.match(/&lt;h1&gt;([\S\s]*?)&lt;\/h1&gt;/);
        if (tmp) return tmp[1];
        return null;
    }

    // Start page
    // URI: [soamfm:start]
    plugin.addURI(plugin.getDescriptor().id + &quot;:start&quot;, function(page) {
    page.type = &quot;directory&quot;;
    page.metadata.title = plugin.getDescriptor().title;
    page.metadata.logo = logo;
        page.loading = true;

        if (showtime.currentVersionInt &lt; 49900000) {
           page.metadata.glwview = plugin.path + &#39;views/array.view&#39;;
        page.contents = &#39;items&#39;;
            page.options.createInt(&#39;childTilesX&#39;, &#39;Tiles by X&#39;, 6, 1, 10, 1, &#39;&#39;, function(v) {
                page.metadata.childTilesX = v;
            }, true);

            page.options.createInt(&#39;childTilesY&#39;, &#39;Tiles by Y&#39;, 2, 1, 4, 1, &#39;&#39;, function(v) {
                page.metadata.childTilesY = v;
            }, true);

            page.options.createBool(&#39;informationBar&#39;, &#39;Information Bar&#39;, 1, function(v) {
                page.metadata.informationBar = v;
            }, true);
        } else
            page.model.contents = &#39;grid&#39;;

        // 请求网页数据 http://somafm.com/listen/
        var doc = showtime.httpReq(BASE_URL + &quot;/listen&quot;).toString();

        // re 筛选数据
        // 1-id, 2-listeners, 3-icon, 4-title, 5-(description/now playing)
        var re = /&lt;!-- Channel: (.*) Listeners: (.*) --&gt;[\S\s]*?&lt;img src=&quot;([\S\s]*?)&quot;[\S\s]*?&lt;h3&gt;([\S\s]*?)&lt;\/h3&gt;([\S\s]*?)&lt;\/li&gt;/g;
        var match = re.exec(doc);
        while (match) {
        page.appendItem(&quot;icecast:&quot; + BASE_URL + &quot;/startstream=&quot; + match[1] + &quot;.pls&quot;, &quot;station&quot;, {
            station: match[4],
            title: match[4],
            description: descr(match[5]),
            icon: BASE_URL + match[3],
                album_art: BASE_URL + match[3],
                nowplaying: (match[5].match(/&lt;span class=&quot;playing&quot;&gt;&lt;a href=&quot;[\S\s]*?&quot;&gt;([\S\s]*?)&lt;\/a&gt;/) ? match[5].match(/&lt;span class=&quot;playing&quot;&gt;&lt;a href=&quot;[\S\s]*?&quot;&gt;([\S\s]*?)&lt;\/a&gt;/)[1] : null),
            listeners: match[2]
        });
            match = re.exec(doc);
        };
    page.loading = false;
    });
})(this);</code></pre>]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
      </tags>
  </entry>
  <entry>
    <title>Movian 插件加载分析</title>
    <url>/2018/01/10/movian-plugin-load/</url>
    <content><![CDATA[<p>分析源文件 <code>src/plugins.c</code></p>
<a id="more"></a>

<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p><code>plugin_install</code> -&gt; <code>plugin_load</code> -&gt; <code>ecmascript_plugin_load</code></p>
<h3 id="plugin-load"><a href="#plugin-load" class="headerlink" title="plugin_load"></a>plugin_load</h3><p>解析 <code>plugin.json</code> 文件</p>
<pre><code>//plugin.json 路径
snprintf(ctrlfile, sizeof(ctrlfile), &quot;%s/plugin.json&quot;, url);

// 读取文件内容
if((b = fa_load(ctrlfile,
                FA_LOAD_ERRBUF(errbuf2, sizeof(errbuf2)),
                NULL)) == NULL) {
  snprintf(errbuf, errlen, &quot;Unable to load %s -- %s&quot;, ctrlfile, errbuf2);
  return -1;
}

// 解析 json 文件
ctrl = htsmsg_json_deserialize2(buf_cstr(b), errbuf, errlen);

// 获取数据
const char *type = htsmsg_get_str(ctrl, &quot;type&quot;);
const char *id   = htsmsg_get_str(ctrl, &quot;id&quot;);
const char *version = htsmsg_get_str(ctrl, &quot;version&quot;);
const char *file = htsmsg_get_str(ctrl, &quot;file&quot;);

//js 文件路径
snprintf(fullpath, sizeof(fullpath), &quot;%s/%s&quot;, url, file);

int version = htsmsg_get_u32_or_default(ctrl, &quot;apiversion&quot;, 1);

// 打开 js 文件
hts_mutex_unlock(&amp;plugin_mutex);
r = ecmascript_plugin_load(id, fullpath, errbuf, errlen, version,
                           buf_cstr(b), pflags);
hts_mutex_lock(&amp;plugin_mutex);</code></pre><h3 id="scmascript-plugin-load"><a href="#scmascript-plugin-load" class="headerlink" title="scmascript_plugin_load"></a>scmascript_plugin_load</h3><pre><code>int
ecmascript_plugin_load(const char *id, const char *url,
                       char *errbuf, size_t errlen,
                       int version, const char *manifest,
                       int flags)
{
  char storage[PATH_MAX];

  snprintf(storage, sizeof(storage),
           &quot;%s/plugins/%s&quot;, gconf.persistent_path, id);

  es_context_t *ec = es_context_create(id, flags | ECMASCRIPT_PLUGIN,
                                       url, storage);

  duk_context *ctx = es_context_begin(ec);

  duk_push_global_object(ctx);

  int plugin_obj_idx = duk_push_object(ctx);

  duk_push_string(ctx, id);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;id&quot;);

  duk_push_string(ctx, url);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;url&quot;);

  duk_push_string(ctx, manifest);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;manifest&quot;);

  duk_push_int(ctx, version);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;apiversion&quot;);
  if(ec-&gt;ec_path) {
    duk_push_string(ctx, ec-&gt;ec_path);
    duk_put_prop_string(ctx, plugin_obj_idx, &quot;path&quot;);
  }

  //Plugin object {&quot;id&quot;: , &quot;url&quot;: , &quot;manifest&quot;: , &quot;apiversion&quot;: , &quot;path&quot;: }
  duk_put_prop_string(ctx, -2, &quot;Plugin&quot;);
  duk_pop(ctx);

  if(version == 1) {

    int64_t ts0 = arch_get_ts();

    // 根据文件及路径编译为函数
    if(es_load_and_compile(ec, &quot;dataroot://res/ecmascript/legacy/api-v1.js&quot;,
                           ctx))
      goto bad;

    int64_t ts1 = arch_get_ts();

    // 执行函数
    if(duk_pcall(ctx, 0)) {
      es_dump_err(ctx);
      goto bad;
    }

    int64_t ts2 = arch_get_ts();

    //xx.js 编译
    if(es_load_and_compile(ec, url, ctx)) {
      duk_pop(ctx);
      goto bad;
    }

    int64_t ts3 = arch_get_ts();

    duk_swap_top(ctx, 0);
    // 执行
    if(duk_pcall_method(ctx, 0))
      es_dump_err(ctx);

    int64_t ts4 = arch_get_ts();

    es_debug(ec, &quot;API v1 emulation: Compile:%dms Exec:%dms&quot;,
             ((int)(ts1 - ts0)) / 1000,
             ((int)(ts2 - ts1)) / 1000);

    es_debug(ec, &quot;Plugin main:      Compile:%dms Exec:%dms&quot;,
             ((int)(ts3 - ts2)) / 1000,
             ((int)(ts4 - ts3)) / 1000);

  } else {
    es_exec(ec, url, ctx);
  }

 bad:
  es_context_end(ec, 1, ctx);

  es_context_release(ec);

  return 0;
}</code></pre>]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
      </tags>
  </entry>
  <entry>
    <title>Movian Plugin Development</title>
    <url>/2018/01/10/movian-plugin-development/</url>
    <content><![CDATA[<p>Movian Development</p>
<a id="more"></a>

<p><a href="https://movian.tv/projects/movian/wiki/PluginDevelopment" target="_blank" rel="noopener">movian development</a></p>
<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>Movian 插件使用 <code>ECMAScript</code> 编写，从 <code>v4.9.401</code> 起使用解析器 <a href="http://duktape.org" target="_blank" rel="noopener">Duktape</a></p>
<p>Movian plugins do not interact directly to the user via the user interface (similar to a web browser) but rather respond to browse and search requests and populate the internal data model with information that is then presented to the user via Movian’s user interface(s).</p>
<h2 id="Structure-of-a-plugin"><a href="#Structure-of-a-plugin" class="headerlink" title="Structure of a plugin"></a>Structure of a plugin</h2><p>每个插件都在它自己的目录中。该目录必须包含一个 <code>plugin.json</code> 文件，其中包含有关该插件的信息。除了 <code>plugin.json</code> 文件之外，对插件目录中文件的命名没有进一步的限制，或者文件放在子目录中等等</p>
<h3 id="plugin-json"><a href="#plugin-json" class="headerlink" title="plugin.json"></a>plugin.json</h3><p><code>Headweb</code> 插件为例：</p>
<pre><code class="json">{
  &quot;type&quot;: &quot;ecmascript&quot;,
  &quot;apiversion&quot;: 1,
  &quot;id&quot;: &quot;headweb&quot;,
  &quot;file&quot;: &quot;headweb.js&quot;,
  &quot;showtimeVersion&quot;: &quot;4.1.22&quot;,
  &quot;version&quot;: &quot;1.5.3&quot;,
  &quot;author&quot;: &quot;Andreas Öman&quot;,
  &quot;title&quot;: &quot;Headweb&quot;,
  &quot;icon&quot;: &quot;headweb_square.png&quot;,
  &quot;synopsis&quot;: &quot;Headweb online video&quot;,
  &quot;category&quot;: &quot;video&quot;,
  &quot;description&quot;: &quot;&lt;p&gt;Headweb is a Swedish online video store.&lt;p&gt;For more information, visit &lt;a href=\&quot;http://www.headweb.com\&quot;&gt;http://www.headweb.com&lt;/a&gt;&quot;,
  &quot;homepage&quot;:&quot;https://github.com/andoma/showtime-plugin-headweb&quot;
}</code></pre>
<h4 id="type-REQUIRED"><a href="#type-REQUIRED" class="headerlink" title="type (REQUIRED)"></a>type (REQUIRED)</h4><p>Type of plugin, as described by the following list.</p>
<ul>
<li>ecmascript - loads the plugin using Duktape.</li>
<li>views - used for user interface (screen keyboard plugin)</li>
</ul>
<h4 id="apiversion-OPTIONAL"><a href="#apiversion-OPTIONAL" class="headerlink" title="apiversion (OPTIONAL)"></a>apiversion (OPTIONAL)</h4><p>Only applicable if type is ecmascript, ie. when running using the Duktape engine. This controls the API exposed by Movian to the plugin.</p>
<ul>
<li>1 - The version 1 API is the default and is compatible with the API which was exposed through the old SpiderMonkey engine.</li>
<li>2 - The version 2 API is a new API which more resembles modern ECMAScript using modules and CommonJS interfaces. Please try to use this.</li>
</ul>
<p>The version 1 API is emulated using the version 2 API using a wrapper. The emulation code can be found here <a href="https://github.com/andoma/showtime/blob/master/resources/ecmascript/legacy/api-v1.js" target="_blank" rel="noopener">api-v1</a></p>
<h4 id="id-REQUIRED"><a href="#id-REQUIRED" class="headerlink" title="id (REQUIRED)"></a>id (REQUIRED)</h4><p>Unique identifier for a plugin. The IDs are assigned by the Movian project. Any ID starting with the string “test” is reserved for development and can be used by plugin developers until a final ID has been assigned. The assigned IDs will be ASCII lowercase. To get an ID please mail <a href="mailto:andreas@lonelycoder.com">andreas@lonelycoder.com</a></p>
<h4 id="file-REQUIRED"><a href="#file-REQUIRED" class="headerlink" title="file (REQUIRED)"></a>file (REQUIRED)</h4><p>Name of the plugin executable/script. <strong>Usually it’s a good idea to give the file a name resembling the plugin ID.</strong></p>
<h4 id="title-RECOMMENDED"><a href="#title-RECOMMENDED" class="headerlink" title="title (RECOMMENDED)"></a>title (RECOMMENDED)</h4><p>Short title of the Plugin. If omitted the ‘id’ field will be used instead which might look a bit bad due to lowercasing, etc</p>
<h4 id="showtimeVersion-RECOMMENDED"><a href="#showtimeVersion-RECOMMENDED" class="headerlink" title="showtimeVersion (RECOMMENDED)"></a>showtimeVersion (RECOMMENDED)</h4><p>Minimum version required of Movian for this plugin to work. If the current version of Movian is less than this version the user won’t be able to install the plugin but will be notified about what version of Movian is required. The same goes if a plugin is updated and the new version requires a newer version of Movian. Then the user will be refused to upgrade the plugin. If this field is omitted Movian will assume the plugin works on all versions of Movian.</p>
<h4 id="version-RECOMMENDED"><a href="#version-RECOMMENDED" class="headerlink" title="version (RECOMMENDED)"></a>version (RECOMMENDED)</h4><p>Version of the plugin. If this does not match the current installed version of a user’s plugin the user will be presented with the possibility to upgrade the plugin. If the field is omitted Movian will set the version to “Unknown”</p>
<h4 id="category-RECOMMENDED"><a href="#category-RECOMMENDED" class="headerlink" title="category (RECOMMENDED)"></a>category (RECOMMENDED)</h4><p>Category of the plugin. If the field is omitted Movian will set the category to “Unknown”. Following categories are known:</p>
<ul>
<li>“tv” - online TV</li>
<li>“video” - streaming video</li>
<li>“music” - streaming music</li>
<li>“glwview” - UI extentions</li>
<li>“subtitles” - subtitles</li>
<li>“glwosk” - on screen keyboard</li>
</ul>
<h4 id="synopsis-RECOMMENDED"><a href="#synopsis-RECOMMENDED" class="headerlink" title="synopsis (RECOMMENDED)"></a>synopsis (RECOMMENDED)</h4><p>A short one line summary of the plugin or the service it accesses</p>
<h4 id="author-OPTIONAL"><a href="#author-OPTIONAL" class="headerlink" title="author (OPTIONAL)"></a>author (OPTIONAL)</h4><p>Plugin developer. Any UTF-8 characters are valid.</p>
<h4 id="homepage-RECOMMENDED"><a href="#homepage-RECOMMENDED" class="headerlink" title="homepage (RECOMMENDED)"></a>homepage (RECOMMENDED)</h4><p>An URI with the location of the plugin homepage</p>
<h4 id="icon-OPTIONAL"><a href="#icon-OPTIONAL" class="headerlink" title="icon (OPTIONAL)"></a>icon (OPTIONAL)</h4><p>Path to plugin icon. The path is relative to the plugin root directory. If no icon is available Movian will use a placeholder image instead.</p>
<h4 id="description-OPTIONAL"><a href="#description-OPTIONAL" class="headerlink" title="description (OPTIONAL)"></a>description (OPTIONAL)</h4><p>Long RichText formatted (some HTML features are supported) description of the plugin.</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>You can reload the development plugin at any time by pressing <code>Shift+F5</code> in Movian</p>
<pre><code>./build.linux/showtime -d -p testplugin</code></pre><p>Go ahead and create the directory:</p>
<pre><code>mkdir testplugin</code></pre><p>Edit the JSON file with your favorite text editor:</p>
<pre><code>vim testplugin/plugin.json</code></pre><p>And put the required fields in there:</p>
<pre><code>{
  &quot;type&quot;: &quot;ecmascript&quot;,
  &quot;file&quot;: &quot;testplugin.js&quot;,
  &quot;id&quot;: &quot;testplugin&quot;
}</code></pre><p>Now go ahead and edit the ECMAScript file</p>
<pre><code>vim testplugin/testplugin.js</code></pre><pre><code>(function(plugin) {
  showtime.print(&quot;Hello! I&#39;m a plugin running inside Movian &quot; + showtime.currentVersionString);
})(this);</code></pre><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>Almost everything in Movian has an URI. This is used for crossplugin communications and interaction with user via unified search edit box at the top of the home screen. Each plugin registers URI starting with plugin’s ID.</p>
<pre><code>(function(plugin) {
  plugin.addURI(&quot;testplugin:hello&quot;, function(page) {
    showtime.print(&quot;I was called&quot;);
  })
})(this);</code></pre><p><code>testplugin:helllo</code> 是 <code>URI</code>，将触发函数</p>
<p><code>somafa</code> 中的 <code>start URI</code></p>
<pre><code>plugin.addURI(plugin.getDescriptor().id + &quot;:start&quot;, function(page) {
...
}</code></pre><p><code>somafm:start</code> 触发函数 <code>start</code></p>
<h2 id="ECMAScript-API-reference"><a href="#ECMAScript-API-reference" class="headerlink" title="ECMAScript API reference"></a>ECMAScript API reference</h2><p>This <a href="https://movian.tv/projects/movian/wiki/JSAPIREF" target="_blank" rel="noopener">API</a> is effective for plugins with apiversion: 1</p>
<h3 id="Service-object"><a href="#Service-object" class="headerlink" title="Service object"></a>Service object</h3><p><code>res/ecmascript/modules/movian/service.js</code></p>
<h3 id="Showtime-object"><a href="#Showtime-object" class="headerlink" title="Showtime object"></a>Showtime object</h3><p><code>res/ecmascript/legacy/api-v1.js</code></p>
<h3 id="Plugin-object"><a href="#Plugin-object" class="headerlink" title="Plugin object"></a>Plugin object</h3><p><code>res/ecmascript/legacy/api-v1.js</code></p>
<h3 id="Page-object"><a href="#Page-object" class="headerlink" title="Page object"></a>Page object</h3><p><code>res/ecmascript/modules/movian/page.js</code></p>
<h3 id="Item-object"><a href="#Item-object" class="headerlink" title="Item object"></a>Item object</h3><p><code>res/ecmascript/modules/movian/page.js</code></p>
<h3 id="Settings-object"><a href="#Settings-object" class="headerlink" title="Settings object"></a>Settings object</h3><p><code>res/ecmascript/modules/movian/settings.js</code></p>
<h3 id="HTTP-response-object"><a href="#HTTP-response-object" class="headerlink" title="HTTP response object"></a>HTTP response object</h3><p><code>res/ecmascript/modules/movian/http.js</code></p>
<h3 id="Playing-a-video-file"><a href="#Playing-a-video-file" class="headerlink" title="Playing a video file"></a>Playing a video file</h3><p>Playing (or more correctly referring to) a video can be done in two ways.</p>
<ul>
<li>Direct URL</li>
<li>Via a video page</li>
</ul>
<h2 id="XML-parsing-in-ECMAScript"><a href="#XML-parsing-in-ECMAScript" class="headerlink" title="XML parsing in ECMAScript"></a>XML parsing in ECMAScript</h2><p>When using ECMAScript and Duktape the plugins need to rely on Movian’s XML parser. To access do:</p>
<pre><code>var XML = require(&#39;showtime/xml&#39;);</code></pre><h2 id="Parsing-HTML-with-Movian"><a href="#Parsing-HTML-with-Movian" class="headerlink" title="Parsing HTML with Movian"></a>Parsing HTML with Movian</h2><p>Starting with version 4.9.389 Movian features a HTML parsing library called <a href="https://github.com/google/gumbo-parser" target="_blank" rel="noopener">gumbo</a>.</p>
<p>This allows parsing of a HTML DOM using APIs not very different from a normal browser.</p>
<p>To use it first do:</p>
<pre><code>var html = require(&#39;showtime/html&#39;);</code></pre>]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-highlight-syntax</title>
    <url>/2017/12/19/vim-highlight-syntax/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="显示颜色"><a href="#显示颜色" class="headerlink" title="显示颜色"></a>显示颜色</h2><pre><code class="bash">(x=`tput op` y=`printf %76s`;for i in {0..256};do o=00$i;echo -e ${o:${#o}-3:3} `tput setaf $i;tput setab $i`${y// /=}$x;done)</code></pre>
<p><a href="https://github.com/lilydjwg/colorizer" target="_blank" rel="noopener">colorizer</a></p>
<p><a href="https://github.com/guns/xterm-color-table.vim" target="_blank" rel="noopener">xterm-color-table.vim</a> 使用命令 <code>:XtermColorTable</code></p>
<h2 id="显示语法"><a href="#显示语法" class="headerlink" title="显示语法"></a>显示语法</h2><p><a href="https://github.com/fogine/vim-syntaxattr" target="_blank" rel="noopener">vim-syntaxattr</a> 使用命令 <code>:call SyntaxAttr()</code></p>
<h2 id="HighLight-Syntax"><a href="#HighLight-Syntax" class="headerlink" title="HighLight Syntax"></a>HighLight Syntax</h2><p><a href="http://vimdoc.sourceforge.net/htmldoc/syntax.html" target="_blank" rel="noopener">Syntax</a></p>
<h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p><code>:syntax</code></p>
<pre><code>:syntax
--- 语法项目 ---
cLabel         xxx default case
cStructure     xxx union struct typedef enum
cStorageClass  xxx inline const volatile alignas register thread_local _Noreturn static extern _Alignas _Atomic restrict noreturn
                   _Thread_local auto
cInclude       xxx match /^\s*\zs\(%:\|#\)\s*include\&gt;\s*[&quot;&lt;]/  display contains=cIncluded
cDefine        xxx start=/^\s*\zs\(%:\|#\)\s*\(define\|undef\)\&gt;/ skip=/\\$/ end=/$/  keepend contains=ALLBUT,@cPreProcGroup,@Spell
cStatement     xxx return goto asm continue break
                   links to Statement</code></pre><p><code>:help highlight-groups</code></p>
<p><code>:help group-name</code></p>
<pre><code>:help group-name

(if syntax highlighting works properly you can see the actual color, except for &quot;Ignore&quot;):

        *Comment        any comment

        *Constant       any constant
         String         a string constant: &quot;this is a string&quot;
         Character      a character constant: &#39;c&#39;, &#39;\n&#39;
         Number         a number constant: 234, 0xff
         Boolean        a boolean constant: TRUE, false
         Float          a floating point constant: 2.3e10

        *Identifier     any variable name
         Function       function name (also: methods for classes)
        *Statement      any statement
         Conditional    if, then, else, endif, switch, etc.
         Repeat         for, do, while, etc.
         Label          case, default, etc.
         Operator       &quot;sizeof&quot;, &quot;+&quot;, &quot;*&quot;, etc.
         Keyword        any other keyword
         Exception      try, catch, throw

        *PreProc        generic Preprocessor
         Include        preprocessor #include
         Define         preprocessor #define
         Macro          same as Define
         PreCondit      preprocessor #if, #else, #endif, etc.

        *Type           int, long, char, etc.
         StorageClass   static, register, volatile, etc.
         Structure      struct, union, enum, etc.
         Typedef        A typedef

        *Special        any special symbol
         SpecialChar    special character in a constant
         Tag            you can use CTRL-] on this
         Delimiter      character that needs attention
         SpecialComment special things inside a comment
         Debug          debugging statements

        *Underlined     text that stands out, HTML links

        *Ignore         left blank, hidden  hl-Ignore

        *Error          any erroneous construct
        *Todo           anything that needs extra attention; mostly the
                        keywords TODO FIXME and XXX</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>highlight</tag>
      </tags>
  </entry>
  <entry>
    <title>proc-pid-intro</title>
    <url>/2017/12/14/proc-pid-intro/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol>
<li><a href="https://github.com/NanXiao/gnu-linux-proc-pid-intro" target="_blank" rel="noopener">GNU/Linux下的/proc/[pid]目录下的文件分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>proc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-user-backtrace</title>
    <url>/2017/12/08/linux-user-backtrace/</url>
    <content><![CDATA[<p>在Linux用户态中打印<code>backtrace</code>需要两个支持</p>
<ol>
<li>编译工具链支持backtrace</li>
<li>-rdynamic</li>
</ol>
<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.lenky.info/archives/2013/01/2190" target="_blank" rel="noopener">gcc选项-g与-rdynamic的异同</a></li>
<li><a href="http://tsecer.blog.163.com/blog/static/15018172012031113824877/" target="_blank" rel="noopener">从glibc中backtrace实现看gcc内联汇编</a></li>
<li><a href="http://blog.csdn.net/jxgz_leo/article/details/53458366" target="_blank" rel="noopener"><strong>在Linux中如何利用backtrace信息解决问题</strong></a></li>
<li><a href="https://stackoverflow.com/questions/3676322/what-flags-do-you-set-for-your-gfortran-debugger-compiler-to-catch-faulty-code" target="_blank" rel="noopener">What flags do you set for your GFORTRAN debugger/compiler to catch faulty code?</a></li>
<li><a href="http://blog.csdn.net/jasonsungblog/article/details/49132291" target="_blank" rel="noopener">linux用户程序调用栈打印backtrace</a></li>
<li><a href="http://www.skyscribe.me/blog/2012/11/27/linuxshang-ru-he-cong-c-plus-plus-cheng-xu-zhong-huo-qu-backtracexin-xi/" target="_blank" rel="noopener"><strong>Linux上如何从C++程序中获取backtrace信息</strong></a></li>
<li><a href="http://blog.csdn.net/ctthuangcheng/article/details/18269995" target="_blank" rel="noopener">Linux下利用backtrace追踪函数调用堆栈以及定位段错</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>backtrace</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核崩溃信息分析</title>
    <url>/2017/12/08/linux-kernel-dumpstack/</url>
    <content><![CDATA[<p><code>kernel panic</code> 之后输出 <code>backtrace</code> 信息有助于调试问题，本文分析 <code>backtrace</code></p>
<p>内核版本 v2.6，需要支持<code>backtrace</code>，并且需要打开配置<code>kallsyms</code></p>
<a id="more"></a>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>使用的内核为<code>Linux2.6</code>，对当前的<code>arch</code>不支持<code>backtrace</code>，当内核崩溃时输出信息为：</p>
<pre><code>Backtrace not supported!</code></pre><p><code>arch/xxx/kernel/traps.c</code>函数如下</p>
<pre><code>void show_trace(void)                                                         
{                                                                             
    printk(&quot;Backtrace not supported!\n&quot;);                                     
} </code></pre><p>从相应的<code>Linux3.0.8</code>中移植函数<code>show_trace</code></p>
<pre><code>void show_trace(unsigned long *stack)                                         
{                                                                             
        unsigned long *endstack;                                                                                                   
        unsigned long addr;                                                   
        int i;                                                                

        printk(&quot;Call Trace:&quot;);                                                
        addr = (unsigned long)stack + THREAD_SIZE - 1;                        
        endstack = (unsigned long *)(addr &amp; -THREAD_SIZE);                    
        i = 0;                                                                
        while (stack + 1 &lt;= endstack) {                                       
                addr = *stack++;                                              
                /*                                                            
                 * If the address is either in the text segment of the        
                 * kernel, or in the region which contains vmalloc&#39;ed         
                 * memory, it *may* be the address of a calling               
                 * routine; if so, print it so that someone tracing           
                 * down the cause of the crash will be able to figure         
                 * out the call path that was taken.                          
                 */                                                           
                if (__kernel_text_address(addr)) {                            
#ifndef CONFIG_KALLSYMS                                                       
                        if (i % 5 == 0)                                       
                                printk(&quot;\n       &quot;);                          
#endif                                                                        
                        printk(&quot; [&lt;%08lx&gt;] %pS\n&quot;, addr, (void *)addr);       
                        i++;                                                  
                }                                                             
        }                                                                     
        printk(&quot;\n&quot;);                                                         
}</code></pre><h2 id="kernel-panic之后输出"><a href="#kernel-panic之后输出" class="headerlink" title="kernel panic之后输出"></a>kernel panic之后输出</h2><p>具体输出信息定义在<code>traps.c</code>中，相关函数</p>
<pre><code>void dump_stack(void)                                                                                                            
{                                                                             
    unsigned long stack;                                                      
    _show_trace(&amp;stack);                                                      
}                                                                             
EXPORT_SYMBOL(dump_stack);   </code></pre><p>用于输出 <code>backtrace</code></p>
<pre><code>/*                                                                            
 *      Generic dumping code. Used for panic and debug.                       
 */                                                                           
void show_registers(struct pt_regs *fp)    </code></pre><h2 id="分析函数show-trace"><a href="#分析函数show-trace" class="headerlink" title="分析函数show_trace"></a>分析函数<code>show_trace</code></h2><p><code>/data/OpenSourceCode/smallprj/C/backtrace/show_pid_backtrace.c</code></p>
<p>用法 </p>
<pre><code>#echo pid &gt; /proc/show_stack 
#cat /proc/show_stack</code></pre><p><code>printk(&quot;[&lt;%p&gt;] %pS/n&quot;, &amp;printk, &amp;printk)</code> <code>%pS</code> 参数将地址转换为函数名，需要<code>kallsyms</code>支持</p>
<p>每次函数调用时候，都会将函数的返回地址(调用函数指令的下一句指令的地址)压入堆栈，已备函数返回时。<br>我们就可以靠这个返回地址来帮助打印函数执行流。<br>但是这个地址并不是一个函数的准确地址呀？<br><code>%pS</code> 需要的参数不一定是准确的函数地址，在函数内部任意指令地址都可以，这就解释了输出形式是 <code>&quot;printk+0x0/0x1c&quot;</code>，<code>0x0</code>表示参数地址相对于printk地址的偏移，<code>0x1c</code>表示printk函数大小。</p>
<p>并且如果函数属于某个模块，还会在输出后面加上模块名称，类似：<code>[&lt;f8cd40a5&gt;] exit+0xd/0xf [hello]</code></p>
<p>这里知道地址在堆栈里，那么怎么取堆栈呢?<br>其实很简单：<br>int stack_pointer;<br>我们只要取临时变量地址值 &amp;stack_pointer 就可以了(也可以用内联汇编取esp值)，然后只要循环遍历堆栈上所有值，然后判断该值是否在<br>内核代码段空间内，如果是那么就用%pS输出。</p>
<p>那么堆栈的结束地址是什么呢？<br>就是当前进程的内核态堆栈段，不懂的话请google，一定要搞清除这个。<br>这里我们记堆栈底为:<br>bottom = (unsigned int)current_thread_info() + THREAD_SIZE;</p>
<p>但是怎么判断地址值是否在内核代码段呢？<br>我们可以用kernel_text_address这个函数就可以了，但是很不幸的是此函数内核没有导出，我们不能使用，<br>那么我们就自己实现个kernel_text_address吧，但是更不幸的是此函数内部实现所依赖的变量_etext等也没有<br>被内核导出，其实我也没想到很好的方法，索性就用个笨办法:<br>手动找出此函数内核中的地址，</p>
<h1 id="grep-kernel-text-address-proc-kallsyms"><a href="#grep-kernel-text-address-proc-kallsyms" class="headerlink" title="grep kernel_text_address /proc/kallsyms"></a>grep kernel_text_address /proc/kallsyms</h1><p>c044f107 T kernel_text_address<br>在代码中通过地址值调用kernel_text_address<br>int (<em>kernel_text_addressp)(unsigned int) = (int (</em>)(unsigned int))0xc044f107;</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/u011553162/article/details/11649869" target="_blank" rel="noopener">内核崩溃的日志</a></li>
<li><a href="http://blog.csdn.net/williamwanglei/article/details/10399899" target="_blank" rel="noopener">linux内核栈与用户栈及调用栈观察方法</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>dumpstack</tag>
        <tag>panic</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kallsyms</title>
    <url>/2017/12/08/linux-kallsyms/</url>
    <content><![CDATA[<p>在2.6版的内核中，为了更方便的调试内核代码，开发者考虑将内核代码中所有函数以及所有非栈变量的地址抽取出来，形成是一个简单的数据块(data blob:符号和地址对应)，并将此链接进 <code>vmlinux</code> 中去。即模块<code>kernel.kallsyms</code></p>
<p>在需要的时候，内核就可以将符号地址信息以及符号名称都显示出来，方便开发者对内核代码的调试。完成这一地址抽取+数据快组织封装功能的相关子系统就称之为 <code>kallsyms</code></p>
<p>反之，如果没有 <code>kallsyms</code> 的帮助，内核只能将十六进制的符号地址呈现给外界，因为它能理解的只有符号地址，并不能显示各种函数名等符号</p>
<p><code>kallsyms</code> 抽取了内核用到的所有函数地址(全局的、静态的)和非栈数据变量地址，生成一个数据块，作为只读数据链接进<code>kernel image</code>，相当于内核中存了一个<code>System.map</code></p>
<a id="more"></a>

<h2 id="配置kallsyms"><a href="#配置kallsyms" class="headerlink" title="配置kallsyms"></a>配置kallsyms</h2><pre><code>make menuconfig
General setup  ---&gt;
    [*] Configure standard kernel features (for small systems)  ---&gt;
        [*]   Load all symbols for debugging/ksymoops
        [ ]     Include all symbols in kallsyms
        [ ]     Do an extra kallsyms pass</code></pre><p>内核启动之后会解析<code>uImage</code>形成<code>/proc/kallsyms</code></p>
<p><code>/proc/kallsyms</code>包含了内核中的函数符号(包括没有EXPORT_SYMBOL)、全局变量(用EXPORT_SYMBOL导出的全局变量)</p>
<p>如果需要景内核中的函数、全局变量、静态变量都导出到<code>/proc/kallsyms</code> 需要配置 <code>Include all symbols in kallsyms</code></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><pre><code>$ less /proc/kallsyms
000000000000a018 D per_cpu__xen_vcpu
000000000000a020 D per_cpu__xen_vcpu_info
000000000000a060 d per_cpu__mc_buffer
000000000000b570 D per_cpu__xen_mc_irq_flags
000000000000b578 D per_cpu__xen_cr3
000000000000b580 D per_cpu__xen_current_cr3
000000000000b5a0 d per_cpu__xen_runstate
000000000000b5e0 d per_cpu__xen_runstate_snapshot
000000000000b610 d per_cpu__xen_residual_stolen
000000000000b618 d per_cpu__xen_residual_blocked
000000000000b620 d per_cpu__xen_clock_events
000000000000b6a0 d per_cpu__xen_debug_irq
000000000000b6a4 d per_cpu__xen_resched_irq
000000000000b6a8 d per_cpu__xen_callfunc_irq
000000000000b6ac d per_cpu__xen_callfuncsingle_irq</code></pre><p>第一列为符号地址，第二列为类型，第三列为符号名</p>
<p><strong>大写符号为全局</strong>，类型如下:</p>
<ul>
<li>A = Absolute</li>
<li>B = Uninitialised data (.bss)</li>
<li>C = Comonsymbol</li>
<li>D = Initialised data</li>
<li>G = Initialised data for small objects</li>
<li>I = Indirectreference to another symbol</li>
<li>N = Debugging symbol</li>
<li>R = Readonly</li>
<li>S = Uninitialised data for small objects</li>
<li>T = Textcode symbol</li>
<li>U = Undefined symbol</li>
<li>V = Weaksymbol</li>
<li>W = Weaksymbol</li>
<li>Corresponding small letters are local symbols</li>
</ul>
<p>更多的符号定义 <code>man nm</code></p>
<h2 id="内核符号表的生成和查找"><a href="#内核符号表的生成和查找" class="headerlink" title="内核符号表的生成和查找"></a><a href="http://blog.csdn.net/jasonchen_gbd/article/details/44025681" target="_blank" rel="noopener">内核符号表的生成和查找</a></h2><p>因为有<code>kallsyms</code>的存在可以使得内核可以在运行过程中随时获得一个符号地址对应的符号名。而内核代码中可以通过 <code>printk(&quot;%pS\n&quot;, addr)</code> 打印符号名</p>
<p><code>System.map</code> 是编译内核时生成的，它记录了内核中的符号列表，以及符号在内存中的虚拟地址。这个文件通过 <code>nm</code> 命令生成，具体可参考内核目录下的 <code>scripts/mksysmap</code> 脚本</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/jasonchen_gbd/article/details/44025681" target="_blank" rel="noopener">内核符号表的生成和查找过程</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kallsyms</tag>
      </tags>
  </entry>
  <entry>
    <title>git-subtree-split</title>
    <url>/2017/12/06/git-subtree-split/</url>
    <content><![CDATA[<p>使用 <code>git subtree</code> 拆分 <code>git仓库</code></p>
<a id="more"></a>

<h2 id="拆分仓库"><a href="#拆分仓库" class="headerlink" title="拆分仓库"></a>拆分仓库</h2><pre><code>git
├── module-A
├── sub-module1
├── .git
└── sub-module2</code></pre><p>需要将 <code>module-A</code> 保留提交记录拆分出来，流程如下：</p>
<pre><code>cd git/module-A
git subtree split -P module-A -b module-A-only (将module-A文件夹拆分为分支module-A-only)
cd -
mkdir moduleA
git init
git checkout -b dev (创建分支dev)
git pull ../git/module-A module-A-only (将module-A拆分分支拉到本地仓库)
git remote add origin https://xxx.xxx.xxx.xxx/git/module-A.git (已经创建好远程git仓库 module-A)
git pull origin dev --allow-unrelated-histories (如果远程仓库不是裸仓库，需要执行这一步，gerrit创建project会产生提交)
git push origin -u dev (将本地分支推送到远程dev分支上)</code></pre><p>如果要迁移所有的分支信息，需要重复上面步骤中对<code>dev</code>分支的操作</p>
<p>可以将<code>git/module-A</code>下的资料清除掉</p>
<pre><code>git filter-branch -f --index-filter &quot;git rm -r -f -q --cached --ignore-unmatch module-A&quot; --prune-empty HEAD</code></pre><h2 id="迁移仓库"><a href="#迁移仓库" class="headerlink" title="迁移仓库"></a>迁移仓库</h2><p>迁移仓库可以保留原仓库的所有信息，包括提交历史及分支，需要使用<code>裸仓库</code></p>
<p>如果你想从别的 Git 托管服务那里复制一份源代码到新的 Git 托管服务器上的话，可以通过以下步骤来操作。</p>
<p>从原地址克隆一份裸版本库，比如原本托管于 GitHub。</p>
<pre><code>git clone --bare git://github.com/username/project.git</code></pre><p>然后到新的 Git 服务器上创建一个新项目，比如 GitCafe。</p>
<p>以镜像推送的方式上传代码到 GitCafe 服务器上。</p>
<pre><code>cd project.git
git push --mirror git@gitcafe.com/username/newproject.git</code></pre><p>删除本地代码</p>
<pre><code>cd ..
rm -rf project.git</code></pre><p>到新服务器 GitCafe 上找到 Clone 地址，直接 Clone 到本地就可以了。</p>
<pre><code>git clone git@gitcafe.com/username/newproject.git</code></pre><h2 id="gerrit"><a href="#gerrit" class="headerlink" title="gerrit"></a>gerrit</h2><p>通过 <code>gerrit</code> 创建的 <code>project</code> 会有权限问题，导致拆分仓库时最后一步失败</p>
<pre><code>Pushing to https://gerrit.googlesource.com/gerrit
POST git-receive-pack (11557 bytes)
remote: Resolving deltas: 100% (76/76)           remote: Resolving deltas: 100% (76/76)        
remote: Processing changes: refs: 1        remote: Processing changes: refs: 1, done            
remote: 
remote: ERROR:  In commit 0a99723fd7039844ce697997916910ce11bdcb4a        
remote: ERROR:  committer email address mani_c...@yahoo.co.in        
remote: ERROR:  does not match your user account.        
remote: ERROR:        
remote: ERROR:  The following addresses are currently registered:        
remote: ERROR:    mani.c...@tcs.com        
remote: ERROR:        
remote: ERROR:  To register an email address, please visit:        
remote: ERROR:  https://gerrit-review.googlesource.com/#/settings/contact        
remote: 
remote: 
To https://gerrit.googlesource.com/gerrit</code></pre><p><a href="https://gerrit-review.googlesource.com/Documentation/error-invalid-committer.html" target="_blank" rel="noopener">invalid committer</a></p>
<p>两种原因：</p>
<ol>
<li>incorrect configuration of the e-mail address on client or server side</li>
<li>missing privileges to push commits that were committed by other users</li>
</ol>
<p>应该是第二个原因导致的，解释如下：</p>
<blockquote>
<p>If pushing to Gerrit fails with the error message “invalid committer” and somebody else committed the change for which the push fails, then you have no permissions to forge the committer identity. In this case you may contact the project owner to request the ‘Forge Committer’ access right or ask the maintainer to commit this change on the author’s behalf.</p>
</blockquote>
<p><a href="https://gerrit-review.googlesource.com/Documentation/access-control.html#category_forge_committer" target="_blank" rel="noopener">Forge Committer</a></p>
<p>在 <code>gerrit</code> 中添加 <code>Forge Committer</code> 权限解决此问题</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
        <tag>repo</tag>
        <tag>gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title>git-repo-gerrit</title>
    <url>/2017/12/01/git-repo-gerrit/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p><a href="https://vra.github.io/2017/04/19/deploy-git/" target="_blank" rel="noopener">搭建自己的Git服务器</a><br><a href="http://blog.csdn.net/davidsky11/article/details/23023729" target="_blank" rel="noopener">使用Gitosis搭建Git服务器</a></p>
<p>使用 <code>git init --bare my-repo.git</code> 来创建裸仓库</p>
<h2 id="搭建Gerrit服务器"><a href="#搭建Gerrit服务器" class="headerlink" title="搭建Gerrit服务器"></a>搭建Gerrit服务器</h2><p><a href="http://hanpfei.github.io/2017/11/24/gerrit_codereview/" target="_blank" rel="noopener">Gerrit代码审核服务器搭建全过程</a></p>
<h2 id="搭建Repo服务器"><a href="#搭建Repo服务器" class="headerlink" title="搭建Repo服务器"></a>搭建Repo服务器</h2><p><a href="http://blog.csdn.net/davidsky11/article/details/23024153" target="_blank" rel="noopener">搭建Repo服务器</a><br><a href="http://www.jianshu.com/p/7893271520b6" target="_blank" rel="noopener">如何使用Google Repo管理复杂项目</a><br><a href="https://www.zhihu.com/question/41440585" target="_blank" rel="noopener">怎么针对自己项目工程建立Repo管理多个git仓库?</a></p>
<p>repo并不是一个程序，而是一个脚本工程，git才是真正的版本管理工具。说到底，Repo就是一堆批处理，它把git的命令进行了合理封装，目标就是同时管理多个git工程。</p>
<pre><code>repo init -u git://10.203.138.81/RepoServer/manifest.git</code></pre><ol>
<li>首先它创建一个.repo的文件夹，这个文件夹是隐藏的。接下来Repo所做的事情都是在.repo这个文件夹底下进行的。</li>
<li>它从网上下载一个repo.git的工程，这个工程才是整整的Repo的全部，也就是我们前面说过的”git命令脚本工程”，它是使用python语言写的。</li>
<li>最后它把”-u git://10.203.138.81/RepoServer/manifest.git”传递给了repo工程。manifest.git工程中其实只有一个文件：default.xml，这个文件记录了一个工程列表。<br>当我们执行repo sync时，Repo通过解析default.xml这个文件，循环遍历下载所有的工程，从而达到统一管理的目的。</li>
</ol>
<pre><code class=".repo">.
├── manifests
├── manifests.git
├── manifest.xml -&gt; manifests/default.xml
├── project.list
├── projects
└── repo</code></pre>
<p>其中 <code>repo</code> 和 <code>manifests</code> 是两个 <code>git仓库</code>，分别为 <code>repo仓库</code> 和 <code>manifests仓库</code></p>
<pre><code>&gt; /.repo &gt; cd repo 
&gt; /.repo/repo &gt; git remote -v
origin    http://xxx.xxx.xxx.xxx/git/repo.git (fetch)
origin    http://xxx.xxx.xxx.xxx/git/repo.git (push)
&gt; /.repo/repo &gt; cd ../manifests
&gt; /.repo/manifests &gt; git remote -v
origin    http://xxx.xxx.xxx.xxx/git/a/b.git (fetch)
origin    http://xxx.xxx.xxx.xxx/git/a/b.git (push)</code></pre><h2 id="Repo工作原理"><a href="#Repo工作原理" class="headerlink" title="Repo工作原理"></a>Repo工作原理</h2><p><a href="http://blog.csdn.net/luoshengyang/article/details/18195205" target="_blank" rel="noopener">Android源代码仓库及其管理工具Repo分析</a></p>
<p>Repo工具实际上是由一系列的Python脚本组成的，这些Python脚本通过调用Git命令来完成自己的功能。比较有意思的是，组成Repo工具的那些Python脚本本身也是一个Git仓库。这个Git仓库在AOSP里面就称为Repo仓库。</p>
<p>上面我们讨论的是Repo仓库，但是实际上我们执行Repo命令想操作的是AOSP。这就要求Repo命令要知道AOSP都包含有哪些子项目，并且要知道这些子项目的名称、仓库地址是什么。换句话说，就是Repo命令要知道AOSP所有子项目的Git仓库元信息。我们知道，AOSP也是不断地迭代法变化的，例如，它的每一个版本所包含的子项目可能都是不一样的。这意味着需要通过另外一个Git仓库来管理AOSP所有的子项目的Git仓库元信息。这个Git仓库在AOSP里面就称为Manifest仓库。</p>
<p>提到了三种类型的Git仓库，分别是Repo仓库、Manifest仓库和AOSP子项目仓库。Repo仓库通过Manifest仓库可以获得所有AOSP子项目仓库的元信息。有了这些元信息之后，我们就可以通过Repo仓库里面的Python脚本来操作AOSP的子项目。那么，Repo仓库和Manifest仓库又是怎么来的呢？答案是通过一个独立的Repo脚本来获取，这个Repo脚本位于AOSP的一个官方网站上，我们可以通过HTTP协议来下载。</p>
<p>通过一个图来来勾勒一下整个AOSP的Picture，它由Repo脚本、Repo仓库、Manifest仓库和AOSP子项目仓库组成，如图1所示：</p>
<p><img src="/images/repo/repo.png" alt="repo"></p>
<h2 id="把已有的repo工程提交到服务器"><a href="#把已有的repo工程提交到服务器" class="headerlink" title="把已有的repo工程提交到服务器"></a>把已有的repo工程提交到服务器</h2><p><a href="http://nicekwell.net/blog/20171112/ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi.html" target="_blank" rel="noopener"><strong>把已有的repo工程提交到服务器</strong></a></p>
<pre><code>一、基础知识
1、git
2、repo
3、manifest.xml文件
二、把已有的repo工程提交到自己的服务器
1、客户端和服务端都安装python3
2、客户端准备一个干净的工程
3、服务器端创建manifest.git工程
4、客户端修改并上传manifest.xml文件
5、服务端分析manifest.xml文件，批量创建工程
6、客户端分析manifest.xml文件，批量上传到服务器
7、测试</code></pre><h2 id="拆分repo仓库"><a href="#拆分repo仓库" class="headerlink" title="拆分repo仓库"></a>拆分repo仓库</h2><p><a href="http://blog.kidwm.net/341" target="_blank" rel="noopener">使用 git subtree 來分拆子目錄成獨立的新 repo</a><br><a href="http://zhjwpku.com/2017/02/08/detach-subdirectory-into-seperate-git-repo.html" target="_blank" rel="noopener">分离子目录到单独的 Git Repo</a></p>
<pre><code>pushd ~/Code/node-browser-compat/
git subtree split -P btoa -b btoa-only
popd

mkdir ~/Code/btoa/
pushd ~/Code/btoa/
git init
git pull ~/Code/node-browser-compat btoa-only</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
        <tag>repo</tag>
        <tag>gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-wpa-supplicant-error</title>
    <url>/2017/11/24/linux-wpa-supplicant-error/</url>
    <content><![CDATA[<p>Linux系统中切换<code>DHCP</code>和<code>STATIC</code>模式出现长时间不能连上wifi的问题，<br>分析log发现是<code>wpa_supplicant</code>问题，mark之</p>
<a id="more"></a>

<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><pre><code>1511502263.447980: rfkill: Cannot open RFKILL control device
1511502263.538880: ctrl_iface exists and seems to be in use - cannot override it
1511502263.539083: Delete &#39;/var/run/wpa_supplicant/ra0&#39; manually if it is not used anymore
1511502263.539316: Failed to initialize control interface &#39;/var/run/wpa_supplicant&#39;.
You may have another wpa_supplicant process already running or the file was
left by an unclean termination of wpa_supplicant in which case you will need
to manually remove this file before starting wpa_supplicant again.</code></pre><p>##</p>
<p>不使用 <code>systemd</code></p>
<p>直接删除可以解决问题？</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://bbs.archlinux.org/viewtopic.php?id=175430" target="_blank" rel="noopener">Trying to switch from DHCP to static</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>wpa-supplicant</tag>
      </tags>
  </entry>
  <entry>
    <title>how-to-check-network-status</title>
    <url>/2017/11/09/how-to-check-network-status/</url>
    <content><![CDATA[<p><a href="https://github.com/antiX-Linux/ifplugd.git" target="_blank" rel="noopener">ifplugd</a> A link detection daemon for ethernet devices</p>
<p>api mode:</p>
<ul>
<li>ethtool</li>
<li>mii</li>
<li>wlan</li>
<li>iff</li>
<li>priv</li>
</ul>
<blockquote>
<p>Force a specific link beat detection ioctl() API. Possible values are auto, iff, wlan, ethtool, mii, and priv for automatic detection, interface flag (IFF_RUNNING), wireless extension, SIOCETHTOOL, SIOCGMIIREG resp. SIOCPRIV. Only the first character of the argument is relevant, case insensitive. (default: auto)</p>
</blockquote>
<a id="more"></a>

<h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><pre><code>    if ((fd = socket(PF_INET, SOCK_DGRAM, 0)) &lt; 0)
        return -1;</code></pre><p>创建<code>socket</code>用于<code>ioctl</code></p>
<h2 id="ethtool-SIOCETHTOOL"><a href="#ethtool-SIOCETHTOOL" class="headerlink" title="ethtool SIOCETHTOOL"></a>ethtool SIOCETHTOOL</h2><p>Ethtool是Linux下用于查询及设置网卡参数的命令</p>
<pre><code>#include &lt;sys/ioctl.h&gt;
#include &lt;net/if.h&gt;

interface_status_t interface_detect_beat_ethtool(int fd, char *iface) {

    struct ifreq ifr;
    struct ethtool_value edata;

    if (interface_auto_up)
        interface_up(fd, iface);

    memset(&amp;ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name)-1);

    edata.cmd = ETHTOOL_GLINK;
    ifr.ifr_data = (caddr_t) &amp;edata;

    if (ioctl(fd, SIOCETHTOOL, &amp;ifr) == -1) {
        if (interface_do_message)
            daemon_log(LOG_ERR, &quot;ETHTOOL_GLINK failed: %s&quot;, strerror(errno));

        return IFSTATUS_ERR;
    }

    return edata.data ? IFSTATUS_UP : IFSTATUS_DOWN;
}</code></pre><p>对应内核代码<code>linux/net/core/dev.c</code>中<code>dev_ioctl()</code>函数，对应的<code>SIOCETHTOOL</code>，又调用了<code>linux/net/core/ethtool.c</code>中的实现，而<code>dev_ethtool()</code>函数，而这个函数最终又会调用相应<code>if</code>驱动的<code>ethtool_ops</code>结构体中注册的函数来实现寄存器的操作。当然，不同的<code>PHY</code>驱动对此有不同的操作，甚至有些<code>PHY</code>驱动根本没有注册这个结构体，这时，我们就要尝试其他方式。</p>
<pre><code>static struct ethtool_ops synopGMAC_ethtool_ops = {
    .get_link       = synopGMAC_get_link
};

.

netdev-&gt;ethtool_ops = &amp;synopGMAC_ethtool_ops;</code></pre><p><code>include/linux/ethtool.h</code> 中存在 <code>ioctl</code> 列表 <code>ETHTOOL_*</code></p>
<h2 id="mii"><a href="#mii" class="headerlink" title="mii"></a>mii</h2><p>mii-tool（这是Linux下专门设置网卡工作模式的命令）　</p>
<p><code>MII</code>的全称是<code>Media Independent Interface</code>，字面意思上就是媒体无关的接口，因此它是独立于具体设备的，仔细想想标准化的东西都是独立于具体设备的。虽然如此，很多以太网卡设备并不支持这些参数的配置，因此当你执行mii-tool的时候，会得到Operation not supported的提示，要不就是没有使用超级用户身份，还有就是若接口编号设置超过eth7时，直接使用mii-tool 不加参数，会出现NO MII xxxxxxxxxx interface 之类的提示，是因为超过了默认值，使用帮助信息可以了解。</p>
<pre><code>interface_status_t interface_detect_beat_mii(int fd, char *iface) {
    struct ifreq ifr;

    if (interface_auto_up)
        interface_up(fd, iface);

    memset(&amp;ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name)-1);

    if (ioctl(fd, SIOCGMIIPHY, &amp;ifr) == -1) {
        if (interface_do_message)
            daemon_log(LOG_ERR, &quot;SIOCGMIIPHY failed: %s&quot;, strerror(errno));

        return IFSTATUS_ERR;
    }

    ((unsigned short*) &amp;ifr.ifr_data)[1] = 1;

    if (ioctl(fd, SIOCGMIIREG, &amp;ifr) == -1) {
        if (interface_do_message)
            daemon_log(LOG_ERR, &quot;SIOCGMIIREG failed: %s&quot;, strerror(errno));

        return IFSTATUS_ERR;
    }

    return (((unsigned short*) &amp;ifr.ifr_data)[3] &amp; 0x0004) ? IFSTATUS_UP : IFSTATUS_DOWN;
}</code></pre><p>对应内核代码<code>linux/net/core/dev.c</code>中<code>dev_ioctl()</code>函数，对应的<code>SIOCxMIIxxx</code>，又调用了<code>dev_ifsioc()</code>函数，这个函数最终调用<code>PHY</code>驱动中注册的<code>do_ioctl()</code>函数来实现PHY寄存器的读写。</p>
<p>例如内核中<code>winbond-840</code>初始化如下：</p>
<pre><code>static int __devinit w840_probe1 (struct pci_dev *pdev, const struct pci_device_id *ent)
{
    struct net_device *dev;
    struct netdev_private *np;
    static int find_cnt;
    int chip_idx = ent-&gt;driver_data;
    int irq;
    int i, option = find_cnt &lt; MAX_UNITS ? options[find_cnt] : 0;
    void __iomem *ioaddr;

    ...

    dev = alloc_etherdev(sizeof(*np));
    if (!dev)
        return -ENOMEM;
    SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);

    ...

    dev-&gt;open = &amp;netdev_open;
    dev-&gt;hard_start_xmit = &amp;start_tx;
    dev-&gt;stop = &amp;netdev_close;
    dev-&gt;get_stats = &amp;get_stats;
    dev-&gt;set_multicast_list = &amp;set_rx_mode;
    dev-&gt;do_ioctl = &amp;netdev_ioctl; //mii
    dev-&gt;ethtool_ops = &amp;netdev_ethtool_ops; //ethtool
    dev-&gt;tx_timeout = &amp;tx_timeout;
    dev-&gt;watchdog_timeo = TX_TIMEOUT;

    i = register_netdev(dev);
}</code></pre><p><code>include/linux/sockios.h</code> 中</p>
<pre><code>#define SIOCGMIIPHY 0x8947      /* Get address of MII PHY in use. */
#define SIOCGMIIREG 0x8948      /* Read MII PHY register.   */
#define SIOCSMIIREG 0x8949      /* Write MII PHY register.  */</code></pre><h2 id="wlan"><a href="#wlan" class="headerlink" title="wlan"></a>wlan</h2><pre><code>    interface_status_t interface_detect_beat_wlan(int fd, char *iface)
    {
        uint8_t mac[6];
        int q;
        struct iwreq req;

        if (interface_auto_up)
            interface_up(fd, iface);

        memset(&amp;req, 0, sizeof(req));
        strncpy(req.ifr_ifrn.ifrn_name, iface, IFNAMSIZ);

        if (ioctl(fd, SIOCGIWAP, &amp;req) &lt; 0) {
            if (interface_do_message)
                daemon_log(LOG_WARNING, &quot;Failed to get AP address: %s&quot;,strerror(errno));
            return IFSTATUS_ERR;
        }

        memcpy(mac, &amp;(req.u.ap_addr.sa_data), ETH_ALEN);

        if (!is_assoc_ap(mac))
            return IFSTATUS_DOWN;

        if ((q = get_wlan_qual_new(fd, iface)) &lt; 0)
            if ((q = get_wlan_qual_old(iface)) &lt; 0) {
                if (interface_do_message)
                    daemon_log(LOG_WARNING, &quot;Failed to get wireless link quality.&quot;);

                return IFSTATUS_ERR;
            }

        return q &gt; 0 ? IFSTATUS_UP : IFSTATUS_DOWN;
    }</code></pre><p>从应用到内核再到wifi驱动的流程如下：</p>
<p>应用上</p>
<pre><code>    if (ioctl(fd, SIOCGIWAP, &amp;req) &lt; 0) {
        if (interface_do_message)
            daemon_log(LOG_WARNING, &quot;Failed to get AP address: %s&quot;,strerror(errno));
        return IFSTATUS_ERR;
    }</code></pre><p>其中 <code>include/linux/wireless.h</code></p>
<pre><code>    #define SIOCGIWAP   0x8B15</code></pre><p>调用流程如下：</p>
<p><code>sock_ioctl[net/socket.c]</code> -&gt; <code>dev_ioctl[net/core/dev.c]</code> -&gt; <code>wext_handle_ioctl[net/wireless/wext.c]</code> -&gt; <code>wireless_process_ioctl[net/wireless/wext.c]</code></p>
<p>对wireless_process_ioctl，又跑到了default中，如果有handler，最后到ioctl_standard_call中；没有handler时，使用老的接口（dev-&gt;do_ioctl）</p>
<pre><code>    /* New driver API : try to find the handler */
    handler = get_handler(dev, cmd);
    if (handler) {
        /* Standard and private are not the same */
        if (cmd &lt; SIOCIWFIRSTPRIV)
            return standard(dev, iwr, cmd, info, handler);
        else
            return private(dev, iwr, cmd, info, handler);
    }
    /* Old driver API : call driver ioctl handler */
    if (dev-&gt;do_ioctl)
        return dev-&gt;do_ioctl(dev, ifr, cmd);</code></pre><p>在WIFI驱动中如下：</p>
<pre><code>    static const iw_handler rt_handler[] =
    {
        (iw_handler) NULL,                      /* SIOCSIWCOMMIT */
        (iw_handler) rt_ioctl_giwname,          /* SIOCGIWNAME   */
        (iw_handler) NULL,                      /* SIOCSIWNWID   */
        (iw_handler) NULL,                      /* SIOCGIWNWID   */
        (iw_handler) rt_ioctl_siwfreq,          /* SIOCSIWFREQ   */
        (iw_handler) rt_ioctl_giwfreq,          /* SIOCGIWFREQ   */
        (iw_handler) rt_ioctl_siwmode,          /* SIOCSIWMODE   */
        (iw_handler) rt_ioctl_giwmode,          /* SIOCGIWMODE   */
        (iw_handler) NULL,                      /* SIOCSIWSENS   */
        (iw_handler) NULL,                      /* SIOCGIWSENS   */
        (iw_handler) NULL /* not used */,       /* SIOCSIWRANGE  */
        (iw_handler) rt_ioctl_giwrange,         /* SIOCGIWRANGE  */
        (iw_handler) rt_ioctl_giwpriv,      /* SIOCSIWPRIV  for Android */
        (iw_handler) NULL /* kernel code */,    /* SIOCGIWPRIV   */
        (iw_handler) NULL /* not used */,       /* SIOCSIWSTATS  */
        (iw_handler) rt28xx_get_wireless_stats /* kernel code */,    /* SIOCGIWSTATS  */
        (iw_handler) NULL,                      /* SIOCSIWSPY    */
        (iw_handler) NULL,                      /* SIOCGIWSPY    */
        (iw_handler) NULL,                      /* SIOCSIWTHRSPY */
        (iw_handler) NULL,                      /* SIOCGIWTHRSPY */
        (iw_handler) rt_ioctl_siwap,            /* SIOCSIWAP     */
        (iw_handler) rt_ioctl_giwap,            /* SIOCGIWAP     */
    };

    const struct iw_handler_def rt28xx_iw_handler_def =
    {
    #define N(a)    (sizeof (a) / sizeof (a[0]))
        .standard   = (iw_handler *) rt_handler,
        .num_standard   = sizeof(rt_handler) / sizeof(iw_handler),
        .private    = (iw_handler *) rt_priv_handlers,
        .num_private        = N(rt_priv_handlers),
        .private_args   = (struct iw_priv_args *) privtab,
        .num_private_args   = N(privtab),
    #if IW_HANDLER_VERSION &gt;= 7
        .get_wireless_stats = rt28xx_get_wireless_stats,
    #endif
    };

    int rt28xx_open(VOID *dev)
    {
        if (OpMode == OPMODE_STA)
            net_dev-&gt;wireless_handlers = (struct iw_handler_def *) &amp;rt28xx_iw_handler_def;
    }</code></pre><p>老的接口实现如下：</p>
<pre><code>    RtmpPhyNetDevInit()
    {
        pNetDevHook-&gt;ioctl = rt28xx_ioctl;
        pNetDevHook-&gt;priv_flags = InfId; /*INT_MAIN; */
        pNetDevHook-&gt;get_stats = RT28xx_get_ether_stats;
    }

    RtmpOSNetDevAttach()
    {
    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,31)
        pNetDevOps-&gt;ndo_open = pDevOpHook-&gt;open;
        pNetDevOps-&gt;ndo_stop = pDevOpHook-&gt;stop;
        pNetDevOps-&gt;ndo_start_xmit =
            (HARD_START_XMIT_FUNC) (pDevOpHook-&gt;xmit);
        pNetDevOps-&gt;ndo_do_ioctl = pDevOpHook-&gt;ioctl;
    #else
        pNetDev-&gt;open = pDevOpHook-&gt;open;
        pNetDev-&gt;stop = pDevOpHook-&gt;stop;
        pNetDev-&gt;hard_start_xmit =
            (HARD_START_XMIT_FUNC) (pDevOpHook-&gt;xmit);
        pNetDev-&gt;do_ioctl = pDevOpHook-&gt;ioctl;
    #endif

    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,18)
        pNetDev-&gt;ethtool_ops = &amp;RALINK_Ethtool_Ops;
    #endif

        /* if you don&#39;t implement get_stats, just leave the callback function as NULL, a dummy
        function will make kernel panic.
        */
        if (pDevOpHook-&gt;get_stats)
    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,31)
            pNetDevOps-&gt;ndo_get_stats = pDevOpHook-&gt;get_stats;
    #else
        pNetDev-&gt;get_stats = pDevOpHook-&gt;get_stats;
    #endif

        /* OS specific flags, here we used to indicate if we are virtual interface */
        /*      pNetDev-&gt;priv_flags = pDevOpHook-&gt;priv_flags; */
        RT_DEV_PRIV_FLAGS_SET(pNetDev, pDevOpHook-&gt;priv_flags);
    #if (WIRELESS_EXT &lt; 21) &amp;&amp; (WIRELESS_EXT &gt;= 12)
        /*      pNetDev-&gt;get_wireless_stats = rt28xx_get_wireless_stats; */
        pNetDev-&gt;get_wireless_stats = pDevOpHook-&gt;get_wstats;
    #endif

    #ifdef CONFIG_STA_SUPPORT
    #if WIRELESS_EXT &gt;= 12
        if (OpMode == OPMODE_STA) {
            /*          pNetDev-&gt;wireless_handlers = &amp;rt28xx_iw_handler_def; */
            pNetDev-&gt;wireless_handlers = pDevOpHook-&gt;iw_handler;
        }
    #endif /*WIRELESS_EXT &gt;= 12 */
    #endif /* CONFIG_STA_SUPPORT */

    #ifdef CONFIG_APSTA_MIXED_SUPPORT
    #if WIRELESS_EXT &gt;= 12
        if (OpMode == OPMODE_AP) {
            /*          pNetDev-&gt;wireless_handlers = &amp;rt28xx_ap_iw_handler_def; */
            pNetDev-&gt;wireless_handlers = pDevOpHook-&gt;iw_handler;
        }
    #endif /*WIRELESS_EXT &gt;= 12 */
    #endif /* CONFIG_APSTA_MIXED_SUPPORT */

        /* copy the net device mac address to the net_device structure. */
        NdisMoveMemory(pNetDev-&gt;dev_addr, &amp;pDevOpHook-&gt;devAddr[0],
                MAC_ADDR_LEN);

        rtnl_locked = pDevOpHook-&gt;needProtcted;
    }

    rt2870_probe()
    {

        net_dev = RtmpPhyNetDevInit(pAd, &amp;netDevHook);

        status = RtmpOSNetDevAttach(OpMode, net_dev, &amp;netDevHook);
    }</code></pre><h2 id="iff"><a href="#iff" class="headerlink" title="iff"></a>iff</h2><pre><code>    interface_status_t interface_detect_beat_iff(int fd, char *iface) {

        struct ifreq ifr;

        if (interface_auto_up)
            interface_up(fd, iface);

        memset(&amp;ifr, 0, sizeof(ifr));
        strncpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name)-1);

        if (ioctl(fd, SIOCGIFFLAGS, &amp;ifr) == -1) {
            if (interface_do_message)
                daemon_log(LOG_ERR, &quot;SIOCGIFFLAGS failed: %s&quot;, strerror(errno));

            return IFSTATUS_ERR;
        }

        return ifr.ifr_flags &amp; IFF_RUNNING ? IFSTATUS_UP : IFSTATUS_DOWN;
    }</code></pre><p>调ioctl的<code>SIOCGIFFLAGS</code>实现，<code>dev_ifsioc_locked</code>函数（net/core/dev.c）中处理：</p>
<pre><code>    case SIOCGIFFLAGS:  /* Get interface flags */                         
        ifr-&gt;ifr_flags = dev_get_flags(dev);                              
        return 0;  </code></pre><pre><code>    unsigned dev_get_flags(const struct net_device *dev)                                                                     
    {                                                                             
        unsigned flags;                                                           

        flags = (dev-&gt;flags &amp; ~(IFF_PROMISC |                                     
                    IFF_ALLMULTI |                                                
                    IFF_RUNNING |                                                 
                    IFF_LOWER_UP |                                                
                    IFF_DORMANT)) |                                               
            (dev-&gt;gflags &amp; (IFF_PROMISC |                                         
                    IFF_ALLMULTI));                                               

        if (netif_running(dev)) {                                                 
            if (netif_oper_up(dev))                                               
                flags |= IFF_RUNNING;                                             
            if (netif_carrier_ok(dev))                                            
                flags |= IFF_LOWER_UP;                                            
            if (netif_dormant(dev))                                               
                flags |= IFF_DORMANT;                                             
        }                                                                         

        return flags;                                                             
    }</code></pre><p><strong>没有由网卡驱动去查硬件，而是查现有的状态标志位来实现。</strong></p>
<h2 id="priv"><a href="#priv" class="headerlink" title="priv"></a>priv</h2><p><code>interface_detect_beat_priv</code> 基本上和 <code>mii</code> 一样，调<code>ioctl</code>的<code>SIOCDEVPRIVATE</code>和<code>SIOCDEVPRIVATE+1</code>实现，<code>dev_ifsioc</code>函数（net/core/dev.c）中处理同方法<code>mii</code>，有一点不同就是<code>SIOCDEVPRIVATE</code>到<code>SIOCDEVPRIVATE + 15</code>是各个网卡自己定义的命令，有的网卡有实现，有的没有。例如e100就没有实现这个ioctl。而rtl8150的usb版本网卡驱动就有实现。</p>
<pre><code>    interface_status_t interface_detect_beat_priv(int fd, char *iface) {
        struct ifreq ifr;

        if (interface_auto_up)
            interface_up(fd, iface);

        memset(&amp;ifr, 0, sizeof(ifr));
        strncpy(ifr.ifr_name, iface, sizeof(ifr.ifr_name)-1);

        if (ioctl(fd, SIOCDEVPRIVATE, &amp;ifr) == -1) {
            if (interface_do_message)
                daemon_log(LOG_ERR, &quot;SIOCDEVPRIVATE failed: %s&quot;, strerror(errno));

            return IFSTATUS_ERR;
        }

        ((unsigned short*) &amp;ifr.ifr_data)[1] = 1;

        if (ioctl(fd, SIOCDEVPRIVATE+1, &amp;ifr) == -1) {
            if (interface_do_message)
                daemon_log(LOG_ERR, &quot;SIOCDEVPRIVATE+1 failed: %s&quot;, strerror(errno));

            return IFSTATUS_ERR;
        }

        return (((unsigned short*) &amp;ifr.ifr_data)[3] &amp; 0x0004) ? IFSTATUS_UP : IFSTATUS_DOWN;
    }</code></pre><h2 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h2><p><code>ethtool</code>，<code>mii</code> 和 <code>wlan</code> 都是通过查询硬件寄存器，<code>priv</code> 可能不支持，<code>iff</code> 查询状态标志位</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.chongchonggou.com/g_69808964.html" target="_blank" rel="noopener">对netlink无法检测到dellink事件和探测网卡是否插网线方法的简单分析</a></li>
<li><a href="http://ju.outofmemory.cn/entry/251118" target="_blank" rel="noopener">Linux无线模块WEXT简单分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ethtool</tag>
        <tag>mii</tag>
        <tag>wlan</tag>
        <tag>iff</tag>
        <tag>priv</tag>
      </tags>
  </entry>
  <entry>
    <title>how_to_use_wpa_supplicant</title>
    <url>/2017/11/01/how-to-use-wpa-supplicant/</url>
    <content><![CDATA[<p>这个工具的下载和移植都很简单。移植后能得到 <code>wpa_supplicant</code> 和 <code>wpa_cli</code>。<code>wpa_supplicant</code> 运行在后台，使用socket与前台进行数据通信。<code>wpa_cli</code> 可以用来进行调试和查看 <code>wpa_supplicant</code> 的运行</p>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在文件 <code>wpa_supplicant.conf</code> 中添加</p>
<pre><code>ctrl_interface=DIR=/var/run/wpa_supplicant</code></pre><p><strong>如果没有的话，无法使用wpa_cli</strong></p>
<p><code>wpa_supplicant</code> 执行时会在 <code>/var/run/wpa_supplicant</code> 下创建 <code>socket</code> 文件</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><pre><code>wpa_supplicant -d -Dnl80211 -i ra0 -c /etc/wpa_supplicant/wpa_supplicant.conf &amp;
wpa_supplicant -i ra0 -t -f wpa_supplicant_tmp -Dwext -c /etc/wpa_supplicant/wpa_supplicant.conf &amp;</code></pre><h2 id="在C代码中集成wpa-cli"><a href="#在C代码中集成wpa-cli" class="headerlink" title="在C代码中集成wpa_cli"></a>在C代码中集成wpa_cli</h2><p><code>wpa_cli</code> 启动之前的必要条件</p>
<ul>
<li>加载好驱动并且开启了网卡</li>
<li>建立/var/run/文件夹</li>
<li>建立一个或者使用原有的配置文件，这个文件的第一行如下：</li>
</ul>
<pre><code>ctrl_interface=/var/run/wpa_supplicant  </code></pre><p><code>ctrl_interface</code> 指向的是一个目录，在这个目录中默认会生成一个文件 <code>/var/run/wpa_supplicant/wlan0</code>，这是 <code>local socket address</code>，用于我们的程序和后台程序 <code>wpa_supplicant</code> 进行通信（我们必须知道 <code>wpa_supplicant</code> 作为后台服务程序是通过本地socket和客户端进行通信的）</p>
<h3 id="wpa-supplicant后台服务程序"><a href="#wpa-supplicant后台服务程序" class="headerlink" title="wpa_supplicant后台服务程序"></a>wpa_supplicant后台服务程序</h3><pre><code>wpa_supplicant -i ra0 -t -f wpa_supplicant_tmp -Dwext -c /etc/wpa_supplicant/wpa_supplicant.conf &amp;</code></pre><h3 id="wpa-ctrl函数接口"><a href="#wpa-ctrl函数接口" class="headerlink" title="wpa_ctrl函数接口"></a>wpa_ctrl函数接口</h3><pre><code>static struct wpa_ctrl *ctrl_conn;
static struct wpa_ctrl *mon_conn;

static int wpa_cli_open_connection(const char *ifname, int attach)
{
#if defined(CONFIG_CTRL_IFACE_UDP) || defined(CONFIG_CTRL_IFACE_NAMED_PIPE)
    ctrl_conn = wpa_ctrl_open(ifname);
    if (ctrl_conn == NULL)
        return -1;

    if (attach &amp;&amp; interactive)
        mon_conn = wpa_ctrl_open(ifname);
    else
        mon_conn = NULL;
#else /* CONFIG_CTRL_IFACE_UDP || CONFIG_CTRL_IFACE_NAMED_PIPE */
    char *cfile = NULL;
    int flen, res;

    if (ifname == NULL)
        return -1;

#ifdef ANDROID
    if (access(ctrl_iface_dir, F_OK) &lt; 0) {
        cfile = os_strdup(ifname);
        if (cfile == NULL)
            return -1;
    }
#endif /* ANDROID */

    if (cfile == NULL) {
        flen = os_strlen(ctrl_iface_dir) + os_strlen(ifname) + 2;
        cfile = os_malloc(flen);
        if (cfile == NULL)
            return -1;
        res = os_snprintf(cfile, flen, &quot;%s/%s&quot;, ctrl_iface_dir,
                  ifname);
        if (res &lt; 0 || res &gt;= flen) {
            os_free(cfile);
            return -1;
        }
    }

    ctrl_conn = wpa_ctrl_open(cfile);
    if (ctrl_conn == NULL) {
        os_free(cfile);
        return -1;
    }

    if (attach &amp;&amp; interactive)
        mon_conn = wpa_ctrl_open(cfile);
    else
        mon_conn = NULL;
    os_free(cfile);
#endif /* CONFIG_CTRL_IFACE_UDP || CONFIG_CTRL_IFACE_NAMED_PIPE */

    if (mon_conn) {
        printf(&quot;\033[32m%s[%d]\n\033[0m&quot;, __func__, __LINE__);
        if (wpa_ctrl_attach(mon_conn) == 0) {
            wpa_cli_attached = 1;
            if (interactive)
                eloop_register_read_sock(
                    wpa_ctrl_get_fd(mon_conn),
                    wpa_cli_mon_receive, NULL, NULL);
        } else {
            printf(&quot;Warning: Failed to attach to &quot;
                   &quot;wpa_supplicant.\n&quot;);
            return -1;
        }
    }

    return 0;
}

struct wpa_ctrl * wpa_ctrl_open(const char *ctrl_path)
{
    struct wpa_ctrl *ctrl;
    static int counter = 0;
    int ret;
    size_t res;
    int tries = 0;

    ctrl = os_malloc(sizeof(*ctrl));
    if (ctrl == NULL)
        return NULL;
    os_memset(ctrl, 0, sizeof(*ctrl));

    ctrl-&gt;s = socket(PF_UNIX, SOCK_DGRAM, 0);
    if (ctrl-&gt;s &lt; 0) {
        os_free(ctrl);
        return NULL;
    }

    ctrl-&gt;local.sun_family = AF_UNIX;
    counter++;
try_again:
    ret = os_snprintf(ctrl-&gt;local.sun_path, sizeof(ctrl-&gt;local.sun_path),
              CONFIG_CTRL_IFACE_CLIENT_DIR &quot;/&quot;
              CONFIG_CTRL_IFACE_CLIENT_PREFIX &quot;%d-%d&quot;,
              (int) getpid(), counter);
    if (ret &lt; 0 || (size_t) ret &gt;= sizeof(ctrl-&gt;local.sun_path)) {
        close(ctrl-&gt;s);
        os_free(ctrl);
        return NULL;
    }
    tries++;
    if (bind(ctrl-&gt;s, (struct sockaddr *) &amp;ctrl-&gt;local,
            sizeof(ctrl-&gt;local)) &lt; 0) {
        if (errno == EADDRINUSE &amp;&amp; tries &lt; 2) {
            /*
             * getpid() returns unique identifier for this instance
             * of wpa_ctrl, so the existing socket file must have
             * been left by unclean termination of an earlier run.
             * Remove the file and try again.
             */
            unlink(ctrl-&gt;local.sun_path);
            goto try_again;
        }
        close(ctrl-&gt;s);
        os_free(ctrl);
        return NULL;
    }

#ifdef ANDROID
    chmod(ctrl-&gt;local.sun_path, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
    chown(ctrl-&gt;local.sun_path, AID_SYSTEM, AID_WIFI);
    /*
     * If the ctrl_path isn&#39;t an absolute pathname, assume that
     * it&#39;s the name of a socket in the Android reserved namespace.
     * Otherwise, it&#39;s a normal UNIX domain socket appearing in the
     * filesystem.
     */
    if (ctrl_path != NULL &amp;&amp; *ctrl_path != &#39;/&#39;) {
        char buf[21];
        os_snprintf(buf, sizeof(buf), &quot;wpa_%s&quot;, ctrl_path);
        if (socket_local_client_connect(
                ctrl-&gt;s, buf,
                ANDROID_SOCKET_NAMESPACE_RESERVED,
                SOCK_DGRAM) &lt; 0) {
            close(ctrl-&gt;s);
            unlink(ctrl-&gt;local.sun_path);
            os_free(ctrl);
            return NULL;
        }
        return ctrl;
    }
#endif /* ANDROID */

    ctrl-&gt;dest.sun_family = AF_UNIX;
    res = os_strlcpy(ctrl-&gt;dest.sun_path, ctrl_path,
             sizeof(ctrl-&gt;dest.sun_path));
    if (res &gt;= sizeof(ctrl-&gt;dest.sun_path)) {
        close(ctrl-&gt;s);
        os_free(ctrl);
        return NULL;
    }
    if (connect(ctrl-&gt;s, (struct sockaddr *) &amp;ctrl-&gt;dest,
            sizeof(ctrl-&gt;dest)) &lt; 0) {
        close(ctrl-&gt;s);
        unlink(ctrl-&gt;local.sun_path);
        os_free(ctrl);
        return NULL;
    }

    return ctrl;
}</code></pre><p>从函数中可以看出，使用wpa_ctrl_open打开两次，获得两个wpa_ctrl变量。这些变量代表着后台服务程序wpa_supplicant，通过这两个变量可以和wpa_supplicant进行通信。不过他们的分工有点不同，一个变量用于客户端主动给服务程序发起命令，另外一个变量用于监控wpa_supplicant的是否有数据发给客户端程序。</p>
<h3 id="支持的命令"><a href="#支持的命令" class="headerlink" title="支持的命令"></a>支持的命令</h3><pre><code>static struct wpa_cli_cmd wpa_cli_commands[] = {
    { &quot;status&quot;, wpa_cli_cmd_status,
      cli_cmd_flag_none,
      &quot;[verbose] = get current WPA/EAPOL/EAP status&quot; },
    { &quot;ping&quot;, wpa_cli_cmd_ping,
      cli_cmd_flag_none,
      &quot;= pings wpa_supplicant&quot; },
    { &quot;relog&quot;, wpa_cli_cmd_relog,
      cli_cmd_flag_none,
      &quot;= re-open log-file (allow rolling logs)&quot; },
    { &quot;note&quot;, wpa_cli_cmd_note,
      cli_cmd_flag_none,
      &quot;&lt;text&gt; = add a note to wpa_supplicant debug log&quot; },
    { &quot;mib&quot;, wpa_cli_cmd_mib,
      cli_cmd_flag_none,
      &quot;= get MIB variables (dot1x, dot11)&quot; },
    { &quot;help&quot;, wpa_cli_cmd_help,
      cli_cmd_flag_none,
      &quot;= show this usage help&quot; },
    { &quot;interface&quot;, wpa_cli_cmd_interface,
      cli_cmd_flag_none,
      &quot;[ifname] = show interfaces/select interface&quot; },
    { &quot;level&quot;, wpa_cli_cmd_level,
      cli_cmd_flag_none,
      &quot;&lt;debug level&gt; = change debug level&quot; },
    { &quot;license&quot;, wpa_cli_cmd_license,
      cli_cmd_flag_none,
      &quot;= show full wpa_cli license&quot; },
    { &quot;quit&quot;, wpa_cli_cmd_quit,
      cli_cmd_flag_none,
      &quot;= exit wpa_cli&quot; },
    { &quot;set&quot;, wpa_cli_cmd_set,
      cli_cmd_flag_none,
      &quot;= set variables (shows list of variables when run without &quot;
      &quot;arguments)&quot; },
    { &quot;get&quot;, wpa_cli_cmd_get,
      cli_cmd_flag_none,
      &quot;&lt;name&gt; = get information&quot; },
    { &quot;logon&quot;, wpa_cli_cmd_logon,
      cli_cmd_flag_none,
      &quot;= IEEE 802.1X EAPOL state machine logon&quot; },
    { &quot;logoff&quot;, wpa_cli_cmd_logoff,
      cli_cmd_flag_none,
      &quot;= IEEE 802.1X EAPOL state machine logoff&quot; },
    { &quot;pmksa&quot;, wpa_cli_cmd_pmksa,
      cli_cmd_flag_none,
      &quot;= show PMKSA cache&quot; },
    { &quot;reassociate&quot;, wpa_cli_cmd_reassociate,
      cli_cmd_flag_none,
      &quot;= force reassociation&quot; },
    { &quot;preauthenticate&quot;, wpa_cli_cmd_preauthenticate,
      cli_cmd_flag_none,
      &quot;&lt;BSSID&gt; = force preauthentication&quot; },
    { &quot;identity&quot;, wpa_cli_cmd_identity,
      cli_cmd_flag_none,
      &quot;&lt;network id&gt; &lt;identity&gt; = configure identity for an SSID&quot; },
    { &quot;password&quot;, wpa_cli_cmd_password,
      cli_cmd_flag_sensitive,
      &quot;&lt;network id&gt; &lt;password&gt; = configure password for an SSID&quot; },
    { &quot;new_password&quot;, wpa_cli_cmd_new_password,
      cli_cmd_flag_sensitive,
      &quot;&lt;network id&gt; &lt;password&gt; = change password for an SSID&quot; },
    { &quot;pin&quot;, wpa_cli_cmd_pin,
      cli_cmd_flag_sensitive,
      &quot;&lt;network id&gt; &lt;pin&gt; = configure pin for an SSID&quot; },
    { &quot;otp&quot;, wpa_cli_cmd_otp,
      cli_cmd_flag_sensitive,
      &quot;&lt;network id&gt; &lt;password&gt; = configure one-time-password for an SSID&quot;
    },
    { &quot;passphrase&quot;, wpa_cli_cmd_passphrase,
      cli_cmd_flag_sensitive,
      &quot;&lt;network id&gt; &lt;passphrase&gt; = configure private key passphrase\n&quot;
      &quot;  for an SSID&quot; },
    { &quot;bssid&quot;, wpa_cli_cmd_bssid,
      cli_cmd_flag_none,
      &quot;&lt;network id&gt; &lt;BSSID&gt; = set preferred BSSID for an SSID&quot; },
    { &quot;blacklist&quot;, wpa_cli_cmd_blacklist,
      cli_cmd_flag_none,
      &quot;&lt;BSSID&gt; = add a BSSID to the blacklist\n&quot;
      &quot;blacklist clear = clear the blacklist\n&quot;
      &quot;blacklist = display the blacklist&quot; },
    { &quot;log_level&quot;, wpa_cli_cmd_log_level,
      cli_cmd_flag_none,
      &quot;&lt;level&gt; [&lt;timestamp&gt;] = update the log level/timestamp\n&quot;
      &quot;log_level = display the current log level and log options&quot; },
    { &quot;list_networks&quot;, wpa_cli_cmd_list_networks,
      cli_cmd_flag_none,
      &quot;= list configured networks&quot; },
    { &quot;select_network&quot;, wpa_cli_cmd_select_network,
      cli_cmd_flag_none,
      &quot;&lt;network id&gt; = select a network (disable others)&quot; },
    { &quot;enable_network&quot;, wpa_cli_cmd_enable_network,
      cli_cmd_flag_none,
      &quot;&lt;network id&gt; = enable a network&quot; },
    { &quot;disable_network&quot;, wpa_cli_cmd_disable_network,
      cli_cmd_flag_none,
      &quot;&lt;network id&gt; = disable a network&quot; },
    { &quot;add_network&quot;, wpa_cli_cmd_add_network,
      cli_cmd_flag_none,
      &quot;= add a network&quot; },
    { &quot;remove_network&quot;, wpa_cli_cmd_remove_network,
      cli_cmd_flag_none,
      &quot;&lt;network id&gt; = remove a network&quot; },
    { &quot;set_network&quot;, wpa_cli_cmd_set_network,
      cli_cmd_flag_sensitive,
      &quot;&lt;network id&gt; &lt;variable&gt; &lt;value&gt; = set network variables (shows\n&quot;
      &quot;  list of variables when run without arguments)&quot; },
    { &quot;get_network&quot;, wpa_cli_cmd_get_network,
      cli_cmd_flag_none,
      &quot;&lt;network id&gt; &lt;variable&gt; = get network variables&quot; },
    { &quot;save_config&quot;, wpa_cli_cmd_save_config,
      cli_cmd_flag_none,
      &quot;= save the current configuration&quot; },
    { &quot;disconnect&quot;, wpa_cli_cmd_disconnect,
      cli_cmd_flag_none,
      &quot;= disconnect and wait for reassociate/reconnect command before\n&quot;
      &quot;  connecting&quot; },
    { &quot;reconnect&quot;, wpa_cli_cmd_reconnect,
      cli_cmd_flag_none,
      &quot;= like reassociate, but only takes effect if already disconnected&quot;
    },
    { &quot;scan&quot;, wpa_cli_cmd_scan,
      cli_cmd_flag_none,
      &quot;= request new BSS scan&quot; },
    { &quot;scan_results&quot;, wpa_cli_cmd_scan_results,
      cli_cmd_flag_none,
      &quot;= get latest scan results&quot; },
    { &quot;bss&quot;, wpa_cli_cmd_bss,
      cli_cmd_flag_none,
      &quot;&lt;&lt;idx&gt; | &lt;bssid&gt;&gt; = get detailed scan result info&quot; },
    { &quot;get_capability&quot;, wpa_cli_cmd_get_capability,
      cli_cmd_flag_none,
      &quot;&lt;eap/pairwise/group/key_mgmt/proto/auth_alg&gt; = get capabilies&quot; },
    { &quot;reconfigure&quot;, wpa_cli_cmd_reconfigure,
      cli_cmd_flag_none,
      &quot;= force wpa_supplicant to re-read its configuration file&quot; },
    { &quot;terminate&quot;, wpa_cli_cmd_terminate,
      cli_cmd_flag_none,
      &quot;= terminate wpa_supplicant&quot; },
    { &quot;interface_add&quot;, wpa_cli_cmd_interface_add,
      cli_cmd_flag_none,
      &quot;&lt;ifname&gt; &lt;confname&gt; &lt;driver&gt; &lt;ctrl_interface&gt; &lt;driver_param&gt;\n&quot;
      &quot;  &lt;bridge_name&gt; = adds new interface, all parameters but &lt;ifname&gt;\n&quot;
      &quot;  are optional&quot; },
    { &quot;interface_remove&quot;, wpa_cli_cmd_interface_remove,
      cli_cmd_flag_none,
      &quot;&lt;ifname&gt; = removes the interface&quot; },
    { &quot;interface_list&quot;, wpa_cli_cmd_interface_list,
      cli_cmd_flag_none,
      &quot;= list available interfaces&quot; },
    { &quot;ap_scan&quot;, wpa_cli_cmd_ap_scan,
      cli_cmd_flag_none,
      &quot;&lt;value&gt; = set ap_scan parameter&quot; },
    { &quot;scan_interval&quot;, wpa_cli_cmd_scan_interval,
      cli_cmd_flag_none,
      &quot;&lt;value&gt; = set scan_interval parameter (in seconds)&quot; },
    { &quot;bss_expire_age&quot;, wpa_cli_cmd_bss_expire_age,
      cli_cmd_flag_none,
      &quot;&lt;value&gt; = set BSS expiration age parameter&quot; },
    { &quot;bss_expire_count&quot;, wpa_cli_cmd_bss_expire_count,
      cli_cmd_flag_none,
      &quot;&lt;value&gt; = set BSS expiration scan count parameter&quot; },
    { &quot;stkstart&quot;, wpa_cli_cmd_stkstart,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = request STK negotiation with &lt;addr&gt;&quot; },
    { &quot;ft_ds&quot;, wpa_cli_cmd_ft_ds,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = request over-the-DS FT with &lt;addr&gt;&quot; },
    { &quot;wps_pbc&quot;, wpa_cli_cmd_wps_pbc,
      cli_cmd_flag_none,
      &quot;[BSSID] = start Wi-Fi Protected Setup: Push Button Configuration&quot; },
    { &quot;wps_pin&quot;, wpa_cli_cmd_wps_pin,
      cli_cmd_flag_sensitive,
      &quot;&lt;BSSID&gt; [PIN] = start WPS PIN method (returns PIN, if not &quot;
      &quot;hardcoded)&quot; },
    { &quot;wps_check_pin&quot;, wpa_cli_cmd_wps_check_pin,
      cli_cmd_flag_sensitive,
      &quot;&lt;PIN&gt; = verify PIN checksum&quot; },
    { &quot;wps_cancel&quot;, wpa_cli_cmd_wps_cancel, cli_cmd_flag_none,
      &quot;Cancels the pending WPS operation&quot; },
#ifdef CONFIG_WPS_OOB
    { &quot;wps_oob&quot;, wpa_cli_cmd_wps_oob,
      cli_cmd_flag_sensitive,
      &quot;&lt;DEV_TYPE&gt; &lt;PATH&gt; &lt;METHOD&gt; [DEV_NAME] = start WPS OOB&quot; },
#endif /* CONFIG_WPS_OOB */
    { &quot;wps_reg&quot;, wpa_cli_cmd_wps_reg,
      cli_cmd_flag_sensitive,
      &quot;&lt;BSSID&gt; &lt;AP PIN&gt; = start WPS Registrar to configure an AP&quot; },
    { &quot;wps_ap_pin&quot;, wpa_cli_cmd_wps_ap_pin,
      cli_cmd_flag_sensitive,
      &quot;[params..] = enable/disable AP PIN&quot; },
    { &quot;wps_er_start&quot;, wpa_cli_cmd_wps_er_start,
      cli_cmd_flag_none,
      &quot;[IP address] = start Wi-Fi Protected Setup External Registrar&quot; },
    { &quot;wps_er_stop&quot;, wpa_cli_cmd_wps_er_stop,
      cli_cmd_flag_none,
      &quot;= stop Wi-Fi Protected Setup External Registrar&quot; },
    { &quot;wps_er_pin&quot;, wpa_cli_cmd_wps_er_pin,
      cli_cmd_flag_sensitive,
      &quot;&lt;UUID&gt; &lt;PIN&gt; = add an Enrollee PIN to External Registrar&quot; },
    { &quot;wps_er_pbc&quot;, wpa_cli_cmd_wps_er_pbc,
      cli_cmd_flag_none,
      &quot;&lt;UUID&gt; = accept an Enrollee PBC using External Registrar&quot; },
    { &quot;wps_er_learn&quot;, wpa_cli_cmd_wps_er_learn,
      cli_cmd_flag_sensitive,
      &quot;&lt;UUID&gt; &lt;PIN&gt; = learn AP configuration&quot; },
    { &quot;wps_er_set_config&quot;, wpa_cli_cmd_wps_er_set_config,
      cli_cmd_flag_none,
      &quot;&lt;UUID&gt; &lt;network id&gt; = set AP configuration for enrolling&quot; },
    { &quot;wps_er_config&quot;, wpa_cli_cmd_wps_er_config,
      cli_cmd_flag_sensitive,
      &quot;&lt;UUID&gt; &lt;PIN&gt; &lt;SSID&gt; &lt;auth&gt; &lt;encr&gt; &lt;key&gt; = configure AP&quot; },
    { &quot;ibss_rsn&quot;, wpa_cli_cmd_ibss_rsn,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = request RSN authentication with &lt;addr&gt; in IBSS&quot; },
#ifdef CONFIG_AP
    { &quot;sta&quot;, wpa_cli_cmd_sta,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = get information about an associated station (AP)&quot; },
    { &quot;all_sta&quot;, wpa_cli_cmd_all_sta,
      cli_cmd_flag_none,
      &quot;= get information about all associated stations (AP)&quot; },
#endif /* CONFIG_AP */
    { &quot;suspend&quot;, wpa_cli_cmd_suspend, cli_cmd_flag_none,
      &quot;= notification of suspend/hibernate&quot; },
    { &quot;resume&quot;, wpa_cli_cmd_resume, cli_cmd_flag_none,
      &quot;= notification of resume/thaw&quot; },
    { &quot;drop_sa&quot;, wpa_cli_cmd_drop_sa, cli_cmd_flag_none,
      &quot;= drop SA without deauth/disassoc (test command)&quot; },
    { &quot;roam&quot;, wpa_cli_cmd_roam,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = roam to the specified BSS&quot; },
#ifdef CONFIG_P2P
    { &quot;p2p_find&quot;, wpa_cli_cmd_p2p_find, cli_cmd_flag_none,
      &quot;[timeout] [type=*] = find P2P Devices for up-to timeout seconds&quot; },
    { &quot;p2p_stop_find&quot;, wpa_cli_cmd_p2p_stop_find, cli_cmd_flag_none,
      &quot;= stop P2P Devices search&quot; },
    { &quot;p2p_connect&quot;, wpa_cli_cmd_p2p_connect, cli_cmd_flag_none,
      &quot;&lt;addr&gt; &lt;\&quot;pbc\&quot;|PIN&gt; = connect to a P2P Devices&quot; },
    { &quot;p2p_listen&quot;, wpa_cli_cmd_p2p_listen, cli_cmd_flag_none,
      &quot;[timeout] = listen for P2P Devices for up-to timeout seconds&quot; },
    { &quot;p2p_group_remove&quot;, wpa_cli_cmd_p2p_group_remove, cli_cmd_flag_none,
      &quot;&lt;ifname&gt; = remove P2P group interface (terminate group if GO)&quot; },
    { &quot;p2p_group_add&quot;, wpa_cli_cmd_p2p_group_add, cli_cmd_flag_none,
      &quot;= add a new P2P group (local end as GO)&quot; },
    { &quot;p2p_prov_disc&quot;, wpa_cli_cmd_p2p_prov_disc, cli_cmd_flag_none,
      &quot;&lt;addr&gt; &lt;method&gt; = request provisioning discovery&quot; },
    { &quot;p2p_get_passphrase&quot;, wpa_cli_cmd_p2p_get_passphrase,
      cli_cmd_flag_none,
      &quot;= get the passphrase for a group (GO only)&quot; },
    { &quot;p2p_serv_disc_req&quot;, wpa_cli_cmd_p2p_serv_disc_req,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; &lt;TLVs&gt; = schedule service discovery request&quot; },
    { &quot;p2p_serv_disc_cancel_req&quot;, wpa_cli_cmd_p2p_serv_disc_cancel_req,
      cli_cmd_flag_none,
      &quot;&lt;id&gt; = cancel pending service discovery request&quot; },
    { &quot;p2p_serv_disc_resp&quot;, wpa_cli_cmd_p2p_serv_disc_resp,
      cli_cmd_flag_none,
      &quot;&lt;freq&gt; &lt;addr&gt; &lt;dialog token&gt; &lt;TLVs&gt; = service discovery response&quot; },
    { &quot;p2p_service_update&quot;, wpa_cli_cmd_p2p_service_update,
      cli_cmd_flag_none,
      &quot;= indicate change in local services&quot; },
    { &quot;p2p_serv_disc_external&quot;, wpa_cli_cmd_p2p_serv_disc_external,
      cli_cmd_flag_none,
      &quot;&lt;external&gt; = set external processing of service discovery&quot; },
    { &quot;p2p_service_flush&quot;, wpa_cli_cmd_p2p_service_flush,
      cli_cmd_flag_none,
      &quot;= remove all stored service entries&quot; },
    { &quot;p2p_service_add&quot;, wpa_cli_cmd_p2p_service_add,
      cli_cmd_flag_none,
      &quot;&lt;bonjour|upnp&gt; &lt;query|version&gt; &lt;response|service&gt; = add a local &quot;
      &quot;service&quot; },
    { &quot;p2p_service_del&quot;, wpa_cli_cmd_p2p_service_del,
      cli_cmd_flag_none,
      &quot;&lt;bonjour|upnp&gt; &lt;query|version&gt; [|service] = remove a local &quot;
      &quot;service&quot; },
    { &quot;p2p_reject&quot;, wpa_cli_cmd_p2p_reject,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = reject connection attempts from a specific peer&quot; },
    { &quot;p2p_invite&quot;, wpa_cli_cmd_p2p_invite,
      cli_cmd_flag_none,
      &quot;&lt;cmd&gt; [peer=addr] = invite peer&quot; },
    { &quot;p2p_peers&quot;, wpa_cli_cmd_p2p_peers, cli_cmd_flag_none,
      &quot;[discovered] = list known (optionally, only fully discovered) P2P &quot;
      &quot;peers&quot; },
    { &quot;p2p_peer&quot;, wpa_cli_cmd_p2p_peer, cli_cmd_flag_none,
      &quot;&lt;address&gt; = show information about known P2P peer&quot; },
    { &quot;p2p_set&quot;, wpa_cli_cmd_p2p_set, cli_cmd_flag_none,
      &quot;&lt;field&gt; &lt;value&gt; = set a P2P parameter&quot; },
    { &quot;p2p_flush&quot;, wpa_cli_cmd_p2p_flush, cli_cmd_flag_none,
      &quot;= flush P2P state&quot; },
    { &quot;p2p_cancel&quot;, wpa_cli_cmd_p2p_cancel, cli_cmd_flag_none,
      &quot;= cancel P2P group formation&quot; },
    { &quot;p2p_unauthorize&quot;, wpa_cli_cmd_p2p_unauthorize, cli_cmd_flag_none,
      &quot;&lt;address&gt; = unauthorize a peer&quot; },
    { &quot;p2p_presence_req&quot;, wpa_cli_cmd_p2p_presence_req, cli_cmd_flag_none,
      &quot;[&lt;duration&gt; &lt;interval&gt;] [&lt;duration&gt; &lt;interval&gt;] = request GO &quot;
      &quot;presence&quot; },
    { &quot;p2p_ext_listen&quot;, wpa_cli_cmd_p2p_ext_listen, cli_cmd_flag_none,
      &quot;[&lt;period&gt; &lt;interval&gt;] = set extended listen timing&quot; },
#endif /* CONFIG_P2P */

#ifdef CONFIG_INTERWORKING
    { &quot;fetch_anqp&quot;, wpa_cli_cmd_fetch_anqp, cli_cmd_flag_none,
      &quot;= fetch ANQP information for all APs&quot; },
    { &quot;stop_fetch_anqp&quot;, wpa_cli_cmd_stop_fetch_anqp, cli_cmd_flag_none,
      &quot;= stop fetch_anqp operation&quot; },
    { &quot;interworking_select&quot;, wpa_cli_cmd_interworking_select,
      cli_cmd_flag_none,
      &quot;[auto] = perform Interworking network selection&quot; },
    { &quot;interworking_connect&quot;, wpa_cli_cmd_interworking_connect,
      cli_cmd_flag_none,
      &quot;&lt;BSSID&gt; = connect using Interworking credentials&quot; },
    { &quot;anqp_get&quot;, wpa_cli_cmd_anqp_get, cli_cmd_flag_none,
      &quot;&lt;addr&gt; &lt;info id&gt;[,&lt;info id&gt;]... = request ANQP information&quot; },
#endif /* CONFIG_INTERWORKING */
    { &quot;sta_autoconnect&quot;, wpa_cli_cmd_sta_autoconnect, cli_cmd_flag_none,
      &quot;&lt;0/1&gt; = disable/enable automatic reconnection&quot; },
    { &quot;tdls_discover&quot;, wpa_cli_cmd_tdls_discover,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = request TDLS discovery with &lt;addr&gt;&quot; },
    { &quot;tdls_setup&quot;, wpa_cli_cmd_tdls_setup,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = request TDLS setup with &lt;addr&gt;&quot; },
    { &quot;tdls_teardown&quot;, wpa_cli_cmd_tdls_teardown,
      cli_cmd_flag_none,
      &quot;&lt;addr&gt; = tear down TDLS with &lt;addr&gt;&quot; },
    { &quot;signal_poll&quot;, wpa_cli_cmd_signal_poll,
      cli_cmd_flag_none,
      &quot;= get signal parameters&quot; },
    { NULL, NULL, cli_cmd_flag_none, NULL }
};</code></pre><h3 id="在C语言中集成wpa-cli"><a href="#在C语言中集成wpa-cli" class="headerlink" title="在C语言中集成wpa_cli"></a>在C语言中集成wpa_cli</h3><p>简化不使用监控socket代码如下：</p>
<pre><code>#ifndef CONFIG_CTRL_IFACE_CLIENT_DIR
#define CONFIG_CTRL_IFACE_CLIENT_DIR &quot;/tmp&quot;
#endif
#ifndef CONFIG_CTRL_IFACE_CLIENT_PREFIX
#define CONFIG_CTRL_IFACE_CLIENT_PREFIX &quot;wpa_ctrl_&quot;
#endif
struct wpa_ctrl * wpa_ctrl_open(const char *ctrl_path)
{
    struct wpa_ctrl *ctrl = NULL;
    static int counter = 0;
    int ret;
    size_t res;
    int tries = 0;

    ctrl = GxCore_Mallocz(sizeof(*ctrl));
    if (ctrl == NULL)
        return NULL;
    memset(ctrl, 0, sizeof(*ctrl));

    ctrl-&gt;s = socket(PF_UNIX, SOCK_DGRAM, 0);
    if (ctrl-&gt;s &lt; 0) {
        GXCORE_FREE(ctrl);
        return NULL;
    }
    ctrl-&gt;local.sun_family = AF_UNIX;
    counter++;
try_again:
    ret = snprintf(ctrl-&gt;local.sun_path, sizeof(ctrl-&gt;local.sun_path),
            CONFIG_CTRL_IFACE_CLIENT_DIR &quot;/&quot;
            CONFIG_CTRL_IFACE_CLIENT_PREFIX &quot;%d-%d&quot;,
            (int) getpid(), counter);
    if (ret &lt; 0 || (size_t) ret &gt;= sizeof(ctrl-&gt;local.sun_path)) {
        close(ctrl-&gt;s);
        GXCORE_FREE(ctrl);
        return NULL;
    }
    tries++;
    if (bind(ctrl-&gt;s, (struct sockaddr *) &amp;ctrl-&gt;local,
                sizeof(ctrl-&gt;local)) &lt; 0) {
        if (errno == EADDRINUSE &amp;&amp; tries &lt; 2) {
            /*
             * getpid() returns unique identifier for this instance
             * of wpa_ctrl, so the existing socket file must have
             * been left by unclean termination of an earlier run.
             * Remove the file and try again.
             */
            unlink(ctrl-&gt;local.sun_path);
            goto try_again;
        }
        close(ctrl-&gt;s);
        GXCORE_FREE(ctrl);
        return NULL;
    }
    ctrl-&gt;dest.sun_family = AF_UNIX;
    res = strlcpy(ctrl-&gt;dest.sun_path, ctrl_path,
            sizeof(ctrl-&gt;dest.sun_path));
    if (res &gt;= sizeof(ctrl-&gt;dest.sun_path)) {
        close(ctrl-&gt;s);
        GXCORE_FREE(ctrl);
        return NULL;
    }
    if (connect(ctrl-&gt;s, (struct sockaddr *) &amp;ctrl-&gt;dest,
                sizeof(ctrl-&gt;dest)) &lt; 0) {
        close(ctrl-&gt;s);
        unlink(ctrl-&gt;local.sun_path);
        GXCORE_FREE(ctrl);
        return NULL;
    }

    return ctrl;
}

static int wpa_cli_open_connection(const char *ifname, int attach)
{
    char *cfile = NULL;
    int flen, res;

    if (ifname == NULL)
        return -1;
    if (cfile == NULL) {
        flen = strlen(ctrl_iface_dir) + strlen(ifname) + 2;
        cfile = GxCore_Mallocz(flen);
        if (cfile == NULL)
            return -1;
        res = snprintf(cfile, flen, &quot;%s/%s&quot;, ctrl_iface_dir,
                ifname);
        if (res &lt; 0 || res &gt;= flen) {
            GXCORE_FREE(cfile);
            return -1;
        }
    }
    ctrl_conn = wpa_ctrl_open(cfile);
    if (ctrl_conn == NULL) {
        GXCORE_FREE(cfile);
        return -1;
    }

    GXCORE_FREE(cfile);

    return 0;

}

static void wpa_ctrl_close(struct wpa_ctrl *ctrl)
{
    if (ctrl == NULL)
        return;
    unlink(ctrl-&gt;local.sun_path);
    if (ctrl-&gt;s &gt;= 0)
        close(ctrl-&gt;s);
    GXCORE_FREE(ctrl);
    ctrl = NULL;
}

static void wpa_cli_close_connection(void)
{
    if (ctrl_conn == NULL)
        return;

    wpa_ctrl_close(ctrl_conn);
    ctrl_conn = NULL;
}

static void wpa_cli_cleanup(void)
{
    wpa_cli_close_connection();
}

static int wpa_cli(const char *ifname, char *cmd)
{
    int ret = 0;
    char *argv[1] = {};
    argv[0] = cmd;

    GXCORE_FREE(ctrl_ifname);
    ctrl_ifname = GxCore_Strdup(ifname);

    if (wpa_cli_open_connection(ctrl_ifname, 0) &lt; 0) {
        //printf(&quot;Failed to connect to wpa_supplicant - wpa_ctrl_open\n&quot;);
        GXCORE_FREE(ctrl_ifname);
        return -1;
    }

    ret = wpa_request(ctrl_conn, 1, &amp;argv[0]);
    GXCORE_FREE(ctrl_ifname);
    wpa_cli_cleanup();

    return ret;
}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.jianshu.com/p/683fcf66c222" target="_blank" rel="noopener">无线网络配置 wpa_supplicant</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_640531380102wldy.html" target="_blank" rel="noopener">wpa_supplicant使用笔记</a></li>
<li><a href="https://stackoverflow.com/questions/38215480/getting-started-with-wpa-supplicant-using-c" target="_blank" rel="noopener">Getting started with wpa_supplicant using C</a></li>
<li><a href="http://blog.csdn.net/king523103/article/details/38014419" target="_blank" rel="noopener">WPA_Supplicant使用及配置</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>wpa_supplicant</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-netlink-socket-get-hotplug-info</title>
    <url>/2017/10/26/linux-netlink-socket-get-hotplug-info/</url>
    <content><![CDATA[<p>使用netlink与内核通信获取U盘插拔信息</p>
<a id="more"></a>

<h2 id="Hotplug-uevent"><a href="#Hotplug-uevent" class="headerlink" title="Hotplug uevent"></a>Hotplug uevent</h2><p>uevent is just string of some special format that is sent via netlink socket. Example:</p>
<pre><code>add@/class/input/input9/mouse2\0    // message
ACTION=add\0                         // action type
DEVPATH=/class/input/input9/mouse2\0 // path in /sys
SUBSYSTEM=input\0                    // subsystem (class)
SEQNUM=1064\0                        // sequence number
PHYSDEVPATH=/devices/pci0000:00/0000:00:1d.1/usb2/2­2/2­2:1.0\0  // device path in /sys
PHYSDEVBUS=usb\0       // bus
PHYSDEVDRIVER=usbhid\0 // driver
MAJOR=13\0             // major number
MINOR=34\0&quot;,           // minor number</code></pre><ul>
<li><a href="http://elixir.free-electrons.com/linux/v3.12/source/lib/kobject_uevent.c#L121" target="_blank" rel="noopener">kobject_uevent_env</a></li>
<li><a href="http://elixir.free-electrons.com/linux/latest/source/lib/kobject_uevent.c" target="_blank" rel="noopener">lib/kobject_uevent.c</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/usb/hotplug.txt" target="_blank" rel="noopener">LINUX HOTPLUGGING</a></li>
<li><a href="http://free-electrons.com/doc/legacy/udev/udev.pdf" target="_blank" rel="noopener">Hotplugging with udev</a></li>
</ul>
<p><code>mdev</code>, the <code>udev</code> for <code>embedded systems</code></p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/netlink.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/poll.h&gt;

static int init_hotplug_sock(void)
{
    struct sockaddr_nl snl;
    const int buffersize = 16 * 1024 * 1024;
    int retval;

    memset(&amp;snl, 0x00, sizeof(struct sockaddr_nl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    snl.nl_groups = -1;
    int hotplug_sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);

    if (hotplug_sock == -1) {
        printf(&quot;error getting socket: %s&quot;, strerror(errno));
        return -1;
    }


    setsockopt(hotplug_sock, SOL_SOCKET, SO_RCVBUFFORCE, &amp;buffersize, sizeof(buffersize));
    retval = bind(hotplug_sock, (struct sockaddr *) &amp;snl, sizeof(struct sockaddr_nl));

    if (retval &lt; 0) {
        printf(&quot;bind failed: %s&quot;, strerror(errno));
        close(hotplug_sock);
        hotplug_sock = -1;
        return -1;
    }
    return hotplug_sock;
}

main(void)
{
    init_hotplug_sock();
    while(1){
        char buf[UEVENT_BUFFER_SIZE*2] = {0};
        recv(hotplug_sock, &amp;buf, sizeof(buf), 0);
        printf(&quot;\033[31m%s\n\033[0m&quot;, buf);
        printf(&quot;==============================\n&quot;);
    }
}</code></pre><p>这种方式只可以输出<code>uevent</code>的第一行内容，是由于<code>recv</code>方式导致，完善如下</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/netlink.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/poll.h&gt;

static int init_hotplug_sock(void)
{
    struct sockaddr_nl snl;
    const int buffersize = 16 * 1024 * 1024;
    int retval;
    struct pollfd pfd;
    char buf[512];

    memset(&amp;snl, 0x00, sizeof(struct sockaddr_nl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    snl.nl_groups = -1;
    pfd.events = POLLIN;
    pfd.fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);

    if (pfd.fd == -1) {
        printf(&quot;error getting socket: %s&quot;, strerror(errno));
        return -1;
    }

    retval = bind(pfd.fd, (struct sockaddr *) &amp;snl, sizeof(struct sockaddr_nl));

    while (-1!=poll(&amp;pfd, 1, -1)) {
        int i, len = recv(pfd.fd, buf, sizeof(buf), 0);
        if (len == -1) die(&quot;recv\n&quot;);
        // Print the data to stdout.
        printf(&quot;@@@@@@@@@@@@@@@@@\n&quot;);
        i = 0;
        while (i&lt;len) {
            if(strstr(buf+i, &quot;add@&quot;) || strstr(buf+i, &quot;remove@&quot;)) {
                printf(&quot;\033[31m%s\n\033[0m&quot;, buf+i);
            }
            else if(strstr(buf+i, &quot;ACTION=&quot;)) {
            }
            else if(strstr(buf+i, &quot;SUBSYSTEM=&quot;)) {
                if(!strstr(buf+i, &quot;usb&quot;)) {
                    len = 0;
                    break;
                }
            }
            else if(strstr(buf+i, &quot;DEVTYPE=&quot;)) {
                if(!strstr(buf+i, &quot;usb_device&quot;)) {
                    len = 0;
                    break;
                }
            }
            else if(strstr(buf+i, &quot;PRODUCT=&quot;)) {
                printf(&quot;\033[31m%s\n\033[0m&quot;, buf+i);
                close(pfd.fd);
                return 0;
            }
            i += strlen(buf+i)+1;
        }
    }

    return pfd.fd;
}</code></pre><h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/netlink.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/poll.h&gt;

void die(char *s)
{
    write(2,s,strlen(s));
    exit(1);
}

int netlink_test(void)
{
    struct sockaddr_nl nls;
    struct pollfd pfd;
    char buf[512];

    // Open hotplug event netlink socket
    memset(&amp;nls,0,sizeof(struct sockaddr_nl));
    nls.nl_family = AF_NETLINK;
    nls.nl_pid = getpid();
    nls.nl_groups = -1; //&lt;--add this so can receive from kernel broadcast
    pfd.events = POLLIN;
    pfd.fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
    if (pfd.fd==-1)
        die(&quot;Not root\n&quot;);
    // Listen to netlink socket
    if (bind(pfd.fd, (void *)&amp;nls, sizeof(struct sockaddr_nl)))
        die(&quot;Bind failed\n&quot;);

    while (-1!=poll(&amp;pfd, 1, -1)) {
        int i, len = recv(pfd.fd, buf, sizeof(buf), 0);
        if (len == -1) die(&quot;recv\n&quot;);
        // Print the data to stdout.
        i = 0;
        while (i&lt;len) {
            printf(&quot;\033[33m%s\n\033[0m&quot;, buf+i);
            i += strlen(buf+i)+1;
        }
    }
    die(&quot;poll\n&quot;);
    // Dear gcc: shut up.
    return 0;
}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://stackoverflow.com/questions/40788161/how-to-receive-kernel-uevents-with-netlink-socket" target="_blank" rel="noopener">How to receive Kernel uevents with Netlink socket?</a></li>
<li><a href="http://blog.csdn.net/Rocky_zhm/article/details/49253293" target="_blank" rel="noopener">检查内核反馈uevent消息，并提取出USB插入事件</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>netlink</tag>
        <tag>usb</tag>
        <tag>hotplug</tag>
      </tags>
  </entry>
  <entry>
    <title>netlink-socket</title>
    <url>/2017/10/23/netlink-socket/</url>
    <content><![CDATA[<p>Linux Kernel Version : 2.6.27.55</p>
<p><code>netlink</code> 是一种用于内核态和用户态进程之间进行数据传输的特殊的IPC机制。</p>
<p>特点：</p>
<ol>
<li>用户态采用socket风格的API</li>
<li>除了预定义的协议类型之外，支持自定义协议类型</li>
<li>异步通讯</li>
<li>支持消息组播</li>
<li>全双工（特别是支持内核主动发起会话）</li>
</ol>
<a id="more"></a>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>include/linux/netlink.h</code><br><code>include/linux/rtnetlink.h</code></p>
<h3 id="netlink地址结构"><a href="#netlink地址结构" class="headerlink" title="netlink地址结构"></a>netlink地址结构</h3><pre><code>struct sockaddr_nl                                                            
{                                                                             
    sa_family_t nl_family;  /* AF_NETLINK   */                                
    unsigned short  nl_pad; /* zero     */                                
    __u32       nl_pid;     /* port ID  */                                    
    __u32       nl_groups;  /* multicast groups mask */                   
};  </code></pre><h3 id="netlink消息结构"><a href="#netlink消息结构" class="headerlink" title="netlink消息结构"></a>netlink消息结构</h3><p><code>nlmsghdr</code> + <code>pad</code> + <code>payload</code> + <code>pad</code> + <code>nlmsghdr</code> + <code>pad</code> + <code>payload</code> + <code>pad</code> …</p>
<p>可以看出来，netlink消息在顶层呈现数组形式平行排列，也就是说，多条netlink消息可以以数组形式一次性传输</p>
<p><code>netlink消息头结构</code></p>
<pre><code>struct nlmsghdr                                                                                                                    
{                                                                             
    __u32       nlmsg_len;  /* Length of message including header */          
    __u16       nlmsg_type; /* Message content */                             
    __u16       nlmsg_flags;    /* Additional flags */                        
    __u32       nlmsg_seq;  /* Sequence number */                             
    __u32       nlmsg_pid;  /* Sending process port ID */                     
}; </code></pre><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example-1"></a>Example-1</h2><pre><code class="内核模块">#include &lt;linux/module.h&gt;
#include &lt;net/sock.h&gt; 
#include &lt;linux/netlink.h&gt;
#include &lt;linux/skbuff.h&gt; 
#define NETLINK_USER 31

struct sock *nl_sk = NULL;

static void hello_nl_recv_msg(struct sk_buff *skb)
{

    struct nlmsghdr *nlh;
    int pid;
    struct sk_buff *skb_out;
    int msg_size;
    char *msg = &quot;Hello from kernel&quot;;
    int res;

    printk(KERN_INFO &quot;Entering: %s\n&quot;, __FUNCTION__);

    msg_size = strlen(msg);

    nlh = (struct nlmsghdr *)skb-&gt;data;
    printk(KERN_INFO &quot;Netlink received msg payload:%s\n&quot;, (char *)nlmsg_data(nlh));
    pid = nlh-&gt;nlmsg_pid; /*pid of sending process */

    skb_out = nlmsg_new(msg_size, 0);
    if (!skb_out) {
        printk(KERN_ERR &quot;Failed to allocate new skb\n&quot;);
        return;
    }

    nlh = nlmsg_put(skb_out, 0, 0, NLMSG_DONE, msg_size, 0);
    NETLINK_CB(skb_out).dst_group = 0; /* not in mcast group */
    strncpy(nlmsg_data(nlh), msg, msg_size);

    res = nlmsg_unicast(nl_sk, skb_out, pid);
    if (res &lt; 0)
        printk(KERN_INFO &quot;Error while sending bak to user\n&quot;);
}

static int __init hello_init(void)
{

    printk(&quot;Entering: %s\n&quot;, __FUNCTION__);
    //nl_sk = netlink_kernel_create(&amp;init_net, NETLINK_USER, 0, hello_nl_recv_msg, NULL, THIS_MODULE);
    struct netlink_kernel_cfg cfg = {
        .input = hello_nl_recv_msg,
    };

    nl_sk = netlink_kernel_create(&amp;init_net, NETLINK_USER, &amp;cfg);
    if (!nl_sk) {
        printk(KERN_ALERT &quot;Error creating socket.\n&quot;);
        return -10;
    }

    return 0;
}

static void __exit hello_exit(void)
{

    printk(KERN_INFO &quot;exiting hello module\n&quot;);
    netlink_kernel_release(nl_sk);
}

module_init(hello_init); module_exit(hello_exit);

MODULE_LICENSE(&quot;GPL&quot;);</code></pre>
<pre><code class="userspace">#include &lt;sys/socket.h&gt;
#include &lt;linux/netlink.h&gt;

#define NETLINK_USER 31

#define MAX_PAYLOAD 1024 /* maximum payload size*/
struct sockaddr_nl src_addr, dest_addr;
struct nlmsghdr *nlh = NULL;
struct iovec iov;
int sock_fd;
struct msghdr msg;

void main()
{
    sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);
    if (sock_fd &lt; 0)
        return -1;

    memset(&amp;src_addr, 0, sizeof(src_addr));
    src_addr.nl_family = AF_NETLINK;
    src_addr.nl_pid = getpid(); /* self pid */

    bind(sock_fd, (struct sockaddr *)&amp;src_addr, sizeof(src_addr));

    memset(&amp;dest_addr, 0, sizeof(dest_addr));
    memset(&amp;dest_addr, 0, sizeof(dest_addr));
    dest_addr.nl_family = AF_NETLINK;
    dest_addr.nl_pid = 0; /* For Linux Kernel */
    dest_addr.nl_groups = 0; /* unicast */

    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(MAX_PAYLOAD));
    memset(nlh, 0, NLMSG_SPACE(MAX_PAYLOAD));
    nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);
    nlh-&gt;nlmsg_pid = getpid();
    nlh-&gt;nlmsg_flags = 0;

    strcpy(NLMSG_DATA(nlh), &quot;Hello&quot;);

    iov.iov_base = (void *)nlh;
    iov.iov_len = nlh-&gt;nlmsg_len;
    msg.msg_name = (void *)&amp;dest_addr;
    msg.msg_namelen = sizeof(dest_addr);
    msg.msg_iov = &amp;iov;
    msg.msg_iovlen = 1;

    printf(&quot;Sending message to kernel\n&quot;);
    sendmsg(sock_fd, &amp;msg, 0);
    printf(&quot;Waiting for message from kernel\n&quot;);

    /* Read message from kernel */
    recvmsg(sock_fd, &amp;msg, 0);
    printf(&quot;Received message payload: %s\n&quot;, NLMSG_DATA(nlh));
    close(sock_fd);
}</code></pre>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example-2"></a>Example-2</h2><p>功能描述：</p>
<ol>
<li>本实例包含2个部分：内核模块和用户程序</li>
<li>用户程序通过netlink socket建立与kernel module连接，并向kernel module发送一条信息</li>
<li>内核在接收到用户的信息后，向用户程序发送一条确认信息</li>
</ol>
<p>内核代码</p>
<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;net/sock.h&gt;
#include &lt;linux/netlink.h&gt;

#define NETLINK_TEST 17
struct {
    __u32 pid;
}user_process;

static struct sock *netlinkfd = NULL;

int send_to_user(char *info) //发送到用户空间
{
    int size;
    struct sk_buff *skb;
    unsigned char *old_tail;
    struct nlmsghdr *nlh; //报文头

    int retval;

    size = NLMSG_SPACE(strlen(info)); //报文大小
    skb = alloc_skb(size, GFP_ATOMIC); //分配一个新的套接字缓存,使用GFP_ATOMIC标志进程不&gt;会被置为睡眠

    //初始化一个netlink消息首部
    nlh = nlmsg_put(skb, 0, 0, 0, NLMSG_SPACE(strlen(info))-sizeof(struct nlmsghdr), 0);
    old_tail = skb-&gt;tail;
    memcpy(NLMSG_DATA(nlh), info, strlen(info)); //填充数据区
    nlh-&gt;nlmsg_len = skb-&gt;tail - old_tail; //设置消息长度

    //设置控制字段
    NETLINK_CB(skb).pid = 0;
    NETLINK_CB(skb).dst_group = 0;

    printk(KERN_DEBUG &quot;[kernel space] skb-&gt;data:%s\n&quot;, (char *)NLMSG_DATA((struct nlmsghdr *)skb-&gt;data));

    //发送数据
    retval = netlink_unicast(netlinkfd, skb, user_process.pid, MSG_DONTWAIT);
    printk(KERN_DEBUG &quot;[kernel space] netlink_unicast return: %d\n&quot;, retval);
    return 0;
}

void kernel_receive(struct sk_buff *__skb) //内核从用户空间接收数据
{
    struct sk_buff *skb;
    struct nlmsghdr *nlh = NULL;

    char *data = &quot;This is eric&#39;s test message from kernel&quot;;

    printk(KERN_DEBUG &quot;[kernel space] begin kernel_receive\n&quot;);
    skb = skb_get(__skb);

    if(skb-&gt;len &gt;= sizeof(struct nlmsghdr)){
        nlh = (struct nlmsghdr *)skb-&gt;data;
        if((nlh-&gt;nlmsg_len &gt;= sizeof(struct nlmsghdr))
            &amp;&amp; (__skb-&gt;len &gt;= nlh-&gt;nlmsg_len)){
            user_process.pid = nlh-&gt;nlmsg_pid;
            printk(KERN_DEBUG &quot;[kernel space] data receive from user are:%s\n&quot;, (char *)NLMSG_DATA(nlh));
            printk(KERN_DEBUG &quot;[kernel space] user_pid:%d\n&quot;, user_process.pid);
            send_to_user(data);
        }
    }else{
        printk(KERN_DEBUG &quot;[kernel space] data receive from user are:%s\n&quot;,(char *)NLMSG_DATA(nlmsg_hdr(__skb)));
        send_to_user(data);
    }

    kfree_skb(skb);
}

int __init test_netlink_init(void)
{

    netlinkfd = netlink_kernel_create(&amp;init_net, NETLINK_TEST, 0, kernel_receive, NULL, THIS_MODULE);
    if(!netlinkfd){
        printk(KERN_ERR &quot;can not create a netlink socket\n&quot;);
        return -1;
    }
    return 0;
}

void __exit test_netlink_exit(void)
{
    sock_release(netlinkfd-&gt;sk_socket);
    printk(KERN_DEBUG &quot;test_netlink_exit!!\n&quot;);
}

module_init(test_netlink_init);
module_exit(test_netlink_exit);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;eric.hu&quot;);</code></pre><p>用户空间代码</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;string.h&gt;
#include &lt;linux/netlink.h&gt;

#define NETLINK_TEST 17
#define MSG_LEN 100

struct msg_to_kernel
{
    struct nlmsghdr hdr;
    char data[MSG_LEN];
};
struct u_packet_info
{
    struct nlmsghdr hdr;
    char msg[MSG_LEN];
};

int main(int argc, char* argv[])
{
    char *data = &quot;This message is from eric&#39;s space&quot;;
    //初始化
    struct sockaddr_nl local;
    struct sockaddr_nl kpeer;
    int skfd, ret, kpeerlen = sizeof(struct sockaddr_nl);
    struct nlmsghdr *message;
    struct u_packet_info info;
    char *retval;
    message = (struct nlmsghdr *)malloc(1);

    skfd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TEST);
    if(skfd &lt; 0){
        printf(&quot;can not create a netlink socket\n&quot;);
        return -1;
    }
    memset(&amp;local, 0, sizeof(local));
    local.nl_family = AF_NETLINK;
    local.nl_pid = getpid();
    local.nl_groups = 0;
    if(bind(skfd, (struct sockaddr *)&amp;local, sizeof(local)) != 0){
        printf(&quot;bind() error\n&quot;);
        return -1;
    }
    memset(&amp;kpeer, 0, sizeof(kpeer));
    kpeer.nl_family = AF_NETLINK;
    kpeer.nl_pid = 0;
    kpeer.nl_groups = 0;

    memset(message, &#39;\0&#39;, sizeof(struct nlmsghdr));
    message-&gt;nlmsg_len = NLMSG_SPACE(strlen(data));
    message-&gt;nlmsg_flags = 0;
    message-&gt;nlmsg_type = 0;
    message-&gt;nlmsg_seq = 0;
    message-&gt;nlmsg_pid = local.nl_pid;

    retval = memcpy(NLMSG_DATA(message), data, strlen(data));

    printf(&quot;message sendto kernel are:%s, len:%d\n&quot;, (char *)NLMSG_DATA(message), message-&gt;nlmsg_len);
    ret = sendto(skfd, message, message-&gt;nlmsg_len, 0,(struct sockaddr *)&amp;kpeer, sizeof(kpeer));
    if(!ret){
        perror(&quot;send pid:&quot;);
        exit(-1);
    }

    //接受内核态确认信息
    ret = recvfrom(skfd, &amp;info, sizeof(struct u_packet_info),0, (struct sockaddr*)&amp;kpeer, &amp;kpeerlen);
    if(!ret){
        perror(&quot;recv form kerner:&quot;);
        exit(-1);
    }

    printf(&quot;message receive from kernel:%s\n&quot;,(char *)info.msg);
    //内核和用户进行通信

    close(skfd);
    return 0;
}</code></pre><h2 id="uevent-message-payload-size"><a href="#uevent-message-payload-size" class="headerlink" title="uevent message payload size"></a>uevent message payload size</h2><p><code>lib/kobject_uevent.c</code> <code>kobject_uevent_env</code></p>
<pre><code class="include/linux/kobject.h">#define UEVENT_BUFFER_SIZE      2048
struct kobj_uevent_env {                                                                                                           
    char *envp[UEVENT_NUM_ENVP];                                              
    int envp_idx;                                                             
    char buf[UEVENT_BUFFER_SIZE];                                             
    int buflen;                                                               
}; </code></pre>
<pre><code>struct kobj_uevent_env *env;
env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);

/* default keys */                                                        
retval = add_uevent_var(env, &quot;ACTION=%s&quot;, action_string);                                                                      
if (retval)                                                               
    goto exit;                                                            
retval = add_uevent_var(env, &quot;DEVPATH=%s&quot;, devpath);                      
if (retval)                                                               
    goto exit;                                                            
retval = add_uevent_var(env, &quot;SUBSYSTEM=%s&quot;, subsystem);                  
if (retval)                                                               
    goto exit;

   ...
/* send netlink message */

NETLINK_CB(skb).dst_group = 1;
netlink_broadcast(uevent_sock, skb, 0, 1, GFP_KERNEL);
</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cnblogs.com/happygirl-zjj/p/6293759.html" target="_blank" rel="noopener">netlink socket编程实例</a></li>
<li><a href="http://bbs.chinaunix.net/thread-2029813-1-1.html" target="_blank" rel="noopener">netlink socket 编程之 why &amp; how</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-netlink/index.html" target="_blank" rel="noopener">Linux 系统内核空间与用户空间通信的实现与分析</a></li>
<li><a href="https://codeday.me/bug/20171018/87465.html" target="_blank" rel="noopener">linux-kernel – 如何使用netlink socket与内核模块通信？</a></li>
<li><a href="http://www.codes51.com/article/detail_4256761.html" target="_blank" rel="noopener">linux的netlink接口详解上</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>netlink</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-scheduling-policies</title>
    <url>/2017/10/19/linux-kernel-scheduling-policies/</url>
    <content><![CDATA[<p><code>Linux Scheduling</code> 有三种调度策略</p>
<ul>
<li>SCHED_FIFO，实时调度策略，先到先服务。一旦占用cpu则一直运行。一直运行直到有更高优先级任务到达或自己放弃</li>
<li>SCHED_RR，实时调度策略，时间片轮转。当进程的时间片用完，系统将重新分配时间片，并置于就绪队列尾。放在队列尾保证了所有具有相同优先级的RR任务的调度公平</li>
<li>SCHED_OTHER，分时调度策略，不支持优先级使用</li>
</ul>
<a id="more"></a>

<h2 id="SCHED-OTHER"><a href="#SCHED-OTHER" class="headerlink" title="SCHED_OTHER"></a>SCHED_OTHER</h2><p>分时调度策略，不支持有限使用，Linux默认采用这种调度策略</p>
<h2 id="SCHED-RR"><a href="#SCHED-RR" class="headerlink" title="SCHED_RR"></a>SCHED_RR</h2><p>实时调度策略，支持优先级。</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="查询并设置调度策略"><a href="#查询并设置调度策略" class="headerlink" title="查询并设置调度策略"></a>查询并设置调度策略</h3><p><code>pthread</code> 库，文件为 <code>&lt;pthread.h&gt;</code></p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;sched.h&gt;

static int get_thread_policy(pthread_attr_t *attr)
{
    int policy;
    int rs = pthread_attr_getschedpolicy(attr, &amp;policy);
    switch (policy)
    {
        case SCHED_FIFO:
            printf(&quot;policy = SCHED_FIFO\n&quot;);
            break;
        case SCHED_RR:
            printf(&quot;policy = SCHED_RR\n&quot;);
            break;
        case SCHED_OTHER:
            printf(&quot;policy = SCHED_OTHER\n&quot;);
            break;
        default:
            printf(&quot;policy = SCHED_UNKNOW\n&quot;);
            break;
    }
    return policy;
}

main(void)
{
    pthread_attr_t attr;
    int rs;
    rs = pthread_attr_init(&amp;attr);
    int policy = get_thread_policy(&amp;attr);
    pthread_attr_setschedpolicy(&amp;attr, SCHED_RR);
    policy = get_thread_policy(&amp;attr);
    pthread_attr_destroy(&amp;attr);
}</code></pre><h3 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h3><pre><code>pthread_attr_t attr;
struct sched_param param;
pthread_attr_init(&amp;attr);
pthread_attr_setschedpolicy(&amp;attr, SCHED_RR);
param.sched_priority = 10;
pthread_attr_setschedparam(&amp;attr, &amp;param);
pthread_create(xxx, &amp;attr, xxx, xxx);
pthread_attr_destory(&amp;attr);</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><pre><code>#ifdef LINUX_RR_SUPPORT
    return _ThreadCreate(thread_name, thread_id, entry_func, arg, stack_size, priority, SCHED_RR, PTHREAD_CREATE_JOINABLE);
#else
    return _ThreadCreate(thread_name, thread_id, entry_func, arg, stack_size, priority, SCHED_OTHER,PTHREAD_CREATE_JOINABLE);
#endif

static int32_t _ThreadCreate(const char *thread_name, handle_t *thread_id,
         void(*entry_func)(void *), void *arg,
         uint32_t stack_size,
         uint32_t priority,
         uint32_t sched_policy,
         uint32_t detach_state)
{
    int                  return_code = 0;
    pthread_attr_t       custom_attr ;
    struct sched_param   priority_holder ;
    int32_t ret = 0;
    uint32_t             local_stack_size;
    ThreadRecord* thread_rec;

#ifdef ASSERT_DEBUG
    assert(thread_id);
    assert(entry_func);
    assert(priority &lt;= MAX_PRIORITY);
#endif

    thread_exit();

    /* Check for NULL pointers */
    if( entry_func == NULL || thread_id == NULL)
        return INVALID_POINTER;

    /* Check for bad priority */
    if (priority &gt; MAX_PRIORITY)
        return INVALID_PRIORITY;

    thread_rec = THREAD_NEW();
    if (thread_rec == NULL)
        return ERR_NO_FREE_IDS;

    /* Set stack size */
    if (pthread_attr_init(&amp;custom_attr)) {
        printf(&quot;pthread_attr_init error in ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);
        goto err;
    }

    local_stack_size = stack_size &lt;= PTHREAD_STACK_MIN ? PTHREAD_STACK_MIN : stack_size;
    if (pthread_attr_setstacksize(&amp;custom_attr, (size_t)local_stack_size)) {
        printf(&quot;pthread_attr_setstacksize error in ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);
        goto err;
    }

    if (sched_policy == SCHED_RR) {
        /* Set priority */
        if (UpUserPermissions() != true) {
            printf(&quot;upuserpermissions err in ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);
            goto err;
        }
        pthread_attr_setschedpolicy(&amp;custom_attr, SCHED_RR);
        ret = pthread_attr_setinheritsched(&amp;custom_attr, PTHREAD_EXPLICIT_SCHED);
        if(ret != 0)
        {
            printf(&quot;pthread_attr_setinheritsched error in ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);
            DownUserPermissions();
            goto err;
        }
        priority_holder.sched_priority = sched_get_priority_max(SCHED_RR) - priority;
        ret = pthread_attr_setschedparam(&amp;custom_attr, &amp;priority_holder);
        if(ret != 0) {
            printf(&quot;pthread_attr_setschedparam error in ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);
            DownUserPermissions();
            goto err;
        }
        DownUserPermissions();
    }

    if (detach_state == PTHREAD_CREATE_DETACHED) {
        ret = pthread_attr_setdetachstate(&amp;custom_attr, PTHREAD_CREATE_DETACHED);
        if (ret != 0) {
            printf(&quot;pthread_attr_setdetachstate failed !\n&quot;);
            goto err;
        }
    }

    /* Create thread */
    thread_rec-&gt;entry_func = entry_func;
    thread_rec-&gt;arg = arg;
    thread_rec-&gt;status = JOINABLE;
    if (UpUserPermissions() != true) {
        printf(&quot;upuserpermissions err in ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);
        goto err;
    }

    return_code = pthread_create(&amp;(thread_rec-&gt;id), &amp;custom_attr, default_thread_function, thread_rec);
    if (return_code != 0) {
        printf(&quot;pthread_create error in ThreadCreate, Pthread ID = %u\n&quot;, thread_rec-&gt;handle);

        DownUserPermissions();
        goto err;
    }
    DownUserPermissions();

    //*thread_id = thread_rec-&gt;handle;
    *thread_id = thread_rec-&gt;handle;
    //id_to_handle[thread_rec-&gt;handle] = thread_rec-&gt;id;

    /* this Id no longer free */
    thread_rec-&gt;stack_size = stack_size;
    thread_rec-&gt;priority = priority;

    return_code = pthread_attr_getstack(&amp;custom_attr, &amp;thread_rec-&gt;stack_base, &amp;thread_rec-&gt;stack_size);
    if (return_code != 0) {
        printf(&quot;%s: pthread_attr_getstack err: %d&quot;, __func__, return_code);
        return ERROR;
    }
    pthread_attr_destroy(&amp;custom_attr);
    return SUCCESS;

err:
    if (thread_rec-&gt;freed == 1)
        THREAD_FREE(thread_rec);
    pthread_attr_destroy(&amp;custom_attr);
    return ERROR;
}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cnblogs.com/xiaotlili/p/3510224.html" target="_blank" rel="noopener">Linux 线程调度与优先级</a></li>
<li><a href="http://liubigbin.github.io/2016/03/21/Linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Linux任务调度机制</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下编码转换</title>
    <url>/2017/10/18/linux-encoding-convert/</url>
    <content><![CDATA[<p>工作中使用<code>git</code>进行代码管理，由于跨操作系统的原因，经常遇到文本编码乱码的问题。这是因为Windows默认<a href="https://en.wikipedia.org/wiki/GBK" target="_blank" rel="noopener">GBK</a>编码格式，Linux默认<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>编码格式，使用以下命令可以进行批量编码转换。</p>
<a id="more"></a>

<h2 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h2><pre><code>$ iconv --help
用法： iconv [选项...] [文件...]
转换给定文件的编码。

 输入/输出格式规范：
  -f, --from-code=名称     原始文本编码
  -t, --to-code=名称       输出编码

 信息：
  -l, --list                 列举所有已知的字符集

 输出控制：
  -c                         从输出中忽略无效的字符
  -o, --output=文件        输出文件
  -s, --silent               关闭警告
      --verbose              打印进度信息

  -?, --help                 给出此帮助列表
      --usage                给出简要的用法信息
  -V, --version              打印程序版本号

长选项的强制或可选参数对对应的短选项也是强制或可选的。</code></pre><h2 id="enca"><a href="#enca" class="headerlink" title="enca"></a>enca</h2><p><code>iconv</code> 需要确认原始编码格式，使用<code>enca</code>可以探测文件格式</p>
<pre><code>enca -L zh_CN file          #检查文件格式
enca -L zn_CN -x UTF-8 file #转换为UTF-8编码</code></pre><pre><code>$ enca -L zh_CN search/*
enca: Cannot read file `search/demos&#39;: Is a directory
search/rch.c: Simplified Chinese National Standard; GB2312
search/ch.c: Universal transformation format 8 bits; UTF-8</code></pre><h2 id="recode"><a href="#recode" class="headerlink" title="recode"></a>recode</h2><p>Charset converter tool and library <a href="http://recode.progiciels-bpi.ca" target="_blank" rel="noopener">http://recode.progiciels-bpi.ca</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>encoding</tag>
        <tag>iconv</tag>
      </tags>
  </entry>
  <entry>
    <title>google-search-engine-optimization</title>
    <url>/2017/10/16/google-search-engine-optimization/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="site"><a href="#site" class="headerlink" title="site"></a>site</h2><p><code>site:</code> 是SEO高级搜索命令，用来搜索某个域名下的所有文件，去掉网站的<code>www</code>，例如：</p>
<pre><code>enca用法 site:github.com</code></pre><h2 id="搜索图片"><a href="#搜索图片" class="headerlink" title="搜索图片"></a>搜索图片</h2><p>按住<code>S</code>按键，鼠标在图片上点右键，可以搜索图片的出处，<code>Chrome</code>浏览器</p>
<h2 id="完全匹配搜索"><a href="#完全匹配搜索" class="headerlink" title="完全匹配搜索"></a>完全匹配搜索</h2><p><code>&quot;&quot;</code> 用于完全匹配搜索</p>
<h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p><code>-</code>搜索不包含<code>-</code>后面的词。使用这个指令时<code>-</code>前面必须是空格，后面紧跟需要排除的词。</p>
<h2 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h2><p><code>WordA OR WordB</code> 搜索包含两关键词之一的页面</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="+"></a>+</h2><p>都包含的页面</p>
<h2 id="-2"><a href="#-2" class="headerlink" title="~"></a>~</h2><p>同义词</p>
<h2 id="-3"><a href="#-3" class="headerlink" title="*"></a>*</h2><p><code>*</code> 通配符</p>
<h2 id="inurl"><a href="#inurl" class="headerlink" title="inurl"></a>inurl</h2><p><code>inurl</code>用于搜索查询词在url中的页面，支持中英文。</p>
<h2 id="allintitle"><a href="#allintitle" class="headerlink" title="allintitle"></a>allintitle</h2><p><code>allintitle</code> 搜索返回的是页面标题中包含多组关键词的文件</p>
<pre><code>allintitle:SEO 搜索引擎优化</code></pre><h2 id="allinurl"><a href="#allinurl" class="headerlink" title="allinurl"></a>allinurl</h2><p>与 <code>allintitle</code> 类似</p>
<p><code>allinurl:SEO 搜索引擎</code> 相当于 <code>inurl:SEO inurl:搜索引擎</code></p>
<h2 id="filetype"><a href="#filetype" class="headerlink" title="filetype"></a>filetype</h2><p><code>filetype:pdf</code> 搜索指定的文件格式</p>
<pre><code>filetype:csv site:baidu.pan.com inurl:movie</code></pre><h2 id="related"><a href="#related" class="headerlink" title="related"></a>related</h2><p><code>related</code> 返回结果是与某个网站有关联的页面</p>
<pre><code>related:zhihu.com</code></pre><h2 id="Google自定义搜索"><a href="#Google自定义搜索" class="headerlink" title="Google自定义搜索"></a>Google自定义搜索</h2><p><code>Google自定义搜索服务</code> -&gt; <code>add</code> -&gt; <code>yun.baidu.com/*</code> -&gt; <code>http://pan.baidu.com/*</code> -&gt; <code>Create</code></p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/google/mfUgTBp.png" alt="google"></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Google</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>git-clone-https-443-error</title>
    <url>/2017/10/13/git-clone-https-443-error/</url>
    <content><![CDATA[<p>使用github出现以下问题：</p>
<pre><code>fatal: unable to access &#39;https://github.com/andoma/rtmpdump.git/&#39;: Failed to connect to github.com port 443: 连接超时</code></pre><p>网上解决办法部分可以通过设置或取消代理来修复，尝试未果。</p>
<p>更换为 <code>ssh</code> 可以正常使用。</p>
<a id="more"></a>



<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><pre><code>git config http.proxy
git config https.proxy
git config --global --unset https.proxy
git config --global &#39;socks5:/127.0.0.1:1080&#39;</code></pre><h2 id="git-version"><a href="#git-version" class="headerlink" title="git version"></a>git version</h2><pre><code>$ git --version 
git version 2.13.0</code></pre><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><pre><code>$ ping github.com
PING github.com (192.30.252.128) 56(84) bytes of data.
^C
--- github.com ping statistics ---
79 packets transmitted, 0 received, 100% packet loss, time 79855ms</code></pre><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><pre><code>$ traceroute 192.30.252.128
traceroute to 192.30.252.128 (192.30.252.128), 30 hops max, 60 byte packets
 1  gateway (192.168.110.1)  0.920 ms  0.908 ms  0.900 ms
 2  * * *
 3  192.168.3.1 (192.168.3.1)  1.542 ms  1.536 ms  1.510 ms
 4  115.236.90.217 (115.236.90.217)  9.464 ms  9.387 ms  9.464 ms
 5  220.191.159.125 (220.191.159.125)  5.358 ms 61.164.19.145 (61.164.19.145)  6.558 ms 61.164.8.45 (61.164.8.45)  5.350 ms
 6  * 61.164.22.149 (61.164.22.149)  3.388 ms *
 7  202.97.82.9 (202.97.82.9)  7.015 ms 202.97.68.137 (202.97.68.137)  6.437 ms 202.97.82.9 (202.97.82.9)  7.958 ms
 8  * * *
 9  * * *
10  * * *
11  * * *
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *</code></pre><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><pre><code>$ netstat -nr
内核 IP 路由表
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         192.168.110.1   0.0.0.0         UG        0 0          0 eth0
0.0.0.0         192.168.188.1   0.0.0.0         UG        0 0          0 wlan0
169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 wlan0
192.168.110.0   0.0.0.0         255.255.254.0   U         0 0          0 eth0
192.168.188.0   0.0.0.0         255.255.254.0   U         0 0          0 wlan0</code></pre><h2 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h2><p>删除 <code>hosts</code> 中关于github的记录</p>
<pre><code class="/etc/hosts">#fix github
23.235.40.249  github.global.ssl.fastly.net
192.30.252.128 github.com
64.233.179.91 dl-ssl.google.com
64.233.169.101 groups.google.com
216.58.218.138 ajax.googleapis.com

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters</code></pre>
<p>将 <code>192.30.252.128 github.com</code> 屏蔽解决问题</p>
<pre><code>$ ping github.com
PING github.com (192.30.255.113) 56(84) bytes of data.
64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=1 ttl=44 time=191 ms
64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=2 ttl=44 time=224 ms
^C
--- github.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2002ms
rtt min/avg/max/mdev = 191.531/208.191/224.851/16.660 ms</code></pre><p>由上面打印可以看出是 <code>github.com</code> 地址发生变化导致 <code>hosts</code> 不对应，从而不能正常访问</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为了方便用户记忆，我们将IP变成一个个的域名来输入到浏览器进行访问。而这使得访问网站时要先将其域名解析成 IP 。DNS (Domain Name Server) 的作用就是进行 IP 解析，把域名对应到 IP。在 Great FireWall 的 5 种封锁方法中，有一种简单而效果很好的方法是 DNS 污染。GFW 会对 DNS 的解析过程进行干扰，这会使对某些被干扰的域名返回一个错误的 IP 地址给你的主机，使你无法正确连接到你要的服务器上读取正确的信息。</p>
<p>Hosts 文件本来是用来提高解析效率。在进行 DNS 请求以前，系统会先检查自己的 Hosts 文件中是否有这个地址映射关系，如果有则调用这个 IP 地址映射，如果没有再向已知的 DNS 服务器提出域名解析。也就是说 Hosts 的请求级别比 DNS 高。当你的 Hosts 文件里面有对应的 IP 时，它就会直接访问那个 IP，而不用通过 DNS。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>RNDIS</title>
    <url>/2017/10/12/linux-RNDIS/</url>
    <content><![CDATA[<a id="more"></a>

<p><strong>RNDIS网络</strong>，一台Linux设备可以作为 <code>usb device</code>，也可以作为 <code>usb host</code></p>
<h2 id="RNDIS"><a href="#RNDIS" class="headerlink" title="RNDIS"></a>RNDIS</h2><p>全称 <code>Remote Network Device Interface Specification</code></p>
<h2 id="HOST"><a href="#HOST" class="headerlink" title="HOST"></a>HOST</h2><pre><code>Symbol: USB_NET_RNDIS_HOST [=y]
    Prompt: Host for RNDIS and ActiveSync devices (EXPERIMENTAL)
      Defined at drivers/net/usb/Kconfig:226
      Depends on: NETDEVICES &amp;&amp; USB &amp;&amp; NET &amp;&amp; USB_USBNET &amp;&amp; EXPERIMENTAL
      Location:
        -&gt; Device Drivers
          -&gt; Network device support (NETDEVICES [=y])
            -&gt; USB Network Adapters
              -&gt; Multi-purpose USB Networking Framework (USB_USBNET [=y])
      Selects: USB_NET_CDCETHER
      Selected by: USB_NET_RNDIS_WLAN &amp;&amp; NETDEVICES &amp;&amp; !S390 &amp;&amp; USB &amp;&amp; WLAN_80211 &amp;&amp; EXPERIMENTAL</code></pre><h2 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h2><pre><code>Symbol: USB_ETH_RNDIS [=y]
Prompt: RNDIS support
    Defined at drivers/usb/gadget/Kconfig:499
    Depends on: &lt;choice&gt; &amp;&amp; USB_ETH
    Location:
    -&gt; Device Drivers
        -&gt; USB support (USB_SUPPORT [=y])
        -&gt; USB Gadget Support (USB_GADGET [=y])
            -&gt; USB Gadget Drivers (&lt;choice&gt; [=y])
            -&gt; Ethernet Gadget (with CDC Ethernet support) (USB_ETH [=y])</code></pre><p>RNDIS gadget driver module can be inserted using $ insmod g_ether.ko</p>
<p>You can, alternatively, change the <M> for USB Gadget Drivers to &lt;<em>&gt; and this will compile the drivers into the kernel, so you won’t have to load the module. You will need to first de-select all child modules under USB Gadget Drivers, then press space bar over USB Gadget Drivers to change the <M> to a &lt;</em>&gt;.</p>
<p>The RNDIS Gadget driver will create an Ethernet device by the name <code>usb0</code>. You need to assign an IP address to the device and bring up the device. The typical command for that would be:</p>
<pre><code>ifconfig usb0 &lt;IP_ADDR&gt; netmask 255.255.255.0 up</code></pre><p>使用以上命令不能正常上网，使用<code>udhpc</code>来完成IP地址分配</p>
<pre><code></code></pre><p>插入 <code>USB Device</code></p>
<pre><code>[   19.980000] usb 1-1: new high speed USB device using EHCI-NationalChip and address 3
[   20.140000] usb 1-1: configuration #1 chosen from 1 choice
[Hotplug] dev: 1-1
[Hotplug] action: add
[Hotplug] dev: 1-1:1.0
[Hotplug] action: add
[   20.270000] usb0: register &#39;rndis_host&#39; at usb-EHCI-NationalChip-1, RNDIS device, e6:92:79:c4:b1:cb</code></pre><p>查看设备</p>
<pre><code>[root@root /]# ifconfig -a
eth0      Link encap:Ethernet  HWaddr 32:11:B7:CC:97:9F
          inet addr:192.168.111.18  Bcast:192.168.111.255  Mask:255.255.254.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:5254 errors:0 dropped:0 overruns:0 frame:0
          TX packets:19 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:6781768 (6.4 MiB)  TX bytes:2538 (2.4 KiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

usb0      Link encap:Ethernet  HWaddr E6:92:79:C4:B1:CB
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p><code>udhpc</code></p>
<pre><code>[root@root /]# ifconfig usb0 up
[root@root /]# udhcpc -t 20 -T 1 -n -q -i usb0
udhcpc (v1.21.0) started
Setting IP address 0.0.0.0 on usb0
Sending discover...
Sending discover...
Sending discover...
Sending select for 192.168.42.36...
Lease of 192.168.42.36 obtained, lease time 3600
Setting IP address 192.168.42.36 on usb0
Deleting routers
route: SIOCDELRT: No such process
Adding router 192.168.42.129
Recreating /tmp/etc/resolv.conf
 Adding DNS server 192.168.42.129</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://os.51cto.com/art/201703/533323.htm" target="_blank" rel="noopener">Linux下使用USB网络</a></li>
<li><a href="http://blog.csdn.net/wangzhen209/article/details/39344703" target="_blank" rel="noopener">Linux下使用USB网络</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rndis</tag>
      </tags>
  </entry>
  <entry>
    <title>sed-and-awk-without-regex</title>
    <url>/2017/09/21/sed-and-awk-without-regex/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><pre><code>grep -F 
-F, --fixed-strings
    Interpret PATTERN as a list of fixed strings (instead of regular expressions), separated by newlines, any of which is to be matched.</code></pre><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p><strong>sed cannot run without regex</strong></p>
<pre><code>sed -i ‘sshttp://127.0.0.1:8080/webinterfaceshttp://192.168.50.13:9091/my/web/interfacesg’ /home/bigbrus_corner/test_sed
         ^                                  ^                                          ^</code></pre><p>use <code>s</code> as a separator</p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>use awk and the string functions index() and substr() that don’t use patterns</p>
<p>使用<code>awk</code>内置函数<code>gsed</code></p>
<pre><code>awk &#39;{gsub(&quot;foo&quot;, &quot;foofoofoo&quot;, $0); print}&#39; data.txt 
awk &#39;{gsub(&quot;^USER=.*&quot;, &quot;1234*()_+123&lt;&gt;?123&quot;, $0); print}&#39; data.txt </code></pre><pre><code>awk -v find=&quot;$param1&quot; -v repl=&quot;$param2&quot; &#39;{
    while (i=index($0,find)) 
        $0 = substr($0,1,i-1) repl substr($0,i+length(find))
    print
}&#39; file</code></pre><pre><code>awk &#39;{gsub(/xxx/,&quot;XXX&quot;);print &gt; &quot;test.txt&quot;}&#39; test.txt

awk &#39;...&#39; urfile &gt; tmp
mv tmp urfile</code></pre><p>第一种方式有风险：<strong>缓冲区溢出</strong></p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>sed</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>i2c-bus</title>
    <url>/2017/09/19/i2c-bus/</url>
    <content><![CDATA[<ul>
<li>I2C Read时，寄存器地址是可选项，是否需要需要根据寄存器手册来确认</li>
<li>I2C每个数据后都有ACK</li>
</ul>
<a id="more"></a>

<h2 id="Write-x-bytes-to-I2C-slave"><a href="#Write-x-bytes-to-I2C-slave" class="headerlink" title="Write x bytes to I2C slave"></a>Write x bytes to I2C slave</h2><ul>
<li>A:Acknowledge(SDA LOW) </li>
<li>A~:Not Acknowledge(SDA HIGH)</li>
<li>S:Start Condition</li>
<li>P:Stop Condition</li>
<li>():From slave to Master</li>
</ul>
<pre><code>S -&gt; SLAVE ADDR+W -&gt; (A) -&gt; REGISTER -&gt; (A) -&gt; DATA0 -&gt; (A) -&gt; DATA1 -&gt; (A) -&gt; DATAx -&gt; (A) -&gt; P</code></pre><h2 id="Set-slave-data-pointer"><a href="#Set-slave-data-pointer" class="headerlink" title="Set slave data pointer"></a>Set slave data pointer</h2><pre><code>S -&gt; SLAVE ADDR+W -&gt; (A) -&gt; REGISTER -&gt; (A) -&gt; P</code></pre><h2 id="Read-x-bytes-from-I2C-slave"><a href="#Read-x-bytes-from-I2C-slave" class="headerlink" title="Read x bytes from I2C slave"></a>Read x bytes from I2C slave</h2><pre><code>S -&gt; SLAVE ADDR+R -&gt; (A) -&gt; (DATA0) -&gt; A -&gt; (DATA1) -&gt; A -&gt; (DATAx) -&gt; A~ -&gt; P</code></pre><h2 id="I2C-BUS-Specification"><a href="#I2C-BUS-Specification" class="headerlink" title="I2C BUS Specification"></a>I2C BUS Specification</h2><p>Each slave device on the bus should have a unique 7-bit address. The communication starts with the Start condition, followed by the 7-bit slave address and the data direction bit. If this bit is 0 then the master will write to the slave device. Otherwise, if the data direction bit is 1, the master will read from slave device. After the slave address and the data direction is sent, the master can continue with reading or writing. The communication is ended with the Stop condition which also signals that the I2C bus is free. If the master needs to communicate with other slaves it can generate a repeated start with another slave address without generation Stop condition. All the bytes are transferred with the MSB bit shifted first.</p>
<p>If the master only writes to the slave device then the data transfer direction is not changed.</p>
<pre><code>S -&gt; SLAVE ADDR+W -&gt; (A) -&gt;</code></pre><p>If the master only needs to read from the slave device then it simply sends the I2C address with the R/W bit set to read. After this the master device starts reading the data.</p>
<pre><code></code></pre><p>Sometimes the master needs to write some data and then read from the slave device. In such cases it must first write to the slave device, change the data transfer direction and then read the device. This means sending the I2C address with the R/W bit set to write and then sending some additional data like register address. After writing is finished the master device generates repeated start condition and sends the I2C address with the R/W bit set to read. After this the data transfer direction is changed and the master device starts reading the data.</p>
<pre><code>S -&gt; SLAVE ADDR+W -&gt; (A)</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://i2c.info/" target="_blank" rel="noopener">I2C Info – I2C Bus, Interface and Protocol</a></li>
<li><a href="http://i2c.info/i2c-bus-specification" target="_blank" rel="noopener">I2C Bus Specification</a></li>
<li><a href="http://www.robot-electronics.co.uk/i2c-tutorial" target="_blank" rel="noopener">Using the I2C Bus</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_533074eb0101c6iv.html" target="_blank" rel="noopener">快速简单理解i2c标准协议</a></li>
<li><a href="http://www.cnblogs.com/hechengfei/p/4117840.html" target="_blank" rel="noopener">巩固理解I2C协议</a></li>
<li><a href="https://www.leiphone.com/news/201708/4z5gAUzK7auatdKJ.html" target="_blank" rel="noopener">I2C 协议分析</a></li>
<li><a href="http://blog.csdn.net/g_salamander/article/details/8016698" target="_blank" rel="noopener">I2c 协议解析</a></li>
<li><a href="https://github.com/firmata/protocol/blob/master/i2c.md" target="_blank" rel="noopener">I2C</a></li>
<li><a href="http://www.microchip.com/forums/m1013076.aspx" target="_blank" rel="noopener">How to read IDs from I2C Devices</a></li>
<li><a href="https://forum.arduino.cc/index.php?topic=360463.0" target="_blank" rel="noopener">how to read from certain register address of i2c slave with wire.h library?</a></li>
<li><a href="https://os.mbed.com/users/okano/notebook/i2c-access-examples/" target="_blank" rel="noopener">I2C access examples</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-thread-exit</title>
    <url>/2017/09/01/linux-thread-exit/</url>
    <content><![CDATA[<ul>
<li>pthread_create 创建一个线程</li>
<li>pthread_self   找出自己的线程ID</li>
<li>pthread_equal  测试2个线程ID是否相等</li>
<li>pthread_detach 设置线程以释放资源</li>
<li>pthread_join   等待一个线程</li>
<li>pthread_cancel 终止另一个线程</li>
<li>pthread_exit   退出线程，而不退出进程</li>
<li>pthread_kill   向线程发送一个信号</li>
</ul>
<a id="more"></a>

<p>因此在信号处理函数中，使用<code>pthread_exit</code>退出某个线程，调用<code>exit</code>来退出进程</p>
<h2 id="exit-exit"><a href="#exit-exit" class="headerlink" title="exit _exit"></a>exit _exit</h2><p>进程终止有5种方式：</p>
<ul>
<li>从main函数返回</li>
<li>调用exit</li>
<li>调用_exit</li>
<li>调用abort</li>
<li>由信号终止</li>
</ul>
<p>_exit()函数的作用最为简单：直接使进程停止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构；exit() 函数则在这些基础上作了一些包装，在执行退出之前加了若干道工序。<br>exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是”清理I/O缓冲”。</p>
<h2 id="pthread-kill"><a href="#pthread-kill" class="headerlink" title="pthread_kill"></a>pthread_kill</h2><p>pthread_kill与kill有区别，是向线程发送signal。，大部分signal的默认动作是终止进程的运行，所以，我们才要用signal()去抓信号并加上处理函数。</p>
<pre><code>int pthread_kill(pthread_t thread, int sig);</code></pre><p>向指定ID的线程发送sig信号，如果线程代码内不做处理，则按照信号默认的行为影响整个进程，也就是说，如果你给一个线程发送了SIGQUIT，但线程却没有实现signal处理函数，则整个进程退出。</p>
<p>pthread_kill(threadid, SIGKILL)杀死整个进程。 如果要获得正确的行为，就需要在线程内实现signal(SIGKILL,sig_handler)。所以，如果int sig的参数不是0，那一定要清楚到底要干什么，而且一定要实现线程的信号处理函数，否则，就会影响整个进程。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol>
<li><a href="http://www.cnblogs.com/mickole/p/3186606.html" target="_blank" rel="noopener">进程退出exit，_exit区别即atexit函数</a></li>
<li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/10/11/2720377.html" target="_blank" rel="noopener">Linux 多线程环境下 进程线程终止函数小结</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>fork-and-signal</title>
    <url>/2017/09/01/fork-and-signal/</url>
    <content><![CDATA[<p>当一个进程调用<code>fork</code>时，因为子进程在开始时复制父进程的存储映像，信号捕捉函数的地址在子进程中是有意义的，所以<strong>子进程继承父进程的信号处理方式。</strong><br>特殊的是<code>exec</code>，因为<code>exec</code>运行新的程序后会覆盖从父进程继承来的存储映像，那么信号捕捉函数在新程序中已无意义，<strong>所以<code>exec</code>会将原先设置为要捕捉的信号都更改为默认动作。</strong></p>
<p><code>SIGTERM</code> 可以被捕捉、被忽略，因此使用 <code>kill $PID</code> 不能终止子进程</p>
<p><code>SIGKILL</code> 不能被捕捉、被忽略，因此推荐使用 <code>kill -9 $PID</code> 来终止子进程</p>
<a id="more"></a>


<h2 id="fork-exec"><a href="#fork-exec" class="headerlink" title="fork exec"></a>fork exec</h2><p>[fork exe对子进程继承父进程信号处理机制的影响]<a href="http://blog.csdn.net/guozhiyingguo/article/details/53837424" target="_blank" rel="noopener">http://blog.csdn.net/guozhiyingguo/article/details/53837424</a>)</p>
<p>当一个进程调用fork时，因为子进程在开始时复制父进程的存储映像，信号捕捉函数的地址在子进程中是有意义的，所以子进程继承父进程的信号处理方式。<br>特殊的是exec，因为exec运行新的程序后会覆盖从父进程继承来的存储映像，那么信号捕捉函数在新程序中已无意义，所以exec会将原先设置为要捕捉的信号都更改为默认动作。</p>
<ol>
<li>fork后子进程会继承父进程的信号屏蔽字，再<strong>继续exec后仍会继承这个信号屏蔽字</strong>。同样地，直接调用system后子进程也会继承父进程的信号屏蔽字。</li>
<li>fork后子进程会继承父进程的信号处理设置，再<strong>继续exec后就不会继承这个信号处理设置了</strong>。</li>
<li>fork后子进程会继承父进程的控制终端，且子进程在父进程的进程组和会话组中；再继续exec后仍会继承这个控制终端，仍在父进程的进程组和会话组中。同样地，调用system后子进程会继承父进程的控制终端，且子进程在父进程的进程组和会话组中。</li>
<li>Ctrl+c产生的SIGINT信号会发送给父进程、fork后的子进程以及继续exec的子进程；同样地，也会发给system调用运行的子进程。</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>对于fork（）：</p>
<ol>
<li>子进程复制父进程的所有进程内存到其内存地址空间中。父、子进程的 “数据段”，“堆栈段”和“代码段”完全相同，即子进程中的每一个字节都和父进程一样。</li>
<li>子进程的当前工作目录、umask掩码值和父进程相同，fork（）之前父进程打开的文件描述符，在子进程中同样打开，并且都指向相同的文件表项。</li>
<li>子进程拥有自己的进程ID。</li>
</ol>
<p>对于exec（）：</p>
<ol>
<li>进程调用exec（）后，将在同一块进程内存里用一个新程序来代替调用exec（）的那个进程，新程序代替当前进程映像，当前进程的“数据段”，“堆栈段”和“代码段”背新程序改写。</li>
<li>新程序会保持调用exec（）进程的ID不变。</li>
<li>调用exec（）之前打开打开的描述字继续打开（好像有什么参数可以令打开的描述字在新程序中关闭）</li>
</ol>
<p>###</p>
<p>fork（）</p>
<p>一个程序一调用fork函数，系统就为一个新的进程准备了前述三个段，首先，系统让新的进程与旧的进程使用同一个代码段，因为它们的程序还是相同的，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。而如果两个进程要共享什么数据的话，就要使用另一套函数（shmget，shmat，shmdt等）来操作。现在，已经是两个进程了，对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中。</p>
<p>事实上，目前大多数的unix系统在实现上并没有作真正的copy。一般的，CPU都是以“页”为单位分配空间的，象INTEL的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。系统在空间上的开销就可以达到最小。 </p>
<p>对于exec系列函数</p>
<p>一个进程一旦调用exec类函数，它本身就“死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。不过exec类函数中有的还允许继承环境变量之类的信息，这个通过exec系列函数中的一部分函数的参数可以得到。</p>
<p>###</p>
<p>子进程继承了父进程的几乎所有的属性,包括如下：　 </p>
<ul>
<li>实际UID,GID和有效UID,GID.　 </li>
<li>环境变量.　 </li>
<li>附加GID.　 </li>
<li>调用exec()时的关闭标志.　 </li>
<li>UID设置模式比特位.　 </li>
<li>GID设置模式比特位.　 </li>
<li>进程组号.　 </li>
<li>会话ID.　 </li>
<li>控制终端.　 </li>
<li>当前工作目录.　 </li>
<li>根目录.　 </li>
<li>文件创建掩码UMASK.　 </li>
<li>文件长度限制ULIMIT.　 </li>
<li>预定值,　如优先级和任何其他的进程预定参数,　根据种类不同决定是否可以继承.　 </li>
<li>还有一些其它属性.　 </li>
</ul>
<p>但子进程也有与父进程不同的属性，这点很重要： </p>
<ul>
<li>进程号,　子进程号不同与任何一个活动的进程组号.　 </li>
<li>父进程号.　 </li>
<li>子进程继承父进程的文件描述符或流时,具有自己的一个拷贝并且与父进程和其它子进程共享该资源.　 </li>
<li>子进程的用户时间和系统时间被初始化为0.　 </li>
<li>子进程的超时时钟设置为0.　 </li>
<li>子进程的信号处理函数指针组置为空.　 </li>
<li>子进程不继承父进程的记录锁.　</li>
</ul>
<h2 id="man-7-signal"><a href="#man-7-signal" class="headerlink" title="man 7 signal"></a>man 7 signal</h2><pre><code>A child created via fork(2) inherits a copy of its parent&#39;s signal dispositions.
During an execve(2), the dispositions of handled signals are reset to the default;
the dispositions of ignored signals are left unchanged.</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>父进程中注册的信号处理函数不会被子进程继承</li>
<li>父进程中忽略的信号会被子进程继承</li>
<li>SIGTERM可以被捕获、忽略</li>
<li><strong>父进程注册SIGTERM信号处理函数之后，子进程不受影响，如果SIGTERM子进程不受影响，应该是子进程添加了信号处理函数导致的</strong></li>
<li>SIGKILL不能被捕获、忽略，因此推荐使用<code>kill -9 $pid</code> 来终止子进程</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-boot-time-optimization</title>
    <url>/2017/08/21/linux-boot-time-optimization/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.sina.com.cn/s/blog_7d7e9d0f0101lmjd.html" target="_blank" rel="noopener">linux启动优化</a></li>
<li><a href="http://tinylab.org/elinux-org-boot-time-optimization/" target="_blank" rel="noopener">嵌入式 Linux 启动时间优化</a></li>
<li><a href="http://www.wowotech.net/180.html" target="_blank" rel="noopener">kernel启动优化</a></li>
<li><a href="http://blog.csdn.net/cjsycyl/article/details/7714286" target="_blank" rel="noopener">嵌入式linux开机时间优化小结</a></li>
<li><a href="http://blog.csdn.net/reille/article/details/5694155" target="_blank" rel="noopener">Linux加速启动，启动时间的极限优化</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-highmem</title>
    <url>/2017/08/16/linux-kernel-highmem/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.2baxb.me/archives/1065" target="_blank" rel="noopener">初探lowmem_reserve_ratio</a></li>
<li><a href="http://armsword.com/2013/08/25/linux-memory-and-manage/" target="_blank" rel="noopener">linux内存空间分配和内存管理</a></li>
<li><a href="http://ilinuxkernel.com/?p=1013" target="_blank" rel="noopener">Linux内核高端内存</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/vm/highmem.txt" target="_blank" rel="noopener">HIGH MEMORY HANDLING</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>waitpid</title>
    <url>/2017/08/11/waitpid/</url>
    <content><![CDATA[<p><code>pid_t waitpid(pid_t pid, int *status, int options);</code></p>
<p><code>man 2 waipid</code></p>
<a id="more"></a>

<pre><code>int status;
child_pid = fork();
if (child_pid == 0) {
    // in child; do stuff including perhaps exec
} else if (child_pid == -1) {
    // failed to fork 
} else {
    if (waitpid(child_pid, &amp;status, WNOHANG) == child_pid) {
        // child exited or interrupted; now you can do something with status
    } else {
        // error etc
    }
}</code></pre><p><strong>WNOHANG</strong> return immediately if no child has exited.</p>
<p>其中 <code>status</code> 存储的是子进程中 <code>exit code</code>，常用一下宏来判断使用 <code>status</code></p>
<ul>
<li>WIFEXITED(wstatus)，程序调用<code>exit</code> 或者 <code>_exit</code> 正常退出</li>
<li>WEXITSTATUS(wstatus)，当<code>WIFEXITED</code>返回TRUE时，用于获取 <code>exit code</code></li>
<li>WIFSIGNALED(wstatus)，程序由信号中止</li>
<li>WTERMSIG(wstatus)，当<code>WIFSIGNALED</code>返回TRUE时，获取信号值</li>
<li>WCOREDUMP(wstatus)，returns  true  if  the  child produced a core dump.</li>
<li>WIFSTOPPED(wstatus)，returns  true  if  the  child process was stopped by delivery of a signal</li>
<li>WSTOPSIG(wstatus)，returns the number of the signal which caused the child to stop.</li>
<li>WIFCONTINUED(wstatus)，returns true if the child process was resumed by delivery of SIGCONT.</li>
</ul>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre><code>pid = fork();
if(pid &lt; 0)
{
    printf(&quot;fork failed\n&quot;);
    return -1;
}
else if(pid == 0)
{
    sleep(5);
    printf(&quot;Child process\n&quot;);
    return 2;
}
else
{
    printf(&quot;Parent process\n&quot;);
    kill(pid, SIGKILL);
    waitpid(pid, &amp;ret, 0);
    if(WIFEXITED(ret))
        printf(&quot;Child process returned normally\n&quot;);
    if(WIFSIGNALED(ret))
        printf(&quot;Child process terminated by signal\n&quot;);
    return 1;
}</code></pre><pre><code>int status = 0;
if(waitpid(pid, &amp;status, WNOHANG) == 0) {
    //do something
}
else {
    if(WIFSIGNALED(status) &amp;&amp; WTERMSIG(status) == SIGTERM) {
        //signal SIGTERM caused the child process to terminate
    }
}</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mm_sysctl</title>
    <url>/2017/08/10/mm-sysctl/</url>
    <content><![CDATA[<ul>
<li>vm.min_free_kbytes</li>
<li>vm.overcommit_memory</li>
<li>vm.lowmem_reserve_ratio</li>
</ul>
<a id="more"></a>

<h2 id="min-free-kbytes"><a href="#min-free-kbytes" class="headerlink" title="min_free_kbytes"></a>min_free_kbytes</h2><p>From kernel docs:</p>
<p>This is used to force the Linux VM to keep a minimum number<br>of kilobytes free.  The VM uses this number to compute a<br>watermark[WMARK_MIN] value for each lowmem zone in the system.<br>Each lowmem zone gets a number of reserved free pages based<br>proportionally on its size.</p>
<p>Some minimal amount of memory is needed to satisfy PF_MEMALLOC<br>allocations; if you set this to lower than 1024KB, your system will<br>become subtly broken, and prone to deadlock under high loads.</p>
<p>Setting this too high will OOM your machine instantly.</p>
<p><strong>代表系统所保留空闲内存的最低限</strong></p>
<p>在系统初始化时会根据内存大小计算一个默认值，计算规则是：</p>
<pre><code>min_free_kbytes = sqrt(lowmem_kbytes * 16) = 4 * sqrt(lowmem_kbytes)(注：lowmem_kbytes即可认为是系统内存大小）</code></pre><p>另外，计算出来的值有最小最大限制，最小为128K，最大为64M。可以看出，min_free_kbytes随着内存的增大不是线性增长</p>
<p><strong>min_free_kbytes的主要用途是计算影响内存回收的三个参数 watermark[min/low/high]</strong></p>
<p><strong>min_free_kbytes大小的影响</strong></p>
<p>min_free_kbytes设的越大，watermark的线越高，同时三个线之间的buffer量也相应会增加。这意味着会较早的启动kswapd进行回收，且会回收上来较多的内存（直至watermark[high]才会停止），这会使得系统预留过多的空闲内存，从而在一定程度上降低了应用程序可使用的内存量。极端情况下设置min_free_kbytes接近内存大小时，留给应用程序的内存就会太少而可能会频繁地导致OOM的发生。<br>min_free_kbytes设的过小，则会导致系统预留内存过小。kswapd回收的过程中也会有少量的内存分配行为（会设上PF_MEMALLOC）标志，这个标志会允许kswapd使用预留内存；另外一种情况是被OOM选中杀死的进程在退出过程中，如果需要申请内存也可以使用预留部分。这两种情况下让他们使用预留内存可以避免系统进入deadlock状态。</p>
<h2 id="overcommit-memory"><a href="#overcommit-memory" class="headerlink" title="overcommit_memory"></a>overcommit_memory</h2><h2 id="lowmem-reserve-ratio"><a href="#lowmem-reserve-ratio" class="headerlink" title="lowmem_reserve_ratio"></a>lowmem_reserve_ratio</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://kernel.taobao.org/index.php?title=Kernel_Documents/mm_sysctl" target="_blank" rel="noopener">Kernel Documents/mm sysctl</a></li>
<li><a href="http://www.cnblogs.com/wjoyxt/p/3777042.html" target="_blank" rel="noopener">vm内核参数优化设置</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_69cc2f0b0100z0la.html" target="_blank" rel="noopener">32位系统，设定vm.min_free_kbytes时，需注意lowmem的值</a></li>
<li><a href="http://fanli7.net/a/caozuoxitong/Linux/20111103/139144.html" target="_blank" rel="noopener">淺析linux內核內存管理之結點與管理區初始化</a></li>
<li><a href="http://zpenglei.com/2016/10/11/kernel-zone-watermark/" target="_blank" rel="noopener">内存域水印的作用与计算</a></li>
<li><a href="http://blog.2baxb.me/archives/1065" target="_blank" rel="noopener">初探lowmem_reserve_ratio</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-modules-debug</title>
    <url>/2017/08/08/linux-modules-debug/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Linux-Kernel-Config"><a href="#Linux-Kernel-Config" class="headerlink" title="Linux Kernel Config"></a>Linux Kernel Config</h2><p>Linux内核调试需要打开如下内核配置</p>
<ul>
<li>Kernel hacking<ul>
<li>Kernel debugging</li>
<li>Detect Soft Lockups</li>
<li>Collect scheduler debugging info</li>
<li>Compile the kernel with debug info</li>
<li>Self test for the backtrace code</li>
</ul>
</li>
</ul>
<h2 id="Linux-module-prepare"><a href="#Linux-module-prepare" class="headerlink" title="Linux module prepare"></a>Linux module prepare</h2><p>Linux模块需要打开调试信息<code>-g -O0 -ggdb</code></p>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><pre><code>(cskygdb) help add-symbol-file
Load symbols from FILE, assuming FILE has been dynamically loaded.
Usage: add-symbol-file FILE ADDR [-s &lt;SECT&gt; &lt;SECT_ADDR&gt; -s &lt;SECT&gt; &lt;SECT_ADDR&gt; ...]
ADDR is the starting address of the file&#39;s text.
The optional arguments are section-name section-address pairs and
should be specified if the data and bss segments are not contiguous
with the text.  SECT is a section name to be loaded at SECT_ADDR.</code></pre><p><strong>加载地址是ko的text段位置，不是ko位置</strong>，计算加载位置如下</p>
<pre><code>$ lsmod | grep xx
xx 1495536 0 - Live 0xc016d000</code></pre><pre><code>$ objdump --section-headers xx.o | grep text
0 .text         000003d0  00000000  00000000  00000034  2**2</code></pre><p>因此，在<code>gdb</code>中加载符号如下：</p>
<pre><code>(gdb) add-symbol-file /path/to/xx.ko 0xc016d034
add symbol table from file &quot;path/to/xx.ko&quot; at
    .text_addr = 0xc016d034
(y or n) y
Reading symbols from /path/to/xx/ko..done</code></pre><h2 id="Linux-modules"><a href="#Linux-modules" class="headerlink" title="Linux modules"></a>Linux modules</h2><p><code>ko</code> 加载时触发 <code>module_init(xx_module_init)</code>，卸载时触发 <code>module_exit(xx_module_exit)</code></p>
<pre><code class="xx_module_init">static int __init xx_module_init(void)
{
    dev_t dev_id;
    int ret = -1, i;

    //执行sub模块init
    device_count = xx_init();

    if (device_count &lt; 0)
        return device_count;

    dev_id = MKDEV(XX_MAJOR, 0);
    if ((ret = register_chrdev_region(dev_id, device_count, XX_DEVICE_NAME)) != 0) {
        printk(KERN_ERR &quot;xx-core: unable to get major %d\n&quot;, XX_MAJOR);
        xx_devices_cleanup();

        return ret;
    }

    cdev_init(&amp;cdev, &amp;xx_fops);
    if ((ret = cdev_add(&amp;cdev, dev_id, device_count)) != 0) {
        printk(KERN_ERR &quot;xx-core: unable register character device\n&quot;);
        goto error;
    }
    xx_class = class_create(THIS_MODULE, XX_CLASS_NAME);
    if (IS_ERR(xx_class)) {
        ret = PTR_ERR(xx_class);
        goto error;
    }

    for (i = 0; i &lt; device_count; i++) {
        CLASS_DEV_CREATE(xx_class, NULL, MKDEV(XX_MAJOR, i), i);
    }
    xx_create_proc_entries();
    printk(KERN_EMERG &quot;%s: ok! \n&quot;, __FUNCTION__);
    return 0;

error:
    cdev_del(&amp;cdev);
    unregister_chrdev_region(dev_id, device_count);
    xx_devices_cleanup();

    return ret;
}</code></pre>
<pre><code class="xx_module_exit">static void __exit xx_module_exit(void)
{
    int i;

    printk(KERN_EMERG &quot;%s: av_devices.count = %d\n&quot;, __FUNCTION__, device_count);

    for (i = 0; i &lt; device_count; i++) {
        CLASS_DEV_DESTROY(xx_class, MKDEV(XX_MAJOR, i));
    }

    xx_devices_cleanup();
    class_destroy(xx_class);
    cdev_del(&amp;cdev);
    unregister_chrdev_region(MKDEV(XX_MAJOR, 0), device_count);

    printk(KERN_EMERG &quot;%s: ok! \n&quot;, __FUNCTION__);
}</code></pre>
<pre><code class="xx_devices_cleanup">void xx_devices_cleanup(void)
{
    struct xx_device *pos = device_list;

    XX_ASSERT(pos != NULL);

    do {
        //uninit主要执行sub模块close和cleanup
        device_uninit(pos);
        device_unregister(pos);

        pos = device_list;
    } while (device_list);
}</code></pre>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>出问题代码</p>
<pre><code>xx_open()
{
    //something

    if(xx.thread == NULL) {
        xx.ops = &amp;xx_ops;
        __xx_init(a, b);
    }
}

xx_close()
{
    //something

    if(xx.thread != NULL) {
        __xx_stop(a, b);
        __xx_exit(xx);
    }
}</code></pre><p>在 <code>xx_open</code> <code>xx_close</code> 上层的封装中并不是调用 <code>open</code> <code>close</code>就会触发底层驱动。<br>而是有<strong>打开次数</strong>来决定的，如果<code>open</code>时当前模块没有打开才会调用<code>xx_open</code>,<br>因此在上述代码中，在某些情况下，其他模块（例如demux1）触发了<code>xx_close</code>，<br>从而将<code>xx</code>结构体清零，而模块（demux0）并没有关闭，<br>当操作demux0时，调用<code>open</code>不会起作用，此时 <code>xx</code>为空导致死机</p>
<p>修改为，将<code>xx</code>相关信息放到 <code>xx_init</code> 和 <code>xx_cleanup</code> 中，这样 <code>xx_open</code> 和 <code>xx_close</code> 对 <code>xx</code> 无影响</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-kdb/index.html" target="_blank" rel="noopener">Linux 系统内核的调试</a></li>
<li><a href="http://blog.csdn.net/justlinux2010/article/details/8508333" target="_blank" rel="noopener">linux下用GDB调试可加载模块</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>size_t</title>
    <url>/2017/08/03/size-t/</url>
    <content><![CDATA[<p>使用size_t可能会提高代码的可移植性、有效性或者可读性，或许同时提高这三者。</p>
<a id="more"></a>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>在标准C库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如说 <code>malloc(n)</code> 函数的参数n指明了需要申请的空间大小，还有 <code>memcpy(s1, s2, n)</code> 的最后一个参数，表明需要复制的内存大小，<code>strlen(s)</code> 函数的返回值表明了以<code>&#39;\0&#39;</code>结尾的字符串的长度（不包括’\0’），其返回值并不是该字符串的实际长度，因为要去掉’\0’。<br>或许你会认为这些参数或者返回值应该被申明为int类型（或者long或者unsigned），但是事实上并不是。C标准中将他们定义为<code>size_t</code>。标准中记载<code>malloc</code>的申明应该出现在，定义为：</p>
<pre><code>void *malloc(size_t n);</code></pre><p>memcpy和strlen的申明：</p>
<pre><code>void *memcpy(void *s1, void const *s2, size_t n);
size_t strlen(char const *s);</code></pre><p><code>size_t</code> 还经常出现在C++标准库中，此外，C++库中经常会使用一个相似的类型 <code>size_type</code> ，用的可能比 <code>size_t</code> 还要多。</p>
<h2 id="可移植性问题"><a href="#可移植性问题" class="headerlink" title="可移植性问题"></a>可移植性问题</h2><p>早期的C语言（由Brian Kernighan 和 Dennis Ritchie 在The C Programming Language书中所写，Prentice-Hall, 1978）并没有提供size_t类型，C标准委员会为了解决移植性问题将size_t引入，举例如下：</p>
<p>让我们来写一个可移植的标准memcpy函数，我们将会看到一些不同的申明和它们在不同平台不同大小的地址空间上编译下的情况。</p>
<p>回忆memcpy(s1, s2, n)函数，它将s2指向地址开始的n个字节拷贝到s2指向的地址，返回s1，这个函数可以拷贝任何数据类型，所以参数和返回值的类型应该为可以指向任何类型的void<em>，同时，源地址不应该被改变，所以第二个参数s2类型应该为const void</em>，这些都不是问题。</p>
<p>真正的问题在于我们如何申明第三个参数，它代表了源对象的大小，我相信大部分程序员都会选择int：</p>
<pre><code>void *memcpy(void *s1, void const *s2, int n);</code></pre><p>使用int类型在大部分情况下都是可以的，但是并不是所有情况下都可以。int是有符号的，它可以表示负数，但是，大小不可能是复数。所以我们可以使用unsigned int代替它让第三个参数表示的范围更大。</p>
<p>在大部分机器上，unsigned int的最大值要比int的最大值大两倍，比如说再也给16位的机器上，unsigned int的最大值为65535，int的最大值为32767。</p>
<p>尽管int类型的大小依赖于C编译器的实现，但是在给定的平台上int对象的大小和unsigned int对象的大小是一样的。因此，使用unsigned int修饰第三个参数的代价与int是相同的：</p>
<pre><code>void *memcpy(void *s1, void const *s2, unsigned int n);  </code></pre><p>这样似乎没有问题了，unsigned int可以表示最大类型的对象大小了，这种情况只有在整形和指针类型具有相同大小的情况下，比如说在IP16中，整形和指针都占2个字节（16位），而在IP32上面，整形和指针都占4个字节（32位）。（参见下面C数据模型表示法）</p>
<h2 id="C数据模型表示法"><a href="#C数据模型表示法" class="headerlink" title="C数据模型表示法"></a>C数据模型表示法</h2><p>使用简明的标记来表述不同目标平台下c语言数据的实现。这些标记的形式形如：</p>
<pre><code>I nI L nL LL nLL P nP。   </code></pre><p>其中每个大写字母（或成对出现）代表一个C的数据类型，每一个对应的n是这个类型包含的位数。I代表int，L代表long，LL代表long long，以及P代表指针（指向数据，而不是函数）。每个字母和数字都是可选的。<br>例如，I16P32架构支持16位int和32位指针类型，没有指明是否支持long或者long long。如果两个连续的类型具有相同的大小，通常省略第一个数字。例如，你可以将I16L32P32写为I16LP32，这是一个支持16位int，32位long，和32位指针的架构。<br>标记通常把字母分类在一起，所以可以按照其对应的数字升序排列。例如，IL32LL64P32表示支持32位int，32位long，64位long long和32位指针的架构；然而，通常写作ILP32LL64。  </p>
<p>不幸的是，这种<code>memcpy</code>的申明在<code>I16LP32</code>架构上（整形是16-bit 长整形和指针类型时32-bits）显得不够用了，比如说摩托罗拉第一代处理器68000，在这种情况下，处理器可能拷贝的数据大于65535个字节，但是这个函数第三个参数n不能处理这么大的数据。<br>什么？你说很容易就可以改正？只需要把memcpy的第三个参数的类型修改一下：</p>
<pre><code>void *memcpy(void *s1, void const *s2, unsigned long  n); </code></pre><p>你可以在I16LP32目标架构上使用这个函数了，它可以处理更大的数据。而且在IP16和IP32平台上效果也还行，说明它确实给出了memcpy的一种移植性较好的申明。但是，在IP16平台上相比于使用unsigned int，你使用unsigned long可能会使你的代码运行效率大打折扣（代码量变大而且运行变慢）。</p>
<p>在标准C中规定，长整形（无论无符号或者有符号）至少占用32位，因此在IP16平台上支持标准C的话，那么它一定是IP16L32 平台。这些平台通常使用一对16位的字来实现32位的长整形。在这种情况下，移动一个长整形需要两条机器指令，每条移动一个16位的块。事实上，这个平台上的大部分的32位操作都需要至上两条指令。</p>
<p>因此，以可移植性为名将memcpy的第三个参数申明为unsigned long而降低某些平台的性能是我们所不希望看到的。使用size_t可以有效避免这种情况。</p>
<p>size_t类型是一个类型定义，通常将一些无符号的整形定义为size_t，比如说unsigned int或者unsigned long，甚至unsigned long long。每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。</p>
<h2 id="使用size-t"><a href="#使用size-t" class="headerlink" title="使用size_t"></a>使用size_t</h2><p><code>size_t</code> 的定义在 <code>&lt;stddef.h&gt;</code>, <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, <code>&lt;string.h&gt;</code>, <code>&lt;time.h&gt;</code>和<code>&lt;wchar.h&gt;</code>这些标准C头文件中，也出现在相应的C++头文件, 等等中，你应该在你的头文件中至少包含一个这样的头文件在使用<code>size_t</code>之前。<br>包含以上任何C头文件（由C或C++编译的程序）表明将<code>size_t</code>作为全局关键字。包含以上任何C++头文件（当你只能在C++中做某种操作时）表明将<code>size_t</code>作为std命名空间的成员。<br>根据定义，<code>size_t</code>是<code>sizeof</code>关键字（注：<code>sizeof</code>是关键字，并非运算符）运算结果的类型。所以，应当通过适当的方式声明n来完成赋值：</p>
<pre><code>n = sizeof(thing);</code></pre><p>考虑到可移植性和程序效率，n应该被申明为size_t类型。类似的，下面的foo函数的参数也应当被申明为sizeof：</p>
<pre><code>foo(sizeof(thing));</code></pre><p>参数中带有<code>size_t</code>的函数通常会含有局部变量用来对数组的大小或者索引进行计算，在这种情况下，<code>size_t</code>是个不错的选择。</p>
<p>适当地使用<code>size_t</code>还会使你的代码变得如同自带文档。当你看到一个对象声明为<code>size_t</code>类型，你马上就知道它代表字节大小或数组索引，而不是错误代码或者是一个普通的算术值。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters?" target="_blank" rel="noopener">Why size_t matters</a></li>
<li><a href="http://jeremybai.github.io/blog/2014/09/10/size-t" target="_blank" rel="noopener">为什么size_t重要</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>duktape</title>
    <url>/2017/08/01/duktape/</url>
    <content><![CDATA[<p>Duktape是一个可嵌入的Javascript引擎，主要关注便携性和精简及紧凑性。</p>
<p>Duktape很容易集成到C/C++项目： 添加duktape.c和duktape.h到您的build中，并使用Duktape API从C代码中，调用ECMAScript代码的功能，反之亦然。</p>
<p>Movian使用Duktape作为Javascript引擎。</p>
<a id="more"></a>

<h2 id="Programming-model"><a href="#Programming-model" class="headerlink" title="Programming model"></a>Programming model</h2><p>Create a Duktape <strong>heap</strong> (a garbage collection region) and an initial <strong>context</strong> (essentially a thread handle) in your program.</p>
<h3 id="Heap-and-context"><a href="#Heap-and-context" class="headerlink" title="Heap and context"></a>Heap and context</h3><p>A Duktape heap is a single region for garbage collection. A heap is used to allocate storage for strings, Ecmascript objects, and other variable size, garbage collected data. Objects in the heap have an internal heap header which provides the necessary information for reference counting, mark-and-sweep garbage collection, object finalization, etc. Heap objects can reference each other, creating a reachability graph from a garbage collection perspective. For instance, the properties of an Ecmascript object reference both the keys and values of the object’s property set. You can have multiple heaps, but objects in different heaps cannot reference each other directly; you need to use serialization to pass values between heaps.</p>
<p>A Duktape context is an Ecmascript “thread of execution” which lives in a certain Duktape heap. A context is represented by a duk_context * in the Duktape API, and is associated with an internal Duktape coroutine (a form of a co-operative thread). Each context is also associated with an environment consisting of global objects; contexts may share the same global environment but can also have different environments. The context handle is given to almost every Duktape API call, and allows the caller to interact with the value stack of the Duktape coroutine: values can be inserted and queries, functions can be called, and so on.</p>
<p><strong>A Duktape heap</strong></p>
<pre><code>duk_context * ec-&gt;ec_duk
ec-&gt;ec_duk = duk_create_heap(es_mem_alloc, es_mem_realloc, es_mem_free, ec, NULL);

duk_set_top(ec-&gt;ec_duk, 0);
if (do_gc) duk_gc(ec-&gt;ec_duk, 0);
duk_destroy_heap(ec-&gt;ec_duk);
ec-&gt;ec_duk = NULL;</code></pre><p><strong>A Duktape context</strong></p>
<pre><code>duk_context *ctx = ec-&gt;ec_duk;
duk_push_global_stash(ctx);
duk_push_object(ctx);
duk_put_prop_string(ctx, -2, &quot;roots&quot;);
duk_push_global_object(ctx);</code></pre><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><pre><code>int obj_idx = duk_push_object(ctx);

duk_push_int(ctx, 42);
duk_put_prop_string(ctx, obj_idx, &quot;meaningOfLife&quot;);
/* object is now: { &quot;meaningOfLife&quot;: 42 } */

duk_push_string(ctx, &quot;v2.0&quot;);
duk_put_prop_string(ctx, obj_idx, &quot;currentVersionString&quot;);
/* object is now: { &quot;currentVersionString&quot;: &quot;v2.0&quot; } */


duk_pop(ctx);  /* pop object */</code></pre><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><pre><code>const duk_function_list_entry my_module_funcs[] = {
    { &quot;tweak&quot;, do_tweak, 0 /* no args */ },
    { &quot;adjust&quot;, do_adjust, 3 /* 3 args */ },
    { &quot;frobnicate&quot;, do_frobnicate, DUK_VARARGS /* variable args */ },
    { NULL, NULL, 0 }
};

/* Initialize an object with a set of function properties, and set it to
 * global object &#39;MyModule&#39;.
 */

duk_push_global_object(ctx);
duk_push_object(ctx);  /* -&gt; [ ... global obj ] */
duk_put_function_list(ctx, -1, my_module_funcs);
duk_put_prop_string(ctx, -2, &quot;MyModule&quot;);  /* -&gt; [ ... global ] */
duk_pop(ctx);


/*
* In Javascript
*/
MyModule.tweak();
MyModule.adjust(a, b, c);</code></pre><h3 id="duk-push-c-function"><a href="#duk-push-c-function" class="headerlink" title="duk_push_c_function()"></a>duk_push_c_function()</h3><pre><code>duk_ret_t my_addtwo(duk_context *ctx) {
    double a, b;

    /* Here one can expect that duk_get_top(ctx) == 2, because nargs
     * for duk_push_c_function() is 2.
     */

    a = duk_get_number(ctx, 0);
    b = duk_get_number(ctx, 1);
    duk_push_number(ctx, a + b);
    return 1;   /*  1 = return value at top
                 *  0 = return &#39;undefined&#39;
                 * &lt;0 = throw error (use DUK_RET_xxx constants)
                 */
}

void test(void) {
    duk_idx_t func_idx;

    func_idx = duk_push_c_function(ctx, my_addtwo, 2);
    duk_push_int(ctx, 2);
    duk_push_int(ctx, 3);  /* -&gt; [ ... func 2 3 ] */
    duk_call(ctx, 2);      /* -&gt; [ ... res ] */
    printf(&quot;2+3 is %ld\n&quot;, (long) duk_get_int(ctx, -1));
    duk_pop(ctx);
}</code></pre><h3 id="duk-push-lstring"><a href="#duk-push-lstring" class="headerlink" title="duk_push_lstring"></a>duk_push_lstring</h3><pre><code>const char tmp1[5] = { &#39;f&#39;, &#39;\0&#39;, &#39;\0&#39;, &#39;x&#39;, &#39;y&#39; };
const char tmp2[1] = { &#39;\0&#39; };

duk_push_lstring(ctx, tmp1, 5);   /* push the string &quot;f\x00\x00xy&quot; */
duk_push_lstring(ctx, tmp2, 1);   /* push the string &quot;\x00&quot; */
duk_push_lstring(ctx, tmp2, 0);   /* push empty string */
duk_push_lstring(ctx, NULL, 0);   /* push empty string */
duk_push_lstring(ctx, NULL, 10);  /* push empty string */</code></pre><h3 id="duk-is-object"><a href="#duk-is-object" class="headerlink" title="duk_is_object"></a>duk_is_object</h3><p>Returns 1 if value at idx is an object, otherwise returns 0. If idx is invalid, also returns 0.</p>
<p><code>duk_bool_t duk_is_object(duk_context *ctx, duk_idx_t idx)</code></p>
<h3 id="duk-get-prop-string"><a href="#duk-get-prop-string" class="headerlink" title="duk_get_prop_string"></a><a href="http://duktape.org/api.html#duk_get_prop_string" target="_blank" rel="noopener">duk_get_prop_string</a></h3><pre><code>int es_prop_to_int(duk_context *ctx, int obj_idx, const char *id, int def)
{
    if (!duk_is_object(ctx, obj_idx)) return def;

    duk_get_prop_string(ctx, obj_idx, id);
    if (duk_is_number(ctx, -1)) def = duk_to_int(ctx, -1);
    duk_pop(ctx);
    return def;
}

rstr_t * es_prop_to_rstr(duk_context *ctx, int obj_idx, const char *id)
{
    rstr_t *r = NULL;

    if(!duk_is_object(ctx, obj_idx)) return NULL;

    duk_get_prop_string(ctx, obj_idx, id);
    const char *str = duk_get_string(ctx, -1);
    if(str != NULL) r = rstr_alloc(str);
    duk_pop(ctx);
    return r;
}</code></pre><h3 id="duk-to-boolean"><a href="#duk-to-boolean" class="headerlink" title="duk_to_boolean"></a><a href="http://duktape.org/api.html#duk_to_boolean" target="_blank" rel="noopener">duk_to_boolean</a></h3><p><code>duk_bool_t duk_to_boolean(duk_context *ctx, duk_idx_t idx)</code></p>
<p>Replace the value at idx with an Ecmascript <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.2" target="_blank" rel="noopener">ToBoolean()</a> coerced value. Returns 1 if the result of the coercion true, 0 otherwise. If idx is invalid, throws an error.</p>
<h3 id="duk-dup"><a href="#duk-dup" class="headerlink" title="duk_dup"></a><a href="http://duktape.org/api.html#duk_dup" target="_blank" rel="noopener">duk_dup</a></h3><pre><code>void es_dumpstack(duk_context *ctx)
{
  int size = duk_get_top(ctx);
  printf(&quot;STACKDUMP\n&quot;);
  for(int i = -1; i &gt; -1 - size; i--) {
    duk_dup(ctx, i);
    printf(&quot;  [%5d]: %s\n&quot;, i, duk_safe_to_string(ctx, -1));
    duk_pop(ctx);
  }
}</code></pre><ul>
<li><a href="http://duktape.org/api.html#duk_get_top" target="_blank" rel="noopener">duk_get_top</a> Get current stack top</li>
<li><a href="http://duktape.org/api.html#duk_dup" target="_blank" rel="noopener">duk_dup</a> Push a duplicate of value at from_idx to the stack</li>
<li><a href="http://duktape.org/api.html#duk_pop" target="_blank" rel="noopener">duk_pop</a> Pop one element off the stack</li>
</ul>
<p>上述函数将<code>stack</code>中所有元素打印出来，并清空<code>stack</code></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>int ecmascript_plugin_load(const char *id, const char *url,
                       char *errbuf, size_t errlen,
                       int version, const char *manifest,
                       int flags)
{
  char storage[PATH_MAX];

  snprintf(storage, sizeof(storage), &quot;%s/plugins/%s&quot;, gconf.persistent_path, id);

  es_context_t *ec = es_context_create(id, flags | ECMASCRIPT_PLUGIN, url, storage);
//TRACE(TRACE_ERROR, &quot;[load]&quot;, &quot;[%s] %s [%s]\n&quot;, id, url, manifest);
  es_context_begin(ec);

  duk_context *ctx = ec-&gt;ec_duk;

  duk_push_global_object(ctx);

  int plugin_obj_idx = duk_push_object(ctx);

  duk_push_string(ctx, id);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;id&quot;);

  duk_push_string(ctx, url);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;url&quot;);

  duk_push_string(ctx, manifest);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;manifest&quot;);

  duk_push_int(ctx, version);
  duk_put_prop_string(ctx, plugin_obj_idx, &quot;apiversion&quot;);

//TRACE(TRACE_ERROR, &quot;[ec_path]&quot;, &quot;%s\n&quot;, ec-&gt;ec_path);
  if(ec-&gt;ec_path) 
  {
    duk_push_string(ctx, ec-&gt;ec_path);
    duk_put_prop_string(ctx, plugin_obj_idx, &quot;path&quot;);
  }

  duk_put_prop_string(ctx, -2, &quot;Plugin&quot;);
  duk_pop(ctx);

  if(version == 1)
  {
    int64_t ts0 = arch_get_ts();

    if(es_load_and_compile(ec, &quot;dataroot://res/ecmascript/legacy/api-v1.js&quot;))
      goto bad;

    int64_t ts1 = arch_get_ts();

    if(duk_pcall(ctx, 0)) 
    {
      es_dump_err(ctx);
      goto bad;
    }

    int64_t ts2 = arch_get_ts();

    if(es_load_and_compile(ec, url)) 
    {
      duk_pop(ctx);
      goto bad;
    }

    int64_t ts3 = arch_get_ts();

    duk_swap_top(ctx, 0);
    if(duk_pcall_method(ctx, 0))
      es_dump_err(ctx);

    int64_t ts4 = arch_get_ts();

    es_debug(ec, &quot;API v1 emulation: Compile:%dms Exec:%dms&quot;,
             ((int)(ts1 - ts0)) / 1000,
             ((int)(ts2 - ts1)) / 1000);

    es_debug(ec, &quot;Plugin main:      Compile:%dms Exec:%dms&quot;,
             ((int)(ts3 - ts2)) / 1000,
             ((int)(ts4 - ts3)) / 1000);
  }
  else
  {
    es_exec(ec, url);
  }

bad:
  es_context_end(ec, 1);
  es_context_release(ec);

  return 0;
}</code></pre><p>Javascript中相关代码</p>
<pre><code>var plugin = {

  createService: function(title, url, type, enabled, icon) {
    return require(&#39;movian/service&#39;).create(title, url, type, enabled, icon);
  },

  createStore: function(name) {
    return require(&#39;movian/store&#39;).create(name);
  },

  addURI: function(re, callback) {
    var page = require(&#39;movian/page&#39;);
    return new page.Route(re, callback);
  },

  addSearcher: function(title, icon, cb) {
    var page = require(&#39;movian/page&#39;);
    return new page.Searcher(title, icon,cb);
  },

  //get from c source code
  path: Plugin.path,

  getDescriptor: function() {
    if(this.descriptor === undefined)
      this.descriptor = JSON.parse(Plugin.manifest);

    return this.descriptor;
  },

  getAuthCredentials: popup.getAuthCredentials,

  addHTTPAuth: require(&#39;native/io&#39;).httpInspectorCreate,

  copyFile: require(&#39;native/fs&#39;).copyfile,
  selectView: misc.selectView,

  createSettings: function(title, icon, description) {
    var settings = require(&#39;movian/settings&#39;);
    return new settings.globalSettings(Plugin.id, title, icon, description);
  },

  cachePut: function(stash, key, obj, maxage) {
    misc.cachePut(&#39;plugin/&#39; + Plugin.id + &#39;/&#39; + stash,
                      key, JSON.stringify(obj), maxage);
  },

  cacheGet: function(stash, key) {
    var v = misc.cacheGet(&#39;plugin/&#39; + Plugin.id + &#39;/&#39; + stash, key);
    return v ? JSON.parse(v) : null;
  },

  config: {},

  properties: prop.global.plugin[Plugin.id],

  addItemHook: function(conf) {
    require(&#39;movian/itemhook&#39;).create(conf);
  },

  addSubtitleProvider: function(fn) {
    require(&#39;native/subtitle&#39;).addProvider(function(root, query, basescore, autosel) {
      var req = Object.create(query);
      req.addSubtitle = function(url, title, language, format,
                                 source, score) {
        require(&#39;native/subtitle&#39;).addItem(root, url, title, language, format, source,
                                 basescore + score, autosel);
      }
      fn(req);
    }, Plugin.id, Plugin.id);
  }

};</code></pre><h2 id="es-modules"><a href="#es-modules" class="headerlink" title="es_modules"></a>es_modules</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://ourjs.com/detail/548a73b58a34fa3204000005" target="_blank" rel="noopener">Duktape：一个新的小巧的超精简可嵌入式JavaScript引擎</a></li>
<li><a href="http://wiki.duktape.org/Home.html" target="_blank" rel="noopener">Duktape Wiki</a></li>
<li><a href="http://duktape.org/guide.html" target="_blank" rel="noopener">Duktape Programmer’s Guide</a></li>
<li><a href="http://duktape.org/api.html#duk_push_global_stash" target="_blank" rel="noopener">Duktape API</a></li>
<li><a href="https://github.com/andoma/movian" target="_blank" rel="noopener">Movian</a></li>
</ol>
]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>duktape</tag>
      </tags>
  </entry>
  <entry>
    <title>system-shell</title>
    <url>/2017/08/01/system-shell/</url>
    <content><![CDATA[<ul>
<li>fork</li>
<li>waitpid</li>
<li>execl</li>
</ul>
<a id="more"></a>

<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>一个进程，包括代码、数据和分配给进程的资源。<code>fork</code> 函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p>
<p>一个进程调用 <code>fork</code> 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<p>当执行 <code>fork</code> 函数后，会生成一个子进程，子进程的执行从 <code>fork</code> 的返回值开始且代码继续往下执行。</p>
<p>所以 <code>fork</code> 执行一次后会有两次返回值：第一次为原来的进程，即父进程会有一次返回值，表示新生成的子进程的进程ID；第二次为子进程的起始执行，返回值为0。如果返回值为-1，则表示创建子进程失败，可能通过 <code>errno</code> 定位失败原因。</p>
<p>示例代码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
int main (int argc, char ** argv)
{
    int flag = 0;
    pid_t pId = fork();
    if (pId == -1) {
        perror(&quot;fork error&quot;);
        exit(EXIT_FAILURE);
    } else if (pId == 0) {
        int myPid = getpid();
        int parentPid = getppid();

        printf(&quot;Child:SelfID=%d ParentID=%d \n&quot;, myPid, parentPid);
        flag = 123;
        printf(&quot;Child:flag=%d %p \n&quot;, flag, &amp;flag);
        int count = 0;
        do{
            count ++;
            sleep(1);
            printf(&quot;Child count=%d \n&quot;, count);
            if (count &gt;= 5) {
                break;
            }
        }while (1);
        return EXIT_SUCCESS;
    } else {
        printf(&quot;Parent:SelfID=%d MyChildPID=%d \n&quot;, getpid(), pId);
        flag = 456;
        printf(&quot;Parent:flag=%d %p \n&quot;, flag, &amp;flag); // 连地址都一样,说明是真的完全拷贝,但值已经是不同的了..
        int count = 0;
        do{
            count ++;
            sleep(1);
            printf(&quot;Parent count=%d \n&quot;, count);
            if (count &gt;= 2) {
                break;
            }
        }while (1);
    }

    return EXIT_SUCCESS;
}</code></pre>
<p>以上代码中，使用 <code>fork</code> 创建了一个子进程。返回值 <code>pId</code> 有两个作用：一是判断 <code>fork</code>是否正常执行；二是判断 <code>fork</code> 正常执行后如何区分父子进程。</p>
<p>在父子进程中，都各自打印出自己的进程ID及父/子进程ID。</p>
<p>通过flag的值可以验证创建的子进程是完全复制父进程的堆栈段(因为flag是在main()方法内声明的)的，两个进程都输出了flag=0的信息。接下来进程可以各自对flag再次更新值，做到了互不干扰。但从打印的int指针地址来看，指针地址值都是一样的，再次印证了子进程是对父进程的完全复制。</p>
<p>接下来，父进程只执行了两次打印，然后就结束且进程销毁退出了；但父进程的结束并不影响子进程的运行，子进程一直打印到数字5才正常退出。所以验证了 <code>fork</code> 出来的进程是各自独立的，完全按照自己的代码逻辑运行直至执行完毕。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>父进程监听子进程状态 <code>wait</code> 的使用</p>
<h3 id="wait能力介绍"><a href="#wait能力介绍" class="headerlink" title="wait能力介绍"></a>wait能力介绍</h3><p>创建子进程后，父进程具有监听子进程的运行状态的能力，用到的函数为：</p>
<pre><code>#include &lt;sys/wait.h&gt;

pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);</code></pre><p>以上函数用于等待子进程子进程的状态变化回调并且获取状态变化信息。所能获取到的状态变化包括：子进程运行结束、子进程被信号量暂停、子进程被信号量恢复运行。</p>
<p>父进程执行了wait函数后，如果子进程已经发生了状态变化，则wait函数立即就会有返回结果；否则wait函数会一直阻塞直至子进程状态发生变化。</p>
<p>通常意义上，如果子进程已经发生了状态变化，但还未被父进程或其它系统回调执行wait，则把此时的子进程称为是可等待的(waitable)。</p>
<p>子进程运行结束后，父进行执行wait函数可以推动系统释放与子进程相关的资源；否则子进程将会被维持在僵尸进程的状态下一直存在。 　　</p>
<h3 id="wait函数讲解"><a href="#wait函数讲解" class="headerlink" title="wait函数讲解"></a>wait函数讲解</h3><p>函数 <code>wait(int * status)</code> 是对 <code>waitpid</code> 的封装，限定了只有在任一子进程运行结束时才会有返回，否则调用进程会一起处于阻塞状态暂停执行。</p>
<p><code>wait(int * status)</code> 等同于如下代码：</p>
<pre><code>waitpid(-1, &amp;status, 0);</code></pre><p><code>waitpid()</code> 会阻塞调用进程直至任一子进程的运行状态发生变化。接下来对 <code>waitpid()</code> 的三个参数进行讲解： 　　</p>
<p><strong>PID</strong></p>
<ul>
<li>pid &lt; -1取该pid的绝对值，如果任意子进程的进程组ID等于该绝对值，则该组进程中任一子进程中的进程状态发生变化都会触发waitpid()的回调。</li>
<li>pid == -1监听范围扩大到任意子进程。</li>
<li>pid == 0监听限制为子进程的进程组ID与父进程相等。</li>
<li>pid &gt; 0监听限制为指定子进程进程ID值。</li>
</ul>
<p><strong>STATUS</strong></p>
<p>值可以为NULL。当不为NULL时，用于存储触发状态变化的信息号值和exit(code)中的code值。<br>wait.h头文件定义了几个宏用于解析status的值，常见的有：</p>
<ul>
<li>WIFEXITED(status) 当子进程调用exit(code)或_exit(code)或正常运行到main()函数结尾时正常结束运行，则返回true</li>
<li>WEXITSTATUS(status) 当WIFEXITED(status)为true时，获取exit(code)或_exit(code)的code值。其中code只能为0或正数，不支持负数。</li>
<li>WIFSIGNALED(status) 当子进程被信号量杀死时则返回true</li>
<li>WTERMSIG(status)  当WIFSIGNALED(status)为true时，获取该信号量的值</li>
<li>WIFSTOPPED(status) 当子进程被信号量暂停执行时则返回true</li>
<li>WSTOPSIG(status) 当WIFSTOPPED(status)为true时，获取该信号量的值</li>
</ul>
<p><strong>Options</strong></p>
<p>值可以是以下常量的任意值或任意常量与0的OR计算值</p>
<ul>
<li>WNOHANG 调用wait时指定的pid仍未结束运行，则wait立即返回0。waitpid将不阻塞如果指定的pid并未结束</li>
<li>WUNTRACED 当子进程被暂停时，则wait立即返回子进程的pid。</li>
<li>WCONTINUED  当被暂停的子进程又被信号量恢复后，则wait立即返回子进程的pid</li>
</ul>
<p><code>wait()</code> 函数在正常执行时会返回被终止进程的pid值，当执行发生错误后会返回-1。</p>
<p><code>waitpid()</code> 函数在正常执行时会返回进程状态发生变化的进程pid值；如果函数 <code>options</code> 中包含了 <code>WNOHANG</code> 常量，则会在指定pid的子进程未退出且进程状态也未发生变化时直接返回0，如果子进程已经退出了，则返回子进程的pid；否则当执行发生错误后会返回-1。</p>
<h2 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h2><p><code>exec</code> 系列函数包括</p>
<pre><code>#include &lt;unistd.h&gt;

extern char **environ;

int execl(const char *path, const char *arg, ...
                /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
                /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
                char *const envp[]);</code></pre><ul>
<li>带 <code>l</code> 的exec函数：execl,execlp,execle，表示后边的参数以可变参数的形式给出且都以一个空指针结束</li>
<li>带 <code>p</code> 的exec函数：execlp,execvp，表示第一个参数path不用输入完整路径，只有给出命令名即可，它会在环境变量PATH当中查找命令</li>
<li>不带 <code>l</code> 的exec函数：execv,execvp表示命令所需的参数以 <code>char *arg[]</code> 形式给出且arg最后一个元素必须 是NULL</li>
<li>带 <code>e</code> 的exec函数：execle表示，将环境变量传递给需要替换的进程</li>
</ul>
<p>例如：</p>
<pre><code>execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);

char *argv[] = {&quot;ls&quot;,&quot;-l&quot;,NULL};
ret = execvp(&quot;ls&quot;,argv);</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>if((pid = fork()) &lt; 0){
    return -1;
}
else if(0 == pid){
    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, cmd, NULL);
    exit(127);
}
else {
    while(waitpid(pid, &amp;status, WNOHANG) == 0){
        //执行脚本未结束，执行一些中间处理
        usleep(10000);
    }

    //脚本执行完成
    //do finish
}</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mdev</title>
    <url>/2017/07/28/mdev/</url>
    <content><![CDATA[<p><code>mdev</code> 是 <code>busybox</code> 自带的一个简化版的udev，适合于嵌入式的应用埸合。其具有使用简单的特点。它的作用，就是在系统启动和热插拔或动态加载驱动程序时，自动产生驱动程序所需的节点文件。在以busybox为基础构建嵌入式linux的根文件系统时，使用它是最优的选择。</p>
<p><code>mdev</code> 的使用可以参看 <code>busybox</code> 中的 <code>mdev.txt</code> 文档</p>
<a id="more"></a>

<h2 id="mdev使用"><a href="#mdev使用" class="headerlink" title="mdev使用"></a>mdev使用</h2><h3 id="busybox-对-mdev-支持"><a href="#busybox-对-mdev-支持" class="headerlink" title="busybox 对 mdev 支持"></a>busybox 对 mdev 支持</h3><pre><code>Linux System Utilities  ---&gt;
    [*] mdev
    [*]   Support /etc/mdev.conf
    [*]     Support command execution at device addition/removal</code></pre><h3 id="mdev-用法"><a href="#mdev-用法" class="headerlink" title="mdev 用法"></a>mdev 用法</h3><p>Mdev has two primary uses: initial population and dynamic updates. Both require sysfs support in the kernel and have it mounted at /sys. For dynamic updates, you also need to have hotplugging enabled in your kernel.</p>
<p><strong>Here’s a typical code snippet from the init script:</strong></p>
<pre><code>[0] mount -t proc proc /proc
[1] mount -t sysfs sysfs /sys
[2] echo /sbin/mdev &gt; /proc/sys/kernel/hotplug
[3] mdev -s</code></pre><p><strong>Alternatively, without procfs the above becomes:</strong></p>
<pre><code>[1] mount -t sysfs sysfs /sys
[2] sysctl -w kernel.hotplug=/sbin/mdev
[3] mdev -s</code></pre><p><strong>Of course, a more “full” setup would entail executing this before the previous code snippet:</strong></p>
<pre><code>[4] mount -t tmpfs -o size=64k,mode=0755 tmpfs /dev
[5] mkdir /dev/pts
[6] mount -t devpts devpts /dev/pts</code></pre><blockquote>
<p>The simple explanation here is that [1] you need to have /sys mounted before executing mdev. Then you [2] instruct the kernel to execute /sbin/mdev whenever a device is added or removed so that the device node can be created or destroyed.  Then you [3] seed /dev with all the device nodes that were created while the system was booting.</p>
</blockquote>
<blockquote>
<p>For the “full” setup, you want to [4] make sure /dev is a tmpfs filesystem (assuming you’re running out of flash).  Then you want to [5] create the /dev/pts mount point and finally [6] mount the devpts filesystem on it.</p>
</blockquote>
<h3 id="mdev-conf"><a href="#mdev-conf" class="headerlink" title="mdev.conf"></a>mdev.conf</h3><p><code>/etc/mdev.conf</code> 配置文件，属于可选项</p>
<pre><code>格式: &lt;device regex&gt; &lt;uid&gt;:&lt;gid&gt; &lt;octal permissions&gt;  [&lt;@|$|*&gt; &lt;command&gt;]
@ 创建了设备之后运行
$ 删除设备之前运行
* 在创建设备之后和删除设备之前运行</code></pre><p>example</p>
<pre><code>sd.* 0:0 0600 */etc/add_remove_log.sh
mmcblk([0-9]+) root:disk 660 &gt;disk/mmc/%1/0</code></pre><h2 id="mdev-s"><a href="#mdev-s" class="headerlink" title="mdev -s"></a>mdev -s</h2><p><code>mdev --help</code></p>
<pre><code>mdev -s is to be run during boot to scan /sys and populate /dev.</code></pre><p>以 <code>-s</code> 参数调用 <code>mdev</code>，扫描 <code>/sys/class</code> 和 <code>/sys/block</code> 中所有的类设备目录，如果在目录中含有名为 <code>dev</code> 的文件，且文件中包含设备号，则 <code>mdev</code> 利用这些信息为这个设备在 <code>/dev</code> 下创建设备节点文件，一般只在启动时执行一次 <code>mdev -s</code></p>
<h3 id="Hotplug"><a href="#Hotplug" class="headerlink" title="Hotplug"></a>Hotplug</h3><p>由于启动时运行了命令 <code>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</code>，那么当有热插拔事件产生时，内核就会调用 <code>mdev</code>。这时 <code>mdev</code> 通过环境变量中的 <code>ACTION</code> 和<code>DEVPATH</code>，（这两个变量是系统自带的）来确定此次热插拔事件的动作以及影响了<code>/sys</code>中的那个目录。接着会看看这个目录中是否有 <code>dev</code> 的属性文件，如果有就利用这些信息为这个设备在 <code>/dev</code> 下创建设备节点文件。</p>
<h2 id="驱动中增加对类设备接口支持"><a href="#驱动中增加对类设备接口支持" class="headerlink" title="驱动中增加对类设备接口支持"></a>驱动中增加对类设备接口支持</h2><p>在驱动程序的初始化函数中，使用以下类似的语句，就能在类设备目录下 <code>/sys/class</code> 添加包含设备号的名为 <code>dev</code> 的属性文件，并通过 <code>mdev</code> 在 <code>/dev</code> 下生成设备节点文件。</p>
<pre><code>include/linux/device.h

#define device_create_drvdata   device_create

//一个struct class结构体类型变量对应一个类
static struct class *mtd_class;

//create your own class under /sysfs
mtd_class = class_create(THIS_MODULE, &quot;mtd&quot;);
//register your own device in sysfs, and this will cause udev to create corresponding device node
device_creat e_drvdata(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd-&gt;index*2), NULL, &quot;mtd%d&quot;, mtd-&gt;index);

//delete device node under /dev
device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd-&gt;index*2));
//delete class created by us
class_destroy(my_class);</code></pre><p>这部分代码适用与字符设备。在2.6较早的内核版本中，<code>device_create</code> 函数名称不同，是 <code>class_device_create</code></p>
<h3 id="misc-设备"><a href="#misc-设备" class="headerlink" title="misc 设备"></a>misc 设备</h3><p><code>misc</code> 设备是主设备号为<code>10</code> 的字符设备，使用的注册函数为</p>
<pre><code>&lt;linux/miscdevice.h&gt;

static struct miscdevice flash_otp_miscdev =
{
    .minor = MISC_OTP_MINOR,
    .name  = &quot;flash_otp&quot;,
    .fops  = &amp;flash_otp_fops,
};

err = misc_register(&amp;flash_otp_miscdev);
if (err) {
    printk(&quot;flash otp probe: failed to register misc device\n&quot;);
    kfree(info);
    err = -EINVAL;
}

int misc_deregister(struct miscdevice *misc);</code></pre><p><code>misc</code> 是特殊的字符设备。注册驱动程序时采用 <code>misc_register</code> 函数注册，此函数中会自动创建设备节点，即设备节点文件，原因是 <code>misc_register</code> 会调用 <code>device_create</code></p>
<pre><code>int misc_register(struct miscdevice * misc)
{
    struct miscdevice *c;
    dev_t dev;
    int err = 0;

    INIT_LIST_HEAD(&amp;misc-&gt;list);  //链表项使用时必须初始化

    mutex_lock(&amp;misc_mtx);
    list_for_each_entry(c, &amp;misc_list, list) {
        if (c-&gt;minor == misc-&gt;minor) {
            mutex_unlock(&amp;misc_mtx);
            return -EBUSY;
        }
    } //遍历链表如果发现次设备号一样的，返回错误

    if (misc-&gt;minor == MISC_DYNAMIC_MINOR) {  //动态次设备号
        int i = DYNAMIC_MINORS;
        while (--i &gt;= 0)
            if ( (misc_minors[i&gt;&gt;3] &amp; (1 &lt;&lt; (i&amp;7))) == 0)
                break;
        if (i&lt;0) {
            mutex_unlock(&amp;misc_mtx);
            return -EBUSY;
        }
        misc-&gt;minor = i;
    }

    if (misc-&gt;minor &lt; DYNAMIC_MINORS)
        misc_minors[misc-&gt;minor &gt;&gt; 3] |= 1 &lt;&lt; (misc-&gt;minor &amp; 7);
    dev = MKDEV(MISC_MAJOR, misc-&gt;minor);

    //misc_class 在 misc_init 函数中创建
    misc-&gt;this_device = device_create(misc_class, misc-&gt;parent, dev,
                        misc, &quot;%s&quot;, misc-&gt;name);
    //udev创建设备节点使用，linux设备模型相关
    if (IS_ERR(misc-&gt;this_device)) {
        err = PTR_ERR(misc-&gt;this_device);
        goto out;
    }

    /*
    * Add it to the front, so that later devices can &quot;override&quot;
    * earlier defaults
    */
    list_add(&amp;misc-&gt;list, &amp;misc_list); //添加到misc_list之中
    out:
    mutex_unlock(&amp;misc_mtx);
    return err;
}</code></pre><blockquote>
<p>杂项设备作为字符设备的封装，为字符设备提供的简单的编程接口，如果编写新的字符驱动，可以考虑使用杂项设备接口，方便简单，只需要初始化一个miscdevice的结构，调用misc_register就可以了。</p>
</blockquote>
<h3 id="block-设备节点文件"><a href="#block-设备节点文件" class="headerlink" title="block 设备节点文件"></a>block 设备节点文件</h3><p><code>mtdblock</code> 文件流程</p>
<pre><code>static struct mtd_blktrans_ops mtdblock_tr = {
    .name       = &quot;mtdblock&quot;,
    .major      = 31,
    .part_bits  = 0,
    .blksize    = 512,
    .open       = mtdblock_open,
    .flush      = mtdblock_flush,
    .release    = mtdblock_release,
    .readsect   = mtdblock_readsect,
    .writesect  = mtdblock_writesect,
    .add_mtd    = mtdblock_add_mtd,
    .remove_dev = mtdblock_remove_dev,
    .owner      = THIS_MODULE,
};

static int __init init_mtdblock(void)
{
    return register_mtd_blktrans(&amp;mtdblock_tr);
}

static void __exit cleanup_mtdblock(void)
{
    deregister_mtd_blktrans(&amp;mtdblock_tr);
}

module_init(init_mtdblock);
module_exit(cleanup_mtdblock);</code></pre><p><code>mtdblock_add_mtd</code> -&gt; <code>add_mtd_blktrans_dev</code> -&gt; <code>add_disk</code> -&gt; <code>register_disk</code><br>-&gt; <code>device_add</code> -&gt; <code>device_create_file</code> -&gt; <code>sysfs_create_file</code></p>
<p><code>loop</code> 流程</p>
<pre><code>static int __init loop_init(void)
{
    int i, nr;
    unsigned long range;
    struct loop_device *lo, *next;

    /*
     * loop module now has a feature to instantiate underlying device
     * structure on-demand, provided that there is an access dev node.
     * However, this will not work well with user space tool that doesn&#39;t
     * know about such &quot;feature&quot;.  In order to not break any existing
     * tool, we do the following:
     *
     * (1) if max_loop is specified, create that many upfront, and this
     *     also becomes a hard limit.
     * (2) if max_loop is not specified, create 8 loop device on module
     *     load, user can further extend loop device by create dev node
     *     themselves and have kernel automatically instantiate actual
     *     device on-demand.
     */

    part_shift = 0;
    if (max_part &gt; 0)
        part_shift = fls(max_part);

    if (max_loop &gt; 1UL &lt;&lt; (MINORBITS - part_shift))
        return -EINVAL;

   if (max_loop) {
        nr = max_loop;
        range = max_loop;
    } else {
        nr = 8;
        range = 1UL &lt;&lt; (MINORBITS - part_shift);
    }

    if (register_blkdev(LOOP_MAJOR, &quot;loop&quot;))
        return -EIO;

    for (i = 0; i &lt; nr; i++) {
        lo = loop_alloc(i);
        if (!lo)
            goto Enomem;
        list_add_tail(&amp;lo-&gt;lo_list, &amp;loop_devices);
    }

    /* point of no return */

    list_for_each_entry(lo, &amp;loop_devices, lo_list)
        add_disk(lo-&gt;lo_disk);

    blk_register_region(MKDEV(LOOP_MAJOR, 0), range,
                  THIS_MODULE, loop_probe, NULL, NULL);

    printk(KERN_INFO &quot;loop: module loaded\n&quot;);
    return 0;

Enomem:
    printk(KERN_INFO &quot;loop: out of memory\n&quot;);

    list_for_each_entry_safe(lo, next, &amp;loop_devices, lo_list)
        loop_free(lo);

    unregister_blkdev(LOOP_MAJOR, &quot;loop&quot;);
    return -ENOMEM;
}

module_init(loop_init);</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://erwinchang.github.io/2017/01/18/mdev/" target="_blank" rel="noopener">mdev</a></li>
<li><a href="http://blog.csdn.net/hugerat/article/details/3437099" target="_blank" rel="noopener">mdev的使用方法和原理</a></li>
<li><a href="http://www.embeddedlinux.org.cn/ldd3note/_173.htm" target="_blank" rel="noopener">mdev使用</a></li>
<li><a href="http://www.cnblogs.com/hnrainll/archive/2011/06/25/2090182.html" target="_blank" rel="noopener">mdev的使用以及mdev.conf的规则配置–busybox</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>circular-linked-lists</title>
    <url>/2017/07/25/circular-linked-lists/</url>
    <content><![CDATA[<p>链表存在以下几种形式</p>
<ul>
<li>单向</li>
<li>双向(doubly)</li>
<li>线性(linear)</li>
<li>循环(circular)</li>
<li>有头</li>
<li>无头(without header node)</li>
</ul>
<p>Linux Kernel <code>include/linux/list.h</code></p>
<a id="more"></a>


<p>a linear list</p>
<pre><code>list --&gt; [info | next] --&gt; [info | next] --&gt; [info | next] --&gt; [info | NULL]</code></pre><p>a circular list with header node</p>
<pre><code>    Header Node       First Node                                            Last Node
--&gt; [NULL | next] --&gt; [info | next] --&gt; [info | next] --&gt; [info | next] --&gt; [info | next]--+
|                                                                                          |
+------------------------------------------------------------------------------------------+</code></pre><h2 id="with-or-without-header-node"><a href="#with-or-without-header-node" class="headerlink" title="with or without header node"></a>with or without header node</h2><p>主要区别在于双向链表的结构体设计，是否需要存在一个不带有有效负载，只有链表控制信息的头节点，例如：</p>
<h3 id="with-header-node"><a href="#with-header-node" class="headerlink" title="with header node"></a>with header node</h3><pre><code>struct gxlist_head
{
    struct gxlist_head *next, *prev;
};

struct _hot_device {
    int                     id;
    int                     active;
    GxFsActionType          action;
    struct gxlist_head      head;
    int                     hot;
    GxHotplugError          error;
    void *priv;
};

#define GX_LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }

#define GX_LIST_HEAD(name) \
     struct gxlist_head name = GX_LIST_HEAD_INIT(name)

GX_LIST_HEAD(__device_list); //双向循环链表的头节点，整个链表通过这个节点进行管理

struct _hot_device *dev = NULL;

gxlist_add(&amp;dev-&gt;head, &amp;__device_list);</code></pre><h3 id="without-header-node"><a href="#without-header-node" class="headerlink" title="without header node"></a>without header node</h3><pre><code>struct gxlist_head
{
    struct gxlist_head *next, *prev;
};

struct _hot_device {
    int                     id;
    int                     active;
    GxFsActionType          action;
    struct gxlist_head      head;
    int                     hot;
    GxHotplugError          error;
    void *priv;
};

#define GX_LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }

#define GX_LIST_HEAD(name) struct gxlist_head name = GX_LIST_HEAD_INIT(name)</code></pre><h2 id="有头双向循环链表"><a href="#有头双向循环链表" class="headerlink" title="有头双向循环链表"></a>有头双向循环链表</h2><h2 id="无头双向循环链表"><a href="#无头双向循环链表" class="headerlink" title="无头双向循环链表"></a>无头双向循环链表</h2><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><p><strong>链表的设计</strong>，next 和 priv 可以指向数据节点也可以指向控制节点，以下代码设计即指向控制节点</p>
<pre><code>struct gxlist_head
{
    struct gxlist_head *next, *prev;
};

//双向链表初始化，next和prev均指向链表header
#define GX_LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }

//声明双向链表Header Node
#define GX_LIST_HEAD(name) struct gxlist_head name = GX_LIST_HEAD_INIT(name)

#define GX_INIT_LIST_HEAD(ptr) do { \
    (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \
} while (0)

void gxlist_add     (struct gxlist_head *newnode, struct gxlist_head *head);
void gxlist_add_tail(struct gxlist_head *newnode, struct gxlist_head *head);
void gxlist_del     (struct gxlist_head *entry);
void gxlist_del_init(struct gxlist_head *entry);
int  gxlist_empty   (struct gxlist_head *head );
void gxlist_splice  (struct gxlist_head *list, struct gxlist_head *head);

struct gxlist_head *gxlist_get(struct gxlist_head *head);

//根据控制成员（member）偏移量来获取数据节点地址
#define gxlist_entry(ptr, type, member) \
    ((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))

//从双向链表中循环取出链表控制信息段（struct gxlist_head）
//从双向链表中循环取出pos，pos类型为 struct gxlist_head
#define gxlist_for_each(pos, head) \
    for (pos = (head)-&gt;next; pos != (head); \
            pos = pos-&gt;next)

//从双向链表中根据member循环取出数据节点
//从双向链表中取出pos，pos类型为包含member成员的结构体
#define gxlist_for_each_entry(pos, head, member)                            \
    for (pos = gxlist_entry((head)-&gt;next, typeof(*pos), member);        \
            &amp;pos-&gt;member != (head);                                     \
            pos = gxlist_entry(pos-&gt;member.next, typeof(*pos), member))

//反序
#define list_for_each_entry_reverse(pos, head, member)                            \
    for (pos = list_entry((head)-&gt;prev, typeof(*pos), member);        \
            &amp;pos-&gt;member != (head);                                     \
            pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))

//从数据节点中直接取出双向循环链表
#define list_from_node(pos, node, member, head)                            \
    for (pos = list_entry((node)-&gt;next, typeof(*pos), member);        \
            pos != (head);                                     \
            pos = list_entry(pos-&gt;member.next, typeof(*pos), member))

//反序从数据节点中直接取出双向循环链表
#define list_from_node_reverse(pos, node, member, head)                            \
    for (pos = list_entry((node)-&gt;prev, typeof(*pos), member);        \
            pos != (head);                                     \
            pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))


//safe系列接口，n与pos相同的数据类型，n为链表中pos的下一个
#define list_for_each_safe(pos, n, head) \
    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \
            pos = n, n = pos-&gt;next)

#define list_for_each_entry_safe(pos, n, head, member)                           \
    for (pos = list_entry((head)-&gt;next, typeof(*pos), member),               \
            n = list_entry(pos-&gt;member.next, typeof(*pos), member);  \
            &amp;pos-&gt;member != (head);                                    \
            pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))

#define list_for_each_entry_safe_reverse(pos, n, head, member)        \
    for (pos = list_entry((head)-&gt;prev, typeof(*pos), member),    \
        n = list_entry(pos-&gt;member.prev, typeof(*pos), member);    \
         &amp;pos-&gt;member != (head);                     \
         pos = n, n = list_entry(n-&gt;member.prev, typeof(*n), member))


#endif</code></pre><pre><code>/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static void __list_add(struct gxlist_head *new_node, struct gxlist_head *head, struct gxlist_head *head_next)
{
    head_next-&gt;prev = new_node;
    new_node-&gt;next = head_next;
    new_node-&gt;prev = head;
    head-&gt;next = new_node;
}

/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
void gxlist_add(struct gxlist_head *new_node, struct gxlist_head *head)
{
    __list_add(new_node, head, head-&gt;next);
}

/**
 * list_add_tail - add a new entry
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
void gxlist_add_tail(struct gxlist_head *new_node, struct gxlist_head *head)
{
    __list_add(new_node, head-&gt;prev, head);
}

/*
 * Delete a list entry by making the prev/next entries
 * point to each other.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static void __list_del(struct gxlist_head *prev_head, struct gxlist_head *next_head)
{
    next_head-&gt;prev = prev_head;
    prev_head-&gt;next = next_head;
}

/**
 * list_del - deletes entry from list.
 * @entry: the element to delete from the list.
 * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
 */
void gxlist_del(struct gxlist_head *entry)
{
    __list_del(entry-&gt;prev, entry-&gt;next);
}

/**
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
void gxlist_del_init(struct gxlist_head *entry)
{
    __list_del(entry-&gt;prev, entry-&gt;next);
    GX_INIT_LIST_HEAD(entry);
}

/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
int gxlist_empty(struct gxlist_head *head)
{
    return head-&gt;next == head;
}

struct gxlist_head *gxlist_get(struct gxlist_head *head)
{
    struct gxlist_head *first = head-&gt;next;

    if (first != head)  {
        __list_del(first-&gt;prev, first-&gt;next);
        return first;
    }

    return 0;
}

/**
 * list_splice - join two lists
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 */
void gxlist_splice(struct gxlist_head *list, struct gxlist_head *head)
{
    //去除header node
    struct gxlist_head *first = list-&gt;next;

    if (first != list) {
        struct gxlist_head *last = list-&gt;prev;
        struct gxlist_head *at = head-&gt;next;

        first-&gt;prev = head;
        head-&gt;next = first;

        last-&gt;next = at;
        at-&gt;prev = last;
    }
}</code></pre><pre><code>GX_LIST_HEAD(__usbwifi_device_list);

cyg_mutex_t usbwifi_list_lock;

#define DEV_LOCK()   cyg_mutex_lock(&amp;usbwifi_list_lock)
#define DEV_UNLOCK() cyg_mutex_unlock(&amp;usbwifi_list_lock)
#define DEV_TRYLOCK()   cyg_mutex_trylock(&amp;usbwifi_list_lock)

void (*proc_wifi_init)(void);
void (*proc_wifi_exit)(void);
static void usbwifi_proc(void *p)
{
    usbwifi_dev_info disk_info;
    struct gx_usbwifi_hot_device *dev = NULL;

    while(1) {
        if (0 != usbwifi_detect(&amp;disk_info)) {
            LOG(&quot;disk_detect return error \n&quot;);
            continue;
        }

        if (disk_info.dev_status == CYG_IO_SET_CONFIG_DISK_IN) {

            dev = GxCore_Malloc(sizeof(struct gx_usbwifi_hot_device));

            if (NULL == dev) {
                printf(&quot; %s cann&#39;t fetch memory, try again \n&quot;, __func__);
                continue;
            }
            memset(dev, 0, sizeof(struct gx_usbwifi_hot_device));

            dev-&gt;id     = disk_info.index;
            dev-&gt;hot    = 0;
            dev-&gt;active = 1;
            dev-&gt;action = PLUG_IN;
            dev-&gt;error = PLUG_SUCCESS;

            DEV_LOCK();
            gxlist_add(&amp;dev-&gt;head, &amp;__usbwifi_device_list);
            DEV_UNLOCK();

            cyg_semaphore_post(&amp;device_detect_sem);

            if (proc_wifi_init)
                (*proc_wifi_init)();
        }
        else if (disk_info.dev_status == CYG_IO_SET_CONFIG_DISK_OUT) {
            int found = 0;

            DEV_LOCK();

            gxlist_for_each_entry(dev, &amp;__usbwifi_device_list, head) {
                if (dev-&gt;id == disk_info.index) {
                    found = 1;
                    break;
                }
            }

            if (found == 0) {
                DEV_UNLOCK();
                continue;
            }

            dev-&gt;action = PLUG_OUT;

            DEV_UNLOCK();

            cyg_semaphore_post(&amp;device_detect_sem);

            if (proc_wifi_exit)
                (*proc_wifi_exit)();
        }

        GxCore_ThreadDelay(20);
    }
}

void GxCore_UsbwifiHotplugInit()
{
    handle_t thread_id_do;

    cyg_semaphore_init(&amp;device_detect_sem, 0);
    cyg_mutex_init(&amp;usbwifi_list_lock);

    LOG(&quot;device_detect_sem.count = 0x%x , line = %d \n&quot;, device_detect_sem.count, __LINE__);

    GxCore_ThreadCreate(
            &quot;usbwifi_proc&quot;,
            &amp;thread_id_do,
            usbwifi_proc,
            NULL,
            8 * 1024,
            GXOS_DEFAULT_PRIORITY);
}

struct gx_usbwifi_hot_device *GxCore_UsbwifiHotplugGetFirst(void)
{
    if (gxlist_empty(&amp;__usbwifi_device_list) )
        return NULL;

    return gxlist_entry(__usbwifi_device_list.next, struct gx_usbwifi_hot_device, head);
}

struct gx_usbwifi_hot_device *GxCore_UsbwifiHotplugGetNext(struct gx_usbwifi_hot_device *dev)
{
    if (dev == NULL)
        return NULL;

    if (dev-&gt;head.next == &amp;__usbwifi_device_list)
        return NULL;

    return gxlist_entry(dev-&gt;head.next, struct gx_usbwifi_hot_device, head);
}

struct gx_usbwifi_hot_device *GxCore_UsbwifiHotplugWait(void)
{
    cyg_semaphore_wait(&amp;device_detect_sem);

    DEV_LOCK();
    if (gxlist_empty(&amp;__usbwifi_device_list) ) {
        return NULL;
    }

    return gxlist_entry(__usbwifi_device_list.next, struct gx_usbwifi_hot_device, head);
}

int GxCore_UsbwifiHotplugClean(void)
{
    struct gx_usbwifi_hot_device *dev, *n;

    gxlist_for_each_entry_safe(dev, n, &amp;__usbwifi_device_list, head) {
        if (dev-&gt;action == PLUG_OUT) {
            gxlist_del(&amp;dev-&gt;head);
            GxCore_Free(dev);
        }
    }
    DEV_UNLOCK();
    return GXCORE_SUCCESS;
}</code></pre><pre><code>typedef enum {
    PLUG_IN    = 1,
    PLUG_OUT   = 2,
    PLUG_CLEAN = 3,
}GxFsActionType;

typedef enum {
    PLUG_SUCCESS             = 0,
    PLUG_ERROR_FS_NO_SUPPORT = 1,
    PLUG_ERROR_NO_PARTITION  = 2,
} GxHotplugError;

struct gx_usbwifi_hot_device {
    int                     id;
    int                     active;
    GxFsActionType          action;          // PLUG-IN PLUG-OUT
    struct gxlist_head      head;
    int                     hot;
    GxHotplugError          error;
    void *priv;
};</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/fisherwan/article/details/19801993" target="_blank" rel="noopener">链表（四）——实现双向循环链表创建、插入、删除、释放内存等简单操作</a></li>
<li><a href="http://www.cnblogs.com/corvoh/p/5595130.html" target="_blank" rel="noopener">单链表/双向链表的建立/遍历/插入/删除</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel-hacking-config</title>
    <url>/2017/07/24/kernel-hacking-config/</url>
    <content><![CDATA[<p>Linux Kernel Hacking 内核配置选项解析</p>
<a id="more"></a>

<ul>
<li><code>Show timing information on printks</code> &gt;&gt; 在printk的输出中包含时间信息</li>
<li><code>Enable __deprecated logic</code> &gt;&gt; </li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>movian</title>
    <url>/2017/07/21/movian/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>SQL描述位于 <code>movian/res/metadb</code>，C语言使用 <code>metadb</code> 进行交互，位于 <code>src/metadata/metadb.c</code>，例如</p>
<pre><code class="res/metadb/005.sql">-- Create artist picture table
CREATE TABLE artistpic (
       artist_id INTEGER REFERENCES artist(id) ON DELETE CASCADE,
       url TEXT,
       width INTEGER,
       height INTEGER,
       UNIQUE (artist_id, url)
);
CREATE INDEX artistpic_artid_id_idx ON artistpic(artist_id);
CREATE INDEX artistpic_url_idx ON artistpic(url);</code></pre>
<pre><code class="c">void
metadb_insert_artistpic(void *db, int64_t artist_id, const char *url,
            int width, int height)
{
  sqlite3_stmt *ins;
  int rc;

  rc = db_prepare(db, &amp;ins,
          &quot;INSERT INTO artistpic &quot;
          &quot;(artist_id, url, width, height) &quot;
          &quot;VALUES &quot;
          &quot;(?1, ?2, ?3, ?4)&quot;);

  if(rc != SQLITE_OK)
    return;

  sqlite3_bind_int64(ins, 1, artist_id);
  sqlite3_bind_text(ins, 2, url, -1, SQLITE_STATIC);
  if(width) sqlite3_bind_int64(ins, 3, width);
  if(height) sqlite3_bind_int64(ins, 4, height);
  db_step(ins);
  sqlite3_finalize(ins);
}</code></pre>
<h2 id="metadb"><a href="#metadb" class="headerlink" title="metadb"></a>metadb</h2><p>函数调用关系：</p>
<p><code>_plugin_store_init</code> -&gt; <code>main_init</code> -&gt; <code>metadb_init</code> -&gt; <code>db_upgrade_schema</code></p>
<p>需要关心的几个函数：</p>
<ul>
<li><code>metadata_init</code></li>
<li><code>app_dataroot</code></li>
<li><code>app_plugin_installed_path</code></li>
</ul>
<p>需要关心的路径信息 <code>gconf.persistent_path</code>，由函数 <code>posix_init</code> 进行初始化</p>
<pre><code>//const char *homedir = &quot;/media/sda1/movian&quot;;//getenv(&quot;HOME&quot;);
const char *homedir = &quot;/tmp/plugin&quot;;//getenv(&quot;HOME&quot;);
if(homedir != NULL)
{
  char buf[PATH_MAX];

  if(gconf.cache_path == NULL)
  {
    snprintf(buf, sizeof(buf), &quot;%s/.cache/%s&quot;, homedir, APPNAME);
    gconf.cache_path = strdup(buf);
  }

  if(gconf.persistent_path == NULL)
  {
    snprintf(buf, sizeof(buf), &quot;%s/.hts/showtime&quot;, homedir);
    gconf.persistent_path = strdup(buf);
  }
}</code></pre><p><code>metadb_init</code> -&gt; <code>db_upgrade_schema</code> -&gt; <code>fa_scandir</code> 载入搜索的 <code>sql files</code></p>
<pre><code class="metadb_init">snprintf(buf, sizeof(buf), &quot;%s/metadb&quot;, gconf.persistent_path);
fa_makedir(buf);
snprintf(buf, sizeof(buf), &quot;%s/metadb/meta.db&quot;, gconf.persistent_path);

//  unlink(buf);

metadb_pool = db_pool_create(buf, 2);
db = metadb_get();
if(db == NULL)
  return;

snprintf(buf, sizeof(buf), &quot;%s/res/metadb&quot;, app_dataroot());
snprintf(buf2, sizeof(buf2), &quot;%s/kvstore/kvstore.db&quot;, gconf.persistent_path);

int r = db_upgrade_schema(db, buf, &quot;metadb&quot;, &quot;kvstore&quot;, buf2);</code></pre>
<pre><code class="db_upgrade_schema">while(1) {

  if(ver == tgtver) {
    TRACE(TRACE_DEBUG, &quot;DB&quot;, &quot;%s: At current version %d&quot;, dbname, ver);
    if(detach[0]) db_one_statement(db, detach, NULL);
    return 0;
  }

  ver++;
  snprintf(path, sizeof(path), &quot;%s/%03d.sql&quot;, schemadir, ver);

  buf_t *sql = fa_load(path,
                        FA_LOAD_ERRBUF(buf, sizeof(buf)),
                        NULL);
  if(sql == NULL) {
    TRACE(TRACE_ERROR, &quot;DB&quot;,
      &quot;%s: Unable to upgrade db schema to version %d using %s -- %s&quot;,
      dbname, ver, path, buf);
    if(detach[0]) db_one_statement(db, detach, NULL);
    return -1;
  }


  if(strstr(buf_cstr(sql), &quot;-- schema-upgrade:disable-fk&quot;)) {
    db_one_statement(db, &quot;PRAGMA foreign_keys=OFF;&quot;, NULL);
    enable_fk = 1;
  }
  db_begin(db);
  snprintf(buf, sizeof(buf), &quot;PRAGMA user_version=%d&quot;, ver);
  if(db_one_statement(db, buf, NULL)) {
    free(sql);
    break;
  }

  const char *s = buf_cstr(sql);

  while(strchr(s, &#39;;&#39;) != NULL) {
    sqlite3_stmt *stmt;

    int rc = sqlite3_prepare_v2(db, s, -1, &amp;stmt, &amp;s);
    if(rc != SQLITE_OK) {
  TRACE(TRACE_ERROR, &quot;DB&quot;,
        &quot;%s: Unable to prepare statement in upgrade %d\n%s&quot;, dbname, ver, s);
  goto fail;
    }

    rc = sqlite3_step(stmt);
    if(rc != SQLITE_DONE) {
  TRACE(TRACE_ERROR, &quot;DB&quot;,
        &quot;%s: Unable to execute statement error %d\n%s&quot;, dbname, rc,
        sqlite3_sql(stmt));
  goto fail;
    }
    sqlite3_finalize(stmt);
  }

  db_commit(db);
  if(enable_fk) {
    db_one_statement(db, &quot;PRAGMA foreign_keys=ON;&quot;, NULL);
    enable_fk = 0;
  }
  TRACE(TRACE_INFO, &quot;DB&quot;, &quot;%s: Upgraded to version %d&quot;, dbname, ver);
  buf_release(sql);
}</code></pre>
<p><code>001.sql</code> 载入流程，通过以上 <code>while</code> 循环执行了所有的 <code>sql</code> 脚本</p>
<p>前置操作 <code>metadb_get</code> -&gt; <code>db_pool_get</code> -&gt; <code>db_open</code> -&gt; <code>sqlite3_open_v2</code> 得到 <code>sqlite3 *db</code></p>
<h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>创建进程函数</p>
<pre><code>hts_thread_create_detached(const char *title, void *(*func)(void *), void *aux, int prio)
hts_thread_create_detached(&quot;metadata&quot;, metadata_thread, NULL, THREAD_PRIO_METADATA);</code></pre><h2 id="BACKEND"><a href="#BACKEND" class="headerlink" title="BACKEND"></a>BACKEND</h2><p><code>src/backend/backend.c</code></p>
<p>其中注册函数 <code>BE_REGISTER(videoparams);</code></p>
<h2 id="插件载入过程"><a href="#插件载入过程" class="headerlink" title="插件载入过程"></a>插件载入过程</h2><p><code>main_init</code> -&gt; <code>plugins_init</code> -&gt; <code>plugin_load</code> -&gt; <code>ecmascript_plugin_load</code></p>
<pre><code>void plugins_init(char **devplugs)
{
  plugins_view_settings_init();

  hts_mutex_init(&amp;plugin_mutex);

  plugins_setup_root_props();

  hts_mutex_lock(&amp;plugin_mutex);

  if (devplugs != NULL)
  {
    const char *path;
    for(; (path = *devplugs) != NULL; devplugs++)
    {
      char errbuf[200];
      char buf[PATH_MAX];

     if(!fa_normalize(path, buf, sizeof(buf)))
        path = buf;

      strvec_addp(&amp;devplugins, path);

      if (plugin_load(path, errbuf, sizeof(errbuf), PLUGIN_LOAD_FORCE | PLUGIN_LOAD_DEBUG))
      {
        TRACE(TRACE_ERROR, &quot;plugins&quot;, &quot;Unable to load development plugin: %s\n%s&quot;, path, errbuf);
      }
      else
      {
        TRACE(TRACE_INFO, &quot;plugins&quot;, &quot;Loaded dev plugin %s&quot;, path);
      }
    }
  }
  hts_mutex_unlock(&amp;plugin_mutex);
}</code></pre><p><code>plugin_load</code> 使用的标志为 <code>PLUGIN_LOAD_FORCE | PLUGIN_LOAD_DEBUG</code></p>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><pre><code>static void  _process_server(void)
{
    int size;
    int ret;
    char buf[COMMAND_BUF_ZISE];
    struct ClentCommand command;
    printf(&quot;server start\n&quot;);
    _plugin_store_init();
    while(1)
    {
        size = read(fd_read, buf, COMMAND_BUF_ZISE);
        if(size &lt;= 0)
            continue;
        if(size != COMMAND_BUF_ZISE)
        {
            break;
        }
        memcpy(&amp;command, buf, size);
        switch(command.type)
        {
            case COMMAND_PLUGIN_INSTALL:
            {
                _plugin_install(command.data);
                command.type = COMMAND_REPLY;
                write(fd_write, &amp;command, COMMAND_BUF_ZISE);
                break;
            }
            case COMMAND_PLUGIN_UNINSTALL:
            {
                _plugin_uninstall(command.data);
                break;
            }
            case COMMAND_CLASSIFICATION_LIST_GET:
            {
                ret = _classification_list_get(command.data);
                command.type = COMMAND_REPLY;
                command.err = ret;
                write(fd_write, &amp;command, COMMAND_BUF_ZISE);
                break;
            }
            case COMMAND_CLASSIFICATION_LIST_REFRESH:
            {
                ret = _classification_list_refresh(command.index);
                command.type = COMMAND_REPLY;
                command.err = ret;
                write(fd_write, &amp;command, COMMAND_BUF_ZISE);
                break;
            }
            case COMMAND_SOURCE_LIST_GET:
            {
                ret = _source_list_get(command.index);
                command.type = COMMAND_REPLY;
                command.err = ret;
                write(fd_write, &amp;command, COMMAND_BUF_ZISE);
                break;
            }
            case COMMAND_SOURCE_LIST_REFRESH:
            {
                ret = _source_list_refresh(command.index);
                command.type = COMMAND_REPLY;
                command.err = ret;
                write(fd_write, &amp;command, COMMAND_BUF_ZISE);
                break;
            }
            case COMMAND_SOURCE_URL_GET:
            {
                ret = _source_url_get(command.index);
                command.type = COMMAND_REPLY;
                command.err = ret;
                write(fd_write, &amp;command, COMMAND_BUF_ZISE);
                break;
            }
            case COMMAND_SOURCE_URL_REFRESH:
            {
                _source_url_refresh();
                break;
            }
            case COMMAND_SOURCE_URL_CLOSE:
            {
                ret = _source_url_refresh_close();
                command.type = COMMAND_REPLY;
                command.err = ret;
                write(fd_write, &amp;command, COMMAND_BUF_ZISE);
            }
        }
        usleep(10000);
    }
    _plugin_store_exit();
}</code></pre><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p><code>_plugin_install(const char *name)</code> -&gt; <code>plugins_init3</code> -&gt; <code>plugin_load</code></p>
<pre><code>void plugins_init3(char *name)
{
    char errbuf[200];
    char path[512];
    char *tmp_name;

    tmp_name = name;
    while(*(++tmp_name) != &#39;\0&#39;);
    if(strncmp(tmp_name - 4, &quot;.zip&quot;, 4) == 0)
        snprintf(path, sizeof(path), &quot;zip://file://%s/%s&quot;, app_plugin_installed_path(), name);
    else
        snprintf(path, sizeof(path), &quot;%s/%s&quot;, app_plugin_installed_path(), name);

    hts_mutex_lock(&amp;plugin_mutex);
    if(plugin_load(path, errbuf, sizeof(errbuf), PLUGIN_LOAD_AS_INSTALLED))
    {
        TRACE(TRACE_ERROR, &quot;plugins&quot;, &quot;Unable to load %s\n&quot;, errbuf);
    }
    hts_mutex_unlock(&amp;plugin_mutex);
}</code></pre><h3 id="plugin-load-分析"><a href="#plugin-load-分析" class="headerlink" title="plugin_load 分析"></a>plugin_load 分析</h3><pre><code>//plugin.json
{
    &quot;type&quot;: &quot;ecmascript&quot;,
    &quot;id&quot;: &quot;stalker&quot;,
    &quot;file&quot;: &quot;stalker.js&quot;,
    &quot;category&quot;: &quot;tv&quot;,
    &quot;showtimeVersion&quot;: &quot;0.0.1&quot;,
    &quot;version&quot;: &quot;0.0.1&quot;,
    &quot;author&quot;: &quot;LuckXiang (@luckxiang)&quot;,
    &quot;title&quot;: &quot;Stalker&quot;,
    &quot;icon&quot;: &quot;stalker.bmp&quot;,
    &quot;synopsis&quot;: &quot;stalker for test&quot;,
    &quot;description&quot;:&quot;&lt;p&gt;just for test stalker api.&lt;/p&gt;&quot;,
    &quot;homepage&quot;:&quot;https://github.com/luckxiang&quot;,
    &quot;setting&quot;:{
        &quot;url&quot;: &quot;&quot;,
        &quot;mac&quot;: &quot;00:1A:79:f5:75:d2&quot;
    }
}</code></pre><pre><code>static int plugin_load(const char *url, char *errbuf, size_t errlen, int flags)
{
  char ctrlfile[URL_MAX];
  char errbuf2[1024];
  buf_t *b;
  htsmsg_t *ctrl;

  //url: zip://file:///home/gx/plugin_env/plugins/stalker.zip
  snprintf(ctrlfile, sizeof(ctrlfile), &quot;%s/plugin.json&quot;, url);

  if((b = fa_load(ctrlfile, FA_LOAD_ERRBUF(errbuf2, sizeof(errbuf2)), NULL)) == NULL)
  {
    snprintf(errbuf, errlen, &quot;Unable to load %s -- %s&quot;, ctrlfile, errbuf2);
    return -1;
  }

  //将内存文件转为htsmsg_t结构体
  ctrl = htsmsg_json_deserialize2(buf_cstr(b), errbuf, errlen);
  if(ctrl == NULL) goto bad;

  //ecmascript
  const char *type = htsmsg_get_str(ctrl, &quot;type&quot;);
  //stalker
  const char *id   = htsmsg_get_str(ctrl, &quot;id&quot;);
  //0.0.1
  const char *version = htsmsg_get_str(ctrl, &quot;version&quot;);
  if(type == NULL)
  {
    snprintf(errbuf, errlen, &quot;Missing \&quot;type\&quot; element in control file %s&quot;, ctrlfile);
    goto bad;
  }

  if(id == NULL)
  {
    snprintf(errbuf, errlen, &quot;Missing \&quot;id\&quot; element in control file %s&quot;, ctrlfile);
    goto bad;
  }

  //根据id查找plugin_t
  plugin_t *pl = plugin_find(id, 1);

  if(version != NULL)
  {
    rstr_t *notifymsg;
    if(is_plugin_blacklisted(id, version, &amp;notifymsg))
    {
      const char *title = htsmsg_get_str(ctrl, &quot;title&quot;) ?: id;
      char tmp[512];
      rstr_t *fmt = _(&quot;Plugin %s has been uninstalled - %s&quot;);
      snprintf(tmp, sizeof(tmp), rstr_get(fmt), title, rstr_get(notifymsg));
      rstr_release(notifymsg);
      notify_add(NULL, NOTIFY_ERROR, NULL, 10, rstr_alloc(tmp));
      plugin_remove(pl);
      goto bad;
    }
  }

  if(!(flags &amp; PLUGIN_LOAD_FORCE) &amp;&amp; pl-&gt;pl_loaded)
  {
    snprintf(errbuf, errlen, &quot;Plugin \&quot;%s\&quot; already loaded&quot;, id);
    goto bad;
  }

  plugin_unload(pl);

  int r;
  char fullpath[URL_MAX];


  if(!strcmp(type, &quot;views&quot;))
  {
    // No special tricks here, we always loads &#39;glwviews&#39; from all plugins
    r = 0;
  }
  else if(!strcmp(type, &quot;ecmascript&quot;))
  {
    // stalker.js
    const char *file = htsmsg_get_str(ctrl, &quot;file&quot;);
    if(file == NULL)
    {
      snprintf(errbuf, errlen, &quot;Missing \&quot;file\&quot; element in control file %s&quot;, ctrlfile);
      goto bad;
    }
    snprintf(fullpath, sizeof(fullpath), &quot;%s/%s&quot;, url, file);

    int version = htsmsg_get_u32_or_default(ctrl, &quot;apiversion&quot;, 1);

    int pflags = 0;
    if(htsmsg_get_u32_or_default(ctrl, &quot;debug&quot;, 0) || flags &amp; PLUGIN_LOAD_DEBUG)
      pflags |= ECMASCRIPT_DEBUG;

    htsmsg_t *e = htsmsg_get_map(ctrl, &quot;entitlements&quot;);
    if(e != NULL)
    {
      if(htsmsg_get_u32_or_default(e, &quot;bypassFileACLRead&quot;, 0))
        pflags |= ECMASCRIPT_FILE_BYPASS_ACL_READ;
      if(htsmsg_get_u32_or_default(e, &quot;bypassFileACLWrite&quot;, 0))
        pflags |= ECMASCRIPT_FILE_BYPASS_ACL_WRITE;
    }

    // 载入plugin
    hts_mutex_unlock(&amp;plugin_mutex);
    r = ecmascript_plugin_load(id, fullpath, errbuf, errlen, version, buf_cstr(b), pflags);
    hts_mutex_lock(&amp;plugin_mutex);
    if(!r)
      pl-&gt;pl_unload = plugin_unload_ecmascript;
  }
  else
  {
    if(flags &amp; PLUGIN_LOAD_BY_USER)
    {
      snprintf(errbuf, errlen, &quot;Unknown type \&quot;%s\&quot; in control file %s&quot;, type, ctrlfile);
      goto bad;
    }
    else
    {
      TRACE(TRACE_ERROR, &quot;Plugin&quot;,
            &quot;Installed plugin at %s has unknown type %s but keeping anyway, &quot;
            &quot;since it might be upgraded&quot;,
            ctrlfile, type);
      r = 0;
    }
  }


  // Load bundled views

  if(!r)
  {
    htsmsg_t *list = htsmsg_get_list(ctrl, &quot;glwviews&quot;);

    if(list != NULL) {
      htsmsg_field_t *f;
      HTSMSG_FOREACH(f, list) {
        htsmsg_t *o;
        if((o = htsmsg_get_map_by_field(f)) == NULL)
          continue;
        const char *uit   = htsmsg_get_str(o, &quot;uitype&quot;) ?: &quot;standard&quot;;
        const char *class = htsmsg_get_str(o, &quot;class&quot;);
        const char *title = htsmsg_get_str(o, &quot;title&quot;);
        const char *file  = htsmsg_get_str(o, &quot;file&quot;);

        if(class == NULL || title == NULL || file == NULL)
          continue;
        snprintf(fullpath, sizeof(fullpath), &quot;%s/%s&quot;, url, file);

        int dosel =
          htsmsg_get_u32_or_default(o, &quot;select&quot;,
                                    !!(flags &amp; PLUGIN_LOAD_BY_USER));

        plugins_view_add(pl, uit, class, title, fullpath, dosel, file);
      }
    }
  }

  if(!r)
  {
    if(flags &amp; PLUGIN_LOAD_AS_INSTALLED)
    {
      plugin_prop_setup(ctrl, pl, url);
      pl-&gt;pl_installed = 1;
      mystrset(&amp;pl-&gt;pl_inst_ver, htsmsg_get_str(ctrl, &quot;version&quot;));
    }

    mystrset(&amp;pl-&gt;pl_title, htsmsg_get_str(ctrl, &quot;title&quot;) ?: id);

    pl-&gt;pl_loaded = 1;
  }

  buf_release(b);
  htsmsg_release(ctrl);
  update_state(pl);
  return 0;

bad:
  buf_release(b);
  htsmsg_release(ctrl);
  return -1;
}</code></pre><h2 id="es-modules"><a href="#es-modules" class="headerlink" title="es modules"></a>es modules</h2><p><code>movian</code> 使用 <code>duktape</code> javascript引擎，es modules加载流程</p>
<p>目录<code>src/ecmascript</code></p>
<pre><code>src/ecmascript
├── ecmascript.c
├── ecmascript.h
├── es_console.c
├── es_crypto.c
├── es_faprovider.c
├── es_fs.c
├── es_gumbo.c
├── es_hook.c
├── es_htsmsg.c
├── es_io.c
├── es_kvstore.c
├── es_metadata.c
├── es_misc.c
├── es_native_obj.c
├── es_prop.c
├── es_root.c
├── es_route.c
├── es_scrobble.c
├── es_searcher.c
├── es_service.c
├── es_sqlite.c
├── es_stats.c
├── es_string.c
├── es_subtitles.c
├── es_timer.c
└── es_websocket.c</code></pre><p>文件 <code>es_fs.c</code></p>
<pre><code>static const duk_function_list_entry fnlist_fs[] = {
  { &quot;open&quot;,             es_file_open,             3 },
  { &quot;read&quot;,             es_file_read,             5 },
  { &quot;write&quot;,            es_file_write,            5 },
  { &quot;fsize&quot;,            es_file_fsize,            1 },
  { &quot;ftrunctae&quot;,        es_file_ftruncate,        2 },
  { &quot;rename&quot;,           es_file_rename,           2 },
  { &quot;mkdirs&quot;,           es_file_mkdirs,           2 },
  { &quot;dirname&quot;,          es_file_dirname,          1 },
  { &quot;basename&quot;,         es_file_basename,         1 },
  { &quot;copyfile&quot;,         es_file_copy,             2 },
  { NULL, NULL, 0}
};

ES_MODULE(&quot;fs&quot;, fnlist_fs);</code></pre><p>文件 <code>es_sqlite.c</code></p>
<pre><code>static const duk_function_list_entry fnlist_sqlite[] =
{
    { &quot;create&quot;,          es_sqlite_create,         1 },
    { &quot;query&quot;,           es_sqlite_query,          DUK_VARARGS },
    { &quot;changes&quot;,         es_db_changes,            1 },
    { &quot;step&quot;,            es_sqlite_step,           1 },
    { &quot;lastErrorCode&quot;,   es_db_last_error_code,    1 },
    { &quot;lastErrorString&quot;, es_db_last_error_str,     1 },
    { &quot;lastRowId&quot;,       es_db_last_insert_row_id, 1 },
    { &quot;upgradeSchema&quot;,   es_db_upgrade_schema,     2 },
    { NULL, NULL, 0}
};


ES_MODULE(&quot;sqlite&quot;, fnlist_sqlite);</code></pre><p><code>ES_MODULE</code> 分析</p>
<pre><code>#define INITIALIZER(f) \
   static void f(void) __attribute__((constructor)); \
   static void f(void)

#define HTS_GLUE(a, b) a ## b
#define HTS_JOIN(a, b) HTS_GLUE(a, b)

typedef struct ecmascript_module
{
    LIST_ENTRY(ecmascript_module) link;
    const char *name;
    const duk_function_list_entry *functions;
} ecmascript_module_t;

void ecmascript_register_module(ecmascript_module_t *m);

#define ES_MODULE(nam, fn)                                        \
  static ecmascript_module_t HTS_JOIN(esmoduledef, __LINE__) = {  \
    .name = nam,                                                  \
    .functions = fn                                               \
  };                                                              \
  INITIALIZER(HTS_JOIN(esmoduledefinit, __LINE__))                \
  { ecmascript_register_module(&amp;HTS_JOIN(esmoduledef, __LINE__));}

void ecmascript_register_module(ecmascript_module_t *m)
{
    LIST_INSERT_HEAD(&amp;modules, m, link);
}</code></pre><p>通过 <code>__attribute__((constructor))</code> 将 <code>module</code> 添加到 <code>LIST modules</code> 中，进而在函数 <code>es_modsearch</code></p>
<pre><code> /* for native modules */
const char *nativemod = mystrbegins(id, &quot;native/&quot;);
if(nativemod != NULL)
{
  ecmascript_module_t *m;
  LIST_FOREACH(m, &amp;modules, link)
  {
    if(!strcmp(m-&gt;name, nativemod))
      break;
  }

  if(m == NULL)
    duk_error(ctx, DUK_ERR_ERROR, &quot;Can&#39;t find native module %s&quot;, id);

  for(int i = 0; m-&gt;functions[i].key != NULL; i++)
  {
    duk_push_c_lightfunc(ctx, m-&gt;functions[i].value,
                         m-&gt;functions[i].nargs, 0, 0);
    duk_put_prop_string(ctx, 2, m-&gt;functions[i].key);
  }
  return 0;
}</code></pre><p>通过 <code>duk_push_c_lightfunc</code> 将 <code>module</code> 中的所有函数推进 <code>duktape stack</code></p>
<h2 id="prop-系统"><a href="#prop-系统" class="headerlink" title="prop 系统"></a>prop 系统</h2><p><code>main_init</code> -&gt; <code>service_init</code> 创建 <code>prop services</code></p>
<pre><code>void service_init(void)
{
  struct prop_nf *pnf;
  prop_t *gs = prop_create(prop_get_global(), &quot;services&quot;);

  hts_mutex_init(&amp;service_mutex);
  hts_cond_init(&amp;service_cond, &amp;service_mutex);

  hts_thread_create_detached(&quot;service probe&quot;, service_probe_loop, NULL, THREAD_PRIO_BGTASK);

  // $global.service.all

  all_services = prop_create(gs, &quot;all&quot;);
#if ENABLE_PLUGINS
  service_create0(&quot;showtime:plugin&quot;,
          NULL, _p(&quot;Plugins&quot;), &quot;plugin:start&quot;,
          &quot;plugin&quot;, NULL, 0, 1, SVC_ORIGIN_SYSTEM);
#endif
  service_create0(&quot;showtime:discovered&quot;,
          NULL, _p(&quot;Local network&quot;), &quot;discovered:&quot;,
          &quot;network&quot;, NULL, 0, 1, SVC_ORIGIN_SYSTEM);

  service_create0(&quot;showtime:settings&quot;,
          NULL, _p(&quot;Settings&quot;), &quot;settings:&quot;,
          &quot;setting&quot;, NULL, 0, 1, SVC_ORIGIN_SYSTEM);


  // $global.service.enabled

  prop_t *enabled = prop_create(gs, &quot;enabled&quot;);

  pnf = prop_nf_create(enabled, all_services, NULL, 0);
  prop_nf_pred_int_add(pnf, &quot;node.enabled&quot;,
               PROP_NF_CMP_EQ, 0, NULL,
               PROP_NF_MODE_EXCLUDE);

  // $global.service.stable

  prop_t *tmp = prop_create_root(NULL);

  pnf = prop_nf_create(tmp, all_services, NULL, 0);
  prop_nf_pred_int_add(pnf, &quot;node.enabled&quot;,
               PROP_NF_CMP_EQ, 0, NULL,
               PROP_NF_MODE_EXCLUDE);

  prop_t *stable = prop_create(gs, &quot;stable&quot;);
  prop_reorder_create(stable, tmp, 0, &quot;allSourcesOrder&quot;);

  // $global.service.discovered

  discovered_nodes = prop_create(gs, &quot;discovered&quot;);

  pnf = prop_nf_create(discovered_nodes, all_services, NULL, 0);

  prop_nf_pred_str_add(pnf, &quot;node.origin&quot;,
               PROP_NF_CMP_NEQ, &quot;discovered&quot;, NULL,
               PROP_NF_MODE_EXCLUDE);
}</code></pre><p>生产数据</p>
<p>消费数据</p>
<pre><code>int _classification_list_get(char *id)
{
    event_openurl_t event;
    char plugin[128];
    struct prop *p;

    snprintf(plugin, 128, &quot;plugin:%s&quot;, id);
    p = prop_find(prop_get_global(), &quot;services&quot;, &quot;all&quot;, plugin, 0);
    if(p == NULL)
        return -1;
    printf(&quot;id:%s,%p\n&quot;, plugin, p);

    memset(&amp;event, 0, sizeof(event));
    event.url = rstr_get(prop_get_string(p, &quot;url&quot;, 0));
    event.h.e_type = EVENT_OPENURL;
    nav_eventsink(nav, &amp;event);
    return 0;
}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://sqlite.org/cintro.html" target="_blank" rel="noopener">An Introduction To The SQLite C/C++ Interface</a></li>
<li><a href="http://blog.csdn.net/hdfqq188816190/article/details/48679753" target="_blank" rel="noopener">sqlite3用法详解</a></li>
<li><a href="http://blog.csdn.net/kfqcome/article/details/6570495" target="_blank" rel="noopener"> sqlite3使用简介</a></li>
</ol>
]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>movian</tag>
        <tag>sql3</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite</title>
    <url>/2017/07/21/sqlite/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>可以把 SQL 分为两个部分：数据操作语言 <code>DML</code> 和 数据定义语言 <code>DDL</code></p>
<p>SQL (结构化查询语言)是用于执行查询的语法。 但是 SQL 语言也包含用于更新、插入和删除记录的语法。</p>
<p>查询和更新指令构成了 SQL 的 DML 部分：</p>
<ul>
<li>SELECT - 从数据库表中获取数据</li>
<li>UPDATE - 更新数据库表中的数据</li>
<li>DELETE - 从数据库表中删除数据</li>
<li>INSERT INTO - 向数据库表中插入数据</li>
</ul>
<p>SQL 的数据定义语言 <code>DDL</code> 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p>
<p>SQL 中最重要的 <code>DDL</code> 语句:</p>
<ul>
<li>CREATE DATABASE - 创建新数据库</li>
<li>ALTER DATABASE - 修改数据库</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 变更（改变）数据库表</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引（搜索键）</li>
<li>DROP INDEX - 删除索引</li>
</ul>
<a id="more"></a>


<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><pre><code class="sql">CREATE TABLE item (
       stash TEXT,
       k TEXT,
       lastaccess INTEGER,
       expiry INTEGER,
       modtime INTEGER,
       etag TEXT,
       payload BLOB,
       UNIQUE(k, stash) ON CONFLICT FAIL);

CREATE INDEX item_key_idx ON item(stash, k);</code></pre>
<p><code>,</code> 分割开 <code>列名称 数据类型</code>，<code>UNIQUE</code> 约束唯一标识数据库表中的每条记录</p>
<p>创建索引以便快速高效地查询数据 <code>CREATE INDEX index_name ON table_name (column_name)</code></p>
<h3 id="ON-CONFLICT"><a href="#ON-CONFLICT" class="headerlink" title="ON CONFLICT"></a>ON CONFLICT</h3><p><code>ON CONFLICT</code> 子句不是独立的SQL命令，不是标准的SQL语言，在 <code>CREATE TABLE</code> 中使用 <code>ON CONFLICT</code>，而对于 <code>INSERT</code> <code>UPDATE</code> 关键词 <code>ON CONFLICT</code> 替换为 <code>OR</code>。例如，不用写 <code>INSERT ON ON CONFLICT</code> 而是 <code>INSERT OR FAIL</code></p>
<p><code>ON CONFLICT</code> 子句定义了解决约束冲突的算法，有以下选择：</p>
<ul>
<li>ROLLBACK</li>
<li>ABORT</li>
<li>FAIL</li>
<li>IGNORE</li>
<li>REPLACE</li>
</ul>
<h3 id="002"><a href="#002" class="headerlink" title="002"></a>002</h3><pre><code class="sql">CREATE TABLE url (
       id INTEGER PRIMARY KEY,
       url TEXT NOT NULL UNIQUE
       );

CREATE INDEX url_url_idx ON url(url);

CREATE TABLE page_kv (
       url_id INTEGER REFERENCES url(id) ON DELETE CASCADE,
       key TEXT NOT NULL,
       value,
       UNIQUE (url_id, key));

CREATE INDEX page_kv_url_id_idx ON page_kv(url_id);</code></pre>
<p><code>UNIQUE</code> 和 <code>PRIMARY KEY</code> 约束均为列或列集合提供了唯一性的保证。<code>PRIMARY KEY</code> 拥有自动定义的 <code>UNIQUE</code> 约束。请注意，每个表可以有多个 <code>UNIQUE</code> 约束，但是每个表只能有一个 <code>PRIMARY KEY</code> 约束。</p>
<p>主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。</p>
<p><code>NOT NULL</code> 约束强制列不接受 NULL 值。 <code>NOT NULL</code> 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p>
<p><code>REFERENCES</code> 为外来键，外键设置的模式：</p>
<ul>
<li>CASCADE，父表 <code>update/delete</code>记录时，同步操作子表记录</li>
<li>SET NULL，在父表上update/delete记录时，将子表上匹配记录的列设为null (要注意子表的外键列不能为not null)</li>
<li>SET DEFAULT，父表有变更时,子表将外键列设置成一个默认的值</li>
<li>NO ACTION，如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作</li>
<li>RESTRICT，同no action, 都是立即检查外键约束</li>
</ul>
<h3 id="003"><a href="#003" class="headerlink" title="003"></a>003</h3><pre><code class="sql">ALTER TABLE item ADD COLUMN restartposition INTEGER DEFAULT 0;

UPDATE item SET restartposition = (SELECT restartposition FROM videoitem WHERE item_id = id);

CREATE TABLE videoitem_tmp(
       item_id INTEGER UNIQUE REFERENCES item(id) ON DELETE CASCADE,
       title TEXT,
       duration INTEGER,
       format TEXT);

INSERT INTO videoitem_tmp SELECT item_id, title, duration, format FROM videoitem;
DROP TABLE videoitem;

ALTER TABLE videoitem_tmp RENAME TO videoitem;

CREATE INDEX videoitem_item_id_idx ON videoitem(item_id);</code></pre>
<h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><p><code>ALTER TABLE</code> 除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作</p>
<pre><code>ALTER TABLE database_name.table_name RENAME TO new_table_name;
ALTER TABLE database_name.table_name ADD COLUMN column_def...;</code></pre><h3 id="UPDATE-TABLE"><a href="#UPDATE-TABLE" class="headerlink" title="UPDATE TABLE"></a>UPDATE TABLE</h3><pre><code>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</code></pre><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>SELECT 语句用于从表中选取数据。结果被存储在一个结果表中（称为结果集）。</p>
<pre><code>SELECT 列名称 FROM 表名称
SELECT * FROM 表名称</code></pre><h3 id="INSERT-INFO"><a href="#INSERT-INFO" class="headerlink" title="INSERT INFO"></a>INSERT INFO</h3><pre><code>INSERT INTO 表名称 VALUES (值1, 值2,....)
INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</code></pre><h3 id="004"><a href="#004" class="headerlink" title="004"></a>004</h3><pre><code class="sql">ALTER TABLE stream ADD COLUMN title TEXT;
DELETE FROM videoitem;</code></pre>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 语句用于删除表中的行。</p>
<pre><code class="sql">DELETE FROM 表名称 WHERE 列名称 = 值
DELETE FROM table_name</code></pre>
<h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><pre><code>CREATE  TRIGGER trigger_name [BEFORE|AFTER] event_name ON table_name
BEGIN
-- Trigger logic goes here....
END;</code></pre><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><p>使用下面的命令来控制事务：</p>
<ul>
<li>BEGIN TRANSACTION：开始事务处理。</li>
<li>COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。</li>
<li>ROLLBACK：回滚所做的更改。</li>
</ul>
<p>事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">SQL 教程</a></li>
<li><a href="http://www.runoob.com/sqlite/sqlite-transaction.html" target="_blank" rel="noopener">SQLite 事务（Transaction)</a></li>
</ol>
]]></content>
      <categories>
        <category>Movian</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
        <tag>movian</tag>
        <tag>showtime</tag>
      </tags>
  </entry>
  <entry>
    <title>git-am-patch-different-repository</title>
    <url>/2017/07/20/git-am-patch-different-repository/</url>
    <content><![CDATA[<a id="more"></a>

<p>跨仓库使用patch</p>
<p>repo A</p>
<pre><code>git format-patch -1 xxxxxxxx
git format-patch HEAD^
git format-patch -M branch1/branch2</code></pre><p>repo B</p>
<pre><code>git am -3 0001.patch</code></pre><p>这种方式很容易导致冲突，尤其是<strong>新增、删除及重命名文件</strong>，使用如下方式</p>
<pre><code>git am --directory=&#39;platform/&#39; 0001.patch</code></pre><ul>
<li>—-directory=’platform’ 为repo A与repo B之间的差异</li>
</ul>
<p>–directory=<root></p>
<pre><code>Prepend &lt;root&gt; to all filenames.
If a &quot;-p&quot; argument was also passed, it is applied before prepending the new root.
For example, a patch that talks about updating a/git-gui.sh to b/git-gui.sh can be applied to the file in the working tree modules/git-gui/git-gui.sh by running git apply --directory=modules/git-gui.</code></pre>]]></content>
  </entry>
  <entry>
    <title>gcc-optimization</title>
    <url>/2017/07/03/gcc-optimization/</url>
    <content><![CDATA[<p><code>GCC</code> 优化级别 <code>-O</code> <code>-O1</code> <code>-O2</code> <code>-Os</code> <code>-03</code></p>
<p>-On(n＝0,1,2,3,也可以是其它单词)是gcc为了一般人方便而做的设定，根据n值大小包含预设标准由低到高的一些优化选项，均为-fxxx(xxx为优化项)，但注意，即使是最高优化选项-O3，也不是包含所有的-f选项，这只是为大多数人的使用方便而预设的。</p>
<a id="more"></a>

<h2 id="O-O1"><a href="#O-O1" class="headerlink" title="-O -O1"></a><code>-O</code> <code>-O1</code></h2><p>这两个命令的效果是一样的，目的都是在不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度。并开启如下的优化选项：</p>
<pre><code>-fauto-inc-dec 
-fbranch-count-reg 
-fcombine-stack-adjustments 
-fcompare-elim 
-fcprop-registers 
-fdce 
-fdefer-pop 
-fdelayed-branch 
-fdse 
-fforward-propagate 
-fguess-branch-probability 
-fif-conversion2 
-fif-conversion 
-finline-functions-called-once 
-fipa-pure-const 
-fipa-profile 
-fipa-reference 
-fmerge-constants 
-fmove-loop-invariants 
-freorder-blocks 
-fshrink-wrap 
-fshrink-wrap-separate 
-fsplit-wide-types 
-fssa-backprop 
-fssa-phiopt 
-fstore-merging 
-ftree-bit-ccp 
-ftree-ccp 
-ftree-ch 
-ftree-coalesce-vars 
-ftree-copy-prop 
-ftree-dce 
-ftree-dominator-opts 
-ftree-dse 
-ftree-forwprop 
-ftree-fre 
-ftree-phiprop 
-ftree-sink 
-ftree-slsr 
-ftree-sra 
-ftree-pta 
-ftree-ter 
-funit-at-a-time</code></pre><h2 id="O2"><a href="#O2" class="headerlink" title="-O2"></a><code>-O2</code></h2><p>该优化选项会牺牲部分编译速度，除了执行-O1所执行的所有优化之外，还会采用几乎所有的目标配置支持的优化算法，用以提高目标代码的运行速度。</p>
<pre><code>-fthread-jumps 
-falign-functions  -falign-jumps 
-falign-loops  -falign-labels 
-fcaller-saves 
-fcrossjumping 
-fcse-follow-jumps  -fcse-skip-blocks 
-fdelete-null-pointer-checks 
-fdevirtualize -fdevirtualize-speculatively 
-fexpensive-optimizations 
-fgcse  -fgcse-lm  
-fhoist-adjacent-loads 
-finline-small-functions 
-findirect-inlining 
-fipa-cp 
-fipa-cp-alignment 
-fipa-bit-cp 
-fipa-sra 
-fipa-icf 
-fisolate-erroneous-paths-dereference 
-flra-remat 
-foptimize-sibling-calls 
-foptimize-strlen 
-fpartial-inlining 
-fpeephole2 
-freorder-blocks-algorithm=stc 
-freorder-blocks-and-partition -freorder-functions 
-frerun-cse-after-loop  
-fsched-interblock  -fsched-spec 
-fschedule-insns  -fschedule-insns2 
-fstrict-aliasing -fstrict-overflow 
-ftree-builtin-call-dce 
-ftree-switch-conversion -ftree-tail-merge 
-fcode-hoisting 
-ftree-pre 
-ftree-vrp 
-fipa-ra</code></pre><h2 id="O3"><a href="#O3" class="headerlink" title="-O3"></a><code>-O3</code></h2><p>该选项除了执行-O2所有的优化选项之外，一般都是采取很多向量化算法，提高代码的并行执行程度，利用现代CPU中的流水线，Cache等。</p>
<pre><code>-finline-functions      // 采用一些启发式算法对函数进行内联
-funswitch-loops        // 执行循环unswitch变换
-fpredictive-commoning  // 
-fgcse-after-reload     //执行全局的共同子表达式消除
-ftree-loop-vectorize　  // 
-ftree-loop-distribute-patterns
-fsplit-paths 
-ftree-slp-vectorize
-fvect-cost-model
-ftree-partial-pre
-fpeel-loops 
-fipa-cp-clone options</code></pre><p><strong>这个选项会提高执行代码的大小，当然会降低目标代码的执行时间。</strong></p>
<h2 id="Os"><a href="#Os" class="headerlink" title="-Os"></a><code>-Os</code></h2><p>这个优化标识和-O3有异曲同工之妙，当然两者的目标不一样，-O3的目标是宁愿增加目标代码的大小，也要拼命的提高运行速度，但是这个选项是在-O2的基础之上，尽量的降低目标代码的大小，这对于存储容量很小的设备来说非常重要。为了降低目标代码大小，会禁用下列优化选项，一般就是压缩内存中的对齐空白(alignment padding)</p>
<pre><code>-falign-functions  
-falign-jumps  
-falign-loops 
-falign-labels
-freorder-blocks  
-freorder-blocks-algorithm=stc 
-freorder-blocks-and-partition  
-fprefetch-loop-arrays</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/lanmanck/article/details/5776173" target="_blank" rel="noopener">gcc 优化选项 -O1 -O2 -O3 -Os 优先级，-fomit-frame-pointer</a></li>
<li><a href="https://www.zhihu.com/question/27090458" target="_blank" rel="noopener">GCC中-O1 -O2 -O3 优化的原理是什么?</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>git-log</title>
    <url>/2017/06/28/git-log/</url>
    <content><![CDATA[<a id="more"></a>

<p>##</p>
<pre><code class="bash">git log --oneline
git log --merges --oneline
git log --no-merges --oneline</code></pre>
<h2 id="params"><a href="#params" class="headerlink" title="params"></a>params</h2><pre><code class="bash">--abbrev                                    -- set minimum SHA1 display-length
--abbrev                                    -- set minimum SHA1 display-length (for use with --abbrev-commit)
--abbrev-commit                             -- show only partial prefixes of commit object names
--after                   --since           -- show commits more recent than given date
--all                                       -- show all commits from refs
--all-match                                 -- limit commits to ones matching all --grep, --author, and --committer
--ancestry-path                             -- only display commits that exists directly on ancestry chains
--author                                    -- limit commits to those by given author
--author-date-order                         -- display commits in author date order
--before                  --until           -- show commits older than given date
--binary                                    -- in addition to --full-index, output binary diffs for git-apply
--bisect                                    -- pretend as if refs/bisect/bad --not refs/bisect/good-* was given on command line
--boundary                                  -- output uninteresting commits at boundary
--branches                                  -- show all commits from refs/heads
--break-rewrites                            -- break complete rewrite changes into pairs of given size
--cc                                        -- combined diff format for merge commits
--check                                     -- warn if changes introduce trailing whitespace or space/tab indents
--cherry                                    -- synonym for --right-only --cherry-mark --no-merges
--cherry-mark                               -- like --cherry-pick but mark equivalent commits instead of omitting them
--cherry-pick                               -- omit any commit that introduces the same change as another commit on &quot;the other side&quot;
--children                                  -- display children of commit
--color                                     -- show colored diff
--color-words                               -- show colored-word diff
--committer                                 -- limit commits to those by given committer
--count                                     -- display how many commits would have been listed
--date                                      -- format of date output
--date-order                                -- display commits in date order
--decorate                                  -- print out ref names of any commits that are shown
--default                                   -- use argument as default revision
--dense                                     -- only display selected commits, plus meaningful history
--diff-algorithm                            -- choose a diff algorithm
--diff-filter                               -- select certain kinds of files for diff
--dirstat                                   -- generate dirstat by amount of changes
--dirstat-by-file                           -- generate dirstat by number of files
--do-walk                                   -- only display given revs, traversing their ancestors
--dst-prefix                                -- use given prefix for destination
--early-output            --output          -- undocumented
--encoding                                  -- output log messages in given encoding
--exclude                                   -- do not include refs matching glob
--exit-code                                 -- report exit code 1 if differences, 0 otherwise
--ext-diff                                  -- allow external diff helper to be executed
--extended-regexp                           -- use POSIX extended regexps
--find-copies                               -- detect copies as well as renames with given scope
--find-copies-harder                        -- try harder to find copies
--find-renames                              -- Detect renames with given scope
--first-parent                              -- follow only first parent from merge commits
--fixed-strings                             -- do not interpret patterns as regexps
--follow                                    -- follow renames
--format                  --pretty          -- pretty print commit messages
--full-diff                                 -- show full commit diffs when using log -p, not only those affecting the given path
--full-history                              -- do not prune history
--full-index                                -- show full object name of pre- and post-image blob
--glob                                      -- show all commits from refs matching glob
--graph                                     -- display graphical representation of commit history
--grep                                      -- limit commits to those with log messages matching the given pattern
--grep-reflog                               -- limit commits to ones whose reflog message matches the given pattern (with -g, --walk-
--histogram                                 -- generate diffs with histogram algorithm
--ignore-all-space                          -- ignore white space when comparing lines
--ignore-blank-lines                        -- do not show hunks that add or remove blank lines
--ignore-missing                            -- ignore invalid object an ref names on command line
--ignore-space-at-eol                       -- ignore changes in whitespace at end of line
--ignore-space-change                       -- ignore changes in amount of white space
--ignore-submodules                         -- ignore changes to submodules
--inter-hunk-context                        -- combine hunks closer than n lines
--irreversible-delete                       -- omit the preimage for deletes
--left-only                                 -- list only commits on the left side of a symmetric range
--left-right                                -- mark which side of symmetric diff commit is reachable from
--log-size                                  -- print log message size in bytes before the message
--max-age                                   -- maximum age of commits to output
--max-count                                 -- maximum number of commits to display
--max-parents                               -- show only commits having at most &lt;n&gt; commits
--merge                                     -- after a failed merge, show refs that touch files having a conflict
--merges                                    -- display only merge commits
--min-age                                   -- minimum age of commits to output
--minimal                                   -- spend extra time to make sure the smallest possible diff is producedm
--min-parents                               -- show only commits having at least &lt;n&gt; commits
--name-only                                 -- show only names of changed files
--name-status                               -- show only names and status of changed files
--no-abbrev-commit        --no-abbrev       -- show the full 40-byte hexadecimal commit object name
--no-color                                  -- turn off colored diff
--no-decorate                               -- do not print out ref names of any commits that are shown
--no-ext-diff                               -- disallow external diff helper to be executed
--no-follow                                 -- do not follow renames
--no-max-parents          --no-min-parents  -- reset limit
--no-merges                                 -- do not display commits with more than one parent
--no-notes                                  -- do not show notes that annotate commit
--no-patch                                  -- suppress diff output
--no-prefix                                 -- do not show any source or destination prefix
--no-renames                                -- turn off rename detection
--not                                       -- reverses meaning of ^ prefix for revisions that follow
--notes                                     -- show notes that annotate commit, with optional ref argument show this notes ref instea
--no-textconv                               -- do not allow external text conversion filters to be run when comparing binary files
--no-walk                                   -- only display given revs, do not traverse their ancestors
--numstat                                   -- generate more machine-friendly diffstat
--objects                                   -- display object ids of objects referenced by listed commits
--objects-edge                              -- display object ids of objects referenced by listed and excluded commits
--oneline                                   -- shorthand for --pretty=oneline --abbrev-commit
--parents                                   -- display parents of commit
--patch                                     -- generate diff in patch format
--patch-with-raw                            -- generate patch but also keep the default raw diff output
--patch-with-stat                           -- generate patch and prepend its diffstat
--patience                                  -- generate diffs with patience algorithm
--pickaxe-all                               -- when -S finds a change, show all changes in that changeset
--pickaxe-regex                             -- treat argument of -S as regular expression
--quiet                                     -- disable all output
--raw                                       -- generate default raw diff output
--reflog                                    -- show all commits from reflogs
--regexp-ignore-case                        -- match regexps ignoring case
--relative                                  -- exclude changes outside and output relative to given directory
--relative-date                             -- show dates relative to current time
--remotes                                   -- show all commits from refs/remotes
--remove-empty                              -- stop when given path disappears from tree
--reverse                                   -- display commits in reverse order
--right-only                                -- list only commits on the right side of a symmetric range
--shortstat                                 -- generate summary diffstat
--show-linear-break                         -- show a barrier between commits from different branches
--show-signature                            -- validate GPG signature of commit
--simplify-by-decoration                    -- show only commits that are referenced by a ref
--simplify-merges                           -- milder version of --full-history
--skip                                      -- skip given number of commits before output
--source                                    -- show which ref each commit is reached from
--sparse                                    -- when paths are given, display only commits that changes any of them
--src-prefix                                -- use given prefix for source
--stat                                      -- generate diffstat instead of patch
--submodule                                 -- select output format for submodule differences
--summary                                   -- generate condensed summary of extended header information
--tags                                      -- show all commits from refs/tags
--text                                      -- treat all files as text
--textconv                                  -- allow external text conversion filters to be run when comparing binary files
--topo-order                                -- display commits in topological order
--unified                                   -- generate diff with given lines of context
--use-mailmap                               -- use mailmap file to map author and committer names and email
--walk-reflogs                              -- walk reflog entries from most recent to oldest
--word-diff                                 -- show word diff
--word-diff-regex                           -- specify what constitutes a word</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-doc</title>
    <url>/2017/06/28/git-doc/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://strivingboy.github.io/blog/2015/06/17/git-doc/" target="_blank" rel="noopener">高效使用Git</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-merge</title>
    <url>/2017/06/28/git-merge/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.jianshu.com/p/58a166f24c81" target="_blank" rel="noopener">git-merge完全解析</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-principle</title>
    <url>/2017/06/28/git-principle/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://coding.net/help/doc/practice/git-principle.html#conflicts" target="_blank" rel="noopener">使用原理视角看 Git</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-merge-and-git-rebase</title>
    <url>/2017/06/28/git-merge-and-git-rebase/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/witnessai1/article/details/68488545" target="_blank" rel="noopener">git merge 和 git rebase 的区别与分析</a></li>
<li><a href="http://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank" rel="noopener">git rebase vs git merge详解</a></li>
<li><a href="https://www.zhihu.com/question/36509119" target="_blank" rel="noopener">在开发过程中使用git rebase还是git merge，优缺点分别是什么?</a></li>
<li><a href="https://segmentfault.com/q/1010000000430041" target="_blank" rel="noopener">团队开发里频繁使用 git rebase 来保持树的整洁好吗?</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-ioctl-args</title>
    <url>/2017/06/14/linux-ioctl-args/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p><code>ioctl</code> 定义使用 <code>_IO</code> <code>_IOW</code>来处理整数和指针表现不一致，待查！！</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/dong_zhihong/article/details/8233295" target="_blank" rel="noopener">linux驱动之ioctl实现与传参</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git-flow</title>
    <url>/2017/05/29/git-flow/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git Flow工作流"></a>Git Flow工作流</h2><h2 id="git-flow脚本"><a href="#git-flow脚本" class="headerlink" title="git-flow脚本"></a>git-flow脚本</h2><p><code>[github](https://github.com/nvie/gitflow/commit/5bca8d9358f5b08af40ac32f289bb14b18965cec)</code></p>
<h2 id="gitflow-GUI"><a href="#gitflow-GUI" class="headerlink" title="gitflow GUI"></a>gitflow GUI</h2><ul>
<li>sourceTree</li>
<li>git-cola</li>
<li>GitEye</li>
<li>GITK</li>
<li>git-gui</li>
<li>QGit</li>
<li>giggle</li>
<li>tig</li>
<li>SmartGit</li>
<li>gitg</li>
<li>RabbitVCS</li>
<li>GitKraken</li>
<li>GitX</li>
<li>git-dag</li>
<li>Bazaar Explorer + bzr-git</li>
<li>TortoiseHg + hggit (best UI, hggit doesn’t work)</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/nvie/gitflow/commit/5bca8d9358f5b08af40ac32f289bb14b18965cec" target="_blank" rel="noopener">gitflow</a></li>
<li><a href="https://datasift.github.io/gitflow/IntroducingGitFlow.html" target="_blank" rel="noopener">Introducing GitFlow</a></li>
<li><a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="noopener">Git 在团队中的最佳实践–如何正确使用Git Flow</a></li>
<li><a href="https://unix.stackexchange.com/questions/48469/gui-for-git-similar-to-sourcetree" target="_blank" rel="noopener">GUI for GIT similar to SourceTree</a></li>
<li><a href="https://github.com/GSoft-SharePoint/Dynamite/wiki/Getting-started-with-SourceTree,-Git-and-git-flow" target="_blank" rel="noopener">Getting started with SourceTree, Git and git flow</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux-nfsroot-server-not-responding</title>
    <url>/2017/05/24/linux-nfsroot-server-not-responding/</url>
    <content><![CDATA[<pre><code>CMDLINE_VALUE = &quot;mem=64M console=ttyS0,115200 init=/init root=/dev/nfs rw nfsroot=192.168.111.238:/opt/nfs,v3,proto=tcp,nolock,rsize=4096,wsize=4096,intr ip=192.168.111.239:::255.255.254.0&quot;</code></pre><a id="more"></a>

<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><pre><code>nfs: server 192.168.111.238 not responding, still trying</code></pre><h2 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h2><p>因为NFS默认采用UDP进行传输中途容易丢包，所以修改成TCP进行传输问题解决</p>
<pre><code>proto=tcp</code></pre><p>This is a problem with NFS and 2.6 kernels, fast server NICs and<br>comparatively slower client NICs. This will show up when the server has<br>a 1000Mb card and the client a 100Mb, or when the server has a 100Mb<br>card and the client a 10Mb.</p>
<pre><code>rsize=4096,wsize=4096</code></pre><p>通过设定大的同时传输的数据块大小(bytes)，以提高NFS读写的速度。改变这些值时要当心，一些旧的linux内核和网卡在大的块大小不能正常工作</p>
<h2 id="nfsroot-c"><a href="#nfsroot-c" class="headerlink" title="nfsroot.c"></a>nfsroot.c</h2><p>Linux Kernel 2.6 nfsroot支持的参数：</p>
<pre><code>nfsroot=xxx</code></pre><pre><code>static match_table_t __initdata tokens = {                                    
    {Opt_port, &quot;port=%u&quot;},                                                    
    {Opt_rsize, &quot;rsize=%u&quot;},                                                  
    {Opt_wsize, &quot;wsize=%u&quot;},                                                  
    {Opt_timeo, &quot;timeo=%u&quot;},                                                  
    {Opt_retrans, &quot;retrans=%u&quot;},                                              
    {Opt_acregmin, &quot;acregmin=%u&quot;},                                            
    {Opt_acregmax, &quot;acregmax=%u&quot;},                                                                                                 
    {Opt_acdirmin, &quot;acdirmin=%u&quot;},                                            
    {Opt_acdirmax, &quot;acdirmax=%u&quot;},                                            
    {Opt_soft, &quot;soft&quot;},                                                       
    {Opt_hard, &quot;hard&quot;},                                                       
    {Opt_intr, &quot;intr&quot;},                                                       
    {Opt_nointr, &quot;nointr&quot;},                                                   
    {Opt_posix, &quot;posix&quot;},                                                     
    {Opt_noposix, &quot;noposix&quot;},                                                 
    {Opt_cto, &quot;cto&quot;},                                                         
    {Opt_nocto, &quot;nocto&quot;},                                                     
    {Opt_ac, &quot;ac&quot;},                                                           
    {Opt_noac, &quot;noac&quot;},                                                       
    {Opt_lock, &quot;lock&quot;},                                                       
    {Opt_nolock, &quot;nolock&quot;},                                                   
    {Opt_v2, &quot;nfsvers=2&quot;},                                                    
    {Opt_v2, &quot;v2&quot;},                                                           
    {Opt_v3, &quot;nfsvers=3&quot;},         
    {Opt_v3, &quot;v3&quot;},                                                           
    {Opt_udp, &quot;proto=udp&quot;},                                                   
    {Opt_udp, &quot;udp&quot;},                                                         
    {Opt_tcp, &quot;proto=tcp&quot;},                                                   
    {Opt_tcp, &quot;tcp&quot;},                                                         
    {Opt_acl, &quot;acl&quot;},                                                         
    {Opt_noacl, &quot;noacl&quot;},                                                     
    {Opt_err, NULL}                                                           
};                            </code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/wang328452854/article/details/51304217" target="_blank" rel="noopener">2440-NFS挂载网络共享目录</a></li>
<li><a href="http://bbs.21ic.com/icview-624427-1-1.html" target="_blank" rel="noopener">nfs:server 172.168.1.22 not responding,still trying问题解决方法</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux-meminfo</title>
    <url>/2017/05/23/linux-meminfo/</url>
    <content><![CDATA[<ul>
<li>单个进程的内存查看  cat /proc/[pid] 下面有几个文件： maps , smaps, status</li>
<li>查看整机内存使用情况的文件 /proc/meminfo</li>
</ul>
<p>linux下内存占用是一个比较复杂的概念，不能简单通过一个单一指标就判断某个程序“内存消耗”大小，原因有下面2点：</p>
<ul>
<li>进程所申请的内存不一定真正会被用到（malloc或mmap的实现）</li>
<li>真正用到了的内存也不一定是只有该进程自己在用 (比如动态共享库)</li>
</ul>
<a id="more"></a>

<h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><h2 id="smaps"><a href="#smaps" class="headerlink" title="smaps"></a>smaps</h2><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><h2 id="meminfo"><a href="#meminfo" class="headerlink" title="meminfo"></a>meminfo</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cnblogs.com/jiayy/p/3458076.html" target="_blank" rel="noopener">linux 内存查看方法：meminfo\maps\smaps\status 文件解析</a></li>
<li><a href="https://my.oschina.net/emptytimespace/blog/111492" target="_blank" rel="noopener">linux进程的内存使用解析</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux-proc-pid-status</title>
    <url>/2017/05/23/linux-proc-pid-status/</url>
    <content><![CDATA[<a id="more"></a>


<pre><code class="shell">[root@gx6602 /]# cat /proc/948/status 
Name:   out.elf
State:  S (sleeping)
Tgid:   948
Pid:    948
PPid:   1
TracerPid:      0
Uid:    0       0       0       0
Gid:    0       0       0       0
FDSize: 256
Groups:
VmPeak:   114756 kB
VmSize:    49220 kB
VmLck:         0 kB
VmHWM:      8056 kB
VmRSS:      8056 kB
VmData:    41252 kB
VmStk:        88 kB
VmExe:      6816 kB
VmLib:         0 kB
VmPTE:       124 kB
Threads:        42
SigQ:   0/512
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000001006
SigCgt: 000000018000c4f9
CapInh: 0000000000000000
CapPrm: fffffffffffffeff
CapEff: fffffffffffffeff
CapBnd: fffffffffffffeff
voluntary_ctxt_switches:        1003
nonvoluntary_ctxt_switches:     13</code></pre>
<ul>
<li>VmPeak: 当前进程运行过程中占用内存的峰值</li>
<li>VmSize: 进程现在正在占用的内存</li>
<li>VmLck: 进程已经锁住的物理内存的大小.锁住的物理内存不能交换到硬盘</li>
<li>VmHWM: 程序得到分配到物理内存的峰值</li>
<li>VmRSS: 程序现在使用的物理内存</li>
<li>VmData: 进程数据段的大小</li>
<li>VmStk: 进程堆栈段的大小</li>
<li>VmExe: 进程代码的大小</li>
<li>VmLib: 进程所使用LIB库的大小</li>
<li>VmPTE: 占用的页表的大小</li>
<li>Threads: 当前进程组线程个数</li>
<li>SigQ: 表示当前待处理信号的个数</li>
</ul>
<p>关于代码段,堆栈段,数据段:</p>
<ul>
<li>代码段可以为机器中运行同一程序的数个进程共享</li>
<li>堆栈段存放的是子程序（函数）的返回地址、子程序的参数及程序的局部变量</li>
<li>数据段则存放程序的全局变量、常数以及动态数据分配的数据空间（比如用malloc函数申请的内存）<br>与代码段不同，如果系统中同时运行多个相同的程序，它们不能使用同一堆栈段和数据段.</li>
</ul>
<p>注意:<br>堆栈段代表的是程序中的堆区(stack),堆区一般是编译器自动分配释放的.<br>我们用malloc申请的内存,它占用的其实是栈区(heap),栈区一般是程序员自已分配释放的,而栈区在这里属于数据段,所以我们看到上面测试程序通过调用malloc函数后,VmData一值有了很大的变化. </p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://my.oschina.net/aiguozhe/blog/125477" target="_blank" rel="noopener">解读/proc/$PID/status中各种参数</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux-proc-pid-intro</title>
    <url>/2017/05/23/linux-proc-pid-intro/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="#auxv">/proc/[pid]/auxv</a><br><a href="#cmdline">/proc/[pid]/cmdline</a><br><a href="#comm">/proc/[pid]/comm</a><br><a href="#cwd">/proc/[pid]/cwd</a><br><a href="#environ">/proc/[pid]/environ</a><br><a href="#exe">/proc/[pid]/exe</a><br><a href="#fd">/proc/[pid]/fd</a><br><a href="#latency">/proc/[pid]/latency</a><br><a href="#limits">/proc/[pid]/limits</a><br><a href="#maps">/proc/[pid]/maps</a><br><a href="#root">/proc/[pid]/root</a><br><a href="#stack">/proc/[pid]/stack</a><br><a href="#statm">/proc/[pid]/statm</a><br><a href="#syscall">/proc/[pid]/syscall</a><br><a href="#wchan">/proc/[pid]/wchan</a>  </p>
<h2 id="auxv"><a href="#auxv" class="headerlink" title="auxv"></a>auxv</h2><p><code>/proc/[pid]/auxv</code>包含传递给进程的<code>ELF</code>解释器信息，格式是每一项都是一个<code>unsigned long</code>长度的<code>ID</code>加上一个<code>unsigned long</code>长度的值。最后一项以连续的两个<code>0x00</code>开头。举例如下：  </p>
<pre><code># hexdump -x /proc/2948/auxv
0000000    0021    0000    0000    0000    0000    1a82    7ffd    0000
0000010    0010    0000    0000    0000    dbf5    1fc9    0000    0000
0000020    0006    0000    0000    0000    1000    0000    0000    0000
0000030    0011    0000    0000    0000    0064    0000    0000    0000
0000040    0003    0000    0000    0000    2040    4326    7f4a    0000
0000050    0004    0000    0000    0000    0038    0000    0000    0000
0000060    0005    0000    0000    0000    0009    0000    0000    0000
0000070    0007    0000    0000    0000    f000    4303    7f4a    0000
0000080    0008    0000    0000    0000    0000    0000    0000    0000
0000090    0009    0000    0000    0000    8e67    4327    7f4a    0000
00000a0    000b    0000    0000    0000    0000    0000    0000    0000
00000b0    000c    0000    0000    0000    0000    0000    0000    0000
00000c0    000d    0000    0000    0000    0000    0000    0000    0000
00000d0    000e    0000    0000    0000    0000    0000    0000    0000
00000e0    0017    0000    0000    0000    0000    0000    0000    0000
00000f0    0019    0000    0000    0000    3de9    1a80    7ffd    0000
0000100    001f    0000    0000    0000    4fe5    1a80    7ffd    0000
0000110    000f    0000    0000    0000    3df9    1a80    7ffd    0000
0000120    0000    0000    0000    0000    0000    0000    0000    0000
0000130</code></pre><p>解析这个文件可以参考这段<a href="http://www.wienand.org/junkcode/linux/read-auxv.c" target="_blank" rel="noopener">代码</a>。</p>
<h2 id="cmdline"><a href="#cmdline" class="headerlink" title="cmdline"></a>cmdline</h2><p><code>/proc/[pid]/cmdline</code>是一个只读文件，包含进程的完整命令行信息。如果这个进程是<code>zombie</code>进程，则这个文件没有任何内容。举例如下：    </p>
<pre><code># ps -ef | grep 2948
root       2948      1  0 Nov05 ?        00:00:04 /usr/sbin/libvirtd --listen

# cat /proc/2948/cmdline
/usr/sbin/libvirtd--listen</code></pre><h2 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h2><p><code>/proc/[pid]/comm</code>包含进程的命令名。举例如下：  </p>
<pre><code># cat /proc/2948/comm
libvirtd</code></pre><p>##cwd<br><code>/proc/[pid]/cwd</code>是进程当前工作目录的符号链接。举例如下：  </p>
<pre><code># ls -lt /proc/2948/cwd
lrwxrwxrwx 1 root root 0 Nov  9 12:14 /proc/2948/cwd -&gt; /</code></pre><h2 id="environ"><a href="#environ" class="headerlink" title="environ"></a>environ</h2><p><code>/proc/[pid]/environ</code>显示进程的环境变量。举例如下：  </p>
<pre><code># strings /proc/2948/environ
LANG=POSIX
LC_CTYPE=en_US.UTF-8
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
NOTIFY_SOCKET=@/org/freedesktop/systemd1/notify
LIBVIRTD_CONFIG=/etc/libvirt/libvirtd.conf
LIBVIRTD_ARGS=--listen
LIBVIRTD_NOFILES_LIMIT=2048</code></pre><h2 id="exe"><a href="#exe" class="headerlink" title="exe"></a>exe</h2><p><code>/proc/[pid]/exe</code>为实际运行程序的符号链接。举例如下：  </p>
<pre><code># ls -lt /proc/2948/exe
lrwxrwxrwx 1 root root 0 Nov  5 13:04 /proc/2948/exe -&gt; /usr/sbin/libvirtd</code></pre><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p><code>/proc/[pid]/fd</code>是一个目录，包含进程打开文件的情况。举例如下：  </p>
<pre><code># ls -lt /proc/3801/fd
total 0
lrwx------. 1 root root 64 Apr 18 16:51 0 -&gt; socket:[37445]
lrwx------. 1 root root 64 Apr 18 16:51 1 -&gt; socket:[37446]
lrwx------. 1 root root 64 Apr 18 16:51 10 -&gt; socket:[31729]
lrwx------. 1 root root 64 Apr 18 16:51 11 -&gt; socket:[34562]
lrwx------. 1 root root 64 Apr 18 16:51 12 -&gt; socket:[39978]
lrwx------. 1 root root 64 Apr 18 16:51 13 -&gt; socket:[34574]
lrwx------. 1 root root 64 Apr 18 16:51 14 -&gt; socket:[39137]
lrwx------. 1 root root 64 Apr 18 16:51 15 -&gt; socket:[39208]
lrwx------. 1 root root 64 Apr 18 16:51 16 -&gt; socket:[39221]
lrwx------. 1 root root 64 Apr 18 16:51 17 -&gt; socket:[41080]
lrwx------. 1 root root 64 Apr 18 16:51 18 -&gt; socket:[40014]
lrwx------. 1 root root 64 Apr 18 16:51 19 -&gt; socket:[34617]
lrwx------. 1 root root 64 Apr 18 16:51 20 -&gt; socket:[34620]
lrwx------. 1 root root 64 Apr 18 16:51 23 -&gt; socket:[42357]
lr-x------. 1 root root 64 Apr 18 16:51 3 -&gt; /dev/urandom
lrwx------. 1 root root 64 Apr 18 16:51 4 -&gt; socket:[37468]
lrwx------. 1 root root 64 Apr 18 16:51 5 -&gt; socket:[37471]
lrwx------. 1 root root 64 Apr 18 16:51 6 -&gt; socket:[289532]
lrwx------. 1 root root 64 Apr 18 16:51 7 -&gt; socket:[31728]
lrwx------. 1 root root 64 Apr 18 16:51 8 -&gt; socket:[37450]
lrwx------. 1 root root 64 Apr 18 16:51 9 -&gt; socket:[37451]
l-wx------. 1 root root 64 Apr 13 16:35 2 -&gt; /root/.vnc/localhost.localdomain:1.log</code></pre><p>目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。  </p>
<h2 id="latency"><a href="#latency" class="headerlink" title="latency"></a>latency</h2><p><code>/proc/[pid]/latency</code>显示哪些代码造成的延时比较大（使用这个<code>feature</code>，需要执行“<code>echo 1 &gt; /proc/sys/kernel/latencytop</code>”）。举例如下：  </p>
<pre><code># cat /proc/2948/latency
Latency Top version : v0.1
30667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d
8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc</code></pre><p>每一行前三个数字分别是后面代码执行的次数，总共执行延迟时间（单位是微秒）和最长执行延迟时间（单位是微秒），后面则是代码完整的调用栈。</p>
<h2 id="limits"><a href="#limits" class="headerlink" title="limits"></a>limits</h2><p><code>/proc/[pid]/limits</code>显示当前进程的资源限制。举例如下：  </p>
<pre><code># cat /proc/2948/limits
Limit                     Soft Limit           Hard Limit           Units
Max cpu time              unlimited            unlimited            seconds
Max file size             unlimited            unlimited            bytes
Max data size             unlimited            unlimited            bytes
Max stack size            8388608              unlimited            bytes
Max core file size        0                    unlimited            bytes
Max resident set          unlimited            unlimited            bytes
Max processes             6409                 6409                 processes
Max open files            1024                 4096                 files
Max locked memory         65536                65536                bytes
Max address space         unlimited            unlimited            bytes
Max file locks            unlimited            unlimited            locks
Max pending signals       6409                 6409                 signals
Max msgqueue size         819200               819200               bytes
Max nice priority         0                    0
Max realtime priority     0                    0
Max realtime timeout      unlimited            unlimited            us</code></pre><p><code>Soft Limit</code>表示<code>kernel</code>设置给资源的值，<code>Hard Limit</code>表示<code>Soft Limit</code>的上限，而<code>Units</code>则为计量单元。</p>
<h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><p><code>/proc/[pid]/maps</code>显示进程的内存区域映射信息。举例如下：  </p>
<pre><code># cat /proc/2948/maps
......
address                   perms offset  dev   inode                      pathname
7f4a2e2ad000-7f4a2e2ae000 rw-p 00006000 08:14 6505977                    /usr/lib64/sasl2/libsasldb.so.3.0.0
7f4a2e2ae000-7f4a2e2af000 ---p 00000000 00:00 0
7f4a2e2af000-7f4a2eaaf000 rw-p 00000000 00:00 0                          [stack:94671]
7f4a2eaaf000-7f4a2eab0000 ---p 00000000 00:00 0
7f4a2eab0000-7f4a2f2b0000 rw-p 00000000 00:00 0                          [stack:94670]
......
7f4a434d0000-7f4a434d5000 rw-p 0006e000 08:14 4292988                    /usr/sbin/libvirtd
7f4a4520a000-7f4a452f7000 rw-p 00000000 00:00 0                          [heap]
7ffd1a7e4000-7ffd1a805000 rw-p 00000000 00:00 0                          [stack]
7ffd1a820000-7ffd1a821000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</code></pre><p>其中注意的一点是<code>[stack:&lt;tid&gt;]</code>是线程的堆栈信息，对应于<code>/proc/[pid]/task/[tid]/</code>路径。  </p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p><code>/proc/[pid]/root</code>是进程根目录的符号链接。举例如下： </p>
<pre><code># ls -lt /proc/2948/root
lrwxrwxrwx 1 root root 0 Nov  9 12:14 /proc/2948/root -&gt; /</code></pre><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>/proc/[pid]/stack</code>显示当前进程的内核调用栈信息，只有内核编译时打开了<code>CONFIG_STACKTRACE</code>编译选项，才会生成这个文件。举例如下：  </p>
<pre><code># cat /proc/2948/stack
[&lt;ffffffff80168375&gt;] poll_schedule_timeout+0x45/0x60
[&lt;ffffffff8016994d&gt;] do_sys_poll+0x49d/0x550
[&lt;ffffffff80169abd&gt;] SyS_poll+0x5d/0xf0
[&lt;ffffffff804c16e7&gt;] system_call_fastpath+0x16/0x1b
[&lt;00007f4a41ff2c1d&gt;] 0x7f4a41ff2c1d
[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff</code></pre><h2 id="statm"><a href="#statm" class="headerlink" title="statm"></a>statm</h2><p><code>/proc/[pid]/statm</code>显示进程所占用内存大小的统计信息，包含七个值，度量单位是<code>page</code>（<code>page</code>大小可通过<code>getconf PAGESIZE</code>得到）。举例如下：  </p>
<pre><code># cat /proc/2948/statm  
72362 12945 4876 569 0 24665 0</code></pre><p>各个值含义：<br>    a）进程占用的总的内存；<br>    b）进程当前时刻占用的物理内存；<br>    c）同其它进程共享的内存；<br>    d）进程的代码段；<br>    e）共享库（从<code>2.6</code>版本起，这个值为<code>0</code>）；<br>    f）进程的堆栈；<br>    g）<code>dirty pages</code>（从<code>2.6</code>版本起，这个值为<code>0</code>）。  </p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p><code>/proc/[pid]/syscall</code>显示当前进程正在执行的系统调用。举例如下：  </p>
<pre><code># cat /proc/2948/syscall
7 0x7f4a452cbe70 0xb 0x1388 0xffffffffffdff000 0x7f4a4274a750 0x0 0x7ffd1a8033f0 0x7f4a41ff2c1d</code></pre><p>第一个值是系统调用号（<code>7</code>代表<code>poll</code>），后面跟着<code>6</code>个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为<code>-1</code>，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个“<code>running</code>”的字符串。</p>
<p>内核编译时打开了<code>CONFIG_HAVE_ARCH_TRACEHOOK</code>编译选项，才会生成这个文件。  </p>
<h2 id="wchan"><a href="#wchan" class="headerlink" title="wchan"></a>wchan</h2><p><code>/proc/[pid]/wchan</code>显示当进程<code>sleep</code>时，<code>kernel</code>当前运行的函数。举例如下：  </p>
<pre><code># cat /proc/2948/wchan
kauditd_thread</code></pre><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>VmData:    33980 kB<br>VmStk:        88 kB<br>VmExe:       320 kB<br>VmLib:      2044 kB</p>
<p>解释:<br>VmData:表示进程数据段的大小.<br>VmStk:表示进程堆栈段的大小.<br>VmExe:表示进程代码的大小.<br>VmLib:表示进程所使用LIB库的大小.</p>
<p>关于代码段,堆栈段,数据段:<br>代码段可以为机器中运行同一程序的数个进程共享<br>堆栈段存放的是子程序（函数）的返回地址、子程序的参数及程序的局部变量<br>数据段则存放程序的全局变量、常数以及动态数据分配的数据空间（比如用malloc函数申请的内存）<br>与代码段不同，如果系统中同时运行多个相同的程序，它们不能使用同一堆栈段和数据段.</p>
<p>注意:<br>堆栈段代表的是程序中的堆区(stack),堆区一般是编译器自动分配释放的.<br>我们用malloc申请的内存,它占用的其实是栈区(heap),栈区一般是程序员自已分配释放的,而栈区在这里属于数据段,所以我们看到上面测试程序通过调用malloc函数后,VmData一值有了很大的变化. </p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/NanXiao/gnu-linux-proc-pid-intro/blob/master/README.md" target="_blank" rel="noopener">gnu-linux-proc-pid-intro</a></li>
<li><a href="https://my.oschina.net/aiguozhe/blog/125477" target="_blank" rel="noopener">解读/proc/$PID/status中各种参数</a></li>
<li><a href="http://yuangeqingtian.blog.51cto.com/6994701/1214789" target="_blank" rel="noopener">linux 下/proc/pid文件内容详解</a></li>
<li><a href="http://smilejay.com/2012/05/proc_pic_stat/" target="_blank" rel="noopener">/proc/$PID/stat详解</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Linux Kernel Cmdline参数解析</title>
    <url>/2017/05/23/linux-kernel-cmdline/</url>
    <content><![CDATA[<p><code>__setup</code> 这条宏在<code>Linux Kernel</code> 中使用最多的地方就是定义处理 <code>Kernel</code> 的启动参数的函数及数据结构</p>
<a id="more"></a>

<h2 id="setup"><a href="#setup" class="headerlink" title="__setup"></a>__setup</h2><p>例如：</p>
<pre><code class="c">__setup(&quot;nfsroot=&quot;, nfs_root_setup);
__setup(&quot;fbcon=&quot;, fb_console_setup);
__setup(&quot;max_loop=&quot;, max_loop_setup);
__setup(&quot;synopGMAC=&quot;, options_setup);</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.linuxdiyf.com/linux/30813.html" target="_blank" rel="noopener">linux kernel的cmdline參数解析原理分析</a></li>
<li><a href="http://blog.csdn.net/fdaopeng/article/details/7895037" target="_blank" rel="noopener"> Linux __setup解析</a></li>
<li><a href="https://01.org/linuxgraphics/gfx-docs/drm/admin-guide/kernel-parameters.html" target="_blank" rel="noopener">The kernel’s command-line parameters</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cmdline</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 单中括号与双中括号区别</title>
    <url>/2017/05/22/shell-test/</url>
    <content><![CDATA[<pre><code class="bash">$type &#39;[&#39; &#39;[[&#39; &#39;test&#39;
[ is a shell builtin
[[ is a reserved word
test is a shell builtin</code></pre>
<p><code>[</code> 和 <code>test</code> 是 <code>Shell</code> 的内部命令，而 <code>[[</code> 是Shell的关键字</p>
<a id="more"></a>

<h2 id="和-test"><a href="#和-test" class="headerlink" title="[ 和 test"></a><code>[</code> 和 <code>test</code></h2><p><code>[</code> 和 <code>test</code> 是相等的</p>
<pre><code class="bash">$[ 2 &lt; 1 ] &amp;&amp; echo True || echo False
zsh: 没有那个文件或目录: 1
False</code></pre>
<p>它就和参数组合为一体被 shell 解释，那样比如 <code>&gt;</code> <code>&lt;</code> 就被 shell 解释为重定向符号</p>
<h2 id=""><a href="#" class="headerlink" title="[["></a><code>[[</code></h2><pre><code class="bash">x=1
y=1

$[ $x == 1 &amp;&amp; $y == 1 ] &amp;&amp; echo True || echo False
-bash: [: missing `]&#39;
False


$[[ $x == 1 &amp;&amp; $y == 1 ]] &amp;&amp; echo True || echo False
True


$[ $x == 1 -a $y == 1 ] &amp;&amp; echo True || echo False
True</code></pre>
<p>在 <code>[[</code> 中使用 <code>&amp;&amp;</code> 和 <code>||</code> 表示逻辑与和逻辑或。<code>[</code> 中使用 <code>-a</code> 和 <code>-o</code> 表示逻辑与和逻辑或</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 <code>[[ ... ]]</code> 条件判断结构，而不是 <code>[ ... ]</code>，能够防止脚本中的许多逻辑错误。<br>比如，<code>&amp;&amp;</code>、<code>||</code>、<code>&lt;</code>和<code>&gt;</code> 操作符能够正常存在于<code>[[ ]]</code>条件判断结构中，<br>但是如果出现在<code>[ ]</code>结构中的话，会报错。比如可以直接使用<code>if [[ $a != 1 &amp;&amp; $a != 2 ]]</code><br>如果不使用双括号, 则为<code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ]</code>或者<code>if [ $a -ne 1 -a $a != 2 ]</code></p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-cpu-percent-calculate</title>
    <url>/2017/05/19/linux-cpu-percent-calculate/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.coolee.me/linux-cpu-percent-calculate.html" target="_blank" rel="noopener">Linux下cpu利用率计算方法</a></li>
<li><a href="http://www.blogjava.net/fjzag/articles/317773.html" target="_blank" rel="noopener">Linux平台Cpu使用率的计算</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Linux下/proc/pid/maps文件分析</title>
    <url>/2017/05/19/linux-proc-maps/</url>
    <content><![CDATA[<p><code>pmap</code>用于输出<code>/proc/pid/maps</code>信息</p>
<a id="more"></a>

<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><pre><code>[root@gx6602 /]# cat /proc/943/maps 
00008000-0075b000 r-xp 00000000 00:0b 2224823    /dvb/out.elf
0075b000-00867000 rw-p 00752000 00:0b 2224823    /dvb/out.elf
00867000-00b05000 rwxp 00867000 00:00 0          [heap]
2aaa8000-2aaa9000 r-xp 2aaa8000 00:00 0          [vdso]
2aaaa000-2e6aa000 rw-s 94400000 00:0c 725        /dev/gxav0
2e6aa000-2e6ab000 ---p 2e6aa000 00:00 0 
2e6ab000-2e7aa000 rw-p 2e6ab000 00:00 0 
2e7aa000-2e7ab000 ---p 2e7aa000 00:00 0 
2e7ab000-2e8aa000 rw-p 2e7ab000 00:00 0 
2e8aa000-2e8ab000 ---p 2e8aa000 00:00 0 
2e8ab000-2e9aa000 rw-p 2e8ab000 00:00 0 
2e9aa000-2e9ab000 ---p 2e9aa000 00:00 0 
2e9ab000-2eaaa000 rw-p 2e9ab000 00:00 0 
2eaaa000-2eaab000 ---p 2eaaa000 00:00 0 
2eaab000-2ebaa000 rw-p 2eaab000 00:00 0 
2ebaa000-2ebab000 ---p 2ebaa000 00:00 0 
2ebab000-2ecaa000 rw-p 2ebab000 00:00 0 
2ecaa000-2ecab000 ---p 2ecaa000 00:00 0 
2ecab000-2edaa000 rw-p 2ecab000 00:00 0 
2edaa000-2edab000 ---p 2edaa000 00:00 0 
2edab000-2eeaa000 rw-p 2edab000 00:00 0 
2eeaa000-2eeab000 ---p 2eeaa000 00:00 0 
2eeab000-2f0f1000 rw-p 2eeab000 00:00 0 
2f0f1000-2f0f2000 ---p 2f0f1000 00:00 0 
2f0f2000-2f1f1000 rw-p 2f0f2000 00:00 0 
2f1f1000-2f1f2000 ---p 2f1f1000 00:00 0 
2f1f2000-2f2f1000 rw-p 2f1f2000 00:00 0 
2f2f1000-2f2f2000 ---p 2f2f1000 00:00 0 
2f2f2000-2f3f1000 rw-p 2f2f2000 00:00 0 
2f3f1000-2f3f2000 ---p 2f3f1000 00:00 0 
2f3f2000-2f4f1000 rw-p 2f3f2000 00:00 0 
2f4f1000-2f4f2000 ---p 2f4f1000 00:00 0 
2f4f2000-2f5f1000 rw-p 2f4f2000 00:00 0 
2f5f1000-2f5f2000 ---p 2f5f1000 00:00 0 
2f5f2000-2f6f1000 rw-p 2f5f2000 00:00 0 
2f6f1000-2f6f2000 ---p 2f6f1000 00:00 0 
2f6f2000-2f7f1000 rw-p 2f6f2000 00:00 0 
2f7f1000-2f7f2000 ---p 2f7f1000 00:00 0 
2f7f2000-2f8f1000 rw-p 2f7f2000 00:00 0 
2f8f1000-2f8f2000 ---p 2f8f1000 00:00 0 
2f8f2000-2f9f1000 rw-p 2f8f2000 00:00 0 
2f9f1000-2f9f2000 ---p 2f9f1000 00:00 0 
2f9f2000-2faf1000 rw-p 2f9f2000 00:00 0 
2faf1000-2faf2000 ---p 2faf1000 00:00 0 
2faf2000-2fbf1000 rw-p 2faf2000 00:00 0 
2fbf1000-2fbf2000 ---p 2fbf1000 00:00 0 
2fbf2000-2fcf1000 rw-p 2fbf2000 00:00 0 
2fcf1000-2fcf2000 ---p 2fcf1000 00:00 0 
2fcf2000-2fdf1000 rw-p 2fcf2000 00:00 0 
2fdf1000-2fdf2000 ---p 2fdf1000 00:00 0 
2fdf2000-2fef1000 rw-p 2fdf2000 00:00 0 
2fef1000-2fef2000 ---p 2fef1000 00:00 0 
2fef2000-2fff1000 rw-p 2fef2000 00:00 0 
2fff1000-2fff2000 ---p 2fff1000 00:00 0 
2fff2000-301e1000 rw-p 2fff2000 00:00 0 
301e1000-301e2000 ---p 301e1000 00:00 0 
301e2000-302e1000 rw-p 301e2000 00:00 0 
302e1000-302e2000 ---p 302e1000 00:00 0 
302e2000-303e1000 rw-p 302e2000 00:00 0 
303e1000-303e2000 ---p 303e1000 00:00 0 
303e2000-304e1000 rw-p 303e2000 00:00 0 
304e1000-304e2000 ---p 304e1000 00:00 0 
304e2000-307e2000 rw-p 304e2000 00:00 0 
307e2000-307e3000 ---p 307e2000 00:00 0 
307e3000-308e2000 rw-p 307e3000 00:00 0 
308e2000-308e3000 ---p 308e2000 00:00 0 
308e3000-309e2000 rw-p 308e3000 00:00 0 
309e2000-309e3000 ---p 309e2000 00:00 0 
309e3000-30ae2000 rw-p 309e3000 00:00 0 
7f91c000-7f931000 rwxp 7ffe2000 00:00 0          [stack]</code></pre><pre><code>[root@gx6602 /]# ./pmap 943
/dvb/out.elf(943)
00008000 (7500 KB)     r-xp (00:0b 2224823)  /dvb/out.elf
0075b000 (1072 KB)     rw-p (00:0b 2224823)  /dvb/out.elf
00867000 (2680 KB)     rwxp (00:00 0)        [heap]
2aaa8000 (4 KB)        r-xp (00:00 0)        [vdso]
2aaaa000 (61440 KB)    rw-s (00:0c 725)      /dev/gxav0
2e6aa000 (4 KB)        ---p (00:00 0)        
2e6ab000 (1020 KB)     rw-p (00:00 0)        
2e7aa000 (4 KB)        ---p (00:00 0)        
2e7ab000 (1020 KB)     rw-p (00:00 0)        
2e8aa000 (4 KB)        ---p (00:00 0)        
2e8ab000 (1020 KB)     rw-p (00:00 0)        
2e9aa000 (4 KB)        ---p (00:00 0)        
2e9ab000 (1020 KB)     rw-p (00:00 0)        
2eaaa000 (4 KB)        ---p (00:00 0)        
2eaab000 (1020 KB)     rw-p (00:00 0)        
2ebaa000 (4 KB)        ---p (00:00 0)        
2ebab000 (1020 KB)     rw-p (00:00 0)        
2ecaa000 (4 KB)        ---p (00:00 0)        
2ecab000 (1020 KB)     rw-p (00:00 0)        
2edaa000 (4 KB)        ---p (00:00 0)        
2edab000 (1020 KB)     rw-p (00:00 0)        
2eeaa000 (4 KB)        ---p (00:00 0)        
2eeab000 (2328 KB)     rw-p (00:00 0)        
2f0f1000 (4 KB)        ---p (00:00 0)        
2f0f2000 (1020 KB)     rw-p (00:00 0)        
2f1f1000 (4 KB)        ---p (00:00 0)        
2f1f2000 (1020 KB)     rw-p (00:00 0)        
2f2f1000 (4 KB)        ---p (00:00 0)        
2f2f2000 (1020 KB)     rw-p (00:00 0)        
2f3f1000 (4 KB)        ---p (00:00 0)        
2f3f2000 (1020 KB)     rw-p (00:00 0)        
2f4f1000 (4 KB)        ---p (00:00 0)        
2f4f2000 (1020 KB)     rw-p (00:00 0)        
2f5f1000 (4 KB)        ---p (00:00 0)        
2f5f2000 (1020 KB)     rw-p (00:00 0)        
2f6f1000 (4 KB)        ---p (00:00 0)        
2f6f2000 (1020 KB)     rw-p (00:00 0)        
2f7f1000 (4 KB)        ---p (00:00 0)        
2f7f2000 (1020 KB)     rw-p (00:00 0)        
2f8f1000 (4 KB)        ---p (00:00 0)        
2f8f2000 (1020 KB)     rw-p (00:00 0)        
2f9f1000 (4 KB)        ---p (00:00 0)        
2f9f2000 (1020 KB)     rw-p (00:00 0)        
2faf1000 (4 KB)        ---p (00:00 0)        
2faf2000 (1020 KB)     rw-p (00:00 0)        
2fbf1000 (4 KB)        ---p (00:00 0)        
2fbf2000 (1020 KB)     rw-p (00:00 0)        
2fcf1000 (4 KB)        ---p (00:00 0)        
2fcf2000 (1020 KB)     rw-p (00:00 0)        
2fdf1000 (4 KB)        ---p (00:00 0)        
2fdf2000 (1020 KB)     rw-p (00:00 0)        
2fef1000 (4 KB)        ---p (00:00 0)        
2fef2000 (1020 KB)     rw-p (00:00 0)        
2fff1000 (4 KB)        ---p (00:00 0)        
2fff2000 (1980 KB)     rw-p (00:00 0)        
301e1000 (4 KB)        ---p (00:00 0)        
301e2000 (1020 KB)     rw-p (00:00 0)        
302e1000 (4 KB)        ---p (00:00 0)        
302e2000 (1020 KB)     rw-p (00:00 0)        
303e1000 (4 KB)        ---p (00:00 0)        
303e2000 (1020 KB)     rw-p (00:00 0)        
304e1000 (4 KB)        ---p (00:00 0)        
304e2000 (3072 KB)     rw-p (00:00 0)        
307e2000 (4 KB)        ---p (00:00 0)        
307e3000 (1020 KB)     rw-p (00:00 0)        
308e2000 (4 KB)        ---p (00:00 0)        
308e3000 (1020 KB)     rw-p (00:00 0)        
309e2000 (4 KB)        ---p (00:00 0)        
309e3000 (1020 KB)     rw-p (00:00 0)        
7f91c000 (84 KB)       rwxp (00:00 0)        [stack]
mapped:   109868 KB writable/private: 40796 KB shared: 61440 KB</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps" target="_blank" rel="noopener">Understanding Linux /proc/id/maps</a></li>
<li><a href="http://www.voidcn.com/blog/mldxs/article/p-804954.html" target="_blank" rel="noopener">linux /proc/pid/maps 信息分析</a></li>
<li><a href="http://zhuqihan0123.blog.163.com/blog/static/63414304201502611633196/" target="_blank" rel="noopener">Linux下 /proc/maps 文件分析</a></li>
<li><a href="https://github.com/cbbrowne/pmap" target="_blank" rel="noopener">pmap</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>proc</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB回溯调试</title>
    <url>/2017/05/19/gdb-reverse-debug/</url>
    <content><![CDATA[<ul>
<li>reverse-continue 反向运行程序知道遇到一个能使程序中断的事件（比如断点，观察点，异常）</li>
<li>reverse-step 反向运行程序到上一次被执行的源代码行</li>
<li>reverse-stepi 反向运行程序到上一条机器指令</li>
<li>reverse-next 反向运行到上一次被执行的源代码行，但是不进入函数</li>
<li>reverse-nexti 反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、整个函数将会被反向执行</li>
<li>reverse-finish 反向运行程序回到调用当前函数的地方</li>
<li>set exec-direction [forward | reverse] 设置程序运行方向，可以用平常的命令step和continue等来执行反向的调试命令</li>
</ul>
<p><strong>上面的反向运行也可以理解为撤销后面运行的语句所产生的效果，回到以前的状态</strong></p>
<p><strong>!!! 必须确认平台支持<code>record</code>功能</strong></p>
<pre><code class="gdb">(gdb)record
Process record: the current architecture doesn&#39;t support record function.</code></pre>
<p>仆街！！！</p>
<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/yusiguyuan/article/details/28480691" target="_blank" rel="noopener">GDB回溯调试技术</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>GDB多线程调试</title>
    <url>/2017/05/19/gdb-with-multithreads/</url>
    <content><![CDATA[<ul>
<li>set follow-fork-mode [parent|child]</li>
<li>set detach-on-fork [on|off]</li>
<li>set print thread-events [on|off]</li>
<li>set scheduler-locking [off|on|step]</li>
<li>thread apply [all|IDS] command </li>
<li>thread apply ID1 ID2 command</li>
<li>break test.c:123 thread all</li>
<li>info threads</li>
<li>thread ID</li>
</ul>
<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/Threads.html" target="_blank" rel="noopener">Debugging Programs with Multiple Threads</a></li>
<li><a href="http://blog.csdn.net/yusiguyuan/article/details/28487315" target="_blank" rel="noopener">GDB调试多线程</a></li>
<li><a href="http://love.junzimu.com/archives/1933" target="_blank" rel="noopener">GDB调试信号、多线程、多进程</a></li>
<li><a href="http://www.jianshu.com/p/0b0be78e3e1c" target="_blank" rel="noopener">gdb调试多线程 如何解死锁问题</a></li>
<li><a href="https://typecodes.com/cseries/multilprocessthreadgdb.html" target="_blank" rel="noopener">Linux多进程和多线程的一次gdb调试实例</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb命令进阶</title>
    <url>/2017/05/19/get-stack-of-allthreads/</url>
    <content><![CDATA[<p>获取所有线程堆栈：</p>
<pre><code class="gdb">(gdb) thread apply all bt</code></pre>
<a id="more"></a>

<h2 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h2><p>可以在<code>C</code>代码中使用<code>backtrace</code>来获取线程堆栈，但是需要<code>glibc</code>支持</p>
<h2 id="thread-apply"><a href="#thread-apply" class="headerlink" title="thread apply"></a>thread apply</h2><pre><code class="gdb">&#39;thread apply [thread-id-list]|[all] args&#39;, a command to apply a command to a list of threads</code></pre>
<h2 id="thread-scheduler"><a href="#thread-scheduler" class="headerlink" title="thread scheduler"></a>thread scheduler</h2><pre><code class="gdb">set scheduler-locking off|on|step </code></pre>
<ul>
<li>off 不锁定任何线程，也就是所有线程都执行，这是默认值</li>
<li>on 只有当前被调试程序会执行</li>
<li>step 在单步的时候，除了next过一个函数的情况<br>(<strong>熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为</strong>)以外，只有当前线程会执行</li>
</ul>
<pre><code class="gdb">set print thread-events off|on</code></pre>
<p>线程产生通知开关</p>
<h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><pre><code class="gdb">break foo if x&gt;0
    commands
    printf “x is %d/n”,x
    continue
    end</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>linux</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-git</title>
    <url>/2017/05/17/2016-git/</url>
    <content><![CDATA[<h2 id="update-git"><a href="#update-git" class="headerlink" title="update git"></a>update git</h2><pre><code>sudo add-apt-repository ppa:git-core/ppa
$ sudo apt-get update
$ sudo apt-get install git</code></pre><a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://linux.cn/article-8419-1.html" target="_blank" rel="noopener">2016 Git 新视界</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>glibc-backtrace</title>
    <url>/2017/05/16/glibc-backtrace/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cppblog.com/aaxron/archive/2013/04/17/199511.html" target="_blank" rel="noopener">Linux下利用backtrace追踪函数调用堆栈以及定位段错误</a></li>
<li><a href="http://www.cnblogs.com/lanyuliuyun/p/3815266.html" target="_blank" rel="noopener">Linux下手动获取当前调用栈</a></li>
<li><a href="http://blog.sae.sina.com.cn/archives/2147" target="_blank" rel="noopener">在Linux程序中输出函数调用栈</a></li>
<li><a href="http://hutaow.com/blog/2013/10/11/dump-stack-with-backtrace/" target="_blank" rel="noopener">在Linux程序中输出函数调用栈</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>pthread-head-file</title>
    <url>/2017/05/16/pthread-head-file/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://m.2cto.com/kf/201608/543268.html" target="_blank" rel="noopener">获取任意线程调用栈的那些事</a></li>
<li><a href="http://blog.csdn.net/yangkuanqaz85988/article/details/52403726" target="_blank" rel="noopener">Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</a></li>
<li><a href="http://blog.csdn.net/hslinux/article/details/7951065" target="_blank" rel="noopener">pthread 简要使用指南（五） 线程属性(pthread_attr_t)</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>signal-and-sigaction</title>
    <url>/2017/05/16/signal-and-sigaction/</url>
    <content><![CDATA[<h2 id="OSCAM"><a href="#OSCAM" class="headerlink" title="OSCAM"></a>OSCAM</h2><p>参考<code>OSCAM</code>中对信号的处理</p>
<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cnblogs.com/phpgo/p/5813867.html" target="_blank" rel="noopener">Linux进程间通信（一）： 信号 signal()、sigaction()</a></li>
<li><a href="http://blog.csdn.net/jnu_simba/article/details/8947410" target="_blank" rel="noopener">linux系统编程之信号（四）：信号的捕捉与sigaction函数</a></li>
<li><a href="http://blog.csdn.net/jnu_simba/article/details/8947410" target="_blank" rel="noopener">信号的捕捉与sigaction函数</a></li>
<li><a href="http://stackoverflow.com/questions/33848558/catching-sigterm-in-c" target="_blank" rel="noopener">Catching SIGTERM in C</a></li>
<li><a href="https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=3&ved=0ahUKEwju7OyI7vPTAhVFUrwKHVx7C1oQFgg3MAI&url=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Flinux%2Fl-cn-signalsec%2F&usg=AFQjCNEQowozYOqu851srl62uBYEEcuoIQ&sig2=j40b1nCLHgXffldkHDXd4g" target="_blank" rel="noopener">Linux 多线程应用中如何编写安全的信号处理函数</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>embedded-linux-reboot-with-busybox</title>
    <url>/2017/05/16/embedded-linux-reboot-with-busybox/</url>
    <content><![CDATA[<pre><code class="busybox">run_shutdown_and_kill_processes(void)</code></pre>
<pre><code>arch/csky/gx3xxx/config.c

void __init config_BSP(void)                                                  
{                                                                             
    mach_time_init = gx3201_timer_init;                                       
    mach_tick = gx3201_tick;                                                  
    mach_hwclk = gx3201_hwclk;                                                
    mach_init_IRQ = gx3xxx_init_IRQ;                                          
    mach_gettimeoffset = gx3201_timer_offset;                                 
    mach_get_auto_irqno = gx3201_get_irqno;                                   

    mach_reset = gx3xxx_restart;                                              
    mach_halt = gx3xxx_halt;                                                                                                       
}                    </code></pre><a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/wavemcu/article/details/8544333" target="_blank" rel="noopener">基于Linux与Busybox的Reboot命令流程分析</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git-diff技巧</title>
    <url>/2017/05/09/git-diff/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="git-difftool"><a href="#git-difftool" class="headerlink" title="git difftool"></a>git difftool</h2><pre><code class="bash">git difftool -t meld -y branch1 branch2
git difftool -t meld -y commitId1  commitId2
git difftool -t meld -y HEAD</code></pre>
<h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p><code>~/.gitconfig</code></p>
<pre><code class=".gitconfig">[diff]
    tool = meld
[difftool]
    prompt = false

[merge]
    tool = jellybc3
[mergetool]
    prompt = false</code></pre>
<p>git支持的比较工具列表：</p>
<ul>
<li>bc3</li>
<li>kdiff3</li>
<li>kompare</li>
<li>tkdiff</li>
<li>meld</li>
<li>xxdiff</li>
<li>emerge</li>
<li>vimdiff</li>
<li>gvimdiff</li>
<li>ecmerge</li>
<li>diffuse</li>
<li>opendiff</li>
<li>p4merge</li>
<li>araxis</li>
</ul>
<h2 id="bc3"><a href="#bc3" class="headerlink" title="bc3"></a>bc3</h2><pre><code>[diff]
    tool = bc3
[difftool]
    prompt = false
[merge]
    tool = bc3
[mergetool]
    prompt = false</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>查看diff</p>
<pre><code>git difftool</code></pre><p>使用bc解决冲突</p>
<pre><code>git mergetool</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/offbye/article/details/6592563" target="_blank" rel="noopener"> Git diff代码比较的高级技巧 </a></li>
<li><a href="http://wonderffee.github.io/blog/2013/10/06/recommend-a-visual-diff-tool-p4merge-for-git-in-macos/" target="_blank" rel="noopener">推荐Git可视化比较工具P4Merge</a></li>
<li><a href="http://www.cnblogs.com/sinojelly/archive/2011/08/07/2130173.html" target="_blank" rel="noopener">Git下使用Beyond Compare作为比较和合并工具</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-subtree</title>
    <url>/2017/03/31/git-subtree/</url>
    <content><![CDATA[<a id="more"></a>



<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.atlassian.com/blog/git/alternatives-to-git-submodule-git-subtree" target="_blank" rel="noopener">Git subtree: the alternative to Git submodule</a></li>
<li><a href="https://medium.com/@v/git-subtrees-a-tutorial-6ff568381844" target="_blank" rel="noopener">git subtrees: a tutorial</a></li>
<li><a href="http://aoxuis.me/post/2013-08-06-git-subtree" target="_blank" rel="noopener">使用git subtree集成项目到子目录</a></li>
<li><a href="http://delai.me/code/git-subtree/" target="_blank" rel="noopener">用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>apply-git-patch-from-one-repository-to-another</title>
    <url>/2017/03/31/apply-git-patch-from-one-repository-to-another/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="生成补丁"><a href="#生成补丁" class="headerlink" title="生成补丁"></a>生成补丁</h2><p>两个分支之间的差异补丁：</p>
<pre><code>git format-patch -M v1.9.6-4-rc3/v1.9.6-4-rc1</code></pre><p>会生成从<code>rc1</code> 到 <code>rc3</code> 的patch列表</p>
<h2 id="apply-patch"><a href="#apply-patch" class="headerlink" title="apply patch"></a>apply patch</h2><pre><code>git am -3 -k file.patch</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.atlassian.com/blog/git/alternatives-to-git-submodule-git-subtree" target="_blank" rel="noopener">Git subtree: the alternative to Git submodule</a></li>
<li><a href="https://medium.com/@v/git-subtrees-a-tutorial-6ff568381844" target="_blank" rel="noopener">git subtrees: a tutorial</a></li>
<li><a href="http://stackoverflow.com/questions/3816040/git-apply-changes-introduced-by-commit-in-one-repo-to-another-repo" target="_blank" rel="noopener">git: Apply changes introduced by commit in one repo to another repo</a></li>
<li><a href="https://git.wiki.kernel.org/index.php/GitTips#How_to_compare_two_local_repositories" target="_blank" rel="noopener">GitTips</a></li>
<li><a href="http://stackoverflow.com/questions/28192623/create-patch-or-diff-file-from-git-repository-and-apply-it-to-another-different" target="_blank" rel="noopener">Create patch or diff file from git repository and apply it to another different git repository</a></li>
<li><a href="http://stackoverflow.com/questions/931882/how-to-apply-a-git-patch-from-one-repository-to-another" target="_blank" rel="noopener">How to apply a git patch from one repository to another?</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux下FAT32格式u盘只读的问题及解决方法</title>
    <url>/2017/03/28/fat32-file-system-panic/</url>
    <content><![CDATA[<pre><code>[ 1721.840000] FAT: Filesystem panic (dev sda)
[ 1721.850000]     fat_free_clusters: deleting FAT entry beyond EOF
[ 1721.850000]     File system has been set read-only
remove_file,592:/media/sda/GxPvr/HD Phx Chinese Channel_20170328023426 no write permissions
remount
/dev/sda
/media/sda
[ 1722.410000] FAT: utf8 is not a recommended IO charset for FAT filesystems, filesystem will be case sensitive!
remount udisk!!!
[ 1722.570000] FAT: Filesystem panic (dev sda)
[ 1722.570000]     fat_get_cluster: invalid cluster chain (i_pos 0)
[ 1722.580000]     File system has been set read-only</code></pre><a id="more"></a>

<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><pre><code>$ mount
/dev/mmcblk0p4 on /mnt/sd type vfat (ro,relatime,fmask=0000,dmask=0000,allow_utime=0022,codepage=cp437,iocharset=cp936)  
/dev/mmcblk0p4 on /home/sd type vfat (ro,relatime,fmask=0000,dmask=0000,allow_utime=0022,codepage=cp437,iocharset=cp936)  

$ mount -o remount,rw /dev/mmcblk0p4

$ sudo /sbin/fsck.vfat /dev/sda5
dosfsck 2.11, 12 Mar 2005, FAT32, LFN
/Harsh.Times[2005]DvDrip[Eng]-aXXo/Harsh.Times[2005]DvDrip[Eng]-aXXo.avi
  File size is 446693376 bytes, cluster chain length is &gt; 446693376 bytes.
  Truncating file to 446693376 bytes.
Free cluster summary wrong (1284873 vs. really 1282508)
1) Correct
2) Don&#39;t correct
? 1
Leaving file system unchanged.
/dev/sda5: 1642 files, 213082/1495590 clusters</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cnblogs.com/lidabo/p/5630522.html" target="_blank" rel="noopener">linux下FAT32格式u盘只读的问题及解决方法</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>fat32</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb-disassemble</title>
    <url>/2017/03/20/gdb-disassemble/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="堆栈信息"><a href="#堆栈信息" class="headerlink" title="堆栈信息"></a>堆栈信息</h2><pre><code>(cskygdb) bt
#0  0x003cfd6a in GxAVWaitEvents (dev=5, module=8, event_mask=1, timeout_us=500000, event=0x2f3325c8) at av/avapi.c:146
#1  0x002bb7d2 in GxBus_SiFilterQuery ()
#2  0x002b9c82 in GxSiServiceConsole ()
#3  0x002b883c in sched_console_thread ()
#4  0x003c88e0 in default_thread_function (arg=0x63b640) at os/linux/osapi.c:428
#5  0x003d8ca0 in ?? ()

(cskygdb) bt full

(cskygdb) info f 0
Stack frame at 0x2f3325c8:
 pc = 0x3cfd6a in GxAVWaitEvents (av/avapi.c:146); saved pc 0x2bb7d2
 called by frame at 0x2f3325f8
 source language c.
 Arglist at 0x2f3325a8, args: dev=5, module=8, event_mask=1, timeout_us=500000, event=0x2f3325c8
 Locals at 0x2f3325a8, Previous frame&#39;s sp is 0x2f3325c8</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>断点 <code>b *GxAVWaitEvents</code>，reg如下：</p>
<pre><code>i r
r0             0x2f3325c8    0x2f3325c8
r1             0x58    88
r2             0x5    5                   //param 0
r3             0x8    8                   //param 1
r4             0x1    1                   //param 2
r5             0x7a120    500000          //param 3
r6             0x2f3325c8    791881160   //param 4
r7             0x6257f0    6445040
r8             0x0    0
r9             0x60da00    6347264
r10            0x0    0
r11            0x621928    6428968
r12            0x0    0
r13            0x0    0
r14            0x2f332608    791881224
r15            0x2bb7d2    2865106         //last frame pc
pc             0x3cfd6a    0x3cfd6a &lt;GxAVWaitEvents+2&gt;
epc            0x0    0
psr            0x1064141    17187137
epsr           0x0    0</code></pre><pre><code>(cskygdb) disassemble GxAVWaitEvents
Dump of assembler code for function GxAVWaitEvents:
                                            //r0 0x2f3325c8
=&gt; 0x003cfd68 &lt;+0&gt;:    subi    r0, r0, 32      //r0 0x2f3325a8
   0x003cfd6a &lt;+2&gt;:    st    r15, (r0, 24)       //last frame pc push
End of assembler dump.

(cskygdb) help disassemble
Disassemble a specified section of memory.
Default is the function surrounding the pc of the selected frame.
With a /m modifier, source lines are included (if available).
With a /r modifier, raw instructions in hex are included.
With a single argument, the function surrounding that address is dumped.
Two arguments (separated by a comma) are taken as a range of memory to dump,
  in the form of &quot;start,end&quot;, or &quot;start,+length&quot;.

(cskygdb) disassemble /m GxAVWaitEvents</code></pre><h2 id="常用反汇编调试命令"><a href="#常用反汇编调试命令" class="headerlink" title="常用反汇编调试命令"></a>常用反汇编调试命令</h2><ul>
<li>b *func 断点在 <code>func</code> 入栈之前</li>
<li>ni/si 汇编指令级单步执行</li>
<li>disassemble func 反汇编 func</li>
<li>disassemble /m func 反汇编 func，带有源代码信息</li>
<li>disassemble $pc-20,$pc+20 反汇编执行区间代码</li>
<li>watch *(int *)0x8049aa4 内存读写断点</li>
<li>rwatch *(int *)0x8049aa4 内存读断点</li>
<li>awatch *(int *)0x8049aa4 内存读写断点</li>
<li>display /i $pc 显示当前汇编指令</li>
<li>info r 查看寄存器</li>
<li>i r rx 查看rx寄存器</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>disassemble</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-memory-space</title>
    <url>/2017/03/17/linux-memory-space/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://os.51cto.com/art/201205/333728.htm" target="_blank" rel="noopener">Linux进程地址空间的探究解析</a></li>
<li><a href="http://blog.csdn.net/yusiguyuan/article/details/45155035" target="_blank" rel="noopener">Linux进程地址空间 &amp;&amp; 进程内存布局</a></li>
<li><a href="http://www.choudan.net/2013/10/24/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0(%E4%B8%80).html" target="_blank" rel="noopener">Linux进程地址空间学习</a></li>
<li><a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">Linux虚拟地址空间布局</a></li>
<li><a href="http://ilinuxkernel.com/?p=1013" target="_blank" rel="noopener">Linux内核高端内存</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-kernel-memory-access/" target="_blank" rel="noopener">从 Linux 内核访问用户空间内存</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Linux内存使用与性能优化</title>
    <url>/2017/03/17/linux-memory-optimization/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://ticktick.blog.51cto.com/823160/817545" target="_blank" rel="noopener">读书笔记：嵌入式Linux内存使用与性能优化</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>mprotect</title>
    <url>/2017/03/17/mprotect/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://blog.finaltheory.me/research/mprotect.html" target="_blank" rel="noopener">libmemguard: 排查内存异常访问bug的终极利器</a></li>
<li><a href="http://blog.csdn.net/xiaoyur347/article/details/8069225" target="_blank" rel="noopener">linux栈溢出检测</a></li>
<li><a href="https://www.gnu.org/software/libsigsegv/" target="_blank" rel="noopener">GNU libsigsegv</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>AddressSanitizer</title>
    <url>/2017/03/17/AddressSanitizer/</url>
    <content><![CDATA[<p>AddressSanitizer (aka ASan) is a memory error detector for C/C++. It finds:</p>
<ul>
<li>Use after free (dangling pointer dereference)</li>
<li>Heap buffer overflow</li>
<li>Stack buffer overflow</li>
<li>Global buffer overflow</li>
<li>Use after return</li>
<li>Use after scope</li>
<li>Initialization order bugs</li>
<li>Memory leaks</li>
</ul>
<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">AddressSanitizer</a></li>
<li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags" target="_blank" rel="noopener">AddressSanitizerFlags</a></li>
<li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerCallStack" target="_blank" rel="noopener">AddressSanitizerCallStack</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>AddressSanitizer</tag>
      </tags>
  </entry>
  <entry>
    <title>如何排查大型C程序中的内存写越界导致的coredump</title>
    <url>/2017/03/17/overflow-and-coredump/</url>
    <content><![CDATA[<p>转载自知乎<a href="https://www.zhihu.com/question/51735480" target="_blank" rel="noopener">如何排查大型C程序中的内存写越界导致的coredump</a></p>
<a id="more"></a>
]]></content>
      <categories>
        <category>C</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>overflow</tag>
        <tag>coredump</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc-add2line</title>
    <url>/2017/03/17/gcc-add2line/</url>
    <content><![CDATA[<p>在 <code>JTAG</code> 中执行 <code>info symbol &lt;ptr&gt;</code>，等价与 <code>add2line -e out.elf &lt;ptr&gt;</code></p>
<a id="more"></a>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/ljeagle/article/details/7206503" target="_blank" rel="noopener">打败Linux系统中的Bug</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>add2line</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc-stack-protector</title>
    <url>/2017/03/17/gcc-stack-protector/</url>
    <content><![CDATA[<ul>
<li>-fstack-protector 只为局部变量中包含长度超过8-byte(含)的char数组的函数插入保护代码</li>
<li>-fstack-protector-strong 满足以下三个条件都会插入保护代码：<ol>
<li>局部变量的地址作为赋值语句的右值或函数参数</li>
<li>局部变量包含数组类型的局部变量，不管数组的长度</li>
<li>带register声明的局部变量</li>
</ol>
</li>
</ul>
<p>Linux系统中存在着三种类型的栈：</p>
<ol>
<li>应用程序栈：工作在Ring3,由应用程序来维护；</li>
<li>内核进程上下文栈：工作在Ring0，由内核在创建线程的时候创建；</li>
<li>内核中断上下文栈：工作在Ring0，在内核初始化的时候给每个CPU核心创建一个。</li>
</ol>
<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://my.oschina.net/macwe/blog/610357" target="_blank" rel="noopener">解读Linux安全机制之栈溢出保护</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/" target="_blank" rel="noopener">GCC 中的编译器堆栈保护技术</a></li>
<li><a href="http://www.geekfan.net/7570/" target="_blank" rel="noopener">如何利用GCC编译选项检测栈溢出</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>softbreakpoint-and-hardbreakpoint</title>
    <url>/2017/03/15/softbreakpoint-and-hardbreakpoint/</url>
    <content><![CDATA[<ul>
<li>硬件断点：硬断点需要硬件寄存器提供支持，断点的数目受Embedded ICE中的Watchpoint数目的限制，但是可以在任何地方设置断点</li>
<li>软件断点：软件断点通过在运行起来的程序中设置特征值实现，其数目不受限制，但是一般情况下软件断点只能在可写的存储器的地址中设置（比如：RAM），而不能在ROM（比如：Flash）中设置</li>
</ul>
<a id="more"></a>

<h2 id="info-symbol-ptr"><a href="#info-symbol-ptr" class="headerlink" title="info symbol ptr"></a>info symbol ptr</h2><pre><code class="log">Feb 22 13:28:27 serverXX kernel: [1953364.275653] gm[16356]: segfault at 0 ip 00007fd137bd41e0 sp 00007fff5770dcd0 error 6 in libGraphicsMagick.so.3.7.0[7fd1379b9000+29d000]</code></pre>
<pre><code class="gdb">(gdb) info symbol 0x21B1E0
WriteOnePNGImage + 13648 in section .text</code></pre>
<pre><code>root@XXX:~# nm vmlinux | grep xx
0000000000104650 T AccessCacheViewPixels
0000000000104700 T AccessDefaultCacheView
00000000000ea030 T AccessDefinition
00000000001061e0 T AccessImmutableIndexes
0000000000106170 T AccessMutableIndexes
[...]
0000000000210d50 T RegisterJP2Image
0000000000213170 T RegisterPNGImage
0000000000210cf0 T UnregisterJP2Image
0000000000213110 T UnregisterPNGImage</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/macrossdzh/article/details/6898928" target="_blank" rel="noopener">硬断点和软断点的区别</a></li>
<li><a href="http://blog.chinaunix.net/uid-21977330-id-3257174.html" target="_blank" rel="noopener">JLink + Vmware调试linux内核</a></li>
<li><a href="http://oenhan.com/jprobe-hw-breakpoint" target="_blank" rel="noopener">内核调试方法:Jprobe与硬件断点</a></li>
<li><a href="http://blog.csdn.net/_xiao/article/details/40619797" target="_blank" rel="noopener">程序中如何给自己设置硬件断点（通过程序代码设置数据断点而不使用JTAG）</a></li>
<li><a href="http://coredump.io/blog/2012/02/23/debugging-segfaults-from-logs-to-gdb/" target="_blank" rel="noopener">Debugging segfaults from logs to gdb</a></li>
<li><a href="http://blog.csdn.net/heli007/article/details/7187586" target="_blank" rel="noopener">使用gdb调试linux内核</a></li>
<li><a href="http://oenhan.com/gdb-principle" target="_blank" rel="noopener">gdb工作原理和内核实现</a></li>
<li><a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">用GDB调试程序</a></li>
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/" target="_blank" rel="noopener">Debugging with GDB</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>linux</tag>
        <tag>hardbreakpoint</tag>
        <tag>softbreakpoint</tag>
      </tags>
  </entry>
  <entry>
    <title>图解git</title>
    <url>/2017/03/15/git-theory/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://huanglei.me/git-theory.html" target="_blank" rel="noopener">用图片分析学习git原理</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git图示所有分支的历史</title>
    <url>/2017/03/15/gitk-with-all-branchs/</url>
    <content><![CDATA[<ul>
<li>gitk –all</li>
<li>gitk –all -d</li>
</ul>
<a id="more"></a>



<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cnblogs.com/chucklu/p/4748394.html" target="_blank" rel="noopener">git图示所有分支的历史</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitk</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 git-svn 和 git-filter-branch 整理svn版本库</title>
    <url>/2017/03/15/svn-migrate-with-git-svn/</url>
    <content><![CDATA[<p>SVN 本身提供了如下版本库整理工具：</p>
<pre><code>svnadmin dump
svndumpfilter include
svndumpfilter exclude
svnadmin load</code></pre><a id="more"></a>


<ul>
<li>svnadmin dump 将整个版本库或部分提交导出为一个导出文件</li>
<li>svndumpfilter 基于配置项的路径（SVN 1.7的 svndumpfilter 还支持通配符路径）对导出文件进行过滤， 过滤结果保存为新的导出文件</li>
<li>svnadmin load 将导出文件导入到另外的版本库中， 导入过程有两个选择——维持路径不变，或导入到某个路径之下。</li>
</ul>
<p>相对于Git提供的用于整理提交的 git filter-branch 命令，SVN的版本库整理工具能做的实在不多。<br>而且SVN的相关工具容错性太差，操作过程经常被中断，可谓步步惊心。</p>
<p>最近遇到的一个案例，需要将两个 SVN 版本库（bar 和 baz）的全部历史导入到另外一个 SVN 版本库（foo）中。<br>并要求版本库 bar 和 baz 的目录结构统一采用 foo 中规定的目录结构。<br>面对要导入的近 20GB 数据（绝大部分是Word、Excel、PDF文档），决定采用Git提供的工具集进行SVN版本库整理。<br>整理过程和过程中开发的脚本记录如下。</p>
<h2 id="将-bar-和-baz-版本库转换为本地Git库"><a href="#将-bar-和-baz-版本库转换为本地Git库" class="headerlink" title="将 bar 和 baz 版本库转换为本地Git库"></a>将 bar 和 baz 版本库转换为本地Git库</h2><p>以 bar 为例，将两个版本库（bar 和 baz）转换为本地的 Git 版本库，<br>以便使用强大的 git filter-branch 命令对提交逐一进行修改（如修改版本库中的文件路径）。</p>
<pre><code>$ git init git/bar
$ cd git/bar
$ git svn init --no-metadata file:///path/to/svn/bar
$ git svn fetch</code></pre><p>说明：</p>
<pre><code>SVN 版本库 bar 位于本机的路径 /path/to/svn/bar 下。
导出的 Git 版本库位于 git/bar 目录下。
因为版本库 bar 并未使用分支（未采用 trunk、branches、tags目录结构），因此执行 git svn 时并未使用 -s 等参数。</code></pre><h2 id="源版本库中文件名过长的问题"><a href="#源版本库中文件名过长的问题" class="headerlink" title="源版本库中文件名过长的问题"></a>源版本库中文件名过长的问题</h2><p>Windows和Linux下文件名长度限制不同，前者255个Unicode字符，后者为255个字节。<br>在此次转换中就遇到 bar 版本库中存在若干文件名超长的文件，导致无法在 Linux 平台上检出。<br>为避免后续操作中出现错误，对其进行重命名。</p>
<p>首先创建一个脚本 rename.sh，该脚本将提供给 git filter-branch 命令对版本库中超长文件名进行重命名操作。</p>
<pre><code>#!/bin/sh

git ls-files -s | \
sed \
    -e &quot;s#\(\t.*/file-name-is-too-long\).*\.pdf#\1-blahblah.pdf#&quot;  \
| GIT_INDEX_FILE=$GIT_INDEX_FILE.new git update-index --index-info &amp;&amp; \
mv &quot;$GIT_INDEX_FILE.new&quot; &quot;$GIT_INDEX_FILE&quot;</code></pre><p>然后执行下面命令对版本库整理：</p>
<pre><code>$ cd git/bar
$ git filter-branch --index-filter &#39;sh /path/to/rename.sh&#39;</code></pre><h2 id="删除空白提交"><a href="#删除空白提交" class="headerlink" title="删除空白提交"></a>删除空白提交</h2><p>从SVN转换的Git版本库可能存在空白提交，例如一些仅修改了SVN属性的提交不被 git-svn 支持，转换成了空提交。<br>这些空提交会对后续操作造成干扰，执行如下命令删除空白提交：</p>
<pre><code>$ cd git/bar
$ git  filter-branch -f --commit-filter &#39;
  if [ &quot;$(git rev-parse $GIT_COMMIT^^{tree} 2&gt;/dev/null)&quot; = &quot;$(git rev-parse $GIT_COMMIT^{tree})&quot; ];
  then
      skip_commit &quot;$@&quot;;
  else
      git commit-tree &quot;$@&quot;;
  fi&#39; HEAD</code></pre><h2 id="向Git日志中添加MetaData"><a href="#向Git日志中添加MetaData" class="headerlink" title="向Git日志中添加MetaData"></a>向Git日志中添加MetaData</h2><p>执行 git log 操作可以看到转换后的提交保持了原有SVN提交的用户名和提交时间，还记录了对应SVN的提交编号信息。<br>但是后续操作（git svn dcommit）会改变Git提交，破坏其中包含的原有SVN提交的提交者和提交时间，<br>因此需要用其他方法将这些信息记录下来，以便补救。</p>
<p>使用 git filter-branch 的 –msg-filter 过滤器逐一向提交插入原有SVN的提交者和提交时间的元信息。</p>
<pre><code>$ cd git/bar
$ git filter-branch -f --msg-filter &#39;
  cat &amp;&amp;
  echo &quot;From: REPO-NAME, author: $GIT_AUTHOR_NAME, date: $GIT_AUTHOR_DATE&quot;&#39; HEAD</code></pre><h2 id="根据需要对版本库目录重新组织"><a href="#根据需要对版本库目录重新组织" class="headerlink" title="根据需要对版本库目录重新组织"></a>根据需要对版本库目录重新组织</h2><p>git filter-branch 至少有两个过滤器可以对提交中的目录和文件进行组织。<br>一个是 –tree-filter ， 一个是 –index-filter 。前者的过滤器脚本写起来简单，但执行起来较后者慢至少一个数量级。</p>
<p>根据路径转换的需求，编写过滤器脚本，如脚本 transform.sh ：</p>
<pre><code>#!/bin/sh

if test -z &quot;$GIT_INDEX_FILE&quot;; then
    GIT_INDEX_FILE=.git/index
fi

git ls-files -s | \
sed \
    -e &quot;s#\(\t\)#\1new-root/#&quot;  \
    -e &quot;s#\(\tnew-root\)\(/old-path-1/\)#\1/new-path-1/#&quot; \
    -e &quot;s#\(\tnew-root\)\(/old-path-2/\)#\1/new-path-2/#&quot; \
    -e &quot;s#\(\tnew-root\)\(/old-path-3/\)#\1/new-path-3/#&quot; \
| GIT_INDEX_FILE=$GIT_INDEX_FILE.new git update-index --index-info &amp;&amp; \
mv &quot;$GIT_INDEX_FILE.new&quot; &quot;$GIT_INDEX_FILE&quot;</code></pre><p>然后执行如下命令对提交进行逐一过滤，将老的目录结构转换为新的目录结构：</p>
<pre><code>$ cd git/bar
$ git filter-branch --index-filter &#39;sh /path/to/transform.sh&#39;</code></pre><h2 id="用git-svn克隆目标版本库（foo）"><a href="#用git-svn克隆目标版本库（foo）" class="headerlink" title="用git-svn克隆目标版本库（foo）"></a>用git-svn克隆目标版本库（foo）</h2><p>执行如下命令将导入的目标版本库转换为本地的 Git 版本库，如下：</p>
<pre><code>$ git init git/foo
$ cd git/foo
$ git svn init --no-metadata file:///path/to/svn/foo
$ git svn fetch</code></pre><p>然后将 bar 整理好的分支变基到当前的 master 分支上：</p>
<pre><code>$ cd git/foo
$ git fetch ../../git/bar
$ git branch bar/master FETCH_HEAD
$ git co bar/master
$ git rebase -k --onto master --root</code></pre><p>说明：</p>
<pre><code>使用 -k 参数，执行效率更高，因为会直接调用 cherry-pick 进行变基，而不需要执行 git format-patch 命令将提交预先转换为补丁文件。</code></pre><p>在执行过程中遇到冲突中断的情况，这时需要解决冲突后执行：</p>
<pre><code>$ git cherry-pick --continue</code></pre><p>然后执行如下命令将不在SVN版本库中的Git提交提交到SVN版本库 foo 中。</p>
<pre><code>$ git svn dcommit --rmdir </code></pre><p>说明：</p>
<pre><code>使用 --rmdir 命令是为了避免在 SVN 版本库中残留由于目录移动产生的空目录。
使用 git svn dcommit 在SVN版本库中创建的新提交，其提交者是当前登录用户，提交时间是当前时间。 即新的SVN提交丢失了原有SVN提交的用户名和时间信息。马上利用之前在提交说明中添加的元信息进行补救。</code></pre><h2 id="修正提交时间和提交者"><a href="#修正提交时间和提交者" class="headerlink" title="修正提交时间和提交者"></a>修正提交时间和提交者</h2><p>编写如下脚本 parse-git-log.rb，读取Git日志对元信息进行处理。</p>
<pre><code>#!/usr/bin/ruby

require &#39;date&#39;

def to_iso8601(date)
    if date =~ /^[0-9]{10}/
      DateTime.strptime(date, &#39;%s&#39;).iso8601.gsub(/\+[0-9]*:[0-9]*$/, &#39;.000000Z&#39;)
    else
      raise &quot;Error: wrong date format: #{date}&quot;
    end
end

def parse_git_log(io)
  svndict={}
  commit, author, date, log, rev = []
  io.each_line do |line|
    line.strip!
    if line =~ /^commit ([0-9a-f]{40})/
      commit = $1
      author, date, log, rev = []
    elsif line =~ /^From: .*, author: (.*), date: @([0-9]+)/
      author = $1
      date = $2
    elsif line =~ /git-svn-id: .+@([0-9]+) .*/
      rev = $1
      if author.nil? or author.empty?
        STDERR.puts &quot;Warning: no author for commit: #{commit}&quot;
        next
      elsif date.nil? or date.empty?
        STDERR.puts &quot;Warning: no author for commit: #{commit}&quot;
        next
      end
      svndict[rev] = {}
      svndict[rev][:author] = author
      svndict[rev][:date] = to_iso8601 date
    end
  end
  svndict
end

url = &#39;file:///path/to/svn/foo&#39;
svndict = {}

if ARGV.size == 1
  if File.exist? ARGV[0]
    File.open(ARGV[0]) do |io|
      svndict = parse_git_log io
    end
  else
    STDERR.puts &quot;Read git log from STDIN&quot;
    url = ARGV[0]
    svndict = parse_git_log STDIN
  end
else
  puts &lt;&lt;-EOF
  Usage:
      #{File.basename $0} git-log.txt
      #{File.basename $0} url-of-svn &lt; git-log.txt
  EOF
  exit 0
end

svndict.keys.map{|x| x.to_i}.sort.reverse.each do |rev|
  author = svndict[rev.to_s][:author]
  date = svndict[rev.to_s][:date]
  puts &quot;svn ps --revprop -r #{rev} svn:date   \&quot;#{date}\&quot; #{url}&quot;
  puts &quot;svn ps --revprop -r #{rev} svn:author \&quot;#{author}\&quot; #{url}&quot;
end</code></pre><p>然后执行如下命令，读取Git日志，将Git提交中的元信息转换为修正 SVN 提交历史的命令脚本 fix-svn-log.sh。</p>
<pre><code>$ cd git/foo
$ git log | ruby parse-git-log.rb file:///path/to/svn/foo &gt; fix-svn-log.sh</code></pre><p>然后执行如下命令修改 SVN 的属性，还原原有SVN的提交用户和提交实现信息：</p>
<pre><code>$ sh fix-svn-log.sh</code></pre><p>因为此操作实际上执行 svn ps –revprop 命令，需要SVN版本库 foo 中创建一个可执行的 pre-revprop-change 钩子脚本。</p>
<p>至此版本库转换完毕。怎么样 git filter-branch 命令够强大吧。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.worldhello.net/2014/04/24/svn-migrate-with-git-svn.html" target="_blank" rel="noopener">ref</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</title>
    <url>/2017/03/10/linux-stacks/</url>
    <content><![CDATA[<p>转载自(<a href="http://kyang.cc/)[http://kyang.cc/]" target="_blank" rel="noopener">http://kyang.cc/)[http://kyang.cc/]</a></p>
<p><code>Linux</code> 中有各种栈，进程栈、线程栈、内核栈、中断栈，讲述这几种栈的作用及位置</p>
<p>进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，Linux 内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制 <code>RLIMIT_STACK</code> (一般为 8M)，我们可以通过 <code>ulimit</code> 来查看或更改 <code>RLIMIT_STACK</code> 的值。</p>
<a id="more"></a>

<h1 id="栈是什么？栈有什么作用？"><a href="#栈是什么？栈有什么作用？" class="headerlink" title="栈是什么？栈有什么作用？"></a>栈是什么？栈有什么作用？</h1><p>首先，栈 (stack) 是一种串列形式的 数据结构。这种数据结构的特点是 后入先出 (LIFO, Last In First Out)，数据只能在串列的一端 (称为：栈顶 top) 进行 推入 (push) 和 弹出 (pop) 操作。根据栈的特点，很容易的想到可以利用数组，来实现这种数据结构。但是本文要讨论的并不是软件层面的栈，而是硬件层面的栈。</p>
<p>大多数的处理器架构，都有实现硬件栈。有专门的栈指针寄存器，以及特定的硬件指令来完成 入栈/出栈 的操作。例如在 ARM 架构上，R13 (SP) 指针是堆栈指针寄存器，而 PUSH 是用于压栈的汇编指令，POP 则是出栈的汇编指令。</p>
<p>栈作用可以从两个方面体现：<strong>函数调用</strong> 和 <strong>多任务支持</strong></p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>我们知道一个函数调用有以下三个基本过程：</p>
<ul>
<li>调用参数的传入</li>
<li>局部变量的空间管理</li>
<li>函数返回</li>
</ul>
<p>函数的调用必须是高效的，而数据存放在 <code>CPU通用寄存器</code> 或者 <code>RAM 内存</code> 中无疑是最好的选择。以传递调用参数为例，我们可以选择使用 CPU通用寄存器 来存放参数。但是通用寄存器的数目都是有限的，当出现函数嵌套调用时，子函数再次使用原有的通用寄存器必然会导致冲突。因此如果想用它来传递参数，那在调用子函数前，就必须先 <code>保存原有寄存器的值</code>，然后当子函数退出的时候再 <code>恢复原有寄存器的值</code>。</p>
<p>函数的调用参数数目一般都相对少，因此通用寄存器是可以满足一定需求的。但是局部变量的数目和占用空间都是比较大的，再依赖有限的通用寄存器未免强人所难，因此我们可以采用某些 RAM 内存区域来存储局部变量。但是存储在哪里合适？既不能让函数嵌套调用的时候有冲突，又要注重效率。</p>
<p>这种情况下，栈无疑提供很好的解决办法：</p>
<ol>
<li>对于通用寄存器传参的冲突，我们可以再调用子函数前，将通用寄存器临时压入栈中；在子函数调用完毕后，在将已保存的寄存器再弹出恢复回来</li>
<li>而局部变量的空间申请，也只需要向下移动下栈顶指针；将栈顶指针向回移动，即可就可完成局部变量的空间释放</li>
<li>对于函数的返回，也只需要在调用子函数前，将返回地址压入栈中，待子函数调用结束后，将函数返回地址弹出给 PC 指针，即完成了函数调用的返回</li>
</ol>
<p>于是上述函数调用的三个基本过程，就演变记录一个栈指针的过程。每次函数调用的时候，都配套一个栈指针。即使循环嵌套调用函数，只要对应函数栈指针是不同的，也不会出现冲突。</p>
<p>典型函数栈帧：</p>
<p><img src="/images/linux/stack-frame.jpg" alt="Stack Frame"></p>
<h2 id="多任务支持"><a href="#多任务支持" class="headerlink" title="多任务支持"></a>多任务支持</h2><p>栈的意义还不只是函数调用，有了它的存在，才能构建出操作系统的多任务模式。</p>
<h1 id="Linux-中有几种栈？各种栈的内存位置？"><a href="#Linux-中有几种栈？各种栈的内存位置？" class="headerlink" title="Linux 中有几种栈？各种栈的内存位置？"></a>Linux 中有几种栈？各种栈的内存位置？</h1><p>内核将栈分成四种：</p>
<ul>
<li>进程栈</li>
<li>线程栈</li>
<li>内核栈</li>
<li>中断栈</li>
</ul>
<h2 id="进程栈"><a href="#进程栈" class="headerlink" title="进程栈"></a>进程栈</h2><p>进程栈是属于用户态栈，和进程 <strong>虚拟地址空间 (Virtual Address Space)</strong> 密切相关。那我们先了解下什么是虚拟地址空间：在 32 位机器下，虚拟地址空间大小为 4G。这些虚拟地址通过页表 (Page Table) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (MMU) 硬件引用。<strong>每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间</strong>。</p>
<p>Linux 内核将这 4G 字节的空间分为两部分，将最高的 1G 字节（0xC0000000-0xFFFFFFFF）供内核使用，称为 <strong>内核空间</strong>。而将较低的3G字节（0x00000000-0xBFFFFFFF）供各个进程使用，称为 <strong>用户空间</strong>。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用。</p>
<p><img src="/images/linux/virtual-addr-space.jpg" alt="Virtual Address Space"></p>
<p>Linux 对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成 (Memory Segment)，主要的内存段如下：</p>
<ul>
<li>程序段 (Text Segment)：可执行文件代码的内存映射</li>
<li>数据段 (Data Segment)：可执行文件的已初始化全局变量的内存映射</li>
<li>BSS段 (BSS Segment)：未初始化的全局变量或者静态变量（用零页初始化）</li>
<li>堆区 (Heap) : 存储动态内存分配，匿名的内存映射</li>
<li>栈区 (Stack) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等</li>
<li>映射段(Memory Mapping Segment)：任何内存映射文件</li>
</ul>
<p><img src="/images/linux/spaces.jpg" alt="Virtual Address Space"></p>
<p><strong>而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈</strong>。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，Linux 内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制 RLIMIT_STACK (一般为 8M)，我们可以通过 ulimit 来查看或更改 RLIMIT_STACK 的值。</p>
<h3 id="如何确定进程栈大小"><a href="#如何确定进程栈大小" class="headerlink" title="如何确定进程栈大小"></a>如何确定进程栈大小</h3><p>我们要知道栈的大小，那必须得知道<strong>栈的起始地址和结束地址</strong>。<strong>栈起始地址</strong> 获取很简单，只需要嵌入汇编指令获取栈指针 esp 地址即可。<strong>栈结束地址</strong> 的获取有点麻烦，我们需要先利用递归函数把栈搞溢出了，然后再 GDB 中把栈溢出的时候把栈指针 esp 打印出来即可。代码如下：</p>
<pre><code class="c">/* file name: stacksize.c */

void *orig_stack_pointer;

void blow_stack() {
    blow_stack();
}

int main() {
    __asm__(&quot;movl %esp, orig_stack_pointer&quot;);

    blow_stack();
    return 0;
}</code></pre>
<pre><code class="gdb">$ g++ -g stacksize.c -o ./stacksize
$ gdb ./stacksize
(gdb) r
Starting program: /home/home/misc-code/setrlimit

Program received signal SIGSEGV, Segmentation fault.
blow_stack () at setrlimit.c:4
4       blow_stack();
(gdb) print (void *)$esp
$1 = (void *) 0xffffffffff7ff000
(gdb) print (void *)orig_stack_pointer
$2 = (void *) 0xffffc800
(gdb) print 0xffffc800-0xff7ff000
$3 = 8378368    // Current Process Stack Size is 8M</code></pre>
<h3 id="Linux内核内存布局"><a href="#Linux内核内存布局" class="headerlink" title="Linux内核内存布局"></a>Linux内核内存布局</h3><p>内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由 <code>mm_struct</code> 结构体表示，下面给出内存描述符结构中各个域的描述，请大家结合前面的进程内存段布局图一起看：</p>
<p><code>include/linux/mm_types.h</code></p>
<pre><code class="c">struct mm_struct {
    struct vm_area_struct *mmap;           /* 内存区域链表 */
    struct rb_root mm_rb;                  /* VMA 形成的红黑树 */
    ...
    unsigned long mmap_base;               /* memory mapping段的起始地址 */
    ...
    struct list_head mmlist;               /* 所有 mm_struct 形成的链表 */
    ...
    unsigned long total_vm;                /* 全部页面数目 */
    unsigned long locked_vm;               /* 上锁的页面数据 */
    unsigned long shared_vm;               /* 共享页面数目 Shared pages (files) */
    unsigned long exec_vm;                 /* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */
    unsigned long stack_vm;                /* 栈区页面数目 VM_GROWSUP/DOWN */
    unsigned long def_flags;
    unsigned long start_code, end_code, start_data, end_data;    /* 代码段、数据段 起始地址和结束地址 */
    unsigned long start_brk, brk, start_stack;                   /* 栈区 的起始地址，堆区 起始地址和结束地址 */
    unsigned long arg_start, arg_end, env_start, env_end;        /* 命令行参数 和 环境变量的 起始地址和结束地址 */
    ...
    /* Architecture-specific MM context */
    mm_context_t context;                  /* 体系结构特殊数据 */

    /* Must use atomic bitops to access the bits */
    unsigned long flags;                   /* 状态标志位 */
    ...
    /* Coredumping and NUMA and HugePage 相关结构体 */
};</code></pre>
<p><img src="/images/linux/mm_struct.jpg" alt="进程-内存描述符"></p>
<h3 id="进程栈的动态生长"><a href="#进程栈的动态生长" class="headerlink" title="进程栈的动态生长"></a>进程栈的动态生长</h3><p>进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个 <strong>缺页异常 (page fault)</strong>。通过异常陷入内核态后，异常会被内核的 <code>expand_stack()</code> 函数处理，进而调用 <code>acct_stack_growth()</code> 来检查是否还有合适的地方用于栈的增长。</p>
<p>如果栈的大小低于 <code>RLIMIT_STACK</code>，那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生 <strong>栈溢出（stack overflow）</strong>，进程将会收到内核发出的 <strong>段错误（segmentation fault）</strong> 信号。</p>
<p>动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。</p>
<h2 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h2><p>从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中。<strong>线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别</strong>。线程创建的时候，加上了 <code>CLONE_VM</code> 标记，这样 <strong>线程的内存描述符 将直接指向 父进程的内存描述符</strong>。</p>
<p>最初的进程定义都包含程序、资源及其执行三部分，其中程序通常指代码，资源在操作系统层面上通常包括内存资源、IO资源、信号处理等部分，而程序的执行通常理解为执行上下文，包括对cpu的占用，后来发展为线程。</p>
<p>在线程概念出现以前，为了减小进程切换的开销，操作系统设计者逐渐修正进程的概念，逐渐允许将进程所占有的资源从其主体剥离出来，允许某些进程共享一部分资源，例如文件、信号，数据内存，甚至代码，这就发展出轻量进程的概念。</p>
<p>在 <code>do_fork()</code> 中，不同的 <code>clone_flags</code> 将导致不同的行为，对于<code>LinuxThreads</code>，<code>glibc</code>使用如下参数来调用<code>clone()</code>创建”线程”</p>
<pre><code class="c">int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL
             | CLONE_SETTLS | CLONE_PARENT_SETTID
             | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM
#if __ASSUME_NO_CLONE_DETACHED == 0
             | CLONE_DETACHED
#endif
             | 0);</code></pre>
<p>Linux内核在2.0.x版本就已经实现了轻量进程，应用程序可以通过一个统一的<code>clone()</code>系统调用接口，<strong>用不同的参数指定创建轻量进程还是普通进程</strong>。在内核中，<code>clone()</code>调用经过参数传递和解释后会调用<code>do_fork()</code>，这个核内函数同时也是<code>fork()</code>、<code>vfork()</code>系统调用的最终实现：</p>
<p><code>kernel/fork.c</code></p>
<pre><code class="c">do_fork(unsigned long clone_flags,
          unsigned long stack_start,
          struct pt_regs *regs,
          unsigned long stack_size,
          int __user *parent_tidptr,
          int __user *child_tidptr)</code></pre>
<pre><code class="c">static int copy_mm(unsigned long clone_flags, struct task_struct * tsk)
{
    ...
    if (clone_flags &amp; CLONE_VM) {
        atomic_inc(&amp;oldmm-&gt;mm_users);
        mm = oldmm;
        goto good_mm;
    }
    ...
}</code></pre>
<p>虽然线程的地址空间和进程一样，但是对待其地址空间的 stack 还是有些区别的。对于 <strong>Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长</strong>。</p>
<p>然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，<strong>而是事先固定下来的，使用 mmap 系统调用</strong>，它不带有 <code>VM_STACK_FLAGS</code> 标记。这个可以从 <code>glibc 的nptl/allocatestack.c</code> 中的 <code>allocate_stack()</code> 函数中看到：</p>
<pre><code class="c">mem = mmap (NULL, size, prot,                                                                                                                                                  
        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);</code></pre>
<p><strong>线程栈不能动态增长，一旦用尽就没了，这是和生成进程的 fork 不同的地方</strong>。由于线程栈是从进程的地址空间中 map 出来的一块内存区域，原则上是线程私有的。但是同一个进程的所有线程生成的时候浅拷贝生成者的 task_struct 的很多字段，其中包括所有的 vma，如果愿意，其它线程也还是可以访问到的，于是一定要注意。</p>
<h2 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h2><p>在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作<strong>进程内核栈</strong>。</p>
<pre><code class="c">union thread_union {
    struct thread_info thread_info;
    unsigned long stack[THREAD_SIZE/sizeof(long)];
};</code></pre>
<p><code>thread_union</code> 进程内核栈 和 <code>task_struct</code> 进程描述符有着紧密的联系。由于内核经常要访问 <code>task_struct</code>，高效获取当前进程的描述符是一件非常重要的事情。因此内核将进程内核栈的头部一段空间，用于存放 <code>thread_info</code> 结构体，而此结构体中则记录了对应进程的描述符，两者关系如下图（对应内核函数为 <code>dup_task_struct()</code>）：</p>
<p><img src="/images/linux/20160901215111055" alt="dup_task_struct"></p>
<h2 id="中断栈"><a href="#中断栈" class="headerlink" title="中断栈"></a>中断栈</h2><p>进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，<strong>当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用</strong>。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。</p>
<p>X86 上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在 <code>arch/x86/kernel/irq_32.c</code> 的 <code>irq_ctx_init()</code> 函数中(如果是多处理器系统，那么每个处理器都会有一个独立的中断栈)，函数使用 <code>__alloc_pages</code> 在低端内存区分配 2个物理页面，也就是8KB大小的空间。有趣的是，这个函数还会为 <code>softirq</code> 分配一个同样大小的独立堆栈。如此说来，<code>softirq</code> 将不会在 <code>hardirq</code> 的中断栈上执行，而是在自己的上下文中执行。</p>
<p><img src="/images/linux/20160901215126528" alt="中断栈"></p>
<p>而 ARM 上中断栈和内核栈则是共享的；中断栈和内核栈共享有一个负面因素，如果中断发生嵌套，可能会造成栈溢出，从而可能会破坏到内核栈的一些重要数据，所以栈空间有时候难免会捉襟见肘。</p>
<h1 id="Linux-为什么需要区分这些栈？"><a href="#Linux-为什么需要区分这些栈？" class="headerlink" title="Linux 为什么需要区分这些栈？"></a>Linux 为什么需要区分这些栈？</h1><p>为什么需要区分这些栈，其实都是设计上的问题。</p>
<h2 id="为什么需要单独的进程内核栈？"><a href="#为什么需要单独的进程内核栈？" class="headerlink" title="为什么需要单独的进程内核栈？"></a>为什么需要单独的进程内核栈？</h2><p>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 <code>schedule()</code> 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据；一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了</p>
<h2 id="为什么需要单独的线程栈？"><a href="#为什么需要单独的线程栈？" class="headerlink" title="为什么需要单独的线程栈？"></a>为什么需要单独的线程栈？</h2><p>Linux 调度程序中并没有区分线程和进程，当调度程序需要唤醒”进程”的时候，必然需要恢复进程的上下文环境，也就是进程栈；但是线程和父进程完全共享一份地址空间，如果栈也用同一个那就会遇到问题</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol>
<li><a href="https://blog.csdn.net/yangkuanqaz85988/article/details/52403726" target="_blank" rel="noopener">Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-thread/index.html" target="_blank" rel="noopener">Linux 线程实现机制分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linux</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux C语言内存越界问题</title>
    <url>/2017/03/07/linux-c-overflow/</url>
    <content><![CDATA[<p>进程地址空间的分配如下图：</p>
<pre><code>       0xFFFFFFFF +-----------------+
                  +---Kernel Space--+   Kernel
       0xC0000000 +-----------------+
                  +-----Stack-------+
                  +-----------------+
                  +-Memory Mapping--+   printf
       0x40000000 +-----------------+
                  +-----Heap--------+   memory/free
                  +-----BSS---------+
                  +-----Data--------+   Load from elf
       0x08048000 +-----Text--------+
                  +-----------------+</code></pre><a id="more"></a>

<p>如果进程是多线程的，则每个线程都会在用户的栈区开辟一个自己的栈。</p>
<p>了解的上述分布图，知道每个变量、每块内存在系统中的布局，很容易区分一个地址是否为有效地址，<br>一个变量或者内存的数据被破坏了可以大致判断出是那个变量或者内存使用越界了。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>ESP寄存器始终指向栈的顶部</li>
<li>EBP寄存器指向函数的一个活动记录成为帧指针</li>
<li>C语言函数调用入栈的顺序是从右向左</li>
<li>如果函数返回一个大的结构体变量，调用该函数的函数要在栈中开辟一个同样大小的空间，然后把该空间的地址作为一个隐式参数传递给该函数，该函数将需要返回的内容拷贝到该地址，然后通过EAX寄存器返回该地址</li>
</ul>
<p>下图是一个很常见的活动记录:</p>
<pre><code>        +--------------------+-------
        |       Params       |
        |--------------------|
        |     Return addr    |
  ebp-&gt; |--------------------|
        |     Old ebp        |
        |--------------------|    活动记录
        |     Registers      |
        |--------------------|
        |     Locals         |
        |--------------------|
        |     other data     |
  esp-&gt; +--------------------+-------
</code></pre><p>总结栈的基本模型如下:</p>
<pre><code>        +------------+------------+
        |  Param N   |  High Addr |
        +------------+------------+
        |  Param ... |            | 参数入栈的顺序与具体的调用方式有关
        +------------+------------+
        |  Param 1   |            |
        +------------+------------+
        |  EIP       |            | 返回本次调用后，下一条指令的地址
        +------------+------------+
        |  EBP       |            | 保存调用者的EBP，然后EBP指向此时的栈顶
        +------------+------------+
        |  Local 1   |            |
        +------------+------------+
        |  Local ... |            |
        +------------+------------+
        |  Local N   |  Low Addr  |
        +------------+------------+</code></pre><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol>
<li><code>malloc</code> 分配小块内存时是在小于 <code>0x40000000</code> 的内存中分配的，通过brk/sbrk不断向上扩展</li>
<li>分配大块内存是是通过 <code>mmap</code> 分配在大于 <code>0x40000000</code> 的文件映射区</li>
<li><code>malloc</code> 分配的内存前面存放该内存的大小，后面是空闲内存块（可能会被<code>malloc</code> 调用分配出去）</li>
</ol>
<h2 id="内存越界的几种情况"><a href="#内存越界的几种情况" class="headerlink" title="内存越界的几种情况"></a>内存越界的几种情况</h2><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><blockquote>
<p>现象</p>
</blockquote>
<ul>
<li>某些全局变量被修改</li>
<li>某些任务不能正常工作函数调用不正常</li>
<li>某些局部变量被修改</li>
</ul>
<blockquote>
<p>原因</p>
</blockquote>
<ul>
<li>线程堆栈开辟的太小</li>
<li>定义的太大的局部变量</li>
<li>函数调用太深</li>
</ul>
<h3 id="堆栈内部越界"><a href="#堆栈内部越界" class="headerlink" title="堆栈内部越界"></a>堆栈内部越界</h3><blockquote>
<p>现象</p>
</blockquote>
<ul>
<li>某些局部变量被修改</li>
<li>函数返回的时候死机</li>
</ul>
<blockquote>
<p>原因</p>
</blockquote>
<ul>
<li>临时变量或者数组越界</li>
</ul>
<h3 id="全局变量或者动态分配的内存越界"><a href="#全局变量或者动态分配的内存越界" class="headerlink" title="全局变量或者动态分配的内存越界"></a>全局变量或者动态分配的内存越界</h3><blockquote>
<p>现象</p>
</blockquote>
<ul>
<li>全局变量被修改</li>
<li>内存泄漏（如果动态分配的内存越界，有可能导致被越界的内存无法释放或者不能全部释放）</li>
</ul>
<blockquote>
<p>原因</p>
</blockquote>
<ul>
<li>全局或者动态分配的内存越界</li>
</ul>
<h2 id="一些容易引起内存越界的操作"><a href="#一些容易引起内存越界的操作" class="headerlink" title="一些容易引起内存越界的操作"></a>一些容易引起内存越界的操作</h2><ul>
<li>注意 <code>strcpy</code> <code>sprintf</code> <code>memcpy</code> 函数目的缓冲区的大小</li>
<li><code>strncpy</code> <code>strcpy</code> 目的缓冲区的大小及源缓冲区是否以 <code>\0</code> 结尾 </li>
<li>还要注意数组的大小、循环的次数</li>
<li>链表的头部和尾部在处理插入和删除节点时的操作</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="全局变量被越界"><a href="#全局变量被越界" class="headerlink" title="全局变量被越界"></a>全局变量被越界</h3><p>可以用 <code>readelf</code> 工具读出可执行文件的符号表，看下该全局变量前面的变量是哪个，然后看下相关代码是否有越界的情况</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>C</category>
        <category>Memory</category>
        <category>MM</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title>CLang调试手段</title>
    <url>/2017/02/28/clang-debug/</url>
    <content><![CDATA[<ul>
<li><a href="http://clang.llvm.org/docs/MemorySanitizer.html" target="_blank" rel="noopener">MemorySanitizer</a></li>
<li><a href="http://clang.llvm.org/docs/AddressSanitizer.html" target="_blank" rel="noopener">AddressSanitizer</a></li>
<li><a href="http://clang.llvm.org/docs/LeakSanitizer.html" target="_blank" rel="noopener">LeakSanitizer</a></li>
</ul>
<a id="more"></a>

<h2 id="MemorySanitizer"><a href="#MemorySanitizer" class="headerlink" title="MemorySanitizer"></a>MemorySanitizer</h2><p>MemSan查没有初始化但是又读过的内存</p>
<h2 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h2><p>AddrSan查越界访问</p>
<blockquote>
<p>gcc4.8版本之后，增加对AddressSanitizer的支持</p>
</blockquote>
<h2 id="LeakSanitizer"><a href="#LeakSanitizer" class="headerlink" title="LeakSanitizer"></a>LeakSanitizer</h2><p>LeakSan查内存泄漏</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Prof</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>c</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-远程分支，远程跟踪分支，跟踪分支的区别</title>
    <url>/2017/02/22/git-branch/</url>
    <content><![CDATA[<p><code>git pro 3.5</code> 关于分支存在三种：</p>
<ul>
<li>远程分支，remote branches</li>
<li>本地分支，local branches</li>
<li>远程跟踪分支，remote-tracking branches</li>
</ul>
<a id="more"></a>

<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p><code>远程分支</code> 就是在远程仓库的普通分支，<br>比如远程仓库上的master，自己在远程仓库创建的分支，以及自己推送到远程仓库上去的在远程仓库上的分支。<br>当运行 <code>git push （仓库名） 分支名</code> 的命令时，便会在远程仓库创建远程分支。</p>
<p>If you just want to take a quick peek at an upstream branch, you can check it out directly:</p>
<h2 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h2><h2 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h2><pre><code>$ git checkout origin/experimental</code></pre><p>But if you want to work on that branch, you’ll need to create a local tracking branch:</p>
<pre><code>$ git checkout -b experimental origin/experimental</code></pre><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>如何查看本地跟踪分支对应的远程分支</p>
<pre><code>git branch --help
git branch -vv</code></pre><blockquote>
<p>-v, -vv, –verbose<br>  When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any).<br>  If given twice, print the name of the upstream branch, as well (see also git remote show <remote>).</p>
</blockquote>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol>
<li><a href="http://blog.csdn.net/xuzhaojia/article/details/16108723" target="_blank" rel="noopener">远程分支和本地分支的相互创建和跟踪</a></li>
<li><a href="http://www.cnblogs.com/Lostork/p/git_remote_remote-tracking_tracking_branch.html" target="_blank" rel="noopener">Git-远程分支，远程跟踪分支，跟踪分支的区别</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">Git远程操作详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用diff和git apply跨仓库合并代码</title>
    <url>/2017/02/22/diff-patch/</url>
    <content><![CDATA[<blockquote>
<p>需要在两个拥有相同代码，但是不是同一个仓库之间合并代码，直接使用 <code>git diff</code> 和 <code>git apply</code> 不能成功。<br>发现可以使用 <code>diff</code> 来生成 <code>UNIX Patch</code>，然后使用 <code>git apply</code>进行合并，记录如下：</p>
</blockquote>
<a id="more"></a>

<h2 id="diff生成patch"><a href="#diff生成patch" class="headerlink" title="diff生成patch"></a><strong>diff生成patch</strong></h2><p>可以使用 <code>diff</code> 来生成标准 <code>unix patch</code></p>
<pre><code>diff [OPTION]... from-files to-files</code></pre><p>from-files + patch = to-files</p>
<p>用到的相关选型：</p>
<ul>
<li>-r 递归</li>
<li>-u 以统一格式创建补丁文件</li>
<li>-N 确保补丁文件将正确地处理已经创建或删除文件的情况</li>
</ul>
<pre><code class="bash">diff -ruN SOURCE-DIR PATCH-DIR &gt; 00.patch</code></pre>
<h2 id="patch应用patch"><a href="#patch应用patch" class="headerlink" title="patch应用patch"></a><strong>patch应用patch</strong></h2><pre><code>patch [options] [originalfile [patchfile]]
patch -pnum &lt;patchfile&gt;</code></pre><p>简单的说，patch就是利用diff制作的补丁来实现源文件（夹）和目的文件（夹）的转换。<br>这样说就意味着你可以有源文件（夹）――&gt;目的文件（夹），也可以目的文件（夹）――&gt;源文件（夹）。下面介绍几个最常用选项：</p>
<ul>
<li>-p0 选项要从当前目录查找目的文件（夹）</li>
<li>-p1 选项要忽略掉第一层目录，从当前目录开始查找</li>
</ul>
<p>在这里以实例说明：</p>
<pre><code>--- old/modules/pcitable       Mon Sep 27 11:03:56 1999
+++ new/modules/pcitable       Tue Dec 19 20:05:41 2000</code></pre><p>如果使用参数-p0，那就表示从当前目录找一个叫做old的文件夹，在它下面寻找modules下的pcitable文件来执行patch操作。<br>如果使用参数-p1， 那就表示忽略第一层目录（即不管old），从当前目录寻找modules的文件夹，在它下面找pcitable。这样的前提是当前目 录必须为modules所在的目录。而diff补丁文件则可以在任意位置，只要指明了diff补丁文件的路径就可以了。当然，可以用相对路径，也可以用绝 对路径。不过我一般习惯用相对路径。</p>
<ul>
<li>-E 选项说明如果发现了空文件，那么就删除它</li>
<li>-R 选项说明在补丁文件中的“新”文件和“旧”文件现在要调换过来了（实际上就是给新版本打补丁，让它变成老版本）</li>
</ul>
<h2 id="diff-和-patch-使用流程"><a href="#diff-和-patch-使用流程" class="headerlink" title="diff 和 patch 使用流程"></a>diff 和 patch 使用流程</h2><p>单个文件</p>
<pre><code>diff –uN from-file to-file &gt; to-file.patch
patch –p0 &lt; to-file.patch
patch –RE –p0 &lt; to-file.patch</code></pre><p>目录</p>
<pre><code>diff –uNr from-docu to-docu &gt;to-docu.patch
patch –p1 &lt; to-docu.patch
patch –R –p1 &lt;to-docu.patch</code></pre><h2 id="git相关补丁"><a href="#git相关补丁" class="headerlink" title="git相关补丁"></a>git相关补丁</h2><p>git用来生成patch的命令：</p>
<pre><code>git format-patch -M v1.0/v1.0</code></pre><p>git用来使用补丁的命令</p>
<pre><code>git am --whitespace=fix 00.patch
git apply --stat 00.patch
git apply --check 00.patch
git apply 00.patch</code></pre><p>其中 <code>git apply</code> 可以使用 <code>diff</code> 生成的patch，需要注意的是：<br><code>git apply --check</code> 会对 <code>patch</code> 路径进行检查，如果路径不对就会导致找不到相应的文件，patch失败。</p>
<p><code>git apply</code>对目标文件的查找是从 <code>.git</code> 文件夹所有位置开始计算的。<br><strong>目标文件使用从 <code>.git</code>开始的相对路径。</strong></p>
<p>脚本如下：</p>
<pre><code class="shell">#!/bin/bash
# $1 原始基线版本
# $2 打过patch之后的版本
# $3 patch名字

SOURCE=$1
PATCH=$2
NAME=$3

echo $SOURCE
echo $PATCH
diff -ru $SOURCE $PATCH &gt; $NAME

sed -i &#39;s/+++ /+++ platform\//g&#39; $NAME</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>useful-git-commands</title>
    <url>/2017/02/21/useful-git-commands/</url>
    <content><![CDATA[<blockquote>
<p>转载自<a href="https://github.com/xirong/my-git/blob/master/useful-git-command.md" target="_blank" rel="noopener">https://github.com/xirong/my-git/blob/master/useful-git-command.md</a></p>
</blockquote>
<a id="more"></a>

<h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><ul>
<li>检出（clone）仓库代码：<code>git clone repository-url</code> / <code>git clone repository-url local-directoryname</code><ul>
<li>例如，clone jquery 仓库到本地： <code>git clone git://github.com/jquery/jquery.git</code></li>
<li>clone jquery 仓库到本地，并且重命名为 my-jquery ：<code>git clone git://github.com/jquery/jquery.git my-jquery</code></li>
</ul>
</li>
<li>查看远程仓库：<code>git remote -v</code></li>
<li>添加远程仓库：<code>git remote add [name] [repository-url]</code></li>
<li>删除远程仓库：<code>git remote rm [name]</code></li>
<li>修改远程仓库地址：<code>git remote set-url origin new-repository-url</code></li>
<li>拉取远程仓库： <code>git pull [remoteName] [localBranchName]</code></li>
<li>推送远程仓库： <code>git push [remoteName] [localBranchName]</code>  例: <code>git push -u orgin master</code> 将当前分支推送到远端master分支</li>
<li>将本地 test 分支提交到远程 master 分支: <code>git push origin test:master</code> (把本地的某个分支 test 提交到远程仓库，并作为远程仓库的 master 分支) 提交本地 test 分支作为远程的 test 分支 :<code>git push origin test:test</code></li>
</ul>
<h2 id="Git-Config"><a href="#Git-Config" class="headerlink" title="Git Config"></a>Git Config</h2><p>Git 配置文件分为三级，系统级(–system)、用户级(–global)和目录级(–local)，三者的使用优先级以离目录 (repository)最近为原则，如果三者的配置不一样，则生效优先级目录级&gt;用户级&gt;系统级，可以通过 <code>git config --help</code> 查看更多内容。</p>
<ul>
<li>系统级配置存储在 <code>/etc/gitconfig</code> 文件中，可以使用 <code>git config --system user.name &quot;jim&quot;</code> ,<code>git config --sytem user.email &quot;jim.jim@gmail.com&quot;</code> 来进行配置，该配置对系统上所有用户及他们所拥有的仓库都生效的配置值。</li>
<li>用户级存储在每个用户的 <code>~/.gitconfig</code> 中，可以使用 <code>git config --global user.name &quot;jim&quot;</code> ,<code>git config --global user.email &quot;jim.jim@gmail.com&quot;</code> 来进行配置，该配置对当前用户上所有的仓库有效。</li>
<li>目录级存储在每个仓库下的 <code>.git/config</code> 中，可以使用 <code>git config --local user.name &quot;jim&quot;</code> , <code>git config --local user.email &quot;jim.jim@gmail.com&quot;</code> 来进行配置，只对当前仓库生效。</li>
</ul>
<h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h2><ul>
<li>添加文件到暂存区（staged）：<code>git add filename</code> / <code>git stage filename</code></li>
<li>将所有修改文件添加到暂存区（staged）： <code>git add --all</code> / <code>git add -A</code></li>
<li>提交修改到暂存区（staged）：<code>git commit -m &#39;commit message&#39;</code> / <code>git commit -a -m &#39;commit message&#39;</code> 注意理解 -a 参数的意义</li>
<li>从Git仓库中删除文件：<code>git rm filename</code></li>
<li>从Git仓库中删除文件，但本地文件保留：<code>git rm --cached filename</code></li>
<li>重命名某个文件：<code>git mv filename newfilename</code> 或者直接修改完毕文件名 ，进行<code>git add -A &amp;&amp; git commit -m &#39;commit message&#39;</code> Git会自动识别是重命名了文件</li>
<li>获取远程最新代码到本地：<code>git pull (origin branchname)</code> 可以指定分支名，也可以忽略。pull 命令自动 fetch 远程代码并且 merge，如果有冲突，会显示在状态栏，需要手动处理。更推荐使用：<code>git fetch</code> 之后 <code>git merge --no-ff origin branchname</code> 拉取最新的代码到本地仓库，并手动 merge 。</li>
</ul>
<h2 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h2><p>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p>
<p>![](./_image/2016-07-14 21-26-37.jpg?r=49) ![](./_image/2016-07-14 21-15-47.jpg?r=49&amp;f=2)</p>
<p><strong>匿名分支</strong>：如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像 master~3 类似的东西，就得到一个匿名分支，称作 detached HEAD（被分离的 HEAD 标识）。</p>
<p>![](./_image/2016-07-14 21-44-06.jpg?r=56)</p>
<p>当HEAD处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)一旦此后你切换到别的分支，比如说 master，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用 2eecb。详细查看：<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html#detached" target="_blank" rel="noopener">visual-git-guide#detached</a><br>但是，如果你想保存这个状态，可以用命令 <code>git checkout -b name</code> 来创建一个新的分支。</p>
<p>![](./_image/2016-07-14 21-45-50.jpg?r=56)</p>
<h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><ul>
<li>查看日志：<code>git log</code></li>
<li>查看日志，并查看每次的修改内容：<code>git log -p</code></li>
<li>查看日志，并查看每次文件的简单修改状态：<code>git log --stat</code></li>
<li>一行显示日志：<code>git log --pretty=oneline</code> / <code>git log --pretty=&#39;format:&quot;%h - %an, %ar : %s&#39;</code></li>
<li>查看日志范围：<ul>
<li>查看最近10条日志：<code>git log -10</code></li>
<li>查看2周前：<code>git log --until=2week</code> 或者指定2周的明确日期，比如：<code>git log --until=2015-08-12</code></li>
<li>查看最近2周内：<code>git log --since=2week</code> 或者指定2周明确日志，比如：<code>git log --since=2015-08-12</code></li>
<li>只查看某个用户的提交：<code>git log --committer=user.name</code> / <code>git log --author=user.name</code></li>
<li>只查看提交msg中包含某个信息的历史，比如包含’测试’两个字的：<code>git log --grep &#39;测试&#39;</code></li>
<li>试试这个 ： <code>git log --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit</code>  感觉好用就加成 alias ，方便日后用，方法：<code>git config --global alias.aliasname &#39;alias-content&#39;</code></li>
<li>更多用法：<a href="http://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" target="_blank" rel="noopener">Viewing the History – 《Pro Git2》</a></li>
</ul>
</li>
</ul>
<h2 id="Undo-things"><a href="#Undo-things" class="headerlink" title="Undo things"></a>Undo things</h2><ul>
<li>上次提交 msg 错误/有未提交的文件应该同上一次一起提交，需要重新提交备注：<code>git commit --amend -m &#39;new msg&#39;</code></li>
<li>一次<code>git add -A</code>后，需要将某个文件撤回到工作区，即：某个文件不应该在本次commit中：<code>git reset HEAD filename</code></li>
<li>撤销某些文件的修改内容：<code>git checkout -- filename</code> 注意：一旦执行，所有的改动都没有了，谨慎！谨慎！谨慎！</li>
<li>将工作区内容回退到远端的某个版本：<code>git reset --hard &lt;sha1-of-commit&gt;</code></li>
</ul>
<h2 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h2><p>reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引，也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<p>![](./_image/2016-07-14 20-31-39.png?r=64&amp;f=1)<br>将工作区内容回退到远端的某个版本：<code>git reset --hard &lt;sha1-of-commit&gt;</code></p>
<ul>
<li><code>git reset --hard HEAD^</code> reset index and working directory ,<commitid> 以来所有的变更全部丢弃，并将 HEAD 指向<commitid></li>
</ul>
<ul>
<li><code>git reset --soft HEAD^</code> nothing changed to index and working directory ,仅仅将 HEAD 指向<commitid> ，所有变更显示在 “changed to be committed”中</li>
<li><code>git reset --mixed HEAD^</code> default,reset index ,nothing to working directory 默认选项，工作区代码不改动，添加变更到index区</li>
</ul>
<h2 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h2><blockquote>
<p><code>git revert</code> will create a new commit that’s the opposite (or inverse) of the given SHA. If the old commit is “matter”, the new commit is “anti-matter”—anything removed in the old commit will be added in the new commit and anything added in the old commit will be removed in the new commit.<br>This is Git’s safest, most basic “undo” scenario, because it doesn’t alter history—so you can now git push the new “inverse” commit to undo your mistaken commit.</p>
</blockquote>
<pre><code class="bash">git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​
git revert --continue
git revert --quit
git revert --abort</code></pre>
<h2 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h2><ul>
<li>查看工作区（working directory）和暂存区（staged）之间差异：<code>git diff</code></li>
<li>查看工作区（working directory）与当前仓库版本（repository）HEAD版本差异：<code>git diff HEAD</code></li>
<li>查看暂存区（staged）与当前仓库版本（repository）差异：<code>git diff --cached</code> / <code>git diff --staged</code></li>
</ul>
<h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>![](./_image/2016-07-14 20-53-25.jpg?r=80)</p>
<ul>
<li>解决冲突后/获取远程最新代码后合并代码：<code>git merge branchname</code> ，将 branchname 分支上面的代码合并到当前分支</li>
<li>保留该存在版本合并log：<code>git merge --no-ff branchname</code> 参数 <code>--no-ff</code> 防止 fast-forward 的提交，详情参考：<a href="http://stackoverflow.com/questions/9069061/what-is-the-difference-between-git-merge-and-git-merge-no-ff" target="_blank" rel="noopener">the difference</a>，fast-forward：分支内容一致，指针直接移动，并未能看出分支信息</li>
</ul>
<h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><p>Rebase 同 Merge 的结果是一样的，就是合并本地、远程的改动，但过程中还有区别。</p>
<pre><code class="bash">git checkout mywork
git rebase origin</code></pre>
<p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉,并且把它们临时 保存为补丁(patch)(这些补丁 放到”.git/rebase”目录中),然后把”mywork”分支更新 到最新的”origin”分支,最后把保存的这些补丁应用 到”mywork”分支上。<br>一张图分清 rebase 和 merge 的区别</p>
<p>![](./_image/2016-07-19 20-35-30.jpg?r=56)<br>在rebase的过程中,也许会出现冲突(conflict). 在这种情况,Git会停止rebase并会让你去解决冲突;在解决完冲突后,用 <code>git-add</code> 命令去更新这些内容的索引(index), 然后,你无需执行 git-commit,只要执行: <code>git rebase --continue</code> 这样git会继续应用(apply)余下的补丁。在任何时候,你可以用 –abort 参数来终止rebase的行动,并且”mywork” 分支会回到rebase开始前的状态。 <code>git rebase --abort</code></p>
<h2 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry Pick"></a>Cherry Pick</h2><p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
<p>![](./_image/2016-07-14 20-57-04.jpg?r=65)</p>
<h2 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h2><p>Aone2 Git 分支开发部署模型详细解读 <a href="http://docs.alibaba-inc.com:8090/pages/viewpage.action?pageId=194872297" target="_blank" rel="noopener">http://docs.alibaba-inc.com:8090/pages/viewpage.action?pageId=194872297</a></p>
<ul>
<li>master：master永远是线上代码，最稳定的分支，存放的是随时可供在生产环境中部署的代码，当开发活动告一段落，产生了一份新的可供部署的代码时，发布成功之后，代码才会由 aone2 提交到 master，master 分支上的代码会被更新。应用上 aone2 后禁掉所有人的 master的写权限</li>
<li>develop：保存当前最新开发成果的分支。通常这个分支上的代码也是可进行每日夜间发布的代码，只对开发负责人开放develop权限。</li>
<li>feature: 功能特性分支，每个功能特性一个 feature/ 分支，开发完成自测通过后合并入 develop 分支。可以从 master 或者develop 中拉出来。</li>
<li>hotfix: 紧急bug分支修复分支。修复上线后，可以直接合并入master。</li>
</ul>
<p>![](./_image/2016-07-19 19-58-15.jpg?r=51)</p>
<p>Git-Develop 分支模式是基于 Git 代码库设计的一种需要严格控制发布质量和发布节奏的开发模式。develop 作为固定的持续集成和发布分支，并且分支上的代码必须经过 CodeReview 后才可以提交到 Develop 分支。它的基本流程如下：</p>
<ol>
<li>每一个需求/变更都单独从Master上创建一条Branch分支；</li>
<li>用户在这个Branch分支上进行Codeing活动；</li>
<li>代码达到发布准入条件后aone上提交Codereview，Codereview通过后代码自动合并到Develop分支；</li>
<li>待所有计划发布的变更分支代码都合并到Develop后，系统再rebase master代码到Develop分支，然后自行构建，打包，部署等动作。</li>
<li>应用发布成功后Aone会基于Develop分支的发布版本打一个“当前线上版本Tag”基线；</li>
<li>应用发布成功后Aone会自动把Develop分支的发布版本合并回master；</li>
</ol>
<p><strong>常用命令:</strong></p>
<ul>
<li>查看分支：<code>git branch</code> 、<code>git branch -v</code>、<code>git branch -vv</code> (查看当前分支 tracking 哪个远端分支)、<code>git branch --merged</code>、<code>git branch --no-merged</code></li>
<li>创建分支：<code>git branch branchname</code><ul>
<li>例： 基于 master 分支新建 dev 分支 ： <code>git branch dev</code></li>
</ul>
</li>
<li>基于之前的某个 Commit 新开分支： <code>git branch branchname &lt;sha1-of-commit&gt;</code><ul>
<li>例： 基于上线的的提交 a207a38d634cc10441636bc4359cd8a18c502dea 创建 hotfix 分支 ： <code>git branch hotfix a207a38</code></li>
<li>例: 基于 remoteBranch、localBranch、commitId、tag 创建分支均可以 <code>git checkout -b newbranch localBranch/remoteBranch/commitId/tag</code></li>
</ul>
</li>
<li>切换分支： <code>git checkout branchname</code><ul>
<li>例： 由分支 master 切换到 dev 分支：<code>git checkout dev</code></li>
</ul>
</li>
<li>创建新分支并切换到下面：<code>git checkout -b branchname</code>  或者 <code>git branch branchname &amp;&amp; git checkout branchname</code><ul>
<li>例：基于 master 分支新建 dev 分支，并切换到 dev 分支上： <code>git checkout -b dev</code> 或 <code>git branch dev &amp;&amp; git checkout dev</code></li>
</ul>
</li>
<li>查看分支代码不同：<code>git diff branchname</code> 比较 branchname 分支与当前分支的差异点</li>
<li>合并分支：<code>git merge branchname</code> 将 branchname 分支代码合并到当前分支</li>
<li>删除分支：<code>git branch -d branchname</code> 强制删除未合并过的分支：<code>git branch -D branchname</code></li>
<li>查看远程分支：<code>git branch -r</code> 或 <code>git branch -r -v</code></li>
<li>获取远程分支到本地：<code>git checkout -b local-branchname origin/remote-branchname</code></li>
<li>推送本地分支到远程：<code>git push origin remote-branchname</code> 或 <code>git push origin local-branchname:remote-branchname</code><ul>
<li>将本地 dev 代码推送到远程 dev 分支： <code>git push (-u) origin dev</code> 或 <code>git push origin dev:dev</code></li>
<li>（技巧）将本地 dev 分支代码推送到远程 master 分支： <code>git push origin dev:master</code></li>
</ul>
</li>
<li>删除远程分支：<code>git push origin :remote-branchname</code> 或 <code>git push origin --delete remote-branchname</code></li>
<li>TrackingBranch，可以通过 <code>git branch -vv</code> 来查看当前 track 的分支情况。新建立分支时会自动 track 相应远程分支，<code>git checkout -b sf origin/serverfix</code> (Branch sf set up to track remote branch serverfix from origin. Switched to a new branch ‘sf’). 也可以手动 track: <code>git branch -u origin/serverfix</code> (Branch serverfix set up to track remote branch serverfix from origin). 等同于命令 <code>git checkout --track origin/serverfix</code></li>
</ul>
<blockquote>
<p>“Checking out a local branch from a remote branch automatically creates what is called a “tracking branch” (or sometimes an “upstream branch”). Tracking branches are local branches that have a direct relationship to a remote branch. If you’re on a tracking branch and type git pull, Git automatically knows which server to fetch from and branch to merge into.<br>When you clone a repository, it generally automatically creates a master branch that tracks origin/master. However, you can set up other tracking branches if you wish – ones that track branches on other remotes, or don’t track the master branch. The simple case is the example you just saw, running git checkout -b [branch] [remotename]/[branch]. This is a common enough operation that git provides the –track shorthand:”</p>
</blockquote>
<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><ul>
<li>查看 tag：<code>git tag</code></li>
<li>查找指定 tag，比如查找 V1.0.* ：<code>git tag -l &#39;V1.0.*&#39;</code> 会列出匹配到的，比如 V1.0.1,V1.0.1.1,V1.0.2 等</li>
<li>创建轻量级 tag（lightweight tags）：<code>git tag tag-name</code> ，例如: <code>git tag v1.0</code></li>
<li>创建 tag（annotated tags）：<code>git tag -a tag-name -v &#39;msg&#39;</code> ，例如：<code>git tag -a v1.0.0 -m &#39;1.0.0版本上线完毕打tag&#39;</code><ul>
<li>annotated tags VS lightweight tags 可以通过命令真实查看下：<code>git show v1.0</code> / <code>git show v1.0.0</code></li>
<li>“A lightweight tag is very much like a branch that doesn’t change – it’s just a pointer to a specific commit.</li>
</ul>
</li>
</ul>
<p>Annotated tags, however, are stored as full objects in the Git database. They’re checksummed; contain the tagger name, e-mail, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). ”</p>
<ul>
<li>查看指定 tag 信息：<code>git show tag-name</code></li>
<li>基于历史某次提交（commit）创建 tag ：<code>git tag -a tagname &lt;sha1-of-commit&gt;</code><ul>
<li>例：基于上线时的提交 a207a38d634cc10441636bc4359cd8a18c502dea 创建tag：<code>git tag -a v1.0.0 a207a38</code></li>
</ul>
</li>
<li>删除 tag ：<code>git tag -d tagname</code></li>
<li>拉取远程 tag 到本地：<code>git pull remotename --tags</code> 例如：<code>git pull origin --tags</code></li>
<li>推送 tag 到远程服务器：<code>git push remotename tagname</code>  例如：<code>git push origin v1.0.0</code></li>
<li>将本地所有 tag 推送到远程：<code>git push remotename --tags</code> 例如：<code>git push origin --tags</code></li>
<li>删除远程 tag ：<code>git push origin :tagname</code> 或者 <code>git push origin --delete tagname</code></li>
</ul>
<h2 id="Submodule"><a href="#Submodule" class="headerlink" title="Submodule"></a>Submodule</h2><p>添加子模块：$ git submodule add [url] [path]<br>    如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs<br>初始化子模块：$ git submodule init  —-只在首次检出仓库时运行一次就行<br>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下<br>删除子模块：（分4步走哦）</p>
<p> 1) $ git rm –cached [path]<br> 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉<br> 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉<br> 4) 手动删除子模块残留的目录</p>
<h2 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h2><p>![](./_image/2016-07-16 21-30-01.jpg?r=64)</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-kernel-thread</title>
    <url>/2017/01/24/linux-kernel-thread/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="退出条件"><a href="#退出条件" class="headerlink" title="退出条件"></a>退出条件</h2><pre><code class="c">while(1)退出不了，需要使用:

while(!thread_could_stop())
{
    wait();
}</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/fontlose/article/details/8291674" target="_blank" rel="noopener">linux驱动学习之内核线程分析</a></li>
<li><a href="http://blog.csdn.net/gatieme/article/details/51589205" target="_blank" rel="noopener">Linux内核线程kernel thread详解–Linux进程的管理与调度</a></li>
<li><a href="http://www.cnblogs.com/wuyuegb2312/archive/2012/06/28/2568411.html" target="_blank" rel="noopener">内核线程的创建、使用和退出；关于延时宏的补充说明</a></li>
<li><a href="http://blog.chinaunix.net/uid-29073321-id-5570170.html" target="_blank" rel="noopener">linux内核线程创建销毁机制</a></li>
<li><a href="http://www.bluezd.info/archives/447" target="_blank" rel="noopener">Kernel Thread 的创建</a></li>
<li><a href="http://blog.csdn.net/luckywang1103/article/details/47859995" target="_blank" rel="noopener">linux内核线程睡眠与唤醒</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>gcc-fstack-usage</title>
    <url>/2017/01/21/gcc-fstack-usage/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>transfer data between kernel space and user space</title>
    <url>/2017/01/18/transfer-data-between-kernel-space-and-user-space/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h2><h2 id="copy-from-user"><a href="#copy-from-user" class="headerlink" title="copy_from_user"></a>copy_from_user</h2><h2 id="get-user"><a href="#get-user" class="headerlink" title="get_user"></a>get_user</h2><h2 id="put-user"><a href="#put-user" class="headerlink" title="put_user"></a>put_user</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=97&t=268280" target="_blank" rel="noopener">copy_to_user,copy_from_user,get_user,put_user函数用法比较</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux-ioctl</title>
    <url>/2017/01/18/linux-ioctl/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>在用户空间，使用<code>ioctl</code>系统调用来控制设备，原型如下:</p>
<pre><code>/*
fd:文件描述符
cmd:控制命令
...:可选参数:插入*argp，具体内容依赖于cmd
*/
int ioctl(int fd,unsigned long cmd,...);</code></pre><p>用户程序所作的只是通过命令码告诉驱动程序它想做什么，至于怎么解释这些命令和怎么实现这些命令，这都是驱动程序要做的事情。</p>
<pre><code>/*
inode与filp两个指针对应于应用程序传递的文件描述符fd，这和传递open方法的参数一样。
cmd 由用户空间直接不经修改的传递给驱动程序
arg 可选。
*/
int (*ioctl) (struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);</code></pre><p>在驱动程序中实现的ioctl函数体内，实际上是有一个switch {case}结构，每一个case对应一个命令码，做出一些相应的操作。<br>怎么实现这些操作，这是每一个程序员自己的事情，因为设备都是特定的。<br>关键在于怎么样组织命令码，因为在ioctl中命令码是唯一联系用户程序命令和驱动程序支持的途径。</p>
<p><code>Linux Kernel</code> 定义CMD的大小为 32位，共分 4 个域：</p>
<ul>
<li>bit31~bit30 2位为 “区别读写” 区，作用是区分是读取命令还是写入命令。</li>
<li>bit29~bit15 14位为 “数据大小” 区，表示 ioctl() 中的 arg 变量传送的内存大小。</li>
<li>bit20~bit08  8位为 “魔数”(也称为”幻数”)区，这个值用以与其它设备驱动程序的 ioctl 命令进行区别。</li>
<li>bit07~bit00   8位为 “区别序号” 区，是区分命令的命令顺序序号。</li>
</ul>
<p>这样一来，一个命令就变成了一个整数形式的命令码。但是命令码非常的不直观，<br>所以Linux Kernel中提供了一些宏，这些宏可根据便于理解的字符串生成命令码，<br>或者是从命令码得到一些用户可以理解的字符串以标明这个命令对应的设备类型、设备序列号、数据传送方向和数据传输尺寸。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><pre><code>//nr为序号，datatype为数据类型,如int
_IO(type, nr ) //没有参数的命令
_IOR(type, nr, datatype) //从驱动中读数据
_IOW(type, nr, datatype) //写数据到驱动
_IOWR(type,nr, datatype) //双向传送</code></pre><h2 id="ioctl-h"><a href="#ioctl-h" class="headerlink" title="ioctl.h"></a>ioctl.h</h2><p>要按Linux内核的约定方法为驱动程序选择ioctl编号，应该首先看看include/asm/ioctl.h和Doucumention/ioctl-number.txt这两个文件。头文件定义了要使用的位字段：类型（幻数）、序数、传送方向以及参数大小等。ioctl-number.txt文件中罗列了内核所使用的幻数，选择自己的幻数要避免和内核冲突。以下是对include/asm/ioctl.h中定义的宏的注释：</p>
<p><code>_IOC</code>宏将<code>dir</code>，<code>type</code>，<code>nr</code>，<code>size</code>四个参数组合成一个cmd参数</p>
<p>Example:</p>
<pre><code class="c">#define MY_CMD_MAGIC 0xdf //type字段，由于字段宽度为8 bits，所以不能大于0xff
#define MY_CMD _IOW(MY_CMD_MAGIC,0,unsigned int)    </code></pre>
<p>于是命令<code>MY_CMD</code> 各组成字段<code>dir，size，type，nr</code>分别为：<br><code>01(=_IOC_WRITE),00 0000 0000 0100(=sizeof(unsigned int)),1101 1111(=MY_CMD_MAGIC),0000 0000(=0)</code>。<br>用十六进制表示即0x4004df00。这个32 bits的”整数”就是该命令的编号（LDD3原文是<code>command number</code>）</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.d0u9.xyz/linuxqu-dong-ioctlru-men/" target="_blank" rel="noopener">Linux驱动－－ioctl入门</a></li>
<li><a href="http://blog.csdn.net/zqixiao_09/article/details/50859302" target="_blank" rel="noopener">Linux 字符设备驱动开发基础（四）—— ioctl() 函数解析</a></li>
<li><a href="http://blog.csdn.net/zhuxiaoping54532/article/details/49680537" target="_blank" rel="noopener">Linux内核中_IO,_IOR,_IOW,_IOWR宏的用法与解析</a></li>
<li><a href="http://www.cnblogs.com/geneil/archive/2011/12/04/2275372.html" target="_blank" rel="noopener">Linux设备驱动之Ioctl控制</a></li>
<li><a href="http://blog.csdn.net/qq_21792169/article/details/51090001" target="_blank" rel="noopener">新内核版本ioctl的变化 _IO, _IOR, _IOW, _IOWR 幻数的理解</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux-misc-devices-and-char-devices</title>
    <url>/2017/01/18/linux-misc-devices-and-char-devices/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.csdn.net/JansonZhe/article/details/50555644" target="_blank" rel="noopener">Linux字符设备驱动和杂项设备驱动对比</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux-user-space-and-kernel-space</title>
    <url>/2017/01/18/linux-user-space-and-kernel-space/</url>
    <content><![CDATA[<p>TEST!!</p>
<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cnblogs.com/wangjiaxu/archive/2013/06/13/3133878.html" target="_blank" rel="noopener">内核态和用户态区别</a></li>
<li><a href="http://blog.csdn.net/zhangskd/article/details/6956638" target="_blank" rel="noopener">linux内核空间和用户空间详解</a></li>
<li><a href="http://blog.tingyun.com/web/article/detail/621" target="_blank" rel="noopener">Linux探秘之用户态与内核态</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块间函数调用</title>
    <url>/2017/01/18/linux-EXPORT-SYMBOL/</url>
    <content><![CDATA[<a id="more"></a>



<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://bluequiet.blogspot.hk/2011/10/exportsymbolkernelkernel.html" target="_blank" rel="noopener">EXPORT_SYMBOL用法</a></li>
<li><a href="http://blog.csdn.net/macrossdzh/article/details/4601648" target="_blank" rel="noopener">谈EXPORT_SYMBOL使用</a></li>
<li><a href="http://www.itdadao.com/articles/c15a691094p0.html" target="_blank" rel="noopener">浅析linux内核中的EXPORT_SYMBOL()</a></li>
<li><a href="http://blog.csdn.net/zengxianyang/article/details/50611828" target="_blank" rel="noopener">Linux内核—EXPORT_SYMBOL宏的使用</a></li>
<li><a href="http://www.cnblogs.com/yuuyuu/p/5119891.html" target="_blank" rel="noopener">初探linux内核编程，参数传递以及模块间函数调用</a></li>
<li><a href="https://www.zhihu.com/question/24662375" target="_blank" rel="noopener">linux 如何在驱动中调用另外一个设备？</a></li>
<li><a href="http://blog.csdn.net/xhz1234/article/details/44278137" target="_blank" rel="noopener"> Linux内核模块间函数调用正确方法</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>modules</tag>
      </tags>
  </entry>
  <entry>
    <title>编译和链接</title>
    <url>/2016/12/22/compile-and-link/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://yq.aliyun.com/articles/15220" target="_blank" rel="noopener">编译和链接那点事&lt;上&gt;</a></li>
<li><a href="https://yq.aliyun.com/articles/15217" target="_blank" rel="noopener">编译和链接那点事&lt;下&gt;</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>静态库符号重定义处理</title>
    <url>/2016/12/21/static-libs-duplicate-symbol/</url>
    <content><![CDATA[<blockquote>
<p>在使用静态库时出现重定义问题，不能控制静态库的生成，记录在这种情况下的处理。</p>
</blockquote>
<a id="more"></a>

<h2 id="multiple-definition"><a href="#multiple-definition" class="headerlink" title="multiple definition"></a>multiple definition</h2><p>出现重定义时，如果源码可控，这种情况下简单，修改源码即可。<br>当源码不可控时，需要考虑其他办法来处理这种问题。</p>
<ul>
<li>直接修改</li>
<li>逆向工程</li>
</ul>
<h2 id="直接修改"><a href="#直接修改" class="headerlink" title="直接修改"></a>直接修改</h2><p>使用 <code>UE</code> 打开存在重定义的 <code>.a</code> 文件，将相关的重定义符号修改为其他名字，必须保证<strong>修改前后长度一致</strong>！</p>
<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><h3 id="nm查看库文件"><a href="#nm查看库文件" class="headerlink" title="nm查看库文件"></a>nm查看库文件</h3><pre><code>nm -a libtest.a</code></pre><h3 id="解压静态库文件"><a href="#解压静态库文件" class="headerlink" title="解压静态库文件"></a>解压静态库文件</h3><pre><code class="c">ar -x libtest.a</code></pre>
<p>此时当前目录存在 <code>.o</code> 文件</p>
<h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><pre><code>objdump -D test.o &gt; test.m</code></pre><h3 id="修改之后打包"><a href="#修改之后打包" class="headerlink" title="修改之后打包"></a>修改之后打包</h3><pre><code>ar -rcs libtest.a *.o</code></pre><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="查看库文件有那些目标文件"><a href="#查看库文件有那些目标文件" class="headerlink" title="查看库文件有那些目标文件"></a>查看库文件有那些目标文件</h3><pre><code>ar -t libtest.a</code></pre><h3 id="查看库文件索引表"><a href="#查看库文件索引表" class="headerlink" title="查看库文件索引表"></a>查看库文件索引表</h3><pre><code>ar -s libtest.a</code></pre>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>nm</tag>
        <tag>c</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc编译流程</title>
    <url>/2016/12/20/gcc-compile-process/</url>
    <content><![CDATA[<blockquote>
<p>转载自<a href="https://github.com/tinyclub/open-c-book" target="_blank" rel="noopener">开源书籍：《C语言编程透视》，透视C的前世今生！</a>，介绍了<code>GCC</code>编译流程。</p>
</blockquote>
<ul>
<li>预处理<ul>
<li>简述</li>
<li>打印出预处理之后的结果</li>
<li>在命令行定义宏</li>
</ul>
</li>
<li>编译（翻译）<ul>
<li>简述</li>
<li>语法检查</li>
<li>编译器优化</li>
<li>生成汇编语言文件</li>
</ul>
</li>
<li>汇编<ul>
<li>简述</li>
<li>生成目标代码</li>
<li>ELF 文件初次接触</li>
<li>ELF 文件的结构</li>
<li>三种不同类型 ELF 文件比较</li>
<li>ELF 主体：节区</li>
<li>汇编语言文件中的节区表述</li>
</ul>
</li>
<li>链接<ul>
<li>简述</li>
<li>可执行文件的段：节区重排</li>
<li>链接背后的故事</li>
<li>用 ld 完成链接过程</li>
<li>C++ 构造与析构：crtbegin.o 和 crtend.o</li>
<li>初始化与退出清理：crti.o 和 crtn.o</li>
<li>C 语言程序真正的入口</li>
<li>链接脚本初次接触</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="Gcc-编译的背后"><a href="#Gcc-编译的背后" class="headerlink" title="Gcc 编译的背后"></a>Gcc 编译的背后</h1><ul>
<li><a href="#toc_27212_14734_1">前言</a></li>
<li><a href="#toc_27212_14734_2">预处理</a><ul>
<li><a href="#toc_27212_14734_3">简述</a></li>
<li><a href="#toc_27212_14734_4">打印出预处理之后的结果</a></li>
<li><a href="#toc_27212_14734_5">在命令行定义宏</a></li>
</ul>
</li>
<li><a href="#toc_27212_14734_6">编译（翻译）</a><ul>
<li><a href="#toc_27212_14734_7">简述</a></li>
<li><a href="#toc_27212_14734_8">语法检查</a></li>
<li><a href="#toc_27212_14734_9">编译器优化</a></li>
<li><a href="#toc_27212_14734_10">生成汇编语言文件</a></li>
</ul>
</li>
<li><a href="#toc_27212_14734_11">汇编</a><ul>
<li><a href="#toc_27212_14734_12">简述</a></li>
<li><a href="#toc_27212_14734_13">生成目标代码</a></li>
<li><a href="#toc_27212_14734_14">ELF 文件初次接触</a></li>
<li><a href="#toc_27212_14734_15">ELF 文件的结构</a></li>
<li><a href="#toc_27212_14734_16">三种不同类型 ELF 文件比较</a></li>
<li><a href="#toc_27212_14734_17">ELF 主体：节区</a></li>
<li><a href="#toc_27212_14734_18">汇编语言文件中的节区表述</a></li>
</ul>
</li>
<li><a href="#toc_27212_14734_19">链接</a><ul>
<li><a href="#toc_27212_14734_20">简述</a></li>
<li><a href="#toc_27212_14734_21">可执行文件的段：节区重排</a></li>
<li><a href="#toc_27212_14734_22">链接背后的故事</a></li>
<li><a href="#toc_27212_14734_23">用 ld 完成链接过程</a></li>
<li><a href="#toc_27212_14734_24">C++ 构造与析构：crtbegin.o 和 crtend.o</a></li>
<li><a href="#toc_27212_14734_25">初始化与退出清理：crti.o 和 crtn.o</a></li>
<li><a href="#toc_27212_14734_26">C 语言程序真正的入口</a></li>
<li><a href="#toc_27212_14734_27">链接脚本初次接触</a></li>
</ul>
</li>
<li><a href="#toc_27212_14734_28">参考资料</a></li>
</ul>
<p><span id="toc_27212_14734_1"></span></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时在 Linux 下写代码，直接用 <code>gcc -o out in.c</code> 就把代码编译好了，但是这背后到底做了什么呢？</p>
<p>如果学习过《<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools" target="_blank" rel="noopener">编译原理</a>》则不难理解，一般高级语言程序编译的过程莫过于：预处理、编译、汇编、链接。</p>
<p><code>gcc</code> 在后台实际上也经历了这几个过程，可以通过 <code>-v</code> 参数查看它的编译细节，如果想看某个具体的编译过程，则可以分别使用 <code>-E</code>，<code>-S</code>，<code>-c</code> 和 <code>-O</code>，对应的后台工具则分别为 <code>cpp</code>，<code>cc1</code>，<code>as</code>，<code>ld</code>。</p>
<p>下面将逐步分析这几个过程以及相关的内容，诸如语法检查、代码调试、汇编语言等。</p>
<p><span id="toc_27212_14734_2"></span></p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p><span id="toc_27212_14734_3"></span></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>预处理是 C 语言程序从源代码变成可执行程序的第一步，主要是 C 语言编译器对各种预处理命令进行处理，包括头文件的包含、宏定义的扩展、条件编译的选择等。</p>
<p>以前没怎么“深入”预处理，脑子对这些东西总是很模糊，只记得在编译的基本过程（词法分析、语法分析）之前还需要对源代码中的宏定义、文件包含、条件编译等命令进行处理。这三类的指令很常见，主要有 <code>#define</code>，<code>#include</code>和 <code>#ifdef ... #endif</code>，要特别地注意它们的用法。</p>
<p><code>#define</code> 除了可以独立使用以便灵活设置一些参数外，还常常和 <code>#ifdef ... #endif</code> 结合使用，以便灵活地控制代码块的编译与否，也可以用来避免同一个头文件的多次包含。关于 <code>#include</code> 貌似比较简单，通过 <code>man</code> 找到某个函数的头文件，复制进去，加上 <code>&lt;&gt;</code> 就好。这里虽然只关心一些技巧，不过预处理还是隐藏着很多潜在的陷阱（可参考《<a href="https://en.wikipedia.org/wiki/C_Traps_and_Pitfalls" target="_blank" rel="noopener">C Traps &amp; Pitfalls</a>》）也是需要注意的。下面仅介绍和预处理相关的几个简单内容。</p>
<p><span id="toc_27212_14734_4"></span></p>
<h3 id="打印出预处理之后的结果"><a href="#打印出预处理之后的结果" class="headerlink" title="打印出预处理之后的结果"></a>打印出预处理之后的结果</h3><pre><code>$ gcc -E hello.c</code></pre><p>这样就可以看到源代码中的各种预处理命令是如何被解释的，从而方便理解和查错。</p>
<p>实际上 <code>gcc</code> 在这里调用了 <code>cpp</code>（虽然通过 <code>gcc -v</code> 仅看到 <code>cc1</code>)，<code>cpp</code> 即 The C Preprocessor，主要用来预处理宏定义、文件包含、条件编译等。下面介绍它的一个比较重要的选项 <code>-D</code>。</p>
<p><span id="toc_27212_14734_5"></span></p>
<h3 id="在命令行定义宏"><a href="#在命令行定义宏" class="headerlink" title="在命令行定义宏"></a>在命令行定义宏</h3><pre><code>$ gcc -Dmacro hello.c</code></pre><p>这个等同于在文件的开头定义宏，即 <code>#define macro</code>，但是在命令行定义更灵活。例如，在源代码中有这些语句。</p>
<pre><code>#ifdef DEBUG
printf(&quot;this code is for debugging\n&quot;);
#endif</code></pre><p>如果编译时加上 <code>-DDEBUG</code> 选项，那么编译器就会把 <code>printf</code> 所在的行编译进目标代码，从而方便地跟踪该位置的某些程序状态。这样 <code>-DDEBUG</code> 就可以当作一个调试开关，编译时加上它就可以用来打印调试信息，发布时则可以通过去掉该编译选项把调试信息去掉。</p>
<p><span id="toc_27212_14734_6"></span></p>
<h2 id="编译（翻译）"><a href="#编译（翻译）" class="headerlink" title="编译（翻译）"></a>编译（翻译）</h2><p><span id="toc_27212_14734_7"></span></p>
<h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>编译之前，C 语言编译器会进行词法分析、语法分析，接着会把源代码翻译成中间语言，即汇编语言。如果想看到这个中间结果，可以用 <code>gcc -S</code>。需要提到的是，诸如 Shell 等解释语言也会经历一个词法分析和语法分析的阶段，不过之后并不会进行“翻译”，而是“解释”，边解释边执行。</p>
<p>把源代码翻译成汇编语言，实际上是编译的整个过程中的第一个阶段，之后的阶段和汇编语言的开发过程没有什么区别。这个阶段涉及到对源代码的词法分析、语法检查（通过 <code>-std</code> 指定遵循哪个标准），并根据优化（<code>-O</code>）要求进行翻译成汇编语言的动作。</p>
<p><span id="toc_27212_14734_8"></span></p>
<h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><p>如果仅仅希望进行语法检查，可以用 <code>gcc</code> 的 <code>-fsyntax-only</code> 选项；如果为了使代码有比较好的可移植性，避免使用 <code>gcc</code> 的一些扩展特性，可以结合 <code>-std</code> 和 <code>-pedantic</code>（或者 <code>-pedantic-erros</code> ）选项让源代码遵循某个 C 语言标准的语法。这里演示一个简单的例子：</p>
<pre><code>$ cat hello.c
#include &lt;stdio.h&gt;
int main()
{
    printf(&quot;hello, world\n&quot;)
    return 0;
}
$ gcc -fsyntax-only hello.c
hello.c: In function ‘main’:
hello.c:5: error: expected ‘;’ before ‘return’
$ vim hello.c
$ cat hello.c
#include &lt;stdio.h&gt;
int main()
{
        printf(&quot;hello, world\n&quot;);
        int i;
        return 0;
}
$ gcc -std=c89 -pedantic-errors hello.c    #默认情况下，gcc是允许在程序中间声明变量的，但是turboc就不支持
hello.c: In function ‘main’:
hello.c:5: error: ISO C90 forbids mixed declarations and code</code></pre><p>语法错误是程序开发过程中难以避免的错误（人的大脑在很多情况下都容易开小差），不过编译器往往能够通过语法检查快速发现这些错误，并准确地告知语法错误的大概位置。因此，作为开发人员，要做的事情不是“恐慌”（不知所措），而是认真阅读编译器的提示，根据平时积累的经验（最好总结一份常见语法错误索引，很多资料都提供了常见语法错误列表，如《<a href="https://en.wikipedia.org/wiki/C_Traps_and_Pitfalls" target="_blank" rel="noopener">C Traps &amp; Pitfalls</a>》和编辑器提供的语法检查功能（语法加亮、括号匹配提示等）快速定位语法出错的位置并进行修改。</p>
<p><span id="toc_27212_14734_9"></span></p>
<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p>语法检查之后就是翻译动作，<code>gcc</code> 提供了一个优化选项 <code>-O</code>，以便根据不同的运行平台和用户要求产生经过优化的汇编代码。例如，</p>
<pre><code>$ gcc -o hello hello.c         # 采用默认选项，不优化
$ gcc -O2 -o hello2 hello.c    # 优化等次是2
$ gcc -Os -o hellos hello.c    # 优化目标代码的大小
$ ls -S hello hello2 hellos    # 可以看到，hellos 比较小, hello2 比较大
hello2  hello  hellos
$ time ./hello
hello, world

real    0m0.001s
user    0m0.000s
sys     0m0.000s
$ time ./hello2     # 可能是代码比较少的缘故，执行效率看上去不是很明显
hello, world

real    0m0.001s
user    0m0.000s
sys     0m0.000s

$ time ./hellos     # 虽然目标代码小了，但是执行效率慢了些
hello, world

real    0m0.002s
user    0m0.000s
sys     0m0.000s</code></pre><p>根据上面的简单演示，可以看出 <code>gcc</code> 有很多不同的优化选项，主要看用户的需求了，目标代码的大小和效率之间貌似存在一个“纠缠”，需要开发人员自己权衡。</p>
<p><span id="toc_27212_14734_10"></span></p>
<h3 id="生成汇编语言文件"><a href="#生成汇编语言文件" class="headerlink" title="生成汇编语言文件"></a>生成汇编语言文件</h3><p>下面通过 <code>-S</code> 选项来看看编译出来的中间结果：汇编语言，还是以之前那个 <code>hello.c</code> 为例。</p>
<pre><code>$ gcc -S hello.c  # 默认输出是hello.s，可自己指定，输出到屏幕`-o -`，输出到其他文件`-o file`
$ cat hello.s
cat hello.s
        .file   &quot;hello.c&quot;
        .section        .rodata
.LC0:
        .string &quot;hello, world&quot;
        .text
.globl main
        .type   main, @function
main:
        leal    4(%esp), %ecx
        andl    $-16, %esp
        pushl   -4(%ecx)
        pushl   %ebp
        movl    %esp, %ebp
        pushl   %ecx
        subl    $4, %esp
        movl    $.LC0, (%esp)
        call    puts
        movl    $0, %eax
        addl    $4, %esp
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
        .size   main, .-main
        .ident  &quot;GCC: (GNU) 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)&quot;
        .section        .note.GNU-stack,&quot;&quot;,@progbits</code></pre><p>不知道看出来没？和课堂里学的 intel 的汇编语法不太一样，这里用的是 <code>AT&amp;T</code> 语法格式。如果想学习 Linux 下的汇编语言开发，下一节开始的所有章节基本上覆盖了 Linux 下汇编语言开发的一般过程，不过这里不介绍汇编语言语法。</p>
<p>在学习后面的章节之前，建议自学旧金山大学的<a href="http://www.cs.usfca.edu/~cruse/cs630f06/" target="_blank" rel="noopener">微机编程课程 CS 630</a>，该课深入介绍了 Linux/X86 平台下的 <code>AT&amp;T</code> 汇编语言开发。如果想在 <code>Qemu</code> 上做这个课程里的实验，可以阅读本文作者写的 <a href="http://www.tinylab.org/cs630-qemu/" target="_blank" rel="noopener">CS630: Linux 下通过 Qemu 学习 X86 AT&amp;T 汇编语言</a>。</p>
<p>需要补充的是，在写 C 语言代码时，如果能够对编译器比较熟悉（工作原理和一些细节）的话，可能会很有帮助。包括这里的优化选项（有些优化选项可能在汇编时采用）和可能的优化措施，例如字节对齐、条件分支语句裁减（删除一些明显分支）等。</p>
<p><span id="toc_27212_14734_11"></span></p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p><span id="toc_27212_14734_12"></span></p>
<h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>汇编实际上还是翻译过程，只不过把作为中间结果的汇编代码翻译成了机器代码，即目标代码，不过它还不可以运行。如果要产生这一中间结果，可用 <code>gcc -c</code>，当然，也可通过 <code>as</code> 命令处理汇编语言源文件来产生。</p>
<p>汇编是把汇编语言翻译成目标代码的过程，如果有在 Windows 下学习过汇编语言开发，大家应该比较熟悉 <code>nasm</code> 汇编工具(支持 Intel 格式的汇编语言)，不过这里主要用 <code>as</code> 汇编工具来汇编 <code>AT&amp;T</code> 格式的汇编语言，因为 <code>gcc</code> 产生的中间代码就是 <code>AT&amp;T</code> 格式的。</p>
<p><span id="toc_27212_14734_13"></span></p>
<h3 id="生成目标代码"><a href="#生成目标代码" class="headerlink" title="生成目标代码"></a>生成目标代码</h3><p>下面来演示分别通过 <code>gcc -c</code> 选项和 <code>as</code> 来产生目标代码。</p>
<pre><code>$ file hello.s
hello.s: ASCII assembler program text
$ gcc -c hello.s   #用gcc把汇编语言编译成目标代码
$ file hello.o     #file命令用来查看文件类型，目标代码可重定位的(relocatable)，
                   #需要通过ld进行进一步链接成可执行程序(executable)和共享库(shared)
hello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped
$ as -o hello.o hello.s        #用as把汇编语言编译成目标代码
$ file hello.o
hello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped</code></pre><p><code>gcc</code> 和 <code>as</code> 默认产生的目标代码都是 ELF 格式的，因此这里主要讨论ELF格式的目标代码（如果有时间再回顾一下 <code>a.out</code> 和 <code>coff</code> 格式，当然也可以先了解一下，并结合 <code>objcopy</code> 来转换它们，比较异同)。</p>
<p><span id="toc_27212_14734_14"></span></p>
<h3 id="ELF-文件初次接触"><a href="#ELF-文件初次接触" class="headerlink" title="ELF 文件初次接触"></a>ELF 文件初次接触</h3><p>目标代码不再是普通的文本格式，无法直接通过文本编辑器浏览，需要一些专门的工具。如果想了解更多目标代码的细节，区分 <code>relocatable</code>（可重定位）、<code>executable</code>（可执行）、<code>shared libarary</code>（共享库）的不同，我们得设法了解目标代码的组织方式和相关的阅读和分析工具。下面主要介绍这部分内容。</p>
<blockquote>
<p>BFD is a package which allows applications to use the same routines to<br>operate on object files whatever the object file format. A new object file<br>format can be supported simply by creating a new BFD back end and adding it to<br>the library.</p>
</blockquote>
<p>binutils（GNU Binary Utilities）的很多工具都采用这个库来操作目标文件，这类工具有 <code>objdump</code>，<code>objcopy</code>，<code>nm</code>，<code>strip</code> 等（当然，我们也可以利用它。如果深入了解ELF格式，那么通过它来分析和编写 Virus 程序将会更加方便），不过另外一款非常优秀的分析工具 <code>readelf</code> 并不是基于这个库，所以也应该可以直接用 <code>elf.h</code> 头文件中定义的相关结构来操作 ELF 文件。</p>
<p>下面将通过这些辅助工具（主要是 <code>readelf</code> 和 <code>objdump</code>），结合 ELF 手册来分析它们。将依次介绍 ELF 文件的结构和三种不同类型 ELF 文件的区别。</p>
<p><span id="toc_27212_14734_15"></span></p>
<h3 id="ELF-文件的结构"><a href="#ELF-文件的结构" class="headerlink" title="ELF 文件的结构"></a>ELF 文件的结构</h3><pre><code>ELF Header(ELF文件头)
Program Headers Table(程序头表，实际上叫段表好一些，用于描述可执行文件和可共享库)
Section 1
Section 2
Section 3
...
Section Headers Table(节区头部表，用于链接可重定位文件成可执行文件或共享库)</code></pre><p>对于可重定位文件，程序头是可选的，而对于可执行文件和共享库文件（动态链接库），节区表则是可选的。可以分别通过 <code>readelf</code> 文件的 <code>-h</code>，<code>-l</code> 和 <code>-S</code> 参数查看 ELF 文件头（ELF Header）、程序头部表（Program Headers Table，段表）和节区表（Section Headers Table）。</p>
<p>文件头说明了文件的类型，大小，运行平台，节区数目等。</p>
<p><span id="toc_27212_14734_16"></span></p>
<h3 id="三种不同类型-ELF-文件比较"><a href="#三种不同类型-ELF-文件比较" class="headerlink" title="三种不同类型 ELF 文件比较"></a>三种不同类型 ELF 文件比较</h3><p>先来通过文件头看看不同ELF的类型。为了说明问题，先来几段代码吧。</p>
<pre><code>/* myprintf.c */
#include &lt;stdio.h&gt;

void myprintf(void)
{
    printf(&quot;hello, world!\n&quot;);
}</code></pre><pre><code>/* test.h -- myprintf function declaration */

#ifndef _TEST_H_
#define _TEST_H_

void myprintf(void);

#endif</code></pre><pre><code>/* test.c */
#include &quot;test.h&quot;

int main()
{
    myprintf();
    return 0;
}</code></pre><p>下面通过这几段代码来演示通过 <code>readelf -h</code> 参数查看 ELF 的不同类型。期间将演示如何创建动态链接库（即可共享文件）、静态链接库，并比较它们的异同。</p>
<p>编译产生两个目标文件 <code>myprintf.o</code> 和 <code>test.o</code>，它们都是可重定位文件（REL）：</p>
<pre><code>$ gcc -c myprintf.c test.c
$ readelf -h test.o | grep Type
  Type:                              REL (Relocatable file)
$ readelf -h myprintf.o | grep Type
  Type:                              REL (Relocatable file)</code></pre><p>根据目标代码链接产生可执行文件，这里的文件类型是可执行的(EXEC)：</p>
<pre><code>$ gcc -o test myprintf.o test.o
$ readelf -h test | grep Type
  Type:                              EXEC (Executable file)</code></pre><p>用 <code>ar</code> 命令创建一个静态链接库，静态链接库也是可重定位文件（REL）：</p>
<pre><code>$ ar rcsv libmyprintf.a myprintf.o
$ readelf -h libmyprintf.a | grep Type
  Type:                              REL (Relocatable file)</code></pre><p>可见，静态链接库和可重定位文件类型一样，它们之间唯一不同是前者可以是多个可重定位文件的“集合”。</p>
<p>静态链接库可直接链接（只需库名，不要前面的 <code>lib</code>），也可用 <code>-l</code> 参数，<code>-L</code> 指定库搜索路径。</p>
<pre><code>$ gcc -o test test.o -lmyprintf -L./</code></pre><p>编译产生动态链接库，并支持 <code>major</code> 和 <code>minor</code> 版本号，动态链接库类型为 <code>DYN</code>：</p>
<pre><code>$ gcc -Wall myprintf.o -shared -Wl,-soname,libmyprintf.so.0 -o libmyprintf.so.0.0
$ ln -sf libmyprintf.so.0.0 libmyprintf.so.0
$ ln -sf libmyprintf.so.0 libmyprintf.so
$ readelf -h libmyprintf.so | grep Type
  Type:                              DYN (Shared object file)</code></pre><p>动态链接库编译时和静态链接库类似：</p>
<pre><code>$ gcc -o test test.o -lmyprintf -L./</code></pre><p>但是执行时需要指定动态链接库的搜索路径，把 <code>LD_LIBRARY_PATH</code> 设为当前目录，指定 <code>test</code> 运行时的动态链接库搜索路径：</p>
<pre><code>$ LD_LIBRARY_PATH=./ ./test
$ gcc -static -o test test.o -lmyprintf -L./</code></pre><p>在不指定 <code>-static</code> 时会优先使用动态链接库，指定时则阻止使用动态链接库，这时会把所有静态链接库文件加入到可执行文件中，使得执行文件很大，而且加载到内存以后会浪费内存空间，因此不建议这么做。</p>
<p>经过上面的演示基本可以看出它们之间的不同：</p>
<ul>
<li>可重定位文件本身不可以运行，仅仅是作为可执行文件、静态链接库（也是可重定位文件）、动态链接库的 “组件”。</li>
<li>静态链接库和动态链接库本身也不可以执行，作为可执行文件的“组件”，它们两者也不同，前者也是可重定位文件（只不过可能是多个可重定位文件的集合），并且在链接时加入到可执行文件中去。</li>
<li>而动态链接库在链接时，库文件本身并没有添加到可执行文件中，只是在可执行文件中加入了该库的名字等信息，以便在可执行文件运行过程中引用库中的函数时由动态链接器去查找相关函数的地址，并调用它们。</li>
</ul>
<p>从这个意义上说，动态链接库本身也具有可重定位的特征，含有可重定位的信息。对于什么是重定位？如何进行静态符号和动态符号的重定位，我们将在链接部分和<a href="02-chapter4.markdown">《动态符号链接的细节》</a>一节介绍。</p>
<p><span id="toc_27212_14734_17"></span></p>
<h3 id="ELF-主体：节区"><a href="#ELF-主体：节区" class="headerlink" title="ELF 主体：节区"></a>ELF 主体：节区</h3><p>下面来看看 ELF 文件的主体内容：节区（Section)。</p>
<p>ELF 文件具有很大的灵活性，它通过文件头组织整个文件的总体结构，通过节区表 (Section Headers Table）和程序头（Program Headers Table 或者叫段表）来分别描述可重定位文件和可执行文件。但不管是哪种类型，它们都需要它们的主体，即各种节区。</p>
<p>在可重定位文件中，节区表描述的就是各种节区本身；而在可执行文件中，程序头描述的是由各个节区组成的段（Segment），以便程序运行时动态装载器知道如何对它们进行内存映像，从而方便程序加载和运行。</p>
<p>下面先来看看一些常见的节区，而关于这些节区（Section）如何通过重定位构成不同的段（Segments），以及有哪些常规的段，我们将在链接部分进一步介绍。</p>
<p>可以通过 <code>readelf -S</code> 查看 ELF 的节区。（建议一边操作一边看文档，以便加深对 ELF 文件结构的理解）先来看看可重定位文件的节区信息，通过节区表来查看：</p>
<p>默认编译好 <code>myprintf.c</code>，将产生一个可重定位的文件 <code>myprintf.o</code>，这里通过 <code>myprintf.o</code> 的节区表查看节区信息。</p>
<pre><code>$ gcc -c myprintf.c
$ readelf -S myprintf.o
There are 11 section headers, starting at offset 0xc0:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 000018 00  AX  0   0  4
  [ 2] .rel.text         REL             00000000 000334 000010 08      9   1  4
  [ 3] .data             PROGBITS        00000000 00004c 000000 00  WA  0   0  4
  [ 4] .bss              NOBITS          00000000 00004c 000000 00  WA  0   0  4
  [ 5] .rodata           PROGBITS        00000000 00004c 00000e 00   A  0   0  1
  [ 6] .comment          PROGBITS        00000000 00005a 000012 00      0   0  1
  [ 7] .note.GNU-stack   PROGBITS        00000000 00006c 000000 00      0   0  1
  [ 8] .shstrtab         STRTAB          00000000 00006c 000051 00      0   0  1
  [ 9] .symtab           SYMTAB          00000000 000278 0000a0 10     10   8  4
  [10] .strtab           STRTAB          00000000 000318 00001a 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre><p>用 <code>objdump -d</code> 可看反编译结果，用 <code>-j</code> 选项可指定需要查看的节区：</p>
<pre><code>$ objdump -d -j .text   myprintf.o
myprintf.o:     file format elf32-i386

Disassembly of section .text:

00000000 &lt;myprintf&gt;:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 ec 08                sub    $0x8,%esp
   6:   83 ec 0c                sub    $0xc,%esp
   9:   68 00 00 00 00          push   $0x0
   e:   e8 fc ff ff ff          call   f &lt;myprintf+0xf&gt;
  13:   83 c4 10                add    $0x10,%esp
  16:   c9                      leave
  17:   c3                      ret</code></pre><p>用 <code>-r</code> 选项可以看到有关重定位的信息，这里有两部分需要重定位：</p>
<pre><code>$ readelf -r myprintf.o

Relocation section &#39;.rel.text&#39; at offset 0x334 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0000000a  00000501 R_386_32          00000000   .rodata
0000000f  00000902 R_386_PC32        00000000   puts</code></pre><p><code>.rodata</code> 节区包含只读数据，即我们要打印的 <code>hello, world!</code></p>
<pre><code>$ readelf -x .rodata myprintf.o

Hex dump of section &#39;.rodata&#39;:
  0x00000000 68656c6c 6f2c2077 6f726c64 2100     hello, world!.</code></pre><p>没有找到 <code>.data</code> 节区, 它应该包含一些初始化的数据：</p>
<pre><code>$ readelf -x .data myprintf.o

Section &#39;.data&#39; has no data to dump.</code></pre><p>也没有 <code>.bss</code> 节区，它应该包含一些未初始化的数据，程序默认初始为 0：</p>
<pre><code>$ readelf -x .bss       myprintf.o

Section &#39;.bss&#39; has no data to dump.</code></pre><p><code>.comment</code> 是一些注释，可以看到是是 <code>Gcc</code> 的版本信息</p>
<pre><code>$ readelf -x .comment myprintf.o

Hex dump of section &#39;.comment&#39;:
  0x00000000 00474343 3a202847 4e552920 342e312e .GCC: (GNU) 4.1.
  0x00000010 3200                                2.</code></pre><p><code>.note.GNU-stack</code> 这个节区也没有内容：</p>
<pre><code>$ readelf -x .note.GNU-stack myprintf.o

Section &#39;.note.GNU-stack&#39; has no data to dump.</code></pre><p><code>.shstrtab</code> 包括所有节区的名字：</p>
<pre><code>$ readelf -x .shstrtab myprintf.o

Hex dump of section &#39;.shstrtab&#39;:
  0x00000000 002e7379 6d746162 002e7374 72746162 ..symtab..strtab
  0x00000010 002e7368 73747274 6162002e 72656c2e ..shstrtab..rel.
  0x00000020 74657874 002e6461 7461002e 62737300 text..data..bss.
  0x00000030 2e726f64 61746100 2e636f6d 6d656e74 .rodata..comment
  0x00000040 002e6e6f 74652e47 4e552d73 7461636b ..note.GNU-stack
  0x00000050 00                                  .</code></pre><p>符号表 <code>.symtab</code> 包括所有用到的相关符号信息，如函数名、变量名，可用 <code>readelf</code> 查看：</p>
<pre><code>$ readelf -symtab myprintf.o

Symbol table &#39;.symtab&#39; contains 10 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS myprintf.c
     2: 00000000     0 SECTION LOCAL  DEFAULT    1
     3: 00000000     0 SECTION LOCAL  DEFAULT    3
     4: 00000000     0 SECTION LOCAL  DEFAULT    4
     5: 00000000     0 SECTION LOCAL  DEFAULT    5
     6: 00000000     0 SECTION LOCAL  DEFAULT    7
     7: 00000000     0 SECTION LOCAL  DEFAULT    6
     8: 00000000    24 FUNC    GLOBAL DEFAULT    1 myprintf
     9: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</code></pre><p>字符串表 <code>.strtab</code> 包含用到的字符串，包括文件名、函数名、变量名等：</p>
<pre><code>$ readelf -x .strtab myprintf.o

Hex dump of section &#39;.strtab&#39;:
  0x00000000 006d7970 72696e74 662e6300 6d797072 .myprintf.c.mypr
  0x00000010 696e7466 00707574 7300              intf.puts.</code></pre><p>从上表可以看出，对于可重定位文件，会包含这些基本节区 <code>.text</code>, <code>.rel.text</code>, <code>.data</code>, <code>.bss</code>, <code>.rodata</code>, <code>.comment</code>, <code>.note.GNU-stack</code>, <code>.shstrtab</code>, <code>.symtab</code> 和 <code>.strtab</code>。</p>
<p><span id="toc_27212_14734_18"></span></p>
<h3 id="汇编语言文件中的节区表述"><a href="#汇编语言文件中的节区表述" class="headerlink" title="汇编语言文件中的节区表述"></a>汇编语言文件中的节区表述</h3><p>为了进一步理解这些节区和源代码的关系，这里来看一看 <code>myprintf.c</code> 产生的汇编代码。</p>
<pre><code>$ gcc -S myprintf.c
$ cat myprintf.s
        .file   &quot;myprintf.c&quot;
        .section        .rodata
.LC0:
        .string &quot;hello, world!&quot;
        .text
.globl myprintf
        .type   myprintf, @function
myprintf:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        subl    $12, %esp
        pushl   $.LC0
        call    puts
        addl    $16, %esp
        leave
        ret
        .size   myprintf, .-myprintf
        .ident  &quot;GCC: (GNU) 4.1.2&quot;
        .section        .note.GNU-stack,&quot;&quot;,@progbits</code></pre><p>是不是可以从中看出可重定位文件中的那些节区和汇编语言代码之间的关系？在上面的可重定位文件，可以看到有一个可重定位的节区，即 <code>.rel.text</code>，它标记了两个需要重定位的项，<code>.rodata</code> 和 <code>puts</code>。这个节区将告诉编译器这两个信息在链接或者动态链接的过程中需要重定位， 具体如何重定位？将根据重定位项的类型，比如上面的 <code>R_386_32</code> 和 <code>R_386_PC32</code>。</p>
<p>到这里，对可重定位文件应该有了一个基本的了解，下面将介绍什么是可重定位，可重定位文件到底是如何被链接生成可执行文件和动态链接库的，这个过程除了进行一些符号的重定位外，还进行了哪些工作呢？</p>
<p><span id="toc_27212_14734_19"></span></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span id="toc_27212_14734_20"></span></p>
<h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p>重定位是将符号引用与符号定义进行链接的过程。因此链接是处理可重定位文件，把它们的各种符号引用和符号定义转换为可执行文件中的合适信息（一般是虚拟内存地址）的过程。</p>
<p>链接又分为静态链接和动态链接，前者是程序开发阶段程序员用 <code>ld</code>（<code>gcc</code> 实际上在后台调用了 <code>ld</code>）静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器（<code>ld-linux.so</code>）自动链接的过程。</p>
<p>比如，如果链接到可执行文件中的是静态链接库 <code>libmyprintf.a</code>，那么 <code>.rodata</code> 节区在链接后需要被重定位到一个绝对的虚拟内存地址，以便程序运行时能够正确访问该节区中的字符串信息。而对于 <code>puts</code> 函数，因为它是动态链接库 <code>libc.so</code> 中定义的函数，所以会在程序运行时通过动态符号链接找出 <code>puts</code> 函数在内存中的地址，以便程序调用该函数。在这里主要讨论静态链接过程，动态链接过程见<a href="02-chapter4.markdown">《动态符号链接的细节》</a>。</p>
<p>静态链接过程主要是把可重定位文件依次读入，分析各个文件的文件头，进而依次读入各个文件的节区，并计算各个节区的虚拟内存位置，对一些需要重定位的符号进行处理，设定它们的虚拟内存地址等，并最终产生一个可执行文件或者是动态链接库。这个链接过程是通过 <code>ld</code> 来完成的，<code>ld</code> 在链接时使用了一个链接脚本（<code>linker script</code>），该链接脚本处理链接的具体细节。</p>
<p>由于静态符号链接过程非常复杂，特别是计算符号地址的过程，考虑到时间关系，相关细节请参考 ELF 手册。这里主要介绍可重定位文件中的节区（节区表描述的）和可执行文件中段（程序头描述的）的对应关系以及 <code>gcc</code> 编译时采用的一些默认链接选项。</p>
<p><span id="toc_27212_14734_21"></span></p>
<h3 id="可执行文件的段：节区重排"><a href="#可执行文件的段：节区重排" class="headerlink" title="可执行文件的段：节区重排"></a>可执行文件的段：节区重排</h3><p>下面先来看看可执行文件的节区信息，通过程序头（段表）来查看，为了比较，先把 <code>test.o</code> 的节区表也列出：</p>
<pre><code>$ readelf -S test.o
There are 10 section headers, starting at offset 0xb4:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 000024 00  AX  0   0  4
  [ 2] .rel.text         REL             00000000 0002ec 000008 08      8   1  4
  [ 3] .data             PROGBITS        00000000 000058 000000 00  WA  0   0  4
  [ 4] .bss              NOBITS          00000000 000058 000000 00  WA  0   0  4
  [ 5] .comment          PROGBITS        00000000 000058 000012 00      0   0  1
  [ 6] .note.GNU-stack   PROGBITS        00000000 00006a 000000 00      0   0  1
  [ 7] .shstrtab         STRTAB          00000000 00006a 000049 00      0   0  1
  [ 8] .symtab           SYMTAB          00000000 000244 000090 10      9   7  4
  [ 9] .strtab           STRTAB          00000000 0002d4 000016 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
$ gcc -o test test.o myprintf.o
$ readelf -l test

Elf file type is EXEC (Executable file)
Entry point 0x80482b0
There are 7 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x0047c 0x0047c R E 0x1000
  LOAD           0x00047c 0x0804947c 0x0804947c 0x00104 0x00108 RW  0x1000
  DYNAMIC        0x000490 0x08049490 0x08049490 0x000c8 0x000c8 RW  0x4
  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r
          .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag
   06</code></pre><p>可发现，<code>test</code> 和 <code>test.o</code>，<code>myprintf.o</code> 相比，多了很多节区，如 <code>.interp</code> 和 <code>.init</code> 等。另外，上表也给出了可执行文件的如下几个段（Segment）：</p>
<ul>
<li><code>PHDR</code>: 给出了程序表自身的大小和位置，不能出现一次以上。</li>
<li><code>INTERP</code>: 因为程序中调用了 <code>puts</code>（在动态链接库中定义），使用了动态链接库，因此需要动态装载器／链接器（<code>ld-linux.so</code>）</li>
<li><code>LOAD</code>: 包括程序的指令，<code>.text</code> 等节区都映射在该段，只读（R）</li>
<li><code>LOAD</code>: 包括程序的数据，<code>.data</code>,<code>.bss</code> 等节区都映射在该段，可读写（RW）</li>
<li><code>DYNAMIC</code>: 动态链接相关的信息，比如包含有引用的动态链接库名字等信息</li>
<li><code>NOTE</code>: 给出一些附加信息的位置和大小</li>
<li><code>GNU_STACK</code>: 这里为空，应该是和GNU相关的一些信息</li>
</ul>
<p>这里的段可能包括之前的一个或者多个节区，也就是说经过链接之后原来的节区被重排了，并映射到了不同的段，这些段将告诉系统应该如何把它加载到内存中。</p>
<p><span id="toc_27212_14734_22"></span></p>
<h3 id="链接背后的故事"><a href="#链接背后的故事" class="headerlink" title="链接背后的故事"></a>链接背后的故事</h3><p>从上表中，通过比较可执行文件 <code>test</code> 中拥有的节区和可重定位文件（<code>test.o</code> 和 <code>myprintf.o</code>）中拥有的节区后发现，链接之后多了一些之前没有的节区，这些新的节区来自哪里？它们的作用是什么呢？先来通过 <code>gcc -v</code> 看看它的后台链接过程。</p>
<p>把可重定位文件链接成可执行文件：</p>
<pre><code>$ gcc -v -o test test.o myprintf.o
Reading specs from /usr/lib/gcc/i486-slackware-linux/4.1.2/specs
Target: i486-slackware-linux
Configured with: ../gcc-4.1.2/configure --prefix=/usr --enable-shared
--enable-languages=ada,c,c++,fortran,java,objc --enable-threads=posix
--enable-__cxa_atexit --disable-checking --with-gnu-ld --verbose
--with-arch=i486 --target=i486-slackware-linux --host=i486-slackware-linux
Thread model: posix
gcc version 4.1.2
 /usr/libexec/gcc/i486-slackware-linux/4.1.2/collect2 --eh-frame-hdr -m
elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o test
/usr/lib/gcc/i486-slackware-linux/4.1.2/../../../crt1.o
/usr/lib/gcc/i486-slackware-linux/4.1.2/../../../crti.o
/usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o
-L/usr/lib/gcc/i486-slackware-linux/4.1.2
-L/usr/lib/gcc/i486-slackware-linux/4.1.2
-L/usr/lib/gcc/i486-slackware-linux/4.1.2/../../../../i486-slackware-linux/lib
-L/usr/lib/gcc/i486-slackware-linux/4.1.2/../../.. test.o myprintf.o -lgcc
--as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed
/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o
/usr/lib/gcc/i486-slackware-linux/4.1.2/../../../crtn.o</code></pre><p>从上述演示看出，<code>gcc</code> 在链接了我们自己的目标文件 <code>test.o</code> 和 <code>myprintf.o</code> 之外，还链接了 <code>crt1.o</code>，<code>crtbegin.o</code> 等额外的目标文件，难道那些新的节区就来自这些文件？</p>
<p><span id="toc_27212_14734_23"></span></p>
<h3 id="用-ld-完成链接过程"><a href="#用-ld-完成链接过程" class="headerlink" title="用 ld 完成链接过程"></a>用 ld 完成链接过程</h3><p>另外 <code>gcc</code> 在进行了相关配置（<code>./configure</code>）后，调用了 <code>collect2</code>，却并没有调用 <code>ld</code>，通过查找 <code>gcc</code> 文档中和 <code>collect2</code> 相关的部分发现 <code>collect2</code> 在后台实际上还是去寻找 <code>ld</code> 命令的。为了理解 <code>gcc</code> 默认链接的后台细节，这里直接把 <code>collect2</code> 替换成 <code>ld</code>，并把一些路径换成绝对路径或者简化，得到如下的 <code>ld</code> 命令以及执行的效果。</p>
<pre><code>$ ld --eh-frame-hdr \
-m elf_i386 \
-dynamic-linker /lib/ld-linux.so.2 \
-o test \
/usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o \
test.o myprintf.o \
-L/usr/lib/gcc/i486-slackware-linux/4.1.2 -L/usr/i486-slackware-linux/lib -L/usr/lib/ \
-lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed \
/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o /usr/lib/crtn.o
$ ./test
hello, world!</code></pre><p>不出所料，它完美地运行了。下面通过 <code>ld</code> 的手册（<code>man ld</code>）来分析一下这几个参数：</p>
<ul>
<li><p><code>--eh-frame-hdr</code></p>
<p>  要求创建一个 <code>.eh_frame_hdr</code> 节区(貌似目标文件test中并没有这个节区，所以不关心它)。</p>
</li>
<li><p><code>-m elf_i386</code></p>
<p>  这里指定不同平台上的链接脚本，可以通过 <code>--verbose</code> 命令查看脚本的具体内容，如 <code>ld -m elf_i386 --verbose</code>，它实际上被存放在一个文件中（<code>/usr/lib/ldscripts</code> 目录下），我们可以去修改这个脚本，具体如何做？请参考 <code>ld</code> 的手册。在后面我们将简要提到链接脚本中是如何预定义变量的，以及这些预定义变量如何在我们的程序中使用。需要提到的是，如果不是交叉编译，那么无须指定该选项。</p>
</li>
<li><p>-dynamic-linker /lib/ld-linux.so.2</p>
<p>  指定动态装载器/链接器，即程序中的 <code>INTERP</code> 段中的内容。动态装载器/链接器负责链接有可共享库的可执行文件的装载和动态符号链接。</p>
</li>
<li><p>-o test</p>
<p>  指定输出文件，即可执行文件名的名字</p>
</li>
<li><p>/usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o</p>
<p>  链接到 <code>test</code> 文件开头的一些内容，这里实际上就包含了 <code>.init</code> 等节区。<code>.init</code> 节区包含一些可执行代码，在 <code>main</code> 函数之前被调用，以便进行一些初始化操作，在 C++ 中完成构造函数功能。</p>
</li>
<li><p>test.o myprintf.o</p>
<p>  链接我们自己的可重定位文件</p>
</li>
<li><p><code>-L/usr/lib/gcc/i486-slackware-linux/4.1.2 -L/usr/i486-slackware-linux/lib -L/usr/lib/ \
-lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed</code></p>
<p>  链接 <code>libgcc</code> 库和 <code>libc</code> 库，后者定义有我们需要的 <code>puts</code> 函数</p>
</li>
<li><p>/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o /usr/lib/crtn.o</p>
<p>  链接到 <code>test</code> 文件末尾的一些内容，这里实际上包含了 <code>.fini</code> 等节区。<code>.fini</code> 节区包含了一些可执行代码，在程序退出时被执行，作一些清理工作，在 C++ 中完成析构造函数功能。我们往往可以通过 <code>atexit</code> 来注册那些需要在程序退出时才执行的函数。</p>
</li>
</ul>
<p><span id="toc_27212_14734_24"></span></p>
<h3 id="C-构造与析构：crtbegin-o和crtend-o"><a href="#C-构造与析构：crtbegin-o和crtend-o" class="headerlink" title="C++构造与析构：crtbegin.o和crtend.o"></a>C++构造与析构：crtbegin.o和crtend.o</h3><p>对于 <code>crtbegin.o</code> 和 <code>crtend.o</code> 这两个文件，貌似完全是用来支持 C++ 的构造和析构工作的，所以可以不链接到我们的可执行文件中，链接时把它们去掉看看，</p>
<pre><code>$ ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o test \
  /usr/lib/crt1.o /usr/lib/crti.o test.o myprintf.o \
  -L/usr/lib -lc /usr/lib/crtn.o    #后面发现不用链接libgcc，也不用--eh-frame-hdr参数
$ readelf -l test

Elf file type is EXEC (Executable file)
Entry point 0x80482b0
There are 7 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x003ea 0x003ea R E 0x1000
  LOAD           0x0003ec 0x080493ec 0x080493ec 0x000e8 0x000e8 RW  0x1000
  DYNAMIC        0x0003ec 0x080493ec 0x080493ec 0x000c8 0x000c8 RW  0x4
  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r
          .rel.dyn .rel.plt .init .plt .text .fini .rodata
   03     .dynamic .got .got.plt .data
   04     .dynamic
   05     .note.ABI-tag
   06
$ ./test
hello, world!</code></pre><p>完全可以工作，而且发现 <code>.ctors</code>（保存着程序中全局构造函数的指针数组）, <code>.dtors</code>（保存着程序中全局析构函数的指针数组）,<code>.jcr</code>（未知）,<code>.eh_frame</code> 节区都没有了，所以 <code>crtbegin.o</code> 和 <code>crtend.o</code> 应该包含了这些节区。</p>
<p><span id="toc_27212_14734_25"></span></p>
<h3 id="初始化与退出清理：crti-o-和-crtn-o"><a href="#初始化与退出清理：crti-o-和-crtn-o" class="headerlink" title="初始化与退出清理：crti.o 和 crtn.o"></a>初始化与退出清理：crti.o 和 crtn.o</h3><p>而对于另外两个文件 <code>crti.o</code> 和 <code>crtn.o</code>，通过 <code>readelf -S</code> 查看后发现它们都有 <code>.init</code> 和 <code>.fini</code> 节区，如果我们不需要让程序进行一些初始化和清理工作呢？是不是就可以不链接这个两个文件？试试看。</p>
<pre><code>$ ld  -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o test \
      /usr/lib/crt1.o test.o myprintf.o -L/usr/lib/ -lc
/usr/lib/libc_nonshared.a(elf-init.oS): In function `__libc_csu_init&#39;:
(.text+0x25): undefined reference to `_init&#39;</code></pre><p>貌似不行，竟然有人调用了 <code>__libc_csu_init</code> 函数，而这个函数引用了 <code>_init</code>。这两个符号都在哪里呢？</p>
<pre><code>$ readelf -s /usr/lib/crt1.o | grep __libc_csu_init
    18: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND __libc_csu_init
$ readelf -s /usr/lib/crti.o | grep _init
    17: 00000000     0 FUNC    GLOBAL DEFAULT    5 _init</code></pre><p>竟然是 <code>crt1.o</code> 调用了 <code>__libc_csu_init</code> 函数，而该函数却引用了我们没有链接的 <code>crti.o</code> 文件中定义的 <code>_init</code> 符号。这样的话不链接 <code>crti.o</code> 和 <code>crtn.o</code> 文件就不成了罗？不对吧，要不干脆不用 <code>crt1.o</code> 算了，看看 <code>gcc</code> 额外链接进去的最后一个文件 <code>crt1.o</code> 到底干了个啥子？</p>
<pre><code>$ ld  -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o \
      test test.o myprintf.o -L/usr/lib/ -lc
ld: warning: cannot find entry symbol _start; defaulting to 00000000080481a4</code></pre><p>这样却说没有找到入口符号 <code>_start</code>，难道 <code>crt1.o</code> 中定义了这个符号？不过它给默认设置了一个地址，只是个警告，说明 <code>test</code> 已经生成，不管怎样先运行看看再说。</p>
<pre><code>$ ./test
hello, world!
Segmentation fault</code></pre><p>貌似程序运行完了，不过结束时冒出个段错误？可能是程序结束时有问题，用 <code>gdb</code> 调试看看：</p>
<pre><code>$ gcc -g -c test.c myprintf.c #产生目标代码, 非交叉编译，不指定-m也可链接，所以下面可去掉-m
$ ld -dynamic-linker /lib/ld-linux.so.2 -o test \
     test.o myprintf.o -L/usr/lib -lc
ld: warning: cannot find entry symbol _start; defaulting to 00000000080481d8
$ ./test
hello, world!
Segmentation fault
$ gdb -q ./test
(gdb) l
1       #include &quot;test.h&quot;
2
3       int main()
4       {
5               myprintf();
6               return 0;
7       }
(gdb) break 7      #在程序的末尾设置一个断点
Breakpoint 1 at 0x80481bf: file test.c, line 7.
(gdb) r            #程序都快结束了都没问题，怎么会到最后出个问题呢？
Starting program: /mnt/hda8/Temp/c/program/test
hello, world!

Breakpoint 1, main () at test.c:7
7       }
(gdb) n        #单步执行看看，怎么下面一条指令是0x00000001，肯定是程序退出以后出了问题
0x00000001 in ?? ()
(gdb) n        #诶，当然找不到边了，都跑到0x00000001了
Cannot find bounds of current function
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00000001 in ?? ()</code></pre><p>原来是这么回事，估计是 <code>return 0</code> 返回之后出问题了，看看它的汇编去。</p>
<pre><code>$ gcc -S test.c #产生汇编代码
$ cat test.s
...
        call    myprintf
        movl    $0, %eax
        addl    $4, %esp
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
...</code></pre><p>后面就这么几条指令，难不成 <code>ret</code> 返回有问题，不让它 <code>ret</code> 返回，把 <code>return</code> 改成 <code>_exit</code> 直接进入内核退出。</p>
<pre><code>$ vim test.c
$ cat test.c    #就把return语句修改成_exit了。
#include &quot;test.h&quot;
#include &lt;unistd.h&gt; /* _exit */

int main()
{
    myprintf();
    _exit(0);
}
$ gcc -g -c test.c myprintf.c
$ ld -dynamic-linker /lib/ld-linux.so.2 -o test test.o myprintf.o -L/usr/lib -lc
ld: warning: cannot find entry symbol _start; defaulting to 00000000080481d8
$ ./test    #竟然好了，再看看汇编有什么不同
hello, world!
$ gcc -S test.c
$ cat test.s    #貌似就把ret指令替换成了_exit函数调用，直接进入内核，让内核处理了，那为什么ret有问题呢？
...
        call    myprintf
        subl    $12, %esp
        pushl   $0
        call    _exit
...
$ gdb -q ./test    #把代码改回去（改成return 0;），再调试看看调用main函数返回时的下一条指令地址eip
(gdb) l
warning: Source file is more recent than executable.
1       #include &quot;test.h&quot;
2
3       int main()
4       {
5               myprintf();
6               return 0;
7       }
(gdb) break 5
Breakpoint 1 at 0x80481b5: file test.c, line 5.
(gdb) break 7
Breakpoint 2 at 0x80481bc: file test.c, line 7.
(gdb) r
Starting program: /mnt/hda8/Temp/c/program/test

Breakpoint 1, main () at test.c:5
5               myprintf();
(gdb) x/8x $esp
0xbf929510:     0xbf92953c      0x080481a4      0x00000000      0xb7eea84f
0xbf929520:     0xbf92953c      0xbf929534      0x00000000      0x00000001</code></pre><p>发现 <code>0x00000001</code> 刚好是之前调试时看到的程序返回后的位置，即 <code>eip</code>，说明程序在初始化时，这个 <code>eip</code> 就是错误的。为什么呢？因为根本没有链接进初始化的代码，而是在编译器自己给我们，初始化了程序入口即 <code>00000000080481d8，也就是说，没有人调用</code>main<code>，</code>main<code>不知道返回哪里去，所以，我们直接让</code>main<code>结束时进入内核调用</code>_exit` 而退出则不会有问题。</p>
<p>通过上面的演示和解释发现只要把return语句修改为_exit语句，程序即使不链接任何额外的目标代码都可以正常运行（原因是不链接那些额外的文件时相当于没有进行初始化操作，如果在程序的最后执行ret汇编指令，程序将无法获得正确的eip，从而无法进行后续的动作）。但是为什么会有“找不到_start符号”的警告呢？通过<code>readelf -s</code>查看crt1.o发现里头有这个符号，并且crt1.o引用了main这个符号，是不是意味着会从<code>_start</code>进入main呢？是不是程序入口是<code>_start</code>，而并非main呢？</p>
<p><span id="toc_27212_14734_26"></span></p>
<h3 id="C-语言程序真正的入口"><a href="#C-语言程序真正的入口" class="headerlink" title="C 语言程序真正的入口"></a>C 语言程序真正的入口</h3><p>先来看看刚才提到的链接器的默认链接脚本（<code>ld -m elf_386 --verbose</code>），它告诉我们程序的入口（entry）是 <code>_start</code>，而一个可执行文件必须有一个入口地址才能运行，所以这就是说明了为什么 <code>ld</code> 一定要提示我们 “_start找不到”，找不到以后就给默认设置了一个地址。</p>
<pre><code>$ ld --verbose  | grep ^ENTRY    #非交叉编译，可不用-m参数；ld默认找_start入口，并不是main哦！
ENTRY(_start)</code></pre><p>原来是这样，程序的入口（entry）竟然不是 <code>main</code> 函数，而是 <code>_start</code>。那干脆把汇编里头的 <code>main</code> 给改掉算了，看行不行？</p>
<p>先生成汇编 <code>test.s</code>：</p>
<pre><code>$ cat test.c
#include &quot;test.h&quot;
#include &lt;unistd.h&gt;     /* _exit */

int main()
{
    myprintf();
    _exit(0);
}
$ gcc -S test.c</code></pre><p>然后把汇编中的 <code>main</code> 改为 <code>_start</code>，即改程序入口为 <code>_start</code>：</p>
<pre><code>$ sed -i -e &quot;s#main#_start#g&quot; test.s
$ gcc -c test.s myprintf.c</code></pre><p>重新链接，发现果然没问题了：</p>
<pre><code>$ ld -dynamic-linker /lib/ld-linux.so.2 -o test test.o myprintf.o -L/usr/lib/ -lc
$ ./test
hello, world!</code></pre><p><code>_start</code> 竟然是真正的程序入口，那在有 <code>main</code> 的情况下呢？为什么在 <code>_start</code> 之后能够找到 <code>main</code> 呢？这个看看 alert7 大叔的<a href="http://www.xfocus.net/articles/200109/269.html" target="_blank" rel="noopener">Before main 分析</a>吧，这里不再深入介绍。</p>
<p>总之呢，通过修改程序的 <code>return</code> 语句为 <code>_exit(0)</code> 和修改程序的入口为 <code>_start</code>，我们的代码不链接 <code>gcc</code> 默认链接的那些额外的文件同样可以工作得很好。并且打破了一个学习 C 语言以来的常识：<code>main</code> 函数作为程序的主函数，是程序的入口，实际上则不然。</p>
<p><span id="toc_27212_14734_27"></span></p>
<h3 id="链接脚本初次接触"><a href="#链接脚本初次接触" class="headerlink" title="链接脚本初次接触"></a>链接脚本初次接触</h3><p>再补充一点内容，在 <code>ld</code> 的链接脚本中，有一个特别的关键字 <code>PROVIDE</code>，由这个关键字定义的符号是 <code>ld</code> 的预定义字符，我们可以在 C 语言函数中扩展它们后直接使用。这些特别的符号可以通过下面的方法获取，</p>
<pre><code>$ ld --verbose | grep PROVIDE | grep -v HIDDEN
  PROVIDE (__executable_start = 0x08048000); . = 0x08048000 + SIZEOF_HEADERS;
  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  _edata = .; PROVIDE (edata = .);
  _end = .; PROVIDE (end = .);</code></pre><p>这里面有几个我们比较关心的，第一个是程序的入口地址 <code>__executable_start</code>，另外三个是 <code>etext</code>，<code>edata</code>，<code>end</code>，分别对应程序的代码段（text）、初始化数据（data）和未初始化的数据（bss）（可参考<code>man etext</code>），如何引用这些变量呢？看看这个例子。</p>
<pre><code>/* predefinevalue.c */
#include &lt;stdio.h&gt;

extern int __executable_start, etext, edata, end;

int main(void)
{
    printf (&quot;program entry: 0x%x \n&quot;, &amp;__executable_start);
    printf (&quot;etext address(text segment): 0x%x \n&quot;, &amp;etext);
    printf (&quot;edata address(initilized data): 0x%x \n&quot;, &amp;edata);
    printf (&quot;end address(uninitilized data): 0x%x \n&quot;, &amp;end);

    return 0;
}</code></pre><p>到这里，程序链接过程的一些细节都介绍得差不多了。在<a href="02-chapter4.markdown">《动态符号链接的细节》</a>中将主要介绍 ELF 文件的动态符号链接过程。</p>
<p><span id="toc_27212_14734_28"></span></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-assembly/index.html" target="_blank" rel="noopener">Linux 汇编语言开发指南</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/hardware/ppc/assembly/index.html" target="_blank" rel="noopener">PowerPC 汇编</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-powasm1.html" target="_blank" rel="noopener">用于 Power 体系结构的汇编语言</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/index.html" target="_blank" rel="noopener">Linux 中 x86 的内联汇编</a></li>
<li>Linux Assembly HOWTO</li>
<li>Linux Assembly Language Programming</li>
<li>Guide to Assembly Language Programming in Linux</li>
<li><a href="http://www.luv.asn.au/overheads/compile.html" target="_blank" rel="noopener">An beginners guide to compiling programs under Linux</a></li>
<li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.2.2/gcc/" target="_blank" rel="noopener">gcc manual</a></li>
<li><a href="http://efrw01.frascati.enea.it/Software/Unix/IstrFTU/cern-cnl-2001-003-25-link.html" target="_blank" rel="noopener">A Quick Tour of Compiling, Linking, Loading, and Handling Libraries on Unix</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/au-unixtools.html" target="_blank" rel="noopener">Unix 目标文件初探</a></li>
<li><a href="http://www.xfocus.net/articles/200109/269.html" target="_blank" rel="noopener">Before main()分析</a></li>
<li><a href="http://www.linuxforums.org/forum/linux-kernel/51790-process-viewing-its-own-proc-pid-map-information.html" target="_blank" rel="noopener">A Process Viewing Its Own /proc/<PID>/map Information</a></li>
<li>UNIX 环境高级编程</li>
<li>Linux Kernel Primer</li>
<li><a href="http://www.linuxforums.org/misc/understanding_elf_using_readelf_and_objdump.html" target="_blank" rel="noopener">Understanding ELF using readelf and objdump</a></li>
<li><a href="http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html" target="_blank" rel="noopener">Study of ELF loading and relocs</a></li>
<li>ELF file format and ABI<ul>
<li><a href="http://www.x86.org/ftp/manuals/tools/elf.pdf" target="_blank" rel="noopener">[1]</a></li>
<li><a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" target="_blank" rel="noopener">[2]</a></li>
</ul>
</li>
<li>TN05.ELF.Format.Summary.pdf</li>
<li><a href="http://www.xfocus.net/articles/200105/174.html" target="_blank" rel="noopener">ELF文件格式(中文)</a></li>
<li>关于 Gcc 方面的论文，请查看历年的会议论文集<ul>
<li><a href="http://www.gccsummit.org/2005/2005-GCC-Summit-Proceedings.pdf" target="_blank" rel="noopener">2005</a></li>
<li><a href="http://www.gccsummit.org/2006/2006-GCC-Summit-Proceedings.pdf" target="_blank" rel="noopener">2006</a></li>
</ul>
</li>
<li><a href="http://www.faqs.org/docs/Linux-HOWTO/GCC-HOWTO.html" target="_blank" rel="noopener">The Linux GCC HOW TO</a></li>
<li><a href="http://linux.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/elf.html" target="_blank" rel="noopener">ELF: From The Programmer’s Perspective</a></li>
<li><a href="http://www.xxlinux.com/linux/article/development/soft/20070424/8267.html" target="_blank" rel="noopener">C/C++ 程序编译步骤详解</a></li>
<li><a href="http://c-faq-chn.sourceforge.net/ccfaq/index.html" target="_blank" rel="noopener">C 语言常见问题集</a></li>
<li><a href="http://elfhack.whitecell.org/mydocs/use_bfd.txt" target="_blank" rel="noopener">使用 BFD 操作 ELF</a></li>
<li><a href="http://sourceware.org/binutils/docs/bfd/index.html" target="_blank" rel="noopener">bfd document</a></li>
<li><a href="http://blog.chinaunix.net/u/19881/showart_215242.html" target="_blank" rel="noopener">UNIX/LINUX 平台可执行文件格式分析</a></li>
<li><a href="http://www.tinylab.org/linux-assembly-language-quick-start/" target="_blank" rel="noopener">Linux 汇编语言快速上手：4大架构一块学</a></li>
<li>GNU binutils 小结</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>代码测试、调试与优化</title>
    <url>/2016/12/20/c-optimization/</url>
    <content><![CDATA[<blockquote>
<p>转载自<a href="https://github.com/tinyclub/open-c-book" target="_blank" rel="noopener">开源书籍：《C语言编程透视》，透视C的前世今生！</a>，主要介绍常用代码优化手段：<code>time</code>、<code>calltree</code>、<code>gprof</code>、<code>valgrind</code>等。</p>
</blockquote>
<p>目录如下：</p>
<ul>
<li>代码测试<ul>
<li>测试程序的运行时间 time</li>
<li>函数调用关系图 calltree</li>
<li>性能测试工具 gprof &amp; kprof</li>
<li>代码覆盖率测试 gcov &amp; ggcov</li>
<li>内存访问越界 catchsegv, libSegFault.so</li>
<li>缓冲区溢出 libsafe.so</li>
<li>内存泄露 Memwatch, Valgrind, mtrace</li>
</ul>
</li>
<li>代码调试<ul>
<li>静态调试：printf + gcc -D（打印程序中的变量）</li>
<li>交互式的调试（动态调试）：gdb（支持本地和远程）/ald（汇编指令级别的调试）</li>
<li>嵌入式系统调试方法 gdbserver/gdb</li>
<li>汇编代码的调试 ald</li>
<li>实时调试：gdb tracepoint</li>
<li>调试内核</li>
</ul>
</li>
<li>代码优化</li>
</ul>
<a id="more"></a>

<h1 id="代码测试、调试与优化"><a href="#代码测试、调试与优化" class="headerlink" title="代码测试、调试与优化"></a>代码测试、调试与优化</h1><ul>
<li><a href="#toc_7140_15195_1">前言</a></li>
<li><a href="#toc_7140_15195_2">代码测试</a><ul>
<li><a href="#toc_7140_15195_3">测试程序的运行时间 time</a></li>
<li><a href="#toc_7140_15195_4">函数调用关系图 calltree</a></li>
<li><a href="#toc_7140_15195_5">性能测试工具 gprof &amp; kprof</a></li>
<li><a href="#toc_7140_15195_6">代码覆盖率测试 gcov &amp; ggcov</a></li>
<li><a href="#toc_7140_15195_7">内存访问越界 catchsegv, libSegFault.so</a></li>
<li><a href="#toc_7140_15195_8">缓冲区溢出 libsafe.so</a></li>
<li><a href="#toc_7140_15195_9">内存泄露 Memwatch, Valgrind, mtrace</a></li>
</ul>
</li>
<li><a href="#toc_7140_15195_10">代码调试</a><ul>
<li><a href="#toc_7140_15195_11">静态调试：printf + gcc -D（打印程序中的变量）</a></li>
<li><a href="#toc_7140_15195_12">交互式的调试（动态调试）：gdb（支持本地和远程）/ald（汇编指令级别的调试）</a><ul>
<li><a href="#toc_7140_15195_13">嵌入式系统调试方法 gdbserver/gdb</a></li>
<li><a href="#toc_7140_15195_14">汇编代码的调试 ald</a></li>
</ul>
</li>
<li><a href="#toc_7140_15195_15">实时调试：gdb tracepoint</a></li>
<li><a href="#toc_7140_15195_16">调试内核</a></li>
</ul>
</li>
<li><a href="#toc_7140_15195_17">代码优化</a></li>
<li><a href="#toc_7140_15195_18">参考资料</a></li>
</ul>
<p><span id="toc_7140_15195_1"></span></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码写完以后往往要做测试（或验证）、调试，可能还要优化。</p>
<ul>
<li><p>关于测试（或验证）</p>
<p>通常对应着两个英文单词 <code>Verification</code> 和 <code>Validation</code>，在资料 <a href="http://satc.gsfc.nasa.gov/assure/agbsec5.txt" target="_blank" rel="noopener">[1]</a> 中有关于这个的定义和一些深入的讨论，在资料 <a href="http://www.faqs.org/qa/qa-9060.html" target="_blank" rel="noopener">[2]</a> 中，很多人给出了自己的看法。但是正如资料 <a href="http://www.faqs.org/qa/qa-9060.html" target="_blank" rel="noopener">[2]</a> 提到的：</p>
<blockquote>
<p>The differences between verification and validation are unimportant except to the theorist; practitioners use the term V&amp;V to refer to all of the activities that are aimed at making sure the software will function as required.</p>
</blockquote>
<p>所以，无论测试（或验证）目的都是为了让软件的功能能够达到需求。测试和验证通常会通过一些形式化（貌似可以简单地认为有数学根据的）或者非形式化的方法去验证程序的功能是否达到要求。</p>
</li>
<li><p>关于调试</p>
<p>而调试对应英文 debug，debug 叫“驱除害虫”，也许一个软件的功能达到了要求，但是可能会在测试或者是正常运行时出现异常，因此需要处理它们。</p>
</li>
<li><p>关于优化</p>
<p>debug 是为了保证程序的正确性，之后就需要考虑程序的执行效率，对于存储资源受限的嵌入式系统，程序的大小也可能是优化的对象。</p>
<p>很多理论性的东西实在没有研究过，暂且不说吧。这里只是想把一些需要动手实践的东西先且记录和总结一下，另外很多工具在这里都有提到和罗列，包括 Linux 内核调试相关的方法和工具。关于更详细更深入的内容还是建议直接看后面的参考资料为妙。</p>
</li>
</ul>
<p>下面的所有演示在如下环境下进行：</p>
<pre><code>$ uname -a
Linux falcon 2.6.22-14-generic #1 SMP Tue Feb 12 07:42:25 UTC 2008 i686 GNU/Linux
$ echo $SHELL
/bin/bash
$ /bin/bash --version | grep bash
GNU bash, version 3.2.25(1)-release (i486-pc-linux-gnu)
$ gcc --version | grep gcc
gcc (GCC) 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)
$ cat /proc/cpuinfo | grep &quot;model name&quot;
model name      : Intel(R) Pentium(R) 4 CPU 2.80GHz</code></pre><p><span id="toc_7140_15195_2"></span></p>
<h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>代码测试有很多方面，例如运行时间、函数调用关系图、代码覆盖度、性能分析（Profiling）、内存访问越界（Segmentation Fault）、缓冲区溢出（Stack Smashing 合法地进行非法的内存访问？所以很危险）、内存泄露（Memory Leak）等。</p>
<p><span id="toc_7140_15195_3"></span></p>
<h3 id="测试程序的运行时间-time"><a href="#测试程序的运行时间-time" class="headerlink" title="测试程序的运行时间 time"></a>测试程序的运行时间 time</h3><p>Shell 提供了内置命令 <code>time</code> 用于测试程序的执行时间，默认显示结果包括三部分：实际花费时间（real time）、用户空间花费时间（user time）和内核空间花费时间（kernel time）。</p>
<pre><code>$ time pstree 2&gt;&amp;1 &gt;/dev/null

real    0m0.024s
user    0m0.008s
sys     0m0.004s</code></pre><p><code>time</code> 命令给出了程序本身的运行时间。这个测试原理非常简单，就是在程序运行（通过 <code>system</code> 函数执行）前后记录了系统时间（用 <code>times</code> 函数），然后进行求差就可以。如果程序运行时间很短，运行一次看不到效果，可以考虑采用测试纸片厚度的方法进行测试，类似把很多纸张叠到一起来测试纸张厚度一样，我们可以让程序运行很多次。</p>
<p>如果程序运行时间太长，执行效率很低，那么得考虑程序内部各个部分的执行情况，从而对代码进行可能的优化。具体可能会考虑到这两点：</p>
<p>对于 C 语言程序而言，一个比较宏观的层次性的轮廓（profile）是函数调用图、函数内部的条件分支构成的语句块，然后就是具体的语句。把握好这样一个轮廓后，就可以有针对性地去关注程序的各个部分，包括哪些函数、哪些分支、哪些语句最值得关注（执行次数越多越值得优化，术语叫 hotspots）。</p>
<p>对于 Linux 下的程序而言，程序运行时涉及到的代码会涵盖两个空间，即用户空间和内核空间。由于这两个空间涉及到地址空间的隔离，在测试或调试时，可能涉及到两个空间的工具。前者绝大多数是基于 <code>Gcc</code> 的特定参数和系统的 <code>ptrace</code> 调用，而后者往往实现为内核的补丁，它们在原理上可能类似，但实际操作时后者显然会更麻烦，不过如果你不去 hack 内核，那么往往无须关心后者。</p>
<p><span id="toc_7140_15195_4"></span></p>
<h3 id="函数调用关系图-calltree"><a href="#函数调用关系图-calltree" class="headerlink" title="函数调用关系图 calltree"></a>函数调用关系图 calltree</h3><p><code>calltree</code> 可以非常简单方便地反应一个项目的函数调用关系图，虽然诸如 <code>gprof</code> 这样的工具也能做到，不过如果仅仅要得到函数调用图，<code>calltree</code> 应该是更好的选择。如果要产生图形化的输出可以使用它的 <code>-dot</code> 参数。从<a href="ftp://ftp.berlios.de/pub/calltree/calltree-2.3.tar.bz2">这里</a>可以下载到它。</p>
<p>这里是一份基本用法演示结果：</p>
<pre><code>$ calltree -b -np -m *.c
main:
|   close
|   commitchanges
|   |   err
|   |   |   fprintf
|   |   ferr
|   |   ftruncate
|   |   lseek
|   |   write
|   ferr
|   getmemorysize
|   modifyheaders
|   open
|   printf
|   readelfheader
|   |   err
|   |   |   fprintf
|   |   ferr
|   |   read
|   readphdrtable
|   |   err
|   |   |   fprintf
|   |   ferr
|   |   malloc
|   |   read
|   truncatezeros
|   |   err
|   |   |   fprintf
|   |   ferr
|   |   lseek
|   |   read$ </code></pre><p>这样一份结果对于“反向工程”应该会很有帮助，它能够呈现一个程序的大体结构，对于阅读和分析源代码来说是一个非常好的选择。虽然 <code>cscope</code> 和 <code>ctags</code> 也能够提供一个函数调用的“即时”（在编辑 Vim 的过程中进行调用）视图（view），但是 <code>calltree</code> 却给了我们一个宏观的视图。</p>
<p>不过这样一个视图只涉及到用户空间的函数，如果想进一步给出内核空间的宏观视图，那么 <code>strace</code>，<code>KFT</code> 或者 <code>Ftrace</code> 就可以发挥它们的作用。另外，该视图也没有给出库中的函数，如果要跟踪呢？需要 <code>ltrace</code> 工具。</p>
<p>另外发现 <code>calltree</code> 仅仅给出了一个程序的函数调用视图，而没有告诉我们各个函数的执行次数等情况。如果要关注这些呢？我们有 <code>gprof</code>。</p>
<p><span id="toc_7140_15195_5"></span></p>
<h3 id="性能测试工具-gprof-amp-kprof"><a href="#性能测试工具-gprof-amp-kprof" class="headerlink" title="性能测试工具 gprof &amp; kprof"></a>性能测试工具 gprof &amp; kprof</h3><p>参考资料<a href="http://www.linuxjournal.com/article/6758" target="_blank" rel="noopener">[3]</a>详细介绍了这个工具的用法，这里仅挑选其中一个例子来演示。<code>gprof</code> 是一个命令行的工具，而 KDE 桌面环境下的 <code>kprof</code> 则给出了图形化的输出，这里仅演示前者。</p>
<p>首先来看一段代码（来自资料<a href="http://www.linuxjournal.com/article/6758" target="_blank" rel="noopener">[3]</a>），算 <code>Fibonacci</code> 数列的，</p>
<pre><code>#include &lt;stdio.h&gt;

int fibonacci(int n);

int main (int argc, char **argv)
{
    int fib;
    int n;

    for (n = 0; n &lt;= 42; n++) {
        fib = fibonacci(n);
        printf(&quot;fibonnaci(%d) = %d\n&quot;, n, fib);
    }

    return 0;
}

int fibonacci(int n)
{
    int fib;

    if (n &lt;= 0) {
        fib = 0;
    } else if (n == 1) {
        fib = 1;
    } else {
        fib = fibonacci(n -1) + fibonacci(n - 2);
    }

    return fib;
}</code></pre><p>通过 <code>calltree</code> 看看这段代码的视图，</p>
<pre><code>$ calltree -b -np -m *.c
main:
|   fibonacci
|   |   fibonacci ....
|   printf</code></pre><p>可以看出程序主要涉及到一个 <code>fibonacci</code> 函数，这个函数递归调用自己。为了能够使用 <code>gprof</code>，需要编译时加上 <code>-pg</code> 选项，让 <code>Gcc</code> 加入相应的调试信息以便 <code>gprof</code> 能够产生函数执行情况的报告。</p>
<pre><code>$ gcc -pg -o fib fib.c
$ ls
fib  fib.c</code></pre><p>运行程序并查看执行时间，</p>
<pre><code>$ time ./fib
fibonnaci(0) = 0
fibonnaci(1) = 1
fibonnaci(2) = 1
fibonnaci(3) = 2
...
fibonnaci(41) = 165580141
fibonnaci(42) = 267914296

real    1m25.746s
user    1m9.952s
sys     0m0.072s
$ ls
fib  fib.c  gmon.out</code></pre><p>上面仅仅选取了部分执行结果，程序运行了 1 分多钟，代码运行以后产生了一个 <code>gmon.out</code> 文件，这个文件可以用于 <code>gprof</code> 产生一个相关的性能报告。</p>
<pre><code>$ gprof  -b ./fib gmon.out 
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 96.04     14.31    14.31       43   332.80   332.80  fibonacci
  4.59     14.99     0.68                             main


                        Call graph


granularity: each sample hit covers 2 byte(s) for 0.07% of 14.99 seconds

index % time    self  children    called     name
                                                 &lt;spontaneous&gt;
[1]    100.0    0.68   14.31                 main [1]
               14.31    0.00      43/43          fibonacci [2]
-----------------------------------------------
                             2269806252             fibonacci [2]
               14.31    0.00      43/43          main [1]
[2]     95.4   14.31    0.00      43+2269806252 fibonacci [2]
                             2269806252             fibonacci [2]
-----------------------------------------------


Index by function name

   [2] fibonacci               [1] main</code></pre><p>从这份结果中可观察到程序中每个函数的执行次数等情况，从而找出值得修改的函数。在对某些部分修改之后，可以再次比较程序运行时间，查看优化结果。另外，这份结果还包含一个特别有用的东西，那就是程序的动态函数调用情况，即程序运行过程中实际执行过的函数，这和 <code>calltree</code> 产生的静态调用树有所不同，它能够反应程序在该次执行过程中的函数调用情况。而如果想反应程序运行的某一时刻调用过的函数，可以考虑采用 <code>gdb</code> 的 <code>backtrace</code> 命令。</p>
<p>类似测试纸片厚度的方法，<code>gprof</code> 也提供了一个统计选项，用于对程序的多次运行结果进行统计。另外，<code>gprof</code> 有一个 KDE 下图形化接口 <code>kprof</code>，这两部分请参考资料<a href="http://www.linuxjournal.com/article/6758" target="_blank" rel="noopener">[3]</a>。</p>
<p>对于非 KDE 环境，可以使用 <a href="https://code.google.com/p/jrfonseca/wiki/Gprof2Dot" target="_blank" rel="noopener">Gprof2Dot</a> 把 <code>gprof</code> 输出转换成图形化结果。</p>
<p>关于 <code>dot</code> 格式的输出，也可以可以考虑通过 <code>dot</code> 命令把结果转成 <code>jpg</code> 等格式，例如：</p>
<pre><code>$ dot -Tjpg test.dot -o test.jp</code></pre><p><code>gprof</code> 虽然给出了函数级别的执行情况，但是如果想关心具体哪些条件分支被执行到，哪些语句没有被执行，该怎么办？</p>
<p><span id="toc_7140_15195_6"></span></p>
<h3 id="代码覆盖率测试-gcov-amp-ggcov"><a href="#代码覆盖率测试-gcov-amp-ggcov" class="headerlink" title="代码覆盖率测试 gcov &amp; ggcov"></a>代码覆盖率测试 gcov &amp; ggcov</h3><p>如果要使用 <code>gcov</code>，在编译时需要加上这两个选项 <code>-fprofile-arcs -ftest-coverage</code>，这里直接用之前的 <code>fib.c</code> 做演示。</p>
<pre><code>$ ls
fib.c
$ gcc -fprofile-arcs -ftest-coverage -o fib fib.c
$ ls
fib  fib.c  fib.gcno</code></pre><p>运行程序，并通过 <code>gcov</code> 分析代码的覆盖度：</p>
<pre><code>$ ./fib
$ gcov fib.c
File &#39;fib.c&#39;
Lines executed:100.00% of 12
fib.c:creating &#39;fib.c.gcov&#39;</code></pre><p>12 行代码 100% 被执行到，再查看分支情况，</p>
<pre><code>$ gcov -b fib.c
File &#39;fib.c&#39;
Lines executed:100.00% of 12
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4
fib.c:creating &#39;fib.c.gcov&#39;</code></pre><p>发现所有函数，条件分支和语句都被执行到，说明代码的覆盖率很高，不过资料<a href="http://www.linuxjournal.com/article/6758" target="_blank" rel="noopener">[3]</a> <code>gprof</code> 的演示显示代码的覆盖率高并不一定说明代码的性能就好，因为那些被覆盖到的代码可能能够被优化成性能更高的代码。那到底哪些代码值得被优化呢？执行次数最多的，另外，有些分支虽然都覆盖到了，但是这个分支的位置可能并不是理想的，如果一个分支的内容被执行的次数很多，那么把它作为最后一个分支的话就会浪费很多不必要的比较时间。因此，通过覆盖率测试，可以尝试着剔除那些从未执行过的代码或者把那些执行次数较多的分支移动到较早的条件分支里头。通过性能测试，可以找出那些值得优化的函数、分支或者是语句。</p>
<p>如果使用 <code>-fprofile-arcs -ftest-coverage</code> 参数编译完代码，可以接着用 <code>-fbranch-probabilities</code> 参数对代码进行编译，这样，编译器就可以对根据代码的分支测试情况进行优化。</p>
<pre><code>$ wc -c fib
16333 fib
$ ls fib.gcda  #确保fib.gcda已经生成，这个是运行fib后的结果
fib.gcda
$ gcc -fbranch-probabilities -o fib fib.c #再次运行
$ wc -c fib
6604 fib
$ time ./fib
...
real    0m21.686s
user    0m18.477s
sys     0m0.008s</code></pre><p>可见代码量减少了，而且执行效率会有所提高，当然，这个代码效率的提高可能还跟其他因素有关，比如 <code>Gcc</code> 还优化了一些跟平台相关的指令。</p>
<p>如果想看看代码中各行被执行的情况，可以直接看 <code>fib.c.gcov</code> 文件。这个文件的各列依次表示执行次数、行号和该行的源代码。次数有三种情况，如果一直没有执行，那么用 <code>####</code> 表示；如果该行是注释、函数声明等，用 <code>-</code> 表示；如果是纯粹的代码行，那么用执行次数表示。这样我们就可以直接分析每一行的执行情况。</p>
<p><code>gcov</code> 也有一个图形化接口 <code>ggcov</code>，是基于 <code>gtk+</code> 的，适合 Gnome 桌面的用户。</p>
<p>现在都已经关注到代码行了，实际上优化代码的前提是保证代码的正确性，如果代码还有很多 bug，那么先要 debug。不过下面的这些 “bug” 用普通的工具确实不太方便，虽然可能，不过这里还是把它们归结为测试的内容，并且这里刚好承接上 <code>gcov</code> 部分，<code>gcov</code> 能够测试到每一行的代码覆盖情况，而无论是内存访问越界、缓冲区溢出还是内存泄露，实际上是发生在具体的代码行上的。</p>
<p><span id="toc_7140_15195_7"></span></p>
<h3 id="内存访问越界-catchsegv-libSegFault-so"><a href="#内存访问越界-catchsegv-libSegFault-so" class="headerlink" title="内存访问越界 catchsegv, libSegFault.so"></a>内存访问越界 catchsegv, libSegFault.so</h3><p>“Segmentation fault” 是很头痛的一个问题，估计“纠缠”过很多人。这里仅仅演示通过 <code>catchsegv</code> 脚本测试段错误的方法，其他方法见后面相关资料。</p>
<p><code>catchsegv</code> 利用系统动态链接的 <code>PRELOAD</code> 机制（请参考<code>man ld-linux</code>），把库 <code>/lib/libSegFault.so</code> 提前 load 到内存中，然后通过它检查程序运行过程中的段错误。</p>
<pre><code>$ cat test.c
#include &lt;stdio.h&gt;

int main(void)
{
    char str[10];

        sprintf(str, &quot;%s&quot;, 111);

        printf(&quot;str = %s\n&quot;, str);
        return 0;
}
$ make test
$ LD_PRELOAD=/lib/libSegFault.so ./test  #等同于catchsegv ./test
*** Segmentation fault
Register dump:

 EAX: 0000006f   EBX: b7eecff4   ECX: 00000003   EDX: 0000006f
 ESI: 0000006f   EDI: 0804851c   EBP: bff9a8a4   ESP: bff9a27c

 EIP: b7e1755b   EFLAGS: 00010206

 CS: 0073   DS: 007b   ES: 007b   FS: 0000   GS: 0033   SS: 007b

 Trap: 0000000e   Error: 00000004   OldMask: 00000000
 ESP/signal: bff9a27c   CR2: 0000006f

Backtrace:
/lib/libSegFault.so[0xb7f0604f]
[0xffffe420]
/lib/tls/i686/cmov/libc.so.6(vsprintf+0x8c)[0xb7e0233c]
/lib/tls/i686/cmov/libc.so.6(sprintf+0x2e)[0xb7ded9be]
./test[0x804842b]
/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xe0)[0xb7dbd050]
./test[0x8048391]
...</code></pre><p>从结果中可以看出，代码的 <code>sprintf</code> 有问题。经过检查发现它把整数当字符串输出，对于字符串的输出，需要字符串的地址作为参数，而这里的 <code>111</code> 则刚好被解释成了字符串的地址，因此 <code>sprintf</code> 试图访问 <code>111</code> 这个地址，从而发生了非法访问内存的情况，出现 “Segmentation Fault”。</p>
<p><span id="toc_7140_15195_8"></span></p>
<h3 id="缓冲区溢出-libsafe-so"><a href="#缓冲区溢出-libsafe-so" class="headerlink" title="缓冲区溢出 libsafe.so"></a>缓冲区溢出 libsafe.so</h3><p>缓冲区溢出是堆栈溢出（Stack Smashing），通常发生在对函数内的局部变量进行赋值操作时，超出了该变量的字节长度而引起对栈内原有数据（比如 eip，ebp 等）的覆盖，从而引发内存访问越界，甚至执行非法代码，导致系统崩溃。关于缓冲区的详细原理和实例分析见<a href="02-chapter5.markdown">《缓冲区溢出与注入分析》</a>。这里仅仅演示该资料中提到的一种用于检查缓冲区溢出的方法，它同样采用动态链接的 <code>PRELOAD</code> 机制提前装载一个名叫 <code>libsafe.so</code> 的库，可以从<a href="http://www.sfr-fresh.com/linux/misc/libsafe-2.0-16.tgz" target="_blank" rel="noopener">这里</a>获取它，下载后，再解压，编译，得到 <code>libsafe.so</code>，</p>
<p>下面，演示一个非常简单的，但可能存在缓冲区溢出的代码，并演示 <code>libsafe.so</code> 的用法。</p>
<pre><code>$ cat test.c
$ make test
$ LD_PRELOAD=/path/to/libsafe.so ./test ABCDEFGHIJKLMN
ABCDEFGHIJKLMN
*** stack smashing detected ***: ./test terminated
Aborted (core dumped)</code></pre><p>资料<a href="http://www.ibm.com/developerworks/linux/library/l-debug/" target="_blank" rel="noopener">[7]</a>分析到，如果不能够对缓冲区溢出进行有效的处理，可能会存在很多潜在的危险。虽然 <code>libsafe.so</code> 采用函数替换的方法能够进行对这类 Stack Smashing 进行一定的保护，但是无法根本解决问题，alert7 大虾在资料<a href="http://www.xfocus.net/articles/200208/423.html" target="_blank" rel="noopener">[10]</a>中提出了突破它的办法，资料<a href="http://www.xfocus.net/articles/200103/78.html" target="_blank" rel="noopener">11</a>11]提出了另外一种保护机制。</p>
<p><span id="toc_7140_15195_9"></span></p>
<h3 id="内存泄露-Memwatch-Valgrind-mtrace"><a href="#内存泄露-Memwatch-Valgrind-mtrace" class="headerlink" title="内存泄露 Memwatch, Valgrind, mtrace"></a>内存泄露 Memwatch, Valgrind, mtrace</h3><p>堆栈通常会被弄在一起叫，不过这两个名词却是指进程的内存映像中的两个不同的部分，栈（Stack）用于函数的参数传递、局部变量的存储等，是系统自动分配和回收的；而堆（heap）则是用户通过 <code>malloc</code> 等方式申请而且需要用户自己通过 <code>free</code> 释放的，如果申请的内存没有释放，那么将导致内存泄露，进而可能导致堆的空间被用尽；而如果已经释放的内存再次被释放（double-free）则也会出现非法操作。如果要真正理解堆和栈的区别，需要理解进程的内存映像，请参考<a href="02-chapter5.markdown">《缓冲区溢出与注入分析》</a></p>
<p>这里演示通过 <code>Memwatch</code> 来检测程序中可能存在内存泄露，可以从<a href="http://www.linkdata.se/sourcecode.html" target="_blank" rel="noopener">这里</a>下载到这个工具。<br>使用这个工具的方式很简单，只要把它链接（ld）到可执行文件中去，并在编译时加上两个宏开关<code>-DMEMWATCH -DMW_STDIO</code>。这里演示一个简单的例子。</p>
<pre><code>$ cat test.c 
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &quot;memwatch.h&quot;

int main(void)
{
    char *ptr1;
    char *ptr2;

    ptr1 = malloc(512);
    ptr2 = malloc(512);

    ptr2 = ptr1;
    free(ptr2);
    free(ptr1);
}
$ gcc -DMEMWATCH -DMW_STDIO test.c memwatch.c -o test
$ cat memwatch.log
============= MEMWATCH 2.71 Copyright (C) 1992-1999 Johan Lindh =============

Started at Sat Mar  1 07:34:33 2008

Modes: __STDC__ 32-bit mwDWORD==(unsigned long)
mwROUNDALLOC==4 sizeof(mwData)==32 mwDataSize==32

double-free: &lt;4&gt; test.c(15), 0x80517e4 was freed from test.c(14)

Stopped at Sat Mar  1 07:34:33 2008

unfreed: &lt;2&gt; test.c(11), 512 bytes at 0x8051a14         {FE FE FE FE FE FE FE FE FE FE FE FE FE FE FE FE ................}

Memory usage statistics (global):
 N)umber of allocations made: 2
 L)argest memory usage      : 1024
 T)otal of all alloc() calls: 1024
 U)nfreed bytes totals      : 512</code></pre><p>通过测试，可以看到有一个 512 字节的空间没有被释放，而另外 512 字节空间却被连续释放两次（double-free）。<code>Valgrind</code> 和 <code>mtrace</code> 也可以做类似的工作，请参考资料<a href="http://www.faqs.org/docs/Linux-HOWTO/Valgrind-HOWTO.html" target="_blank" rel="noopener">[4]</a>，<a href="http://www.cprogramming.com/debugging/valgrind.html" target="_blank" rel="noopener">[5]</a>和 <code>mtrace</code> 的手册。</p>
<p><span id="toc_7140_15195_10"></span></p>
<h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><p>调试的方法很多，调试往往要跟踪代码的运行状态，<code>printf</code> 是最基本的办法，然后呢？静态调试方法有哪些，非交互的呢？非实时的有哪些？实时的呢？用于调试内核的方法有哪些？有哪些可以用来调试汇编代码呢？</p>
<p><span id="toc_7140_15195_11"></span></p>
<h3 id="静态调试：printf-gcc-D（打印程序中的变量）"><a href="#静态调试：printf-gcc-D（打印程序中的变量）" class="headerlink" title="静态调试：printf + gcc -D（打印程序中的变量）"></a>静态调试：printf + gcc -D（打印程序中的变量）</h3><p>利用 <code>Gcc</code> 的宏定义开关（<code>-D</code>）和 <code>printf</code> 函数可以跟踪程序中某个位置的状态，这个状态包括当前一些变量和寄存器的值。调试时需要用 <code>-D</code> 开关进行编译，在正式发布程序时则可把 <code>-D</code> 开关去掉。这样做比单纯用 <code>printf</code> 方便很多，它可以避免清理调试代码以及由此带来的代码误删除等问题。</p>
<pre><code>$ cat test.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    int i = 0;

#ifdef DEBUG
        printf(&quot;i = %d\n&quot;, i);

        int t;
        __asm__ __volatile__ (&quot;movl %%ebp, %0;&quot;:&quot;=r&quot;(t)::&quot;%ebp&quot;);
        printf(&quot;ebp = 0x%x\n&quot;, t);
#endif

        _exit(0);
}
$ gcc -DDEBUG -g -o test test.c
$ ./test
i = 0
ebp = 0xbfb56d98</code></pre><p>上面演示了如何跟踪普通变量和寄存器变量的办法。跟踪寄存器变量采用了内联汇编。</p>
<p>不过，这种方式不够灵活，我们无法“即时”获取程序的执行状态，而 <code>gdb</code> 等交互式调试工具不仅解决了这样的问题，而且通过把调试器拆分成调试服务器和调试客户端适应了嵌入式系统的调试，另外，通过预先设置断点以及断点处需要收集的程序状态信息解决了交互式调试不适应实时调试的问题。</p>
<p><span id="toc_7140_15195_12"></span></p>
<h3 id="交互式的调试（动态调试）：gdb（支持本地和远程）-ald（汇编指令级别的调试）"><a href="#交互式的调试（动态调试）：gdb（支持本地和远程）-ald（汇编指令级别的调试）" class="headerlink" title="交互式的调试（动态调试）：gdb（支持本地和远程）/ald（汇编指令级别的调试）"></a>交互式的调试（动态调试）：gdb（支持本地和远程）/ald（汇编指令级别的调试）</h3><p><span id="toc_7140_15195_13"></span></p>
<h4 id="嵌入式系统调试方法-gdbserver-gdb"><a href="#嵌入式系统调试方法-gdbserver-gdb" class="headerlink" title="嵌入式系统调试方法 gdbserver/gdb"></a>嵌入式系统调试方法 gdbserver/gdb</h4><p>估计大家已经非常熟悉 GDB（Gnu DeBugger）了，所以这里并不介绍常规的 <code>gdb</code> 用法，而是介绍它的服务器／客户（<code>gdbserver/gdb</code>）调试方式。这种方式非常适合嵌入式系统的调试，为什么呢？先来看看这个：</p>
<pre><code>$ wc -c /usr/bin/gdbserver 
56000 /usr/bin/gdbserver
$ which gdb
/usr/bin/gdb
$ wc -c /usr/bin/gdb
2557324 /usr/bin/gdb
$ echo &quot;(2557324-56000)/2557324&quot;  | bc -l
.97810210986171482377</code></pre><p><code>gdb</code> 比 <code>gdbserver</code> 大了将近 97%，如果把整个 <code>gdb</code> 搬到存储空间受限的嵌入式系统中是很不合适的，不过仅仅 5K 左右的 <code>gdbserver</code> 即使在只有 8M Flash 卡的嵌入式系统中也都足够了。所以在嵌入式开发中，我们通常先在本地主机上交叉编译好 <code>gdbserver/gdb</code>。</p>
<p>如果是初次使用这种方法，可能会遇到麻烦，而麻烦通常发生在交叉编译 <code>gdb</code> 和 <code>gdbserver</code> 时。在编译 <code>gdbserver/gdb</code> 前，需要配置(./configure)两个重要的选项：</p>
<ul>
<li><code>--host</code>，指定 gdb/gdbserver 本身的运行平台，</li>
<li><code>--target</code>，指定 gdb/gdbserver 调试的代码所运行的平台，</li>
</ul>
<p>关于运行平台，通过 <code>$MACHTYPE</code> 环境变量就可获得，对于 <code>gdbserver</code>，因为要把它复制到嵌入式目标系统上，并且用它来调试目标平台上的代码，因此需要把 <code>--host</code> 和 <code>--target</code> 都设置成目标平台；而 <code>gdb</code> 因为还是运行在本地主机上，但是需要用它调试目标系统上的代码，所以需要把 <code>--target</code> 设置成目标平台。</p>
<p>编译完以后就是调试，调试时需要把程序交叉编译好，并把二进制文件复制一份到目标系统上，并在本地需要保留一份源代码文件。调试过程大体如下，首先在目标系统上启动调试服务器：</p>
<pre><code>$ gdbserver :port /path/to/binary_file
...</code></pre><p>然后在本地主机上启动gdb客户端链接到 <code>gdb</code> 调试服务器，（<code>gdbserver_ipaddress</code> 是目标系统的IP地址，如果目标系统不支持网络，那么可以采用串口的方式，具体看手册）</p>
<pre><code>$ gdb -q
(gdb) target remote gdbserver_ipaddress:2345
...</code></pre><p>其他调试过程和普通的gdb调试过程类似。</p>
<p><span id="toc_7140_15195_14"></span></p>
<h4 id="汇编代码的调试-ald"><a href="#汇编代码的调试-ald" class="headerlink" title="汇编代码的调试 ald"></a>汇编代码的调试 ald</h4><p>用 <code>gdb</code> 调试汇编代码貌似会比较麻烦，不过有人正是因为这个原因而开发了一个专门的汇编代码调试器，名字就叫做 <code>assembly language debugger</code>，简称 <code>ald</code>，你可以从<a href="http://ald.sourceforge.net/" target="_blank" rel="noopener">这里</a>下载到。</p>
<p>下载后，解压编译，我们来调试一个程序看看。</p>
<p>这里是一段非常简短的汇编代码：</p>
<pre><code>.global _start 
_start:
        popl %ecx
        popl %ecx
        popl %ecx
        movb $10,12(%ecx) 
        xorl %edx, %edx
        movb $13, %dl
        xorl %eax, %eax 
        movb $4, %al 
        xorl %ebx, %ebx
        int $0x80 
        xorl %eax, %eax
        incl %eax        
        int $0x80</code></pre><p>汇编、链接、运行：</p>
<pre><code>$ as -o test.o test.s
$ ld -o test test.o
$ ./test &quot;Hello World&quot;
Hello World</code></pre><p>查看程序的入口地址：</p>
<pre><code>$ readelf -h test | grep Entry 
  Entry point address:               0x8048054</code></pre><p>接着用 <code>ald</code> 调试： </p>
<pre><code>$ ald test
ald&gt; display
Address 0x8048054 added to step display list
ald&gt; n
eax = 0x00000000 ebx = 0x00000000 ecx = 0x00000001 edx = 0x00000000 
esp = 0xBFBFDEB4 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000 
ds  = 0x007B es  = 0x007B fs  = 0x0000 gs  = 0x0000 
ss  = 0x007B cs  = 0x0073 eip = 0x08048055 eflags = 0x00200292 

Flags: AF SF IF ID 

Dumping 64 bytes of memory starting at 0x08048054 in hex
08048054:  59 59 59 C6 41 0C 0A 31 D2 B2 0D 31 C0 B0 04 31    YYY.A..1...1...1
08048064:  DB CD 80 31 C0 40 CD 80 00 2E 73 79 6D 74 61 62    ...1.@....symtab
08048074:  00 2E 73 74 72 74 61 62 00 2E 73 68 73 74 72 74    ..strtab..shstrt
08048084:  61 62 00 2E 74 65 78 74 00 00 00 00 00 00 00 00    ab..text........

08048055                      59                   pop ecx</code></pre><p>可见 <code>ald</code> 在启动时就已经运行了被它调试的 <code>test</code> 程序，并且进入了程序的入口 <code>0x8048054</code>，紧接着单步执行时，就执行了程序的第一条指令 <code>popl ecx</code>。</p>
<p><code>ald</code> 的命令很少，而且跟 <code>gdb</code> 很类似，比如这个几个命令用法和名字都类似 <code>help,next,continue,set args,break,file,quit,disassemble,enable,disable</code> 等。名字不太一样但功能对等的有：<code>examine</code> 对 <code>x</code>, <code>enter</code> 对 <code>set variable {int} 地址=数据</code>。</p>
<p>需要提到的是：Linux 下的调试器包括上面的 <code>gdb</code> 和 <code>ald</code>，以及 <code>strace</code> 等都用到了 Linux 系统提供的 ptrace() 系统调用，这个调用为用户访问内存映像提供了便利，如果想自己写一个调试器或者想hack一下 <code>gdb</code> 和 <code>ald</code>，那么好好阅读资料<a href="http://linuxgazette.net/issue81/sandeep.html" target="_blank" rel="noopener">12</a>和 <code>man ptrace</code> 吧。</p>
<p>如果确实需要用gdb调试汇编，可以参考：</p>
<ul>
<li><a href="http://web.cecs.pdx.edu/~bjorn/CS200/linux_tutorial/" target="_blank" rel="noopener">Linux Assembly “Hello World” Tutorial, CS 200</a></li>
<li><a href="http://lab46.corning-cc.edu/Documentation-Assembly_GDB_Debugger.php" target="_blank" rel="noopener">Debugging your Alpha Assembly Programs using GDB</a></li>
</ul>
<p><span id="toc_7140_15195_15"></span></p>
<h3 id="实时调试：gdb-tracepoint"><a href="#实时调试：gdb-tracepoint" class="headerlink" title="实时调试：gdb tracepoint"></a>实时调试：gdb tracepoint</h3><p>对于程序状态受时间影响的程序，用上述普通的设置断点的交互式调试方法并不合适，因为这种方式将由于交互时产生的通信延迟和用户输入命令的时延而完全改变程序的行为。所以 <code>gdb</code> 提出了一种方法以便预先设置断点以及在断点处需要获取的程序状态，从而让调试器自动执行断点处的动作，获取程序的状态，从而避免在断点处出现人机交互产生时延改变程序的行为。</p>
<p>这种方法叫 <code>tracepoints</code>（对应 <code>breakpoint</code>），它在 <code>gdb</code> 的用户手册里头有详细的说明，见 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Tracepoints.html" target="_blank" rel="noopener">Tracepoints</a>。</p>
<p>在内核中，有实现了相应的支持，叫 <a href="http://lwn.net/Articles/538818/" target="_blank" rel="noopener">KGTP</a>。</p>
<p><span id="toc_7140_15195_16"></span></p>
<h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><p>虽然这里并不会演示如何去 hack 内核，但是相关的工具还是需要简单提到的，<a href="http://elinux.org/images/c/c6/Tools_slides.pdf" target="_blank" rel="noopener">这个资料</a>列出了绝大部分用于内核调试的工具，这些对你 hack 内核应该会有帮助的。</p>
<p><span id="toc_7140_15195_17"></span></p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>这部分暂时没有准备足够的素材，有待进一步完善。</p>
<p>暂且先提到两个比较重要的工具，一个是 Oprofile，另外一个是 Perf。</p>
<p>实际上呢？“代码测试”部分介绍的很多工具是为代码优化服务的，更多具体的细节请参考后续资料，自己做实验吧。</p>
<p><span id="toc_7140_15195_18"></span></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://satc.gsfc.nasa.gov/assure/agbsec5.txt" target="_blank" rel="noopener">VERIFICATION AND VALIDATION</a></li>
<li><a href="http://www.faqs.org/qa/qa-9060.html" target="_blank" rel="noopener">difference between verification and Validation</a></li>
<li><a href="http://www.linuxjournal.com/article/6758" target="_blank" rel="noopener">Coverage Measurement and Profiling(覆盖度测量和性能测试,Gcov and Gprof)</a></li>
<li>Valgrind Usage<ul>
<li><a href="http://www.faqs.org/docs/Linux-HOWTO/Valgrind-HOWTO.html" target="_blank" rel="noopener">Valgrind HOWTO</a></li>
<li><a href="http://www.cprogramming.com/debugging/valgrind.html" target="_blank" rel="noopener">Using Valgrind to Find Memory Leaks and Invalid Memory Use</a></li>
</ul>
</li>
<li><a href="http://www.linkdata.se/sourcecode.html" target="_blank" rel="noopener">MEMWATCH</a></li>
<li><a href="http://www.ibm.com/developerworks/linux/library/l-debug/" target="_blank" rel="noopener">Mastering Linux debugging techniques</a></li>
<li><a href="http://arxiv.org/pdf/cs.PF/0507073.pdf" target="_blank" rel="noopener">Software Performance Analysis</a></li>
<li><a href="http://dslab.lzu.edu.cn/docs/publications/runtime_debug.pdf" target="_blank" rel="noopener">Runtime debugging in embedded systems</a></li>
<li><a href="http://www.xfocus.net/articles/200208/423.html" target="_blank" rel="noopener">绕过libsafe的保护–覆盖_dl_lookup_versioned_symbol技术</a></li>
<li><a href="http://www.xfocus.net/articles/200103/78.html" target="_blank" rel="noopener">介绍Propolice怎样保护stack-smashing的攻击</a></li>
<li>Tools Provided by System：ltrace,mtrace,strace</li>
<li><a href="http://linuxgazette.net/issue81/sandeep.html" target="_blank" rel="noopener">Process Tracing Using Ptrace</a></li>
<li>Kernel Debugging Related Tools：KGDB, KGOV, KFI/KFT/Ftrace, GDB Tracepoint，UML, kdb</li>
<li>用Graphviz 可视化函数调用</li>
<li><a href="http://www.tinylab.org/explor-linux-segmentation-fault/" target="_blank" rel="noopener">Linux 段错误详解</a></li>
<li>源码分析之函数调用关系绘制系列<ul>
<li><a href="http://www.tinylab.org/callgraph-draw-the-calltree-of-c-functions/" target="_blank" rel="noopener">源码分析：静态分析 C 程序函数调用关系图</a></li>
<li><a href="http://www.tinylab.org/source-code-analysis-gprof2dot-draw-a-runtime-function-calls-the-c-program/" target="_blank" rel="noopener">源码分析：动态分析 C 程序函数调用关系</a></li>
<li><a href="http://www.tinylab.org/source-code-analysis-dynamic-analysis-of-linux-kernel-function-calls/" target="_blank" rel="noopener">源码分析：动态分析 Linux 内核函数调用关系</a></li>
<li><a href="http://www.tinylab.org/source-code-analysis-how-best-to-draw-a-function-call/" target="_blank" rel="noopener">源码分析：函数调用关系绘制方法与逆向建模</a></li>
</ul>
</li>
<li>Linux 下缓冲区溢出攻击的原理及对策</li>
<li>Linux 汇编语言开发指南</li>
<li><a href="02-chapter5.markdown">缓冲区溢出与注入分析(第一部分：进程的内存映像)</a></li>
<li>Optimizing C Code</li>
<li>Performance programming for scientific computing</li>
<li>Performance Programming</li>
<li>Linux Profiling and Optimization</li>
<li>High-level code optimization</li>
<li>Code Optimization</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Prof</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>使用valgrind分析jansson memory leak</title>
    <url>/2016/12/20/valgrind-profile-jansson/</url>
    <content><![CDATA[<p>使用三方库 <code>Jansson</code> 造成 <code>memory leak</code>，使用 <code>valgrind</code> 分析如下：</p>
<pre><code>$ gcc -O0 -g -ggdb main.c -ljansson                                      
$ valgrind --tool=memcheck --leak-check=full --show-reachable=yes ./a.out

==21533== 4,752 bytes in 1 blocks are definitely lost in loss record 4 of 4
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E3F3C4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3C9F7: json_dumps (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40155F: ipc_db_save (main.c:153)
==21533==    by 0x401C29: main (main.c:287)
==21533== 
==21533== LEAK SUMMARY:
==21533==    definitely lost: 18,480 bytes in 4 blocks
==21533==    indirectly lost: 0 bytes in 0 blocks
==21533==      possibly lost: 0 bytes in 0 blocks
==21533==    still reachable: 0 bytes in 0 blocks
==21533==         suppressed: 0 bytes in 0 blocks
==21533== 
==21533== For counts of detected and suppressed errors, rerun with: -v
==21533== ERROR SUMMARY: 8 errors from 8 contexts (suppressed: 0 from 0)</code></pre><a id="more"></a>

<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><pre><code class="c">int ipc_db_save(int index, AppIPCInfoClass *ipc_info)
{
    json_t *root = NULL;
    json_t *new_ipc = NULL;
    json_error_t error;

    if (NULL == ipc_info) {
        return 1;
    }

    if(access(&quot;ipcamera.dat&quot;, 0))
    {
        _new_db(&quot;ipcamera.dat&quot;);
    }

    root = json_load_file(&quot;ipcamera.dat&quot;, 0, &amp;error);
    printf(&quot;[%s]source %s\n&quot;, __func__, error.source);
    printf(&quot;[%s]text %s\n&quot;, __func__, error.text);

    if (!json_is_array(root)) {
        json_decref(root);
    }

    if ((new_ipc = json_object()) == NULL) {
        json_decref(root);
    }
    printf(&quot;[%s]%d: obj type = %d\n&quot;, __func__, __LINE__, json_typeof(root));

    char *result = json_dumps(root, JSON_PRESERVE_ORDER);
    printf(&quot;[%s]%d: result %s\n&quot;, __func__, __LINE__, result);
    //free(result);

    _object_integer(new_ipc, CAMERA_TYPE_KEY, ipc_info-&gt;type);
    _object_string(new_ipc, CAMERA_NAME_KEY, ipc_info-&gt;name);
    _object_string(new_ipc, CAMERA_IP_KEY, ipc_info-&gt;ip);
    _object_integer(new_ipc, CAMERA_PORT_KEY, ipc_info-&gt;port);
    _object_string(new_ipc, CAMERA_USER_KEY, ipc_info-&gt;user);
    _object_integer(new_ipc, CAMERA_CHANNEL_KEY, ipc_info-&gt;channel);
    _object_string(new_ipc, CAMERA_PASSWD_KEY, ipc_info-&gt;passwd);
    _object_string(new_ipc, CAMERA_STREAM_KEY, ipc_info-&gt;stream);

    if (index == -1) { //add mode
        json_array_append(root, new_ipc);
    }
    else { //edit mode
        json_array_set(root, index, new_ipc);
    }

    result = json_dumps(root, JSON_PRESERVE_ORDER);
    printf(&quot;[%s]%d: result %s\n&quot;, __func__, __LINE__, result);
    free(result);

    json_dump_file(root, &quot;ipcamera.dat&quot;, 0);
    json_decref(new_ipc);
    json_decref(root);

    return 0;
}

int ipc_db_get(int index, AppIPCInfoClass *ipc_info)
{
    json_t *root = NULL;
    json_t *info_obj = NULL;
    json_t *obj_value = NULL;
    json_error_t error;
    const char *obj_key = NULL;

    if (ipc_info == NULL) {
        return 1;
    }

    root = json_load_file(&quot;ipcamera.dat&quot;, 0, &amp;error);
    if (!json_is_array(root)) {
        json_decref(root);
        return 1;
    }

    info_obj = json_array_get(root, index);
    if (!json_is_object(info_obj)) {
        json_decref(info_obj);
        json_decref(root);
        return 1;
    }

    json_object_foreach(info_obj, obj_key, obj_value) {
        _parse_info(obj_key, obj_value, ipc_info);
    }

    json_decref(info_obj);
    json_decref(root);

    return 0;
}</code></pre>
<h2 id="valgrind-memcheck"><a href="#valgrind-memcheck" class="headerlink" title="valgrind memcheck"></a>valgrind memcheck</h2><pre><code class="c">$ gcc -O0 -g -ggdb main.c -ljansson
$ valgrind --tool=memcheck --leak-check=full --show-reachable=yes ./a.out

==21533== Memcheck, a memory error detector
==21533== Copyright (C) 2002-2015, and GNU GPL&#39;d, by Julian Seward et al.
==21533== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==21533== Command: ./a.out
==21533== 
==21533== Invalid read of size 8
==21533==    at 0x4E42009: json_delete (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x40186F: ipc_db_get (main.c:213)
==21533==    by 0x401C44: main (main.c:293)
==21533==  Address 0x54b09b8 is 8 bytes inside a block of size 72 free&#39;d
==21533==    at 0x4C2EDEB: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x401860: ipc_db_get (main.c:212)
==21533==    by 0x401C44: main (main.c:293)
==21533==  Block was alloc&#39;d at
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E417BA: json_object (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3E8E4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EBB2: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EDAD: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F165: json_loadf (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F1E7: json_load_file (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40170F: ipc_db_get (main.c:195)
==21533==    by 0x401C44: main (main.c:293)
==21533== 
==21533== Invalid write of size 8
==21533==    at 0x4E4201A: json_delete (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x40186F: ipc_db_get (main.c:213)
==21533==    by 0x401C44: main (main.c:293)
==21533==  Address 0x54b09b8 is 8 bytes inside a block of size 72 free&#39;d
==21533==    at 0x4C2EDEB: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x401860: ipc_db_get (main.c:212)
==21533==    by 0x401C44: main (main.c:293)
==21533==  Block was alloc&#39;d at
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E417BA: json_object (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3E8E4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EBB2: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EDAD: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F165: json_loadf (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F1E7: json_load_file (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40170F: ipc_db_get (main.c:195)
==21533==    by 0x401C44: main (main.c:293)
==21533== 
==21533== Invalid read of size 8
==21533==    at 0x4E42009: json_delete (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x40186F: ipc_db_get (main.c:213)
==21533==    by 0x401C55: main (main.c:294)
==21533==  Address 0x54c4918 is 8 bytes inside a block of size 72 free&#39;d
==21533==    at 0x4C2EDEB: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x401860: ipc_db_get (main.c:212)
==21533==    by 0x401C55: main (main.c:294)
==21533==  Block was alloc&#39;d at
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E417BA: json_object (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3E8E4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EBB2: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EDAD: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F165: json_loadf (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F1E7: json_load_file (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40170F: ipc_db_get (main.c:195)
==21533==    by 0x401C55: main (main.c:294)
==21533== 
==21533== Invalid write of size 8
==21533==    at 0x4E4201A: json_delete (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x40186F: ipc_db_get (main.c:213)
==21533==    by 0x401C55: main (main.c:294)
==21533==  Address 0x54c4918 is 8 bytes inside a block of size 72 free&#39;d
==21533==    at 0x4C2EDEB: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x401860: ipc_db_get (main.c:212)
==21533==    by 0x401C55: main (main.c:294)
==21533==  Block was alloc&#39;d at
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E417BA: json_object (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3E8E4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EBB2: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EDAD: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F165: json_loadf (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F1E7: json_load_file (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40170F: ipc_db_get (main.c:195)
==21533==    by 0x401C55: main (main.c:294)
==21533== 
==21533== 
==21533== HEAP SUMMARY:
==21533==     in use at exit: 18,480 bytes in 4 blocks
==21533==   total heap usage: 5,525 allocs, 5,521 frees, 425,812 bytes allocated
==21533== 
==21533== 4,409 bytes in 1 blocks are definitely lost in loss record 1 of 4
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E3F3C4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3C9F7: json_dumps (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40155F: ipc_db_save (main.c:153)
==21533==    by 0x401A2C: main (main.c:251)
==21533== 
==21533== 4,577 bytes in 1 blocks are definitely lost in loss record 2 of 4
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E3F3C4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3C9F7: json_dumps (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40155F: ipc_db_save (main.c:153)
==21533==    by 0x401AD5: main (main.c:263)
==21533== 
==21533== 4,742 bytes in 1 blocks are definitely lost in loss record 3 of 4
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E3F3C4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3C9F7: json_dumps (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40155F: ipc_db_save (main.c:153)
==21533==    by 0x401B74: main (main.c:275)
==21533== 
==21533== 4,752 bytes in 1 blocks are definitely lost in loss record 4 of 4
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E3F3C4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3C9F7: json_dumps (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40155F: ipc_db_save (main.c:153)
==21533==    by 0x401C29: main (main.c:287)
==21533== 
==21533== LEAK SUMMARY:
==21533==    definitely lost: 18,480 bytes in 4 blocks
==21533==    indirectly lost: 0 bytes in 0 blocks
==21533==      possibly lost: 0 bytes in 0 blocks
==21533==    still reachable: 0 bytes in 0 blocks
==21533==         suppressed: 0 bytes in 0 blocks
==21533== 
==21533== For counts of detected and suppressed errors, rerun with: -v
==21533== ERROR SUMMARY: 8 errors from 8 contexts (suppressed: 0 from 0)</code></pre>
<h3 id="Invalid-read-of-size-8"><a href="#Invalid-read-of-size-8" class="headerlink" title="Invalid read of size 8"></a>Invalid read of size 8</h3><pre><code>==21533== Invalid read of size 8
==21533==    at 0x4E42009: json_delete (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x40186F: ipc_db_get (main.c:213)
==21533==    by 0x401C44: main (main.c:293)
==21533==  Address 0x54b09b8 is 8 bytes inside a block of size 72 free&#39;d
==21533==    at 0x4C2EDEB: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x400EFA: json_decref (jansson.h:106)
==21533==    by 0x401860: ipc_db_get (main.c:212)
==21533==    by 0x401C44: main (main.c:293)
==21533==  Block was alloc&#39;d at
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E417BA: json_object (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3E8E4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EBB2: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3EDAD: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F165: json_loadf (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3F1E7: json_load_file (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40170F: ipc_db_get (main.c:195)
==21533==    by 0x401C44: main (main.c:293)</code></pre><p>重复释放，将<code>main.c:212</code>注释掉</p>
<h3 id="memory-leak"><a href="#memory-leak" class="headerlink" title="memory leak"></a>memory leak</h3><pre><code>==21533== 4,577 bytes in 1 blocks are definitely lost in loss record 2 of 4
==21533==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21533==    by 0x4E3F3C4: ??? (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x4E3C9F7: json_dumps (in /usr/lib/x86_64-linux-gnu/libjansson.so.4.7.0)
==21533==    by 0x40155F: ipc_db_save (main.c:153)
==21533==    by 0x401AD5: main (main.c:263)</code></pre><p><code>main.c:153</code>处申请内存没有释放，添加 <code>free</code> 解决此问题</p>
<h2 id="正常结果"><a href="#正常结果" class="headerlink" title="正常结果"></a>正常结果</h2><pre><code>$ gcc -O0 -g -ggdb main.c -ljansson                                      
$ valgrind --tool=memcheck --leak-check=full --show-reachable=yes ./a.out
==21929== Memcheck, a memory error detector
==21929== Copyright (C) 2002-2015, and GNU GPL&#39;d, by Julian Seward et al.
==21929== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==21929== Command: ./a.out
==21929== 
==21929== 
==21929== HEAP SUMMARY:
==21929==     in use at exit: 0 bytes in 0 blocks
==21929==   total heap usage: 5,919 allocs, 5,919 frees, 443,103 bytes allocated
==21929== 
==21929== All heap blocks were freed -- no leaks are possible
==21929== 
==21929== For counts of detected and suppressed errors, rerun with: -v
==21929== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre>]]></content>
      <categories>
        <category>C</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>valgrind</tag>
        <tag>jansson</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串复制相关 (strcpy, strncpy, memcpy, sprintf, snprintf, sizeof, strlen)</title>
    <url>/2016/12/14/string-copy/</url>
    <content><![CDATA[<h2 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h2><ul>
<li>字符串是最后一个字符为 <code>NULL</code> <code>\0</code> 字符的字符数组。字符串一定是字符数组</li>
<li>字符数组，即字符类型的数组。字符数组不一定是字符串</li>
<li>字符数组的长度是固定的，其中的任何一个字符都可以为 <code>NULL</code> 字符</li>
<li>字符串只能以 <code>NULL</code> 结尾，其后的字符便不属于该字符串</li>
<li><code>strlen()</code> 等字符串函数对字符串完全适用，对不是字符串的字符数组不适用，容易出现问题</li>
</ul>
<pre><code class="c">//这是字符数组赋初值的方法
char cArr[] = {&#39;Q&#39;,&#39;U&#39;,&#39;A&#39;,&#39;N&#39;,&#39;X&#39;,&#39;U&#39;,&#39;E&#39;};
//这是字符串赋初值的方法
char sArr[] = &quot;quanxue&quot;;

//用sizeof()求长度
printf(&quot;cArr的长度=%d\n&quot;, sizeof(cArr));   //长度为7
printf(&quot;sArr的长度=%d\n&quot;, sizeof(sArr));   //长度为8，最后一位是NULL

//用printf的%s打印内容
printf(&quot;cArr的内容=%s\n&quot;, cArr);   //不能正确显示
printf(&quot;sArr的内容=%s\n&quot;, sArr);   //可以正确显示

//用strlen()求长度
printf(&quot;cArr的长度=%d\n&quot;, strlen(cArr));   //不正确的结果
printf(&quot;sArr的长度=%d\n&quot;, strlen(sArr));   //NULL不在计算范围</code></pre>
<a id="more"></a>

<p>从上面例子看来，还要注意以下几点：</p>
<ul>
<li>char sArr[] = “quanxue”;这种方式，<strong>编译时会自动在末尾增加一个NULL字符</strong></li>
<li>sizeof()运算符求的是字符数组的长度，而不是字符串长度</li>
<li>strlen()函数求的是字符串长度，而不是字符数组。它不适用于字符串以外的类型</li>
<li>char sArr[] = “quanxue”;也可以写成char sArr[8] = “quanxue”;（注意：是8而不是7） </li>
</ul>
<p>字符数组中插入一个NULL字符，NULL字符前面（包括NULL字符）就成了字符串，一般NULL字符插在有效字符的最后</p>
<pre><code class="c">//因为最后有NULL，所以这就变成了字符串
char cArr[] = {&#39;Q&#39;, &#39;U&#39;, &#39;A&#39;, &#39;N&#39;, &#39;X&#39;, &#39;U&#39;, &#39;E&#39;, &#39;\0&#39;};
//因为少定义了一位，最后无NULL，所以这就变成了字符数组
char sArr[7] = &quot;quanxue&quot;;
//最后一个元素未赋值
char tArr[16] = &quot;www.quanxue.cn&quot;;</code></pre>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p><code>sizeof(...)</code>是运算符，在头文件中 <code>typedef</code> 为 <code>unsigned int</code>，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。<br>由于在编译时计算，因此 <strong><code>sizeof</code> 不能用来返回动态分配的内存空间的大小</strong>。实际上，<strong>用 <code>sizeof</code> 来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系</strong>。<br>具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：</p>
<ul>
<li>数组 编译时分配的数组空间大小</li>
<li>指针 存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4</li>
<li>类型 该类型所占的空间大小</li>
<li>对象 对象的实际占用空间大小</li>
<li>函数 函数的返回类型所占的空间大小。函数的返回类型不能是void</li>
</ul>
<h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p><code>strlen(...)</code>是函数，要在运行时才能计算。参数必须是字符型指针<code>（char*）</code>。当数组名作为参数传入时，实际上数组就退化成指针了。<br>它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。<strong>返回的长度大小不包括NULL</strong>。</p>
<h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><p><code>strcpy</code>提供了字符串的复制，只用于字符串复制，会复制字符串的结束符。</p>
<pre><code class="c">char* strcpy(char* dest, const char* src);</code></pre>
<p><strong><code>strcpy</code>不需要指定长度，它遇到被复制字符的串结束符<code>\0</code>才结束，所以容易溢出</strong></p>
<h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p><code>memcpy</code>提供了一般内存的复制，对于需要复制的内容没有限制。例如字符数组、整型、结构体、类等。</p>
<pre><code class="c">void *memcpy( void *dest, const void *src, size_t count );</code></pre>
<p><code>memcpy</code>是根据其第3个参数决定复制的长度</p>
<h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h2><pre><code class="c">char *strncpy(char *dest, char *src, int n);</code></pre>
<p>功能：把src所指由NULL结束的字符串的前n个字节复制到dest所指的数组中。</p>
<ul>
<li>如果src的前n个字节不含 <code>\0</code> 字符，则结果不会以 <code>\0</code> 字符结束</li>
<li>如果src的长度小于n个字节，<strong>则以 <code>\0</code> 填充dest直到复制完n个字节</strong></li>
<li>src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串</li>
</ul>
<p><strong>如果对src发生了截取，返回的dest不是想要的字符串，因为没有<code>\0</code>，如果对dest进行字符串类操作，会发生错误！！</strong><br><strong>使用 <code>snprintf</code> 替换这种可能有隐含错误的用法</strong></p>
<h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf"></a>snprintf</h2><p><code>snprintf</code> 是 <code>sprintf</code> 的安全版本，防止溢出</p>
<pre><code class="c">int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
snprintf(char *dest, size_t size, &quot;%s&quot;, char *src);</code></pre>
<p><code>dest</code> 会输出 <code>size-1</code> 字符和 <code>\0</code> 结尾的字符串</p>
<h3 id="sprintf-与-snprintf"><a href="#sprintf-与-snprintf" class="headerlink" title="sprintf 与 snprintf"></a>sprintf 与 snprintf</h3><p>代码如下：</p>
<pre><code class="c">char tlist_1[1024] = {0},tlist_2[1024]={0};
char fname[7][8] = {&quot;a1&quot;,&quot;b1&quot;,&quot;c1&quot;,&quot;d1&quot;,&quot;e1&quot;,&quot;f1&quot;,&quot;g1&quot;};
int i = 0, len_1,len_2 = 0;

len_1 = snprintf(tlist_1,1024,&quot;%s;&quot;,fname[0]);
len_2 = snprintf(tlist_2,1024,&quot;%s;&quot;,fname[0]);

for(i=1;i&lt;7;i++)
{
    len_1 = snprintf(tlist_1,1024,&quot;%s%s;&quot;,tlist_1,fname[i]);
    len_2 = sprintf(tlist_2,&quot;%s%s;&quot;,tlist_2,fname[i]);
}

printf(&quot;tlist_1: %s\n&quot;,tlist_1);
printf(&quot;tlist_2: %s\n&quot;,tlist_2);

&gt;&gt; tlist_1: g1;
&gt;&gt; tlist_2: a1;b1;c1;d1;e1;f1;g1;</code></pre>
<p>上述代码表明， <code>snprintf</code> 会清除缓冲区内容， <code>sprintf</code> 不会清除缓冲区内容，针对使用场景分别使用</p>
<p><code>snprintf</code> 调用 <code>_IO_vsnprintf</code> 实现：</p>
<pre><code class="c">int
_IO_vsnprintf (string, maxlen, format, args)
    char *string;
    _IO_size_t maxlen;
    const char *format;
    _IO_va_list args;
{
    ...
        string[0] = &#39;\0&#39;;
    ...
}</code></pre>
<p><code>sprintf</code> 调用 <code>_IO_vsprintf</code> 实现中，没有相关的操作。</p>
]]></content>
      <categories>
        <category>C</category>
        <category>Functions</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>string</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 中的替换功能</title>
    <url>/2016/12/14/vim-replace-tips/</url>
    <content><![CDATA[<h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><pre><code class="vim">%s/old/new/g
%s/old/new/gc
%s/\&lt;old\&gt;/new/gc</code></pre>
<ul>
<li><code>%</code> 所有行</li>
<li><code>g</code> 所有匹配</li>
<li><code>c</code> 替换前确认</li>
<li><code>&lt;&gt;</code> 确认单词边界，需要使用转义符<code>\</code></li>
</ul>
<a id="more"></a>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre><code class="vim">%s/\([^,]*\),\(.*\)/New\1/gc</code></pre>
<ul>
<li><code>()</code> 用于反向引用</li>
<li><code>[^,]</code> 匹配除<code>,</code>之外</li>
<li><code>*</code> 任意多次 </li>
<li><code>.</code> 任意字符</li>
<li><code>\1</code> 反向引用，表示第一个<code>()</code>匹配的内容</li>
</ul>
<h2 id="多文件修改"><a href="#多文件修改" class="headerlink" title="多文件修改"></a>多文件修改</h2><h3 id="args-amp-argdo"><a href="#args-amp-argdo" class="headerlink" title="args &amp; argdo"></a>args &amp; argdo</h3><p>需要替换当前目录下所有的<code>.c</code>文件中的<code>Old</code>为<code>New</code>：</p>
<pre><code class="vim">:args *.c
:args **/*.c
:args */*.c

:argdo %s/Old/New/gc | update</code></pre>
<ul>
<li><code>*.c</code> 当前目录下的所有<code>.c</code></li>
<li><code>**/*.c</code> 递归扫描所有下级目录</li>
<li><code>*/*.c</code> 只扫描下一级目录（即不扫描当前目录）</li>
<li><code>update</code> 直接更新写入硬盘</li>
</ul>
<h3 id="使用宏"><a href="#使用宏" class="headerlink" title="使用宏"></a>使用宏</h3><p>录制 <code>宏命令</code></p>
<pre><code class="vim">qa
:%s/\&lt;Old\&gt;/New/g
:wnext
q</code></pre>
<p>使用 <code>宏定义</code></p>
<pre><code class="vim">100@a</code></pre>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="删除多余空格"><a href="#删除多余空格" class="headerlink" title="删除多余空格"></a>删除多余空格</h3><pre><code class="vim">%s/\s\+$//</code></pre>
<h3 id="删除Windows文本文件中的-“-M”-标记"><a href="#删除Windows文本文件中的-“-M”-标记" class="headerlink" title="删除Windows文本文件中的 “^M” 标记"></a>删除Windows文本文件中的 “^M” 标记</h3><pre><code class="vim">%s/\r//g</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>regexp</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM启动时间优化</title>
    <url>/2016/12/09/Profiling-Vim-startup-time/</url>
    <content><![CDATA[<h2 id="startuptime"><a href="#startuptime" class="headerlink" title="startuptime"></a>startuptime</h2><p><code>vim</code> 安装大量插件之后导致启动变慢，可以通过以下命令来排查各个插件的启动时间：</p>
<pre><code class="shell">vim --startuptime vim.log</code></pre>
<p><code>vim.log</code> 中保存了启动时间信息：</p>
<pre><code class="log">000.003  000.003: --- VIM STARTING ---                                        
000.068  000.065: Allocated generic buffers                                   
000.092  000.024: locale set                                                  
000.102  000.010: GUI prepared                                                
000.105  000.003: clipboard setup                                             
000.109  000.004: window checked                                              
000.584  000.475: inits 1                                                     
000.588  000.004: parsing arguments                                           
000.589  000.001: expanding arguments                                         
000.595  000.006: shell init                                                  
000.779  000.184: Termcap init                                                
000.810  000.031: inits 2                                                     
000.903  000.093: init highlight                            </code></pre>
<h2 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h2><pre><code class="vim">help cmd

--cmd {command}                        *--cmd*
        {command} will be executed before processing any vimrc file.
        Otherwise it acts like -c {command}.  You can use up to 10 of
        these commands, independently from &quot;-c&quot; commands.
        {not in Vi}

-c {command}    {command} will be executed after the first file has been
        read (and after autocommands and modelines for that file have
        been processed).  &quot;command&quot; is interpreted as an Ex command.
        If the &quot;command&quot; contains spaces, it must be enclosed in
        double quotes (this depends on the shell that is used).</code></pre>
<a id="more"></a>

<pre><code class="vim">help profile

For example, to profile the one_script.vim script file: &gt;
    :profile start /tmp/one_script_profile
    :profile file one_script.vim
    :source one_script.vim
    :exit


:prof[ile] start {fname}            *:prof* *:profile* *E750*
:prof[ile] func {pattern}
:prof[ile][!] file {pattern}</code></pre>
<pre><code class="shell">vim --cmd &#39;profile start profile.log&#39; \
    --cmd &#39;profile func *&#39; \
    --cmd &#39;profile file *&#39; \
    -c &#39;profdel func *&#39; \
    -c &#39;profdel file *&#39; \
    -c &#39;qa!&#39;</code></pre>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p><a href="https://github.com/hyiltiz/vim-plugins-profile" target="_blank" rel="noopener">vim-plugins-profile</a>用于优化</p>
<pre><code class="shell">sudo apt-get install r-base</code></pre>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p><a href="https://github.com/bchretien/vim-profiler" target="_blank" rel="noopener">vim-profiler</a></p>
<pre><code class="shell">./vim-profiler.py
Running vim to generate startup logs... done.
Loading and processing logs... done.
Plugin directory: /home/yanwzh/.vim/bundle
====================================
Top 10 plugins slowing vim&#39;s startup
====================================
1    29.111   TagHighlight
2    21.479   nerdtree
3    18.853   c.vim
4    11.260   FuzzyFinder
5     6.034   vim-easymotion
6     4.738   unite.vim
7     4.680   vim-airline
8     1.427   vim-sensible
9     1.365   Tagbar
10    1.344   nerdtree-git-plugin</code></pre>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://stackoverflow.com/questions/1687799/profiling-vim-startup-time" target="_blank" rel="noopener">Profiling Vim startup time</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>git pull强制覆盖本地文件</title>
    <url>/2016/12/09/git-pull-force/</url>
    <content><![CDATA[<pre><code class="bash">git fetch --all  
git reset --hard origin/master 
git pull</code></pre>
<p><code>gitk</code> 工具用来看分支关系</p>
<p><a href="https://zlargon.gitbooks.io/git-tutorial/content/remote/force_update.html" target="_blank" rel="noopener">強制更新遠端分支</a></p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>本地Git仓库和远程仓库的创建及关联</title>
    <url>/2016/12/09/git-branch/</url>
    <content><![CDATA[<p>git本地新建一个分支后，必须要做远程分支关联。如果没有关联，git会在下面的操作中提示你显示的添加关联。关联目的是如果在本地分支下操作： git pull, git push ，不需要指定在命令行指定远程的分支．推送到远程分支后，你只要没有显示指定，git pull的时候，就会提示你。</p>
<h2 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h2><p>使用－－set-upstream去跟踪远程分支：</p>
<pre><code class="bash">$ git branch --set-upstream
  master
* source</code></pre>
<a id="more"></a>

<h2 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h2><p>需要做关联，操作如下：</p>
<pre><code class="bash">git init
git add xxx
git ci -m &quot;log&quot;
git remote add origin git@github.com:zzz/xxx.git
git push -u origin master</code></pre>
<ul>
<li><code>origin</code>:远程仓库名字; <code>master</code>:分支</li>
<li><strong>第一次push的时候,加上-u参数</strong>, Git就会把本地的master分支和远程的master分支进行关联起来,我们以后的push操作就不再需要加上<code>-u</code>参数了</li>
<li>分支可以将 <code>master</code> 修改为其他分支</li>
</ul>
<h2 id="git-clone-分支"><a href="#git-clone-分支" class="headerlink" title="git clone 分支"></a>git clone 分支</h2><p>直接 <code>git clone</code> 某个分支：</p>
<pre><code class="bash">git clone -b &lt;branch&gt; &lt;remote_repo&gt;
git clone -b source &lt;remote_repo&gt;</code></pre>
<p>默认分支为 <code>master</code>，<code>-b</code> 可以指定分支。</p>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>当执行 <code>git push</code> 时出现如下提示：</p>
<pre><code>warning: push.default 尚未设置，它的默认值在 Git 2.0 已从 &#39;matching&#39; 变更为 &#39;simple&#39;。若要不再显示本信息并保持传统习惯，进行如下设置：

git config --global push.default matching

若要不再显示本信息并从现在开始采用新的使用习惯，设置：

git config --global push.default simple

当 push.default 设置为 &#39;matching&#39; 后，git 将推送和远程同名的所有本地分支。

从 Git 2.0 开始，Git 默认采用更为保守的 &#39;simple&#39; 模式，只推送当前分支到远程关联的同名分支，即 &#39;git push&#39; 推送当前分支。</code></pre><p>设置如下：</p>
<pre><code>git config --global push.default simple</code></pre><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>执行i <code>git pull</code> 的时候，实际上是做了<code>git fetch + git merge</code>操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p>
<p>当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p>
<pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; develop  
// 或者git push --set-upstream origin develop </code></pre><p>实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作</p>
<pre><code>[branch &quot;develop&quot;]
    remote = origin
    merge = refs/heads/develop // [1]为什么不是refs/remotes/develop?</code></pre><h2 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h2><p>最终所有的修改都是修改 <code>config</code> 文件，如下：</p>
<pre><code>[core]                                                                                                                             
    repositoryformatversion = 0                                               
    filemode = true                                                           
    bare = false                                                              
    logallrefupdates = true                                                   
[remote &quot;origin&quot;]                                                             
    url = xxx.github.io.git      
    fetch = +refs/heads/*:refs/remotes/origin/*                               
[branch &quot;master&quot;]                                                             
    remote = origin                                                           
    merge = refs/heads/master                                                 
[branch &quot;source&quot;]                                                             
    remote = origin                                                           
    merge = refs/heads/source     </code></pre><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol>
<li><a href="http://blog.angular.in/git-pushmo-ren-fen-zhi/" target="_blank" rel="noopener">Git push与pull的默认行为</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">Git远程操作详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 一个邮箱管理多个SSH Key</title>
    <url>/2016/12/09/multi-sshkey-with-github/</url>
    <content><![CDATA[<blockquote>
<p>SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。</p>
</blockquote>
<h2 id="Github下使用多个SSH-Key"><a href="#Github下使用多个SSH-Key" class="headerlink" title="Github下使用多个SSH Key"></a>Github下使用多个SSH Key</h2><p>如果有多个github帐号，当尝试将pc的ssh-key依次加入到不同的github帐号进行commit的时候，会添加失败，提示：</p>
<pre><code>Key is already in use。</code></pre><p>SSH公钥使用时相当于用户名密码，不可能两个不同的帐号使用同一个用户名密码。要想在多个GitHub帐号上添加公钥，就要在本地生成多个SSH Keys，每个GitHub帐号对应一个不同的SSH Keys。</p>
<p>一个github帐号下，存在多个 <code>Organization</code>，需要生成多个 <code>SSH Key</code> 进行管理</p>
<h2 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h2><p>生成<code>SSH Key</code>方法:</p>
<pre><code class="bash">ssh-keygen -t rsa -C &quot;mailname1@xxx.com&quot;  </code></pre>
<a id="more"></a>

<p>上面这个email地址就是你在github上注册该账号时使用的email，系统会提示你，<br>是否将key保存在 <del>/.ssh/id_rsa 这个文件中，<br>如果这是你第一次生成SSH KEY，并且也你也只有一个账号，那么就可以存储到这个默认的位置，<br>如果有多个账号的话，建议保存为</del>/.ssh/id_rsa_xxx，方便以后识别。</p>
<p>同一个 <code>email</code> 生成两个 <code>SSH Key</code> 如下：</p>
<pre><code class="bash">.
├── config
├── id_rsa
├── id_rsa_breezetempleio
├── id_rsa_breezetempleio.pub
├── id_rsa.pub
└── known_hosts</code></pre>
<h2 id="SSH-Key-config文件"><a href="#SSH-Key-config文件" class="headerlink" title="SSH Key config文件"></a>SSH Key config文件</h2><p>当生成了N个账号的SSH KEY并保存到相应的文件中时，在~/.ssh文件夹下建立一个 <code>config</code> 文件，<br>该文件用来指明，当使用某个账号时对应使用哪个<code>SSH KEY</code>：</p>
<pre><code>Host github.com                                                               
    Hostname ssh.github.com                                                   
    Port 443                                                                  
    User git                                                                  
    IdentityFile ~/.ssh/id_rsa                                                

Host BreezeTempleIO.com         # ssh别名，随意取
    Hostname ssh.github.com     # 主机名                             
    Port 443                    # SSH端口号                                      
    User git                    # 用户                                   
    IdentityFile ~/.ssh/id_rsa_breezetempleio       </code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>当完成 <code>SSH Key</code> 配置之后通过如下命令验证是否可以用公钥访问：</p>
<pre><code class="bash">ssh -T git@**github.com**
ssh -T git@**BreezeTempleIO.com**</code></pre>
<p><code>@</code> 之后的值取自上述 <code>config</code> 文件中的 <code>Host</code> 值</p>
<p>验证成功提示如下：</p>
<pre><code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h2 id="修改具体项目的config文件"><a href="#修改具体项目的config文件" class="headerlink" title="修改具体项目的config文件"></a>修改具体项目的config文件</h2><p>在push前，我们还需要修改下该项目.git文件夹下的配置文件config:</p>
<pre><code>url = git@github.com:breezetemple/breezetemple.github.com.git
url = BreezeTempleIO.com:breezetemple/breezetemple.github.com.git</code></pre><p><code>BreezeTempleIO.com</code> 和 <code>config host</code>设置是对应的。<br>很显然，我们需要引导它去读取正确的私钥去和服务端保存的公钥匹配。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://gist.github.com/jexchan/2351996" target="_blank" rel="noopener">Multiple SSH Keys settings for different github account</a></li>
<li><a href="http://ajucs.com/2016/04/20/use-multi-ssh-key-for-git.html" target="_blank" rel="noopener">管理多个SSH Key以支持多个Git账号</a></li>
<li><a href="http://jetyoung.github.io/2015/12/18/Github%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AASSH%20Key/" target="_blank" rel="noopener">Github下使用多个SSH Key</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
        <tag>sshkey</tag>
      </tags>
  </entry>
  <entry>
    <title>python编写lyngsat爬虫小结</title>
    <url>/2016/12/02/python-crawler-tips/</url>
    <content><![CDATA[<p>使用 <code>requests</code> 和 <code>bs4</code> 爬取 <code>lyngsat</code> 网页数据，生出数据库，或导出为 <code>Excel</code>。期间遇到一些问题，记录如下：</p>
<a id="more"></a>

<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre><code class="python">class Crawler:
    def __init__(self, a, b):
        a = a
        b = b

    def function1(self):
        pass

    def function2(self):
        pass

    def start(self):
        pass

if __name__ == &quot;__main__&quot;:
    crawler - Crawler(a, b)
    crawler.start()</code></pre>
<h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><pre><code class="python">import getopt

try:
    options, args = getopt.getopt(sys.argv[1:],&quot;ha:s:o:&quot;, [&quot;show=&quot;, &quot;keyword=&quot;])
except getopt.GetoptError:                                                
    usage()                                                               

for key, value in options:
    if (key == &quot;-h&quot;):
        pass
    elif(key == &#39;-a&#39;):
        area = value
    else:
        assert False, &quot;unhandled option&quot;</code></pre>
<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><pre><code class="python">import requests

try:                                                                  
    response = requests.get(url, proxies = proxy, verify=False)  
except requests.exceptions.RequestException as e:                     
    print e                                                           

pass

response.close()</code></pre>
<h2 id="bs4"><a href="#bs4" class="headerlink" title="bs4"></a>bs4</h2><pre><code class="python">import bs4

soup = bs4.BeautifulSoup(response.content, &#39;lxml&#39;)
for table in soup.find_all(&#39;table&#39;, align=&#39;center&#39;, width=720):
    for tr in table.find_all(&#39;tr&#39;)[1:]:
        print tr.find(&#39;td&#39;, width=180).text, tr.find(&#39;td&#39;, width=180).find(&#39;a&#39;)[&#39;href&#39;]
soup.decompose()</code></pre>
<h2 id="xlwt"><a href="#xlwt" class="headerlink" title="xlwt"></a>xlwt</h2><pre><code class="python">import xlwt

wb = xlwt.Workbook(encoding=&#39;utf-8&#39;, style_compression=2)
ws = wb.add_sheet(&#39;sheet&#39;)

ws.col(0).width=256*8   #8 characters width
ws.col(1).width=256*10  #10 characters width

pattern = xlwt.Pattern()                                              
pattern.pattern = xlwt.Pattern.SOLID_PATTERN                          
pattern.pattern_fore_colour = xlwt.Style.colour_map[color]            
pattern.pattern_back_colour = xlwt.Style.colour_map[&#39;black&#39;]          

alignment = xlwt.Alignment()                                          
alignment.horz = alignment.HORZ_LEFT                                  
alignment.vert = alignment.VERT_CENTER                                

font = xlwt.Font()                                                    
font.name = &#39;Times New Roman&#39;                                         

borders = xlwt.Borders()                                              
borders.left = 1                                                      
borders.right = 1                                                     
borders.top = 1                                                                                                            
borders.bottom = 1                                                    
borders.bottom_colour=0x3A                                            

style = xlwt.XFStyle()                                                
style.pattern=pattern                                                 
style.font = font                                                     
style.borders = borders                                               
style.alignment = alignment        

ws.write_merge(1, 1, 0, 4, &#39;TP&#39;, style)
ws.write_merge(1, 1, 5, 9, &#39;Service&#39;, style)

ws.write(row, 9, sys)
ws.write(row, 10, sym, style)

wb.save(xlsname)</code></pre>
<h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><pre><code class="python">import re
name = re.sub(r&#39;\(.*\)&#39;, &#39;&#39;, td_name.text)
provider_name = re.sub(r&#39;^@ *&#39;, &#39;&#39;, re.sub(r&#39;\(.*\)&#39;, &#39;&#39;, name))</code></pre>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><pre><code class="python">import struct

file = open(name, &quot;wb&quot;)
binary += struct.pack(&#39;I&#39;, DB_STARTCODE)
binary += struct.pack(&#39;III&#39;, len(satlist), len(tplist), 0)

for sat in satlist:
    m_nTunerSelect = 0b00
    m_nLongitude = int(float(longitude)*10)&amp;0x7ff

    if lnb.lower() == &quot;ku&quot;:
        m_nLnbType = 0b01
        m_Lnb1 = 0b0011
        m_Lnb2 = 0b0101
        m_nSat22k = 0b10
    elif lnb.lower() == &quot;c&quot;:
        m_nLnbType = 0b00
        m_Lnb1 = 0b0000
        m_Lnb2 = 0b0010
        m_nSat22k = 0b00
    else:
        print &quot;Error Satellite Lnb Type&quot;

    if direction.lower() == &quot;e&quot;:
        m_nLongitudeDirection = 0b0
    elif direction.lower() == &quot;w&quot;:
        m_nLongitudeDirection = 0b1
    else:
        print &quot;Error Satellite Direction&quot;

    m_nDiseqc12Pos = 0b00000000
    m_nDiseqc10 = 0b000
    m_nDiseqcMotor = 0b00
    m_nSat12v = 0b00

    m_nTpStartPos = tp_pos
    m_nTpNum = tp_num

    info0 = 0&lt;&lt;30 | m_nTunerSelect
    info1 = m_nLongitudeDirection&lt;&lt;31 | m_nSat22k&lt;&lt;29 | m_nDiseqc12Pos&lt;&lt;21 | m_Lnb2&lt;&lt;17 | m_Lnb1&lt;&lt;13 | m_nLnbType&lt;&lt;11 | m_nLongitude
    info2 = m_nDiseqc10&lt;&lt;29 | m_nSat12v&lt;&lt;28 | m_nTpStartPos&lt;&lt;15 | m_nTpNum&lt;&lt;2 | m_nDiseqcMotor
    info2 = m_nDiseqcMotor&lt;&lt;30 | m_nTpNum&lt;&lt;17 | m_nTpStartPos&lt;&lt;4 | m_nSat12v&lt;&lt;3 | m_nDiseqc10

    binary += struct.pack(&#39;16sIII&#39;, sat_name.encode(&#39;utf-8&#39;), info0, info1, info2)
    binary += struct.pack(&#39;I&#39;, DB_ENDCODE)
    file.write(binary)</code></pre>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><pre><code class="python">video.append(vpid.replace(u&#39;\xa0&#39;, u&#39; &#39;).strip())

audio_codec = (len(info) &gt; 2) and info[2] or &#39;&#39;

if &#39;psk&#39; in text.lower() or (&#39;-&#39; in text and &#39;/&#39; in text) or (&#39;-&#39; in  text and &#39;?&#39; in text):
    continue 

point = (len(tr.select(&#39;td[rowspan]&#39;)) &gt; 0) and 1 or 0

length = int(tr.find(&#39;td&#39;)[&#39;rowspan&#39;])</code></pre>
<h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><p><code>requests</code> <code>bs4</code> 存在大量内存使用，使用相关的 <code>python profile</code> 工具来调试内存泄漏和优化</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>lyngsat</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式必知必会笔记</title>
    <url>/2016/11/06/regex-notes/</url>
    <content><![CDATA[<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul>
<li><a href="http://regexr.com/" target="_blank" rel="noopener"><strong>RegExrv2.1</strong></a></li>
<li><a href="http://www.regexpal.com/93395" target="_blank" rel="noopener">Regex test Regex</a></li>
</ul>
<p><strong>RegExrv2.1</strong> 提供 <code>Explain</code></p>
<img src="/images/others/regexr.png" height="450" width="800" />

<a id="more"></a>

<h2 id="Matching-Single-Characters"><a href="#Matching-Single-Characters" class="headerlink" title="Matching Single Characters"></a>Matching Single Characters</h2><ul>
<li>纯文本</li>
<li><code>.</code> Match any single character except \n (unless /s)</li>
<li><code>\</code> Escape next character, such as <code>\/</code> or <code>\(</code> or <code>\)</code></li>
</ul>
<h2 id="Matching-Sets-of-Characters"><a href="#Matching-Sets-of-Characters" class="headerlink" title="Matching Sets of Characters"></a>Matching Sets of Characters</h2><ul>
<li><code>[]</code> [abc] Match one out of a set of characters</li>
<li><code>-</code> [a-z] Match one character from range, often [a-zA-Z]</li>
<li><code>^</code> [^abc] Match one character not in set</li>
</ul>
<p><code>^</code> 用于字符集合求非</p>
<h2 id="Using-Metacharacters"><a href="#Using-Metacharacters" class="headerlink" title="Using Metacharacters"></a>Using Metacharacters</h2><ul>
<li><code>\d</code> Digit <code>[0-9]</code></li>
<li><code>\D</code> pposite of \d <code>[^0-9]</code></li>
<li><code>\w</code> Word character (alphanumeric, underscore) <code>[a-zA-Z0-9]</code></li>
<li><code>\W</code> Opposite of <code>\w</code> <code>[^a-zA-Z0-9]</code> </li>
<li><code>\s</code> Whitespace character (space, tab, etc.) <code>[\f\n\r\t\v]</code></li>
<li><code>\S</code> Opposite of <code>\s</code> <code>[^\f\n\r\t\v]</code></li>
<li><code>[\b]</code> Backspace (any use of \b in a character set)</li>
<li><code>\n</code> Newline</li>
<li><code>\c</code> Control character</li>
<li><code>\f</code> Form feed</li>
<li><code>\r</code> Carriage return</li>
<li><code>\t</code> Tab</li>
<li><code>\v</code> Vertical tab</li>
<li><code>\x</code> Hexadecimal number; <code>\xf0</code> matches hex <code>f0</code></li>
<li><code>\0</code> Octal number; <code>\021</code> matches octal 21</li>
<li><code>POSIX字符类</code></li>
</ul>
<h2 id="Repeating-Matches"><a href="#Repeating-Matches" class="headerlink" title="Repeating Matches"></a>Repeating Matches</h2><ul>
<li><code>*</code> Match 0 or more of previous char/subexpression</li>
<li><code>+</code> Match 1 or more of previous char/subexpression</li>
<li><code>?</code> Match 0 or 1 of previous char/subexpression</li>
<li><code>{m,n}</code>  Match m to n (inclusive) of previous char/subex.</li>
<li><code>{n,}</code>   Match n or more of previous char/subexpression</li>
<li><code>{n}</code>    Match exactly n of previous char/subexpression</li>
<li><code>*?</code>, <code>??</code>  Lazy version of same (works for any quantifier)</li>
<li><code>*+</code>, <code>?+</code>  Possessive version (works for any quantifier)</li>
</ul>
<p><strong>防止过度匹配</strong>:</p>
<p>默认为 <strong>贪婪型元字符</strong>，例如 <code>*</code> <code>+</code> <code>{n,}</code>，匹配结果是<strong>多多益善而不是适可而止</strong>，<br>当不需要这种<strong>贪婪</strong>特性时，使用<strong>懒惰型元字符</strong>， <code>*?</code> <code>+?</code> <code>{n,}?</code>，特性是匹配<strong>尽可能少的字符</strong>.</p>
<h2 id="Position-Matching"><a href="#Position-Matching" class="headerlink" title="Position Matching"></a>Position Matching</h2><ul>
<li><code>^</code>    Start of string (equivalent: $A unless /m is used)</li>
<li><code>$</code>    End of string (equivalent: $Z unless /m is used)</li>
<li><code>\b</code>   Word boundary, similar to: (\w\W|\W\w)</li>
<li><code>\B</code>   Anything but a word boundary</li>
<li><code>(?m)</code> <code>^</code> or <code>$</code></li>
</ul>
<p><strong>分行匹配模式</strong>：</p>
<p>分行匹配模式(Multiline Mode) <code>(?m)</code> 使得正则表达式引擎将行分隔符当作一个字符串分隔符来对待。<br>在这种模式下，<code>^</code>不但匹配正常的字符串开头，还将匹配行分隔符(换行符)后面的开始位置；<br>类似的还有 <code>$</code>.</p>
<h2 id="Using-Subexpressions"><a href="#Using-Subexpressions" class="headerlink" title="Using Subexpressions"></a>Using Subexpressions</h2><ul>
<li><code>()</code> Define a subexpression</li>
<li><code>|</code> OR; <code>(ab|cd)</code> matches <code>ab</code> or <code>cd</code></li>
</ul>
<p>常用来对重复次数元字符的作用对象做出精确的设定和控制，子表达式允许嵌套</p>
<h2 id="Using-Backreferences"><a href="#Using-Backreferences" class="headerlink" title="Using Backreferences"></a>Using Backreferences</h2><ul>
<li><code>\a</code> a subexpression (use inside match, eg <code>s/(.)\1/a/</code>)</li>
</ul>
<p>回溯引用允许正则表达式引用前面的匹配结果，<br><code>\1</code> 也代表着模式里的第一个子表达式，<code>\2</code> 代表第二个子表达式，<code>\3</code> 代表着第三个，依次轮推。</p>
<p><strong>回溯引用只能引用模式中的子表达式 ( 和 ) 括起来的正则表达式片段</strong></p>
<ul>
<li><code>\l</code>   Make next character lowercase</li>
<li><code>\u</code>   Make next character uppercase</li>
<li><code>\L</code>   Make entire string (up to <code>\E</code>) lowercase</li>
<li><code>\U</code>   Make entire string (up to <code>\E</code>) uppercase</li>
<li><code>\E</code>   End <code>\L</code> or <code>\U</code> (so they only apply before <code>\E</code>)</li>
<li><code>\u\L</code> Capitalize first char, lowercase rest (sentence)</li>
</ul>
<h2 id="Looking-Ahead-and-Behind"><a href="#Looking-Ahead-and-Behind" class="headerlink" title="Looking Ahead and Behind"></a>Looking Ahead and Behind</h2><ul>
<li>正向前查找 <code>(?=)</code>  Look-ahead; <code>m/a(?=b)/</code> matches <code>ab</code> , “eats” a </li>
<li>正向后查找 <code>(?&lt;=)</code> Look-behind; <code>m/(?&lt;=a)b/</code> matches <code>ab</code> , “eats” b</li>
<li>负向前查找 <code>(?!)</code>  Negative look-ahead</li>
<li>负向后查找 <code>(?&lt;!)</code> Negative look-behind</li>
</ul>
<h2 id="Embedding-Conditions"><a href="#Embedding-Conditions" class="headerlink" title="Embedding Conditions"></a>Embedding Conditions</h2><ul>
<li><code>?(a)b</code>   Conditional; if a then b</li>
<li><code>?(a)b|c</code> Conditional; if a then b else c</li>
</ul>
<h2 id="RegExrV2-1-CheatSheet"><a href="#RegExrV2-1-CheatSheet" class="headerlink" title="RegExrV2.1 CheatSheet"></a><strong>RegExrV2.1 CheatSheet</strong></h2><hr>
<p>Character classes</p>
<pre><code>.           any character except newline
\w \d \s    word, digit, whitespace
\W \D \S    not word, digit, whitespace
[abc]       any of a, b, or c
[^abc]      not a, b, or c
[a-g]       character between a &amp; g</code></pre><hr>
<p>Anchors</p>
<pre><code>^abc$   start / end of the string
\b \B   word, not-word boundary</code></pre><hr>
<p>Escaped Character</p>
<pre><code>\. \* \\    escaped special characters
\t \n \r    tab, linefeed, carriage return
\u00A9      unicode escaped ©</code></pre><hr>
<p>Groups &amp; Lookaround</p>
<pre><code>(abc)   capture group
\1      backreference to group #1
(?:abc) non-capturing group
(?=abc) positive lookahead
(?!abc) negative lookahead</code></pre><hr>
<p>Quantifiers &amp; Alternation</p>
<pre><code>a* a+ a?    0 or more, 1 or more, 0 or 1
a{5} a{2,}  exactly five, two or more
a{1,3}      between one &amp; three
a+? a{2,}?  match as few as possible
ab|cd       match ab or cd</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 的 initcall函数</title>
    <url>/2016/10/24/linux-initcall/</url>
    <content><![CDATA[<p>kernel启动调用流程：<br><code>start_kernel</code> -&gt; <code>rest_init</code> -&gt; <code>kernel_thread</code> -&gt; <code>init</code> -&gt; <code>do_basic_setup</code> -&gt; <code>do_initcalls</code></p>
<a id="more"></a>


<h2 id="module-init"><a href="#module-init" class="headerlink" title="module_init"></a>module_init</h2><pre><code class="c:include/linux/init.h">/* initcalls are now grouped by functionality into separate                   
 * subsections. Ordering inside the subsections is determined                 
 * by link order.                                                             
 * For backwards compatibility, initcall() puts the call in                   
 * the device init subsection.                                                
 *                                                                            
 * The `id&#39; arg to __define_initcall() is needed so that multiple initcalls                                                        
 * can point at the same handler without causing duplicate-symbol build errors.
 */                                                                           

#define __define_initcall(level,fn,id) \                                      
    static initcall_t __initcall_##fn##id __used \                            
    __attribute__((__section__(&quot;.initcall&quot; level &quot;.init&quot;))) = fn              

#define core_initcall(fn)       __define_initcall(&quot;1&quot;,fn,1)                   
#define postcore_initcall(fn)   __define_initcall(&quot;2&quot;,fn,2)               
#define arch_initcall(fn)       __define_initcall(&quot;3&quot;,fn,3)                   
#define subsys_initcall(fn)     __define_initcall(&quot;4&quot;,fn,4)                   
#define fs_initcall(fn)         __define_initcall(&quot;5&quot;,fn,5)                   
#define rootfs_initcall(fn)     __define_initcall(&quot;rootfs&quot;,fn,rootfs)         
#define device_initcall(fn)     __define_initcall(&quot;6&quot;,fn,6)                   
#define late_initcall(fn)       __define_initcall(&quot;7&quot;,fn,7)                   

#define __initcall(fn) device_initcall(fn)                             

/**                                                                           
 * module_init() - driver initialization entry point                          
 * @x: function to be run at kernel boot time or module insertion             
 *                                                                            
 * module_init() will either be called during do_initcalls() (if              
 * builtin) or at module insertion time (if a module).  There can only        
 * be one per module.                                                         
 */                                                                           
#define module_init(x)  __initcall(x);         </code></pre>
<p>可以发现这些 <code>*_initcall(fn)</code> 最终都是通过 <code>__define_initcall(level,fn)</code> 宏定义生成的。</p>
<pre><code class="c">#define __define_initcall(level,fn,id) \                                      
    static initcall_t __initcall_##fn##id __used \                            
    __attribute__((__section__(&quot;.initcall&quot; level &quot;.init&quot;))) = fn              </code></pre>
<p>定义一个 <code>initcall_t</code> 型的初始化函数，函数存放在 <code>.initcall”level”.init</code> section内。<br><code>.initcall”level”.init</code> section定义在vmlinux.lds内。</p>
<p><code>__initcall_start</code> 和 <code>__initcall_end</code> 定义在vmlinux.lds内，表示 <code>initcall section</code> 的起始和结束地址。</p>
<pre><code class="c:arch/csky/kernel/vmlinux.lds">__initcall_start = .;
*(.initcall1.init)
*(.initcall2.init)
*(.initcall3.init)
*(.initcall4.init)
*(.initcall5.init)
*(.initcallrootfs.init)
*(.initcall6.init)
*(.initcall7.init)
__initcall_end = .;</code></pre>
<p>正好包括了上面 <code>init.h</code> 里定义的从 <code>core_initcall</code> 到 <code>late_initcall</code> 等7个level等级的 <code>.initcall”level”.init section</code>.<br>因此通过不同的 <code>*_initcall</code> 声明的函数指针最终都会存放不同level等级的 <code>.initcall”level”.init section</code> 内。<br>这些不同level的section按level等级高低依次存放。</p>
<h2 id="do-initcalls"><a href="#do-initcalls" class="headerlink" title="do_initcalls"></a>do_initcalls</h2><p>kernel启动调用流程：</p>
<p><code>start_kernel</code> -&gt; <code>rest_init</code> -&gt; <code>kernel_thread</code> -&gt; <code>init</code> -&gt; <code>do_basic_setup</code> -&gt; <code>do_initcalls</code></p>
<pre><code class="c:init/main.c:rest_init">static void noinline __init_refok rest_init(void)                             
    __releases(kernel_lock)                                                   
{                                                                             
    int pid;                                                                  

    kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);               
    numa_default_policy();                                                    
    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);              
    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);                   
    unlock_kernel();                                                          

    /*                                                                        
     * The boot idle thread must execute schedule()                           
     * at least once to get things moving:                                    
     */                                                                       
    init_idle_bootup_task(current);                                           
    preempt_enable_no_resched();                                              
    schedule();                                                               
    preempt_disable();                                                        

    /* Call into cpu_idle with preempt disabled */                            
    cpu_idle();                                                               
}                    </code></pre>
<p>通过 <code>kernel_thread</code> 创建一个内核线程执行init函数。<br>其实这里创建的即Linux的1号进程(init进程), 为linux中所有其他进程的父进程。</p>
<pre><code class="c:init/main.c:do_initcalls">static void __init do_initcalls(void)                                         
{                                                                             
    initcall_t *call;                                                         

    for (call = __early_initcall_end; call &lt; __initcall_end; call++)                                                               
        do_one_initcall(*call);                                               

    /* Make sure there is no pending stuff from the initcall sequence */      
    flush_scheduled_work();                                                   
}                                                                             </code></pre>
<p><code>__initcall_start</code> 和 <code>__initcall_end</code> 定义在 <code>vmlinux.lds</code> 内，表示 <code>initcall section</code> 的起始和结束地址。</p>
<p>依次循环调用预先存储在 <code>initcall section</code> 内的所有各个级别的初始化函数。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p><code>rest_init</code> 函数原型：</p>
<pre><code class="c">static void noinline __init_refok rest_init(void)                             
    __releases(kernel_lock)       </code></pre>
<p>其中 <code>__releases(kernel_lock)</code> 用于kernel代码静态检测</p>
<p>Sparse 诞生于 2004 年, 是由linux之父开发的, 目的就是提供一个静态检查代码的工具, 从而减少linux内核的隐患.</p>
<p>内核代码中还有一个简略的关于 Sparse的说明文件: Documentation/sparse.txt</p>
<p>Sparse通过 gcc 的扩展属性 <code>__attribute__</code> 以及自己定义的 <code>__context__</code> 来对代码进行静态检查.</p>
<ul>
<li><code>__acquires(x)   __attribute__((context(x, 0, 1)))</code>   参数x 在执行前引用计数必须是0,执行后,引用计数必须为1</li>
<li><code>__releases(x)  __attribute__((context(x, 1, 0)))</code>   与 <code>__acquires(x)</code> 相反</li>
<li><code>__acquire(x)   __context__(x, 1)</code>   参数x 的引用计数 + 1</li>
<li><code>__release(x)   __context__(x, -1)</code>  与 <code>__acquire(x)</code> 相反</li>
</ul>
<p>其中 <code>__acquires(x)</code> 和 <code>__releases(x)</code>, <code>__acquire(x)</code> 和 <code>__release(x)</code> 必须配对使用, 否则 Sparse 会给出警告</p>
<pre><code class="c">void __lockfunc _raw_spin_lock(raw_spinlock_t *lock) __acquires(lock);
void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock) __releases(lock);
# define __acquires(x) __attribute__((context(x,0,1)))
# define __releases(x) __attribute__((context(x,1,0)))</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>module</tag>
        <tag>driver</tag>
        <tag>initcall</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 贡献代码流程</title>
    <url>/2016/10/17/github-fork-and-push/</url>
    <content><![CDATA[<p>分两种情况：</p>
<ol>
<li>代码仓库管理者给你添加该仓库的写入权限，这样的话可以直接push</li>
<li>如果不能直接push（大多数情况），采用经典的 <code>fork &amp; pull request</code> 来提交代码，下面讲述这种情况</li>
</ol>
<a id="more"></a>

<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>首先需要fork这个项目, 进入项目页面, 点击右上角的 <code>Fork按钮</code></p>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>clone到本地:</p>
<pre><code>git clone https://github.com/yourname/project.git</code></pre><h2 id="添加原项目远程地址"><a href="#添加原项目远程地址" class="headerlink" title="添加原项目远程地址"></a>添加原项目远程地址</h2><p>使用 git remote -v 查看 origin 和 upstream 对应的是否正确:</p>
<ul>
<li>origin对应的应该是自己github的地址，即yourname/project</li>
<li>upstream对应的应该是原项目的地址，即sourcename/project</li>
</ul>
<pre><code>$ git remote add upstream https://github.com/sourcename/project.git //设置原代码地址
$ git remote -v
origin  git@github.com:breezet/ccextractor.git (fetch)
origin  git@github.com:breezet/ccextractor.git (push)
upstream    https://github.com/CCExtractor/ccextractor.git (fetch)
upstream    https://github.com/CCExtractor/ccextractor.git (push)</code></pre><h2 id="获取原项目最新代码"><a href="#获取原项目最新代码" class="headerlink" title="获取原项目最新代码"></a>获取原项目最新代码</h2><pre><code>git pull upstream master</code></pre><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><ul>
<li>好了, 现在可以开始贡献我们的代码了 按照国际惯例, 我们一般不在 master 上提交新代码,<br>而需要为新增的功能或者 <code>fixbug</code> 建立新分支, 再合并到 <code>master</code> 上, 使用以下代码创建分支</li>
</ul>
<pre><code>git checkout -b branch1</code></pre><p>现在我们可以在分支上更改代码了</p>
<ul>
<li>假设我们已经添加了一些代码, 提交到代码库</li>
</ul>
<pre><code>git commit -a -m &quot;new commit&quot;</code></pre><h2 id="合并修改"><a href="#合并修改" class="headerlink" title="合并修改"></a>合并修改</h2><ul>
<li><p>一个常见的问题是远程的 <code>upstream</code> 有了新的更新,<br>从而会导致我们提交的 <code>Pull Request</code> 时会导致冲突,<br>因此我们可以在提交前先把远程其他开发者的commit和我们的commit合并.</p>
</li>
<li><p>使用以下代码切换到 master 分支:</p>
</li>
</ul>
<pre><code>git checkout master</code></pre><ul>
<li>使用以下代码拉出远程的最新代码:</li>
</ul>
<pre><code>git pull upstream master</code></pre><ul>
<li>切换回 branch1:</li>
</ul>
<pre><code>git checkout branch1</code></pre><ul>
<li>把 master 的 commit 合并到 branch1:</li>
</ul>
<pre><code>git rebase master</code></pre><ul>
<li>把更新代码提交到自己的 branch1 中:</li>
</ul>
<pre><code>git push origin branch1</code></pre><h2 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h2><ul>
<li>可以在你的 github 代码仓库页面切换到 branches 页面点击 branch1 分支后点击 New pull request 按钮, 添加相关注释后提交.</li>
<li>或者，切换到 branch1 分支的代码仓库点击 Compare &amp; pull request 按钮, 添加相关注释后提交.</li>
</ul>
<h2 id="Pull-Request发送之后……"><a href="#Pull-Request发送之后……" class="headerlink" title="Pull Request发送之后……"></a>Pull Request发送之后……</h2><p>一旦你从自己的主题branch（例如branch1）推送了一条Pull Request，<br>那么在这条Pull Request被关闭之前，再次向这个branch里push代码，<br>所有的commits都会被自动追加到这个Pull Request后面（不需要再另开Pull Request）。</p>
<p>这个功能尤其有用，比如你最初提交的Pull Request里存在某些问题，项目维护者要求你打回去修改；<br>或者要求你给你的新feature添加一条相应的unit test（这种情况简直太常见了）。<br>只要追加commits到你的这个主题branch中即可。</p>
<h2 id="Pull-Request关闭之后"><a href="#Pull-Request关闭之后" class="headerlink" title="Pull Request关闭之后"></a>Pull Request关闭之后</h2><p>如果是已经被merge后关闭的Pull Request，你可以在页面的最下方找到一个“Delete this branch”的蓝色按钮。</p>
<p>这表明这个主题branch的历史使命已经完成（branch1的commit已经被合并到主项目中），可以安全地从远程库中删除了。</p>
<p>在本地库中亦可删除这个branch：</p>
<pre><code>$ git branch -d fix-unicode-error</code></pre><ol>
<li><a href="https://gist.github.com/zxhfighter/62847a087a2a8031fbdf" target="_blank" rel="noopener">如何给开源项目贡献代码</a></li>
<li><a href="https://segmentfault.com/a/1190000000736629" target="_blank" rel="noopener">如何优雅地在github上贡献代码</a></li>
<li><a href="http://www.jianshu.com/p/d4a34e55f490" target="_blank" rel="noopener">fork一个项目到贡献代码流程</a></li>
<li><a href="http://ju.outofmemory.cn/entry/90629" target="_blank" rel="noopener">Pull Request的正确打开方式</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>色表及 echo 颜色输出</title>
    <url>/2016/10/08/echo-color/</url>
    <content><![CDATA[<h2 id="bash-echo"><a href="#bash-echo" class="headerlink" title="bash echo"></a>bash echo</h2><pre><code class="bash">T=&#39;gYw&#39;   # The test text                                                      

echo -e &quot;\n                 40m     41m     42m     43m\                       
    44m     45m     46m     47m&quot;;                                              

for FGs in &#39;    m&#39; &#39;   1m&#39; &#39;  30m&#39; &#39;1;30m&#39; &#39;  31m&#39; &#39;1;31m&#39; &#39;  32m&#39; \           
    &#39;1;32m&#39; &#39;  33m&#39; &#39;1;33m&#39; &#39;  34m&#39; &#39;1;34m&#39; &#39;  35m&#39; &#39;1;35m&#39; \                  
    &#39;  36m&#39; &#39;1;36m&#39; &#39;  37m&#39; &#39;1;37m&#39;;                                           
  do FG=${FGs// /}                                                             
      echo -en &quot; $FGs \033[$FG  $T  &quot;                                          
      for BG in 40m 41m 42m 43m 44m 45m 46m 47m;                               
      do echo -en &quot;$EINS \033[$FG\033[$BG  $T  \033[0m&quot;;                                                                           
      done                                                                     
      echo;                                                                    
  done                                                                         
  echo                          </code></pre>
<a id="more"></a>

<h2 id="full-256-colors"><a href="#full-256-colors" class="headerlink" title="full 256 colors"></a>full 256 colors</h2><pre><code class="bash">#!/bin/bash
#
# generates an 8 bit color table (256 colors) for
# reference purposes, using the \033[48;5;${val}m
# ANSI CSI+SGR (see &quot;ANSI Code&quot; on Wikipedia)
#
echo -en &quot;\n   +  &quot;
for i in {0..35}; do
  printf &quot;%2b &quot; $i
done

printf &quot;\n\n %3b  &quot; 0
for i in {0..15}; do
  echo -en &quot;\033[48;5;${i}m  \033[m &quot;
done

#for i in 16 52 88 124 160 196 232; do
for i in {0..6}; do
  let &quot;i = i*36 +16&quot;
  printf &quot;\n\n %3b  &quot; $i
  for j in {0..35}; do
    let &quot;val = i+j&quot;
    echo -en &quot;\033[48;5;${val}m  \033[m &quot;
  done
done

echo -e &quot;\n&quot;</code></pre>
<h2 id="colors"><a href="#colors" class="headerlink" title="colors"></a>colors</h2><pre><code class="bash"># Colors
end=&quot;\033[0m&quot;
black=&quot;\033[0;30m&quot;
blackb=&quot;\033[1;30m&quot;
white=&quot;\033[0;37m&quot;
whiteb=&quot;\033[1;37m&quot;
red=&quot;\033[0;31m&quot;
redb=&quot;\033[1;31m&quot;
green=&quot;\033[0;32m&quot;
greenb=&quot;\033[1;32m&quot;
yellow=&quot;\033[0;33m&quot;
yellowb=&quot;\033[1;33m&quot;
blue=&quot;\033[0;34m&quot;
blueb=&quot;\033[1;34m&quot;
purple=&quot;\033[0;35m&quot;
purpleb=&quot;\033[1;35m&quot;
lightblue=&quot;\033[0;36m&quot;
lightblueb=&quot;\033[1;36m&quot;

function black {
  echo -e &quot;${black}${1}${end}&quot;
}

function blackb {
  echo -e &quot;${blackb}${1}${end}&quot;
}

function white {
  echo -e &quot;${white}${1}${end}&quot;
}

function whiteb {
  echo -e &quot;${whiteb}${1}${end}&quot;
}

function red {
  echo -e &quot;${red}${1}${end}&quot;
}

function redb {
  echo -e &quot;${redb}${1}${end}&quot;
}

function green {
  echo -e &quot;${green}${1}${end}&quot;
}

function greenb {
  echo -e &quot;${greenb}${1}${end}&quot;
}

function yellow {
  echo -e &quot;${yellow}${1}${end}&quot;
}

function yellowb {
  echo -e &quot;${yellowb}${1}${end}&quot;
}

function blue {
  echo -e &quot;${blue}${1}${end}&quot;
}

function blueb {
  echo -e &quot;${blueb}${1}${end}&quot;
}

function purple {
  echo -e &quot;${purple}${1}${end}&quot;
}

function purpleb {
  echo -e &quot;${purpleb}${1}${end}&quot;
}

function lightblue {
  echo -e &quot;${lightblue}${1}${end}&quot;
}

function lightblueb {
  echo -e &quot;${lightblueb}${1}${end}&quot;
}

function colors {
  black &quot;black&quot;
  blackb &quot;blackb&quot;
  white &quot;white&quot;
  whiteb &quot;whiteb&quot;
  red &quot;red&quot;
  redb &quot;redb&quot;
  green &quot;green&quot;
  greenb &quot;greenb&quot;
  yellow &quot;yellow&quot;
  yellowb &quot;yellowb&quot;
  blue &quot;blue&quot;
  blueb &quot;blueb&quot;
  purple &quot;purple&quot;
  purpleb &quot;purpleb&quot;
  lightblue &quot;lightblue&quot;
  lightblueb &quot;lightblueb&quot;
}

function colortest {
  if [[ -n &quot;$1&quot; ]]; then
    T=&quot;$1&quot;
  fi
  T=&#39;gYw&#39;   # The test text

  echo -e &quot;\n                 40m     41m     42m     43m\
       44m     45m     46m     47m&quot;;

  for FGs in &#39;    m&#39; &#39;   1m&#39; &#39;  30m&#39; &#39;1;30m&#39; &#39;  31m&#39; &#39;1;31m&#39; &#39;  32m&#39; \
             &#39;1;32m&#39; &#39;  33m&#39; &#39;1;33m&#39; &#39;  34m&#39; &#39;1;34m&#39; &#39;  35m&#39; &#39;1;35m&#39; \
             &#39;  36m&#39; &#39;1;36m&#39; &#39;  37m&#39; &#39;1;37m&#39;;
    do FG=${FGs// /}
    echo -en &quot; $FGs \033[$FG  $T  &quot;
    for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
      do echo -en &quot;$EINS \033[$FG\033[$BG  $T  \033[0m&quot;;
    done
    echo;
  done
  echo
}</code></pre>
<h2 id="tput"><a href="#tput" class="headerlink" title="tput"></a>tput</h2><pre><code class="bash">#!/bin/bash                                                                   

if ! hash tput 2&gt;/dev/null; then                                                                                                   
    echo &quot;I cannot find the &#39;tput&#39; program.&quot; \                                
        &#39;You might find it in one of the ncurses packages.&#39; &gt;&amp;2               
    exit 1                                                                    
fi                                                                            

for i in {0..255}; do                                                         
    tput setab $i &amp;&amp; echo -n &quot; $i &quot;                                           
done                                                                          

tput sgr0                                                                     
echo        </code></pre>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol>
<li><a href="http://bitmote.com/index.php?post/2012/11/19/Using-ANSI-Color-Codes-to-Colorize-Your-Bash-Prompt-on-Linux" target="_blank" rel="noopener">Using ANSI Color Codes to Colorize Your Bash Prompt on Linux</a></li>
<li><a href="https://gist.github.com/thomd/171888" target="_blank" rel="noopener">available_colors.sh</a></li>
<li><a href="https://gist.github.com/daytonn/8677243" target="_blank" rel="noopener">colors</a></li>
<li><a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors" target="_blank" rel="noopener">ANSI_escape_code#Colors</a></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>color</tag>
        <tag>shell</tag>
        <tag>echo</tag>
      </tags>
  </entry>
  <entry>
    <title>vim下文件路径</title>
    <url>/2016/10/07/vim-file-path/</url>
    <content><![CDATA[<pre><code class="vim">:help filename-modifiers
:help fnamemodify
:help extend</code></pre>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><pre><code>Examples, when the file name is &quot;src/version.c&quot;, current dir                  
&quot;/home/mool/vim&quot;:                                                             

    :p                    /home/mool/vim/src/version.c                          
    :p:.                                 src/version.c                          
    :p:~                           ~/vim/src/version.c                          
    :h                                   src                                    
    :p:h                  /home/mool/vim/src                                    
    :p:h:h                /home/mool/vim                                        
    :t                                       version.c                          
    :p:t                                     version.c                          
    :r                                   src/version                            
    :p:r                  /home/mool/vim/src/version                            
    :t:r                                     version                            
    :e                                               c                          
    :s?version?main?                     src/main.c                                                                                  
    :s?version?main?:p    /home/mool/vim/src/main.c                             
    :p:gs?/?\\?           \home\mool\vim\src\version.c      </code></pre><a id="more"></a>

<pre><code>Examples, when the file name is &quot;src/version.c.gz&quot;:                           

    :p                    /home/mool/vim/src/version.c.gz                       
    :e                                                 gz                       
    :e:e                                             c.gz                       
    :e:e:e                                           c.gz                       
    :e:e:r                                           c                          
    :r                                   src/version.c                          
    :r:e                                             c                          
    :r:r                                 src/version                                                                                 
    :r:r:r                               src/version        </code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vimscript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 Xlrd/xlwt 操作 Excel</title>
    <url>/2016/09/19/python-excel/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="zsh">sudo easy_install xlrd
sudo easy_install xlwt</code></pre>
<p><strong><code>xlutils</code></strong>（依赖于xlrd和xlwt）提供复制excel文件内容和修改文件的功能。<br>其实际也只是在xlrd.Book和xlwt.Workbook之间建立了一个管道而已.</p>
<h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><pre><code class="python">import xlrd
data = xlrd.open_workbook(&#39;demo.xls&#39;) # 打开demo.xls
data.sheet_names()        # 获取xls文件中所有sheet的名称
table = data.sheets()[0]  # 获取xls文件第一个工作表
table = data.sheet_by_index(0)        # 通过索引获取xls文件第0个sheet
table = data.sheet_by_name(u&#39;Sheet1&#39;) # 通过工作表名获取 sheet
# 获取行数和列数
nrows = table.nrows
ncols = table.ncols
# 获取整行和整列的值（数组）
table.row_values(i)
table.col_values(i)
# 循环行,得到索引的列表
for rownum in range(table.nrows):
    print table.row_values(rownum)
# 获取单元格
cell_A1 = table.cell(0,0).value
cell_C4 = table.cell(2,3).value
# 分别使用行列索引
cell_A1 = table.row(0)[0].value
cell_A2 = table.col(1)[0].value
# 简单的写入
row = 0
col = 0
ctype = 1 # 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error
value = &#39;liluo&#39;
xf = 0 # 扩展的格式化 (默认是0)
table.put_cell(row, col, ctype, value, xf)
table.cell(0,0) # 文本:u&#39;lixiaoluo&#39;
table.cell(0,0).value # &#39;lixiaoluo&#39;</code></pre>
<a id="more"></a>

<pre><code class="python">import xlwt
file = xlwt.Workbook()                # 注意这里的Workbook首字母是大写
table = file.add_sheet(&#39;sheet name&#39;)  # 新建一个sheet

table.write(0,0,&#39;test&#39;)               # 写入数据table.write(行,列,value)

# 如果对一个单元格重复操作，会引发
# returns error:
# Exception: Attempt to overwrite cell:
# sheetname=u&#39;sheet 1&#39; rowx=0 colx=0
# 所以在打开时加cell_overwrite_ok=True解决

table = file.add_sheet(&#39;sheet name&#39;,cell_overwrite_ok=True)
file.save(&#39;demo.xls&#39;)     # 保存文件

# 另外，使用style
style = xlwt.XFStyle()    # 初始化样式
font = xlwt.Font()        # 为样式创建字体
font.name = &#39;Times New Roman&#39;
font.bold = True
style.font = font         #为样式设置字体
table.write(0, 0, &#39;some bold Times text&#39;, style) # 使用样式</code></pre>
<h2 id="根据格式化文本生成excel"><a href="#根据格式化文本生成excel" class="headerlink" title="根据格式化文本生成excel"></a>根据格式化文本生成excel</h2><pre><code class="python"># -*- coding: utf-8 -*-

import xlwt
import sys, os
import glob
import types
import linecache

title = []

sat_title = []

def create_defalut_xls():

    file_num = sys.argv[1]
    print file_num

    cwd = os.getcwd()
    xls_name = cwd + &quot;/output/&quot; + &quot;default_strong.xls&quot;
    print &quot;defalut xls = %s&quot; % (xls_name)

    sheetID = 0
    wb = xlwt.Workbook(encoding=&#39;utf-8&#39;)
    ws = wb.add_sheet(&#39;Satellites&#39;)

    style = xlwt.XFStyle()
    style.num_format_str = &#39;General&#39;

    for i in range(0, len(title)):
        ws.write(sheetID, i, title[i])
        #ws.write(0, i, title[i], set_style(&#39;Times New Roman&#39;, 220, True))

    sheetID = 1;

    for i in range(0, int(file_num)):
        file = cwd + &quot;/output/&quot; + str(i) + &quot;.txt&quot;
        #print &quot;file = %s&quot; % (file)

        #if os.path.isfile(file):
        #    fp = open(file, &quot;r&quot;)
        #    for line in fp:
        #        print line.strip(&#39;\n&#39;)
        #        print line.strip(&#39;\n&#39;).split(&#39;,&#39;)

        if os.path.isfile(file):
            line = len(open(file, &quot;rU&quot;).readlines())
            print line
            sat_sheet_line = 0
            for k in range(1, line+1):
                content = linecache.getline(file, k).strip(&#39;\n&#39;)
                if k == 1:
                    name,longitude,id,direction = content.split(&#39;,&#39;)

                    sheetname = name.replace(&#39; &#39;, &#39;_&#39;).replace(&#39;/&#39;, &#39;_&#39;)
                    sheet = wb.add_sheet(sheetname)
                    #row = [&#39;A&#39;, name, sheetname, int(longitude), 0, 0, 0, 0, 0, 0, int(direction), 0, 0]
                    row = [&#39;A&#39;, name, sheetname, longitude, str(0), str(0), str(0), str(0), str(0), str(0), direction, str(0), str(0)]
                    #print row
                    for j in range(0, len(row)):
                        if j == 1:
                            #link = &#39;HYPERLINK(&quot;#&#39;str(i)&#39;!A1&quot;, &quot;Link&quot;)&#39;
                            #link = &#39;HYPERLINK(&quot;#&#39;+ str(i) +&#39;&quot;, &quot;&#39;+ name +&#39;&quot;)&#39;
                            link = &#39;HYPERLINK(&quot;#&#39;+ sheetname + &#39;!A1&quot;, &quot;&#39;+ name +&#39;&quot;)&#39;
                            ws.write(sheetID, j, xlwt.Formula(link))
                        else:
                            ws.write(sheetID, j, row[j], style)

                    for m in range(0, len(sat_title)):
                        sheet.write(sat_sheet_line, m, sat_title[m])
                    sat_sheet_line = sat_sheet_line + 1

                    sheetID = sheetID + 1
                else:
                    #print content
                    polar = content.split(&#39;,&#39;)[1]
                    fre = content.split(&#39;,&#39;)[4]
                    sym = content.split(&#39;,&#39;)[5]

                    #row = [&#39; &#39;, int(fre), int(sym), polar]
                    row = [&#39; &#39;, fre, sym, polar.strip(&#39; &#39;)]
                    for n in range(0, len(row)):
                        sheet.write(sat_sheet_line, n, row[n])
                    sat_sheet_line = sat_sheet_line + 1

    wb.save(xls_name)

if __name__ == &quot;__main__&quot;:
    create_defalut_xls()</code></pre>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol>
<li><a href="http://www.python-excel.org/" target="_blank" rel="noopener">Working with Excel Files in Python</a></li>
<li><a href="http://stackoverflow.com/questions/26957831/edit-existing-excel-workbooks-and-sheets-with-xlrd-and-xlwt" target="_blank" rel="noopener">Edit existing excel workbooks and sheets with xlrd and xlwt</a></li>
<li><a href="http://www.ourunix.org/post/233.html" target="_blank" rel="noopener">使用第三方库xlutils来追加写Excel</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>xlutils</tag>
        <tag>xlrd</tag>
        <tag>xlwt</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>lyngsat crawler</title>
    <url>/2016/09/09/lyngsat-crawler/</url>
    <content><![CDATA[<p>主要用到 <code>requests</code> 和 <code>bs4</code> 这两个包</p>
<pre><code class="python">
import requests
import bs4

proxy = {&quot;http&quot;:&quot;http://127.0.0.1:8787&quot;,&quot;https&quot;:&quot;https://127.0.0.1:8787&quot;}

url = &#39;http://www.lyngsat.com/asia.html&#39;

#results = [[data.get_text() for data in row.find_all(&#39;td&#39;)] for row in allRows]

def get_info_from_table(table):
    rowspan_count = 0
    current_tr = 0
    trs = table.find_all(&#39;tr&#39;)

    for i in range(0, len(trs))[2:-1]:
        #print i
        if rowspan_count != 0:
            td = trs[i].find_all(&#39;td&#39;)
            if i == current_tr + 1:
                print &quot;\t&quot; + td[1].getText()
            else:
                print &quot;\t&quot; + td[0].getText()
            rowspan_count = rowspan_count - 1
            continue

        for td in trs[i].find_all(&#39;td&#39;):
            if td.has_attr(&quot;rowspan&quot;):
                rowspan_count = int(td[&quot;rowspan&quot;]) - 1
                current_tr = i
                #print &quot;rowspan_count : %d&quot; % (rowspan_count)

        td = trs[i].find_all(&#39;td&#39;)
        #print td[1].b.getText() + &quot; &quot; + td[6].getText()
        sym = td[6].getText().split(&quot;-&quot;)[0]
        print &quot;\n&quot; + td[1].b.getText().strip(&#39; &#39;) + &quot; &quot; + sym
        print &quot;\t&quot; + td[3].getText()

def get_one_satellite(url):
    print &quot;Start get data from %s&quot; % (url)
    response = requests.get(url, proxies = proxy, verify=False)
    soup = bs4.BeautifulSoup(response.content, &quot;lxml&quot;)
    #print soup.prettify()

    for table in soup.find_all(&#39;table&#39;, width=720, cellspacing=0, cellpadding=0):
        for tr in table.find_all(&#39;tr&#39;)[0:len(table.find_all(&#39;tr&#39;))-1]:
            for td in tr.find_all(&#39;td&#39;,colspan=10, align=&quot;center&quot;):
                print td.string
                get_info_from_table(table)
                print 

    #tables[6].find_all(&#39;tr&#39;)[2].find_all(&#39;td&#39;)[1]


def get_urls():
    response = requests.get(url, proxies = proxy, verify=False)
    soup = bs4.BeautifulSoup(response.content, &quot;lxml&quot;)
    #print soup.prettify()

    #links = [a.attrs.get(&#39;href&#39;) for a in soup.select(&#39;tr a[href]&#39;)]
    #for link in soup.find_all(&#39;a&#39;):
    #    print(link.get(&#39;href&#39;))

    #tables = soup.find_all(&#39;table&#39;, align=&quot;center&quot;, width=720)
    #for link in tables[0].find_all(&#39;a&#39;):
    #    print link.string
    #    print(link.get(&#39;href&#39;))

    #tables = soup.find_all(&#39;table&#39;, align=&quot;center&quot;, width=720)
    #tds = tables[0].find_all(&#39;td&#39;, width=70)
    #for i in range(0, len(tds)):
    #    link = tds[i].find_all(&#39;a&#39;)
    #    print(link[0].get(&#39;href&#39;))

    #tables = soup.find_all(&#39;table&#39;, align=&quot;center&quot;, width=720)
    #tds = tables[0].find_all(&#39;td&#39;, width=70)
    #for td in tds:
    #    for link in td.find_all(&#39;a&#39;):
    #        print link.get(&#39;href&#39;)

    for table in soup.find_all(&#39;table&#39;, align=&quot;center&quot;, width=720):
        for td in table.find_all(&#39;td&#39;, width=70):
            for link in td.find_all(&#39;a&#39;):
                get_one_satellite(link.get(&#39;href&#39;))


def main():
    get_urls()

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<a id="more"></a>

<ol>
<li><a href="http://wuchong.me/blog/2014/04/24/easy-web-scraping-with-python/" target="_blank" rel="noopener">使用 Python 轻松抓取网页</a></li>
<li><a href="http://www.zhidaow.com/post/python-requests-install-and-brief-introduction" target="_blank" rel="noopener">python requests的安装与简单运用</a></li>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">Beautiful Soup Documentation</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
        <tag>bs4</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title>tumblr crawler</title>
    <url>/2016/09/08/tumblr-crawler/</url>
    <content><![CDATA[<ol>
<li><a href="https://github.com/tumblr/pytumblr" target="_blank" rel="noopener">pytumblr</a></li>
<li><a href="http://jmduke.com/posts/crawling-tumblr-with-multiprocessing/" target="_blank" rel="noopener">Crawling Tumblr with multiprocessing</a></li>
<li><a href="https://www.tumblr.com/docs/en/api/v2" target="_blank" rel="noopener">Tumblr API</a></li>
<li><a href="http://cuiqingcai.com/2652.html" target="_blank" rel="noopener">PySpider的用法</a></li>
<li><a href="https://github.com/dixudx/tumblr-crawler" target="_blank" rel="noopener">tumblr-crawler</a></li>
</ol>
<a id="more"></a>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>webs</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>git stash 系列命令的使用</title>
    <url>/2016/08/28/git-stash/</url>
    <content><![CDATA[<ul>
<li>toc<br>{:toc}</li>
</ul>
<hr>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><pre><code class="bash">$ &gt; git stash -h
usage: git stash list [&lt;options&gt;]
   or: git stash show [&lt;stash&gt;]
   or: git stash drop [-q|--quiet] [&lt;stash&gt;]
   or: git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]
   or: git stash branch &lt;branchname&gt; [&lt;stash&gt;]
   or: git stash [save [--patch] [-k|--[no-]keep-index] [-q|--quiet]
                       [-u|--include-untracked] [-a|--all] [&lt;message&gt;]]
   or: git stash clear

$ &gt; man git stash

$ &gt; man git log</code></pre>
<a id="more"></a>

<h3 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h3><p>列出所有暂存文件，<br>The command takes options applicable to the git log command to control what is shown and how. See git-log(1).</p>
<h3 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h3><pre><code class="bash">$ git stash show 默认第一个 `stash@{0}`
$ git stash show stash@{0} 显示那些文件有改动
$ git stash show -p stash@{0} 显示具体各个文件改动</code></pre>
<h3 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h3><pre><code class="bash">$ git stash drop 丢弃暂存，默认第一个
$ git stash drop stash@{1} 丢弃第二个暂存</code></pre>
<h3 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h3><pre><code class="bash">$ git stash clear 清除所有暂存</code></pre>
<h3 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h3><pre><code class="bash">$ git stash pop 恢复最新的暂存，并从list中删除
$ git stash pop stash@{id} 恢复指定暂存，并从list中删除</code></pre>
<h3 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h3><pre><code class="bash">$ git stash apply 恢复最新的暂存，不从list中删除
$ git stash apply stash@{id} 恢复指定暂存，不从list中删除</code></pre>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><pre><code class="bash">$ git stash 可用来暂存当前正在进行的工作
$ git stash save &quot;message&quot; 添加信息
$ git stash save -a &quot;message&quot; --all
$ git stash save -u &quot;message&quot; --include-untracked
$ git stash save --keep-index    # save all other changes to the stash</code></pre>
<h3 id="git-stash-branch"><a href="#git-stash-branch" class="headerlink" title="git stash branch"></a>git stash branch</h3><h3 id="git-stash-create"><a href="#git-stash-create" class="headerlink" title="git stash create"></a>git stash create</h3><h3 id="git-stash-store"><a href="#git-stash-store" class="headerlink" title="git stash store"></a>git stash store</h3><h2 id="git-stash-conflict"><a href="#git-stash-conflict" class="headerlink" title="git stash conflict"></a>git stash conflict</h2><h3 id="CONFLICT"><a href="#CONFLICT" class="headerlink" title="CONFLICT"></a>CONFLICT</h3><pre><code class="bash"># On branch master
# Unmerged paths:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)
#
#   both modified:      src/js/globals.tpl.js
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<p>Afterwards just run <code>git reset</code> to unstage the changes and keep on hacking – or <code>git add ...</code> and commit.</p>
<h3 id="git-reset-or-git-add"><a href="#git-reset-or-git-add" class="headerlink" title="git reset or git add"></a>git reset or git add</h3><p>暂存文件与更新文件存在冲突解决如下：</p>
<pre><code class="bash">$ git stash pop -&gt; CONFLICT
# ...manually resolve conflict(s)
$ git add file</code></pre>
<p>丢弃修改暂存</p>
<p><code>git st</code>中列出来的文件：</p>
<ul>
<li>[G]绿色：加入暂存区文件，不可以用 <code>git diff</code></li>
<li>[R]红色：未加入暂存区文件，可以用 <code>git diff</code></li>
</ul>
<pre><code class="bash">$ git stash pop -&gt; CONFLICT
$ git st
位于分支 test
要提交的变更：
  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）

  修改：     bsp/lib/libpanel.a [G]
  修改：     scripts/inc.Makefile.conf.mak [G]

  未合并的路径：
  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）
  （使用 &quot;git add &lt;文件&gt;...&quot; 标记解决方案）

  双方修改：   app/full_screen.c [R]

$ git reset HEAD 恢复提交
重置后取消暂存的变更：
M   solution/app/full_screen.c
M   solution/bsp/lib/libpanel.a
M   solution/scripts/inc.Makefile.conf.mak

$ git st 
位于分支 test
尚未暂存以备提交的变更：
  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
    （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）

    修改：     app/full_screen.c [R]
    修改：     bsp/lib/libpanel.a [R]
    修改：     scripts/inc.Makefile.conf.mak [R]

$ git reset HEAD app/full_screen.c
重置后取消暂存的变更：
M   solution/app/full_screen.c
$ git st
位于分支 test
要提交的变更：
（使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）

    修改：     bsp/lib/libpanel.a [G]
    修改：     scripts/inc.Makefile.conf.mak [G]

尚未暂存以备提交的变更：
（使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
（使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）

    修改：     app/full_screen.c [R]

$ git reset --hard 回到上次提交时的状态，干净分支
位于分支 test</code></pre>
<h2 id="EXAMPLES"><a href="#EXAMPLES" class="headerlink" title="EXAMPLES"></a>EXAMPLES</h2><h3 id="Pulling-into-a-dirty-tree"><a href="#Pulling-into-a-dirty-tree" class="headerlink" title="Pulling into a dirty tree"></a>Pulling into a dirty tree</h3><pre><code class="bash">$ git pull
...
file foobar not up to date, cannot merge.
$ git stash
$ git pull
$ git stash pop</code></pre>
<h3 id="Interrupted-workflow"><a href="#Interrupted-workflow" class="headerlink" title="Interrupted workflow"></a>Interrupted workflow</h3><pre><code class="bash"># ... hack hack hack ...
$ git checkout -b my_wip
$ git commit -a -m &quot;WIP&quot;
$ git checkout master
$ edit emergency fix
$ git commit -a -m &quot;Fix in a hurry&quot;
$ git checkout my_wip
$ git reset --soft HEAD^
# ... continue hacking ...</code></pre>
<p>You can use git stash to simplify the above, like this:</p>
<pre><code class="bash"># ... hack hack hack ...
$ git stash
$ edit emergency fix
$ git commit -a -m &quot;Fix in a hurry&quot;
$ git stash pop
# ... continue hacking ...</code></pre>
<h3 id="Testing-partial-commits"><a href="#Testing-partial-commits" class="headerlink" title="Testing partial commits"></a>Testing partial commits</h3><p>You can use git stash save –keep-index when you want to make two or more commits out of the changes in the work tree,<br>and you want to test each change before committing:</p>
<pre><code class="bash"># ... hack hack hack ...
$ git add --patch foo            # add just first part to the index
$ git stash save --keep-index    # save all other changes to the stash
$ edit/build/test first part
$ git commit -m &#39;First part&#39;     # commit fully tested change
$ git stash pop                  # prepare to work on all other changes
# ... repeat above five steps until one commit remains ...
$ edit/build/test remaining parts
$ git commit foo -m &#39;Remaining parts&#39;</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>通过矢量字库制作点阵字库</title>
    <url>/2016/08/14/ttf-to-dot/</url>
    <content><![CDATA[<ol>
<li><a href="http://blog.csdn.net/ws_540/article/details/20048343" target="_blank" rel="noopener">使用MCT6.0工具和fontconver制作MTK字库文件</a></li>
<li><a href="http://blog.csdn.net/picasso_l/article/details/39370339" target="_blank" rel="noopener">通过矢量字库制作点阵字库</a></li>
</ol>
<a id="more"></a>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Font</category>
      </categories>
      <tags>
        <tag>ttf</tag>
        <tag>MCT6.0</tag>
        <tag>fontconver</tag>
      </tags>
  </entry>
  <entry>
    <title>shell逐行处理文本</title>
    <url>/2016/08/08/shell-read-line/</url>
    <content><![CDATA[<ul>
<li>toc<br>{:toc}</li>
</ul>
<hr>
<h2 id="IFS"><a href="#IFS" class="headerlink" title="IFS"></a>IFS</h2><p>在弄清楚循环语句前，先看看字段分隔符的作用。<br><strong>字段分隔符(Internal Field Separator, IFS)是shell脚本中的一个重要概念</strong>，<br>处理文本数据的时候非常的有用，<br>是把单个数据流划分成不同数据元素的定界符。<br><strong>系统环境默认的IFS是空白字符(换行符、制表符或者空格)</strong>。</p>
<p>当 shell 处理”命令替换”和”参数替换”时，<br>shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，<br>然后对特殊字符进行处理，最后重新组合赋值给该变量。</p>
<p>以下是值得注意的地方：</p>
<ol>
<li>IFS is the space, tab, and newline characters by default，连续多个空白被看做一个处理</li>
<li><code>$*</code> 使用IFS中的第一个字符作为分隔符，把参数连接</li>
<li>awk中的FS（域分隔符）也和IFS有类似的用法和作用</li>
</ol>
<a id="more"></a>

<h2 id="查看IFS值"><a href="#查看IFS值" class="headerlink" title="查看IFS值"></a>查看IFS值</h2><pre><code class="bash">&gt; echo -n &quot;$IFS&quot; | od -ab
0000000  sp  ht  nl nul
        040 011 012 000
0000004</code></pre>
<h2 id="while-read-line"><a href="#while-read-line" class="headerlink" title="while read line"></a>while read line</h2><pre><code class="bash">cat $FILE | while read line
do
    echo &quot;&gt;&gt; ${line}&quot;
done

echo &quot;&quot;

while read line
do
    echo &quot;&gt;&gt; ${line}&quot;
done &lt; $FILE

while IFS=&#39;&#39; read line
do
    echo &quot;&gt;&gt; ${line}&quot;
done &lt; $FILE</code></pre>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><pre><code class="bash">cat $FILE | awk &#39;{print $0}&#39;
cat $FILE | awk &#39;{for(i=2;i&lt;NF;i++) {printf $i} printf &quot;\n&quot;}&#39;</code></pre>
<h2 id="for-var-in-file"><a href="#for-var-in-file" class="headerlink" title="for var in file"></a>for var in file</h2><p><code>for var in file</code>　表示变量var在file中循环取值．取值的分隔符由<code>$IFS</code>确定</p>
<pre><code class="bash">IFS=&quot;
&quot;

for line in $(cat $FILE)
do 
    echo &quot;&gt;&gt; ${line}&quot;
done

for line in `cat $FILE`
do 
    echo &quot;&gt;&gt; ${line}&quot;
done</code></pre>
<hr>
<ol>
<li><a href="http://www.vpsee.com/2009/09/shell-script-read-a-file-line-by-line/" target="_blank" rel="noopener">逐行读取文本文件的 shell 脚本</a></li>
<li><a href="http://skypegnu1.blog.51cto.com/8991766/1543319" target="_blank" rel="noopener">Shell中的 IFS</a></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title>Vimscript中的路径</title>
    <url>/2016/07/19/vimscript-path/</url>
    <content><![CDATA[<p>Vim是一个文本编辑器，并且文本编辑器经常是对文本文件进行操作。<br>文本文件是在文件系统里进行管理的，我们需要通过文件路径来指定文件。<br>当你需要对路径进行操作的时候，vim提供了一些很有用的内置函数。</p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>有些时候外部脚本取得某些文件的路径是很简单的。运行下面的命令：</p>
<pre><code class="vimscript">:echom expand(&#39;%&#39;)
:echom expand(&#39;%:p&#39;)
:echom fnamemodify(&#39;foo.txt&#39;,&#39;:p&#39;)</code></pre>
<p>第一条命令用来显示你当前在编辑的文件的相对路径。%代表“当前文件”。vim里还有很多可以用expand()来进行替换的字符串。</p>
<p>第二条命令会输出当前文件的全路径。字符串里的:p用来告诉vim取文件的全路径。vim里也有很多这样的修饰符可以使用。</p>
<p>第三条命令根据当前路径显示foo.txt文件的绝对路径，而不用考虑这个文件是否存在。<br>fnamemodify()是一个vim函数，它比expand()函数更加灵活，因为它可以指定任何文件，不仅仅只是expand()的特殊字符。</p>
<h3 id="列出文件"><a href="#列出文件" class="headerlink" title="列出文件"></a>列出文件</h3><p>有时候你会需要取得某个目录下的文件列表。运行下面的命令：</p>
<pre><code class="vimscript">:echo globpath(&#39;.&#39;,&#39;*&#39;)</code></pre>
<p>Vim会列出当前目录下的所有文件。globpath()函数返回一个字符串，包含所有的文件名，文件名之间用回车分割。如果想要拿到第一个列表的话，你可以自己用split来切分。运行下面的命令：</p>
<pre><code class="vimscript">:echo split(globpath(&#39;.&#39;,&#39;*&#39;),&#39;\n&#39;)</code></pre>
<p>这次vim会输出一个包含所有文件的列表。</p>
<p>golbpath函数的通配符基本上也是按照你所认为的方式去工作的。运行下面的命令：</p>
<pre><code class="vimscript">:echo split(globpath(&#39;.&#39;,&#39;*.txt&#39;),&#39;\n&#39;)</code></pre>
<p>Vim输出当前目录的下所有的以.txt结尾的文件的列表。</p>
<p>你可以通过<code>\*\*</code>来递归地列举当前文件夹下的所有文件。运行下面的命令：</p>
<pre><code class="vimscript">:echo split(globpath(&#39;.&#39;,&#39;**&#39;))</code></pre>
<p>Vim会输出当前文件夹下的所有文件和文件夹。</p>
<p>globpath的功能非常强大，在你完成本章的练习之后，你会学到更多东西。</p>
<h3 id="fnamemodify"><a href="#fnamemodify" class="headerlink" title="fnamemodify"></a>fnamemodify</h3><pre><code class="vimscript">:help filename-modifiers</code></pre>
<p>可用选项如下：</p>
<pre><code class="txt">:echo fnamemodify(&quot;main.c&quot;, &quot;:p:h&quot;)

:_%: ::8 ::p ::. ::~ ::h ::t ::r ::e ::s ::gs ::S 
    %:8 %:p %:. %:~ %:h %:t %:r %:e %:s %:gs %:S </code></pre>
<p>各种效果如下：</p>
<pre><code class="txt">Examples, when the file name is &quot;src/version.c&quot;, current dir
&quot;/home/mool/vim&quot;: &gt;
  :p            /home/mool/vim/src/version.c
  :p:.                       src/version.c
  :p:~                 ~/vim/src/version.c
  :h                       src
  :p:h            /home/mool/vim/src
  :p:h:h        /home/mool/vim
  :t                       version.c
  :p:t                       version.c
  :r                       src/version
  :p:r            /home/mool/vim/src/version
  :t:r                       version
  :e                           c
  :s?version?main?               src/main.c
  :s?version?main?:p    /home/mool/vim/src/main.c
  :p:gs?/?\\?        \home\mool\vim\src\version.c

Examples, when the file name is &quot;src/version.c.gz&quot;: &gt;
  :p            /home/mool/vim/src/version.c.gz
  :e                             gz
  :e:e                           c.gz
  :e:e:e                       c.gz
  :e:e:r                       c
  :r                       src/version.c
  :r:e                           c
  :r:r                       src/version
  :r:r:r                   src/version</code></pre>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul>
<li>Read :help expand().</li>
<li>Read :help fnamemodify().</li>
<li>Read :help filename-modifiers.</li>
<li>Read :help simplify().</li>
<li>Read :help resolve().</li>
<li>Read :help globpath().</li>
<li>Read :help wildcards.</li>
</ul>
<hr>
<ol>
<li><a href="https://kenvifire.gitbooks.io/vimscript/content/40.html" target="_blank" rel="noopener">路径</a></li>
<li><a href="https://kenvifire.gitbooks.io/vimscript/content/index.html" target="_blank" rel="noopener">Vimscript编程指南</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vimscript</tag>
      </tags>
  </entry>
  <entry>
    <title>vim插件YouCompleteMe安装</title>
    <url>/2016/07/18/vim-ycm/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://github.com/Valloric/YouCompleteMe#ubuntu-linux-x64" target="_blank" rel="noopener">Ubuntu Linux x64</a></p>
<pre><code class="bash">sudo apt-get install build-essential cmake
sudo apt-get install python-dev python3-dev</code></pre>
<p>在 <code>.vimrc</code> 中：</p>
<pre><code class="vim">Bundle &#39;Valloric/YouCompleteMe&#39;</code></pre>
<p>下载完成之后需要编译，支持语义分析：</p>
<pre><code class="bash">cd ~/.vim/bundle/YouCompleteMe
./install.py --clang-completer</code></pre>
<p>编译完成后，完成安装，接下来需要配置</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在vim启动后,YCM会找寻当前路径以及上层路径的 <code>.ycm_extra_conf.py</code> .</p>
<p>在<code>~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py</code> 中提供了默认的模板.</p>
<p>可以使用 <code>newycm_extra_conf.py</code> 来生成模板</p>
<p>使用-isystem添加系统的头文件进行解析，使用-I添加第三方的头文件进行解析，在flags部分后添加如下内容：</p>
<pre><code class="bash">&#39;-isystem&#39;,
&#39;/usr/include&#39;,</code></pre>
<p>修改之后用于C工程配置文件如下：</p>
<pre><code class="py"># This file is NOT licensed under the GPLv3, which is the license for the rest
# of YouCompleteMe.
#
# Here&#39;s the license text for this file:
#
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to &lt;http://unlicense.org/&gt;

import os
import ycm_core

# These are the compilation flags that will be used in case there&#39;s no
# compilation database set (by default, one is not set).
# CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.
flags = [
&#39;-Wall&#39;
, &#39;-Wextra&#39;
#&#39;-Werror&#39;, # Fucking unused parameter &#39;argc&#39;
, &#39;-Wno-long-long&#39;
, &#39;-Wno-variadic-macros&#39;
, &#39;-Wno-unused-parameter&#39;
, &#39;-Wno-missing-field-initializers&#39;
, &#39;-fexceptions&#39;
, &#39;-DNDEBUG&#39;
, &#39;-DUSE_CLANG_COMPLETER&#39;
, &#39;-Wno-int-to-pointer-cast&#39;
, &#39;-Wno-pointer-to-int-cast&#39;
, &#39;-Wno-sign-compare&#39;
# THIS IS IMPORTANT! Without a &quot;-std=&lt;something&gt;&quot; flag, clang won&#39;t know which
# language to use when compiling headers. So it will guess. Badly. So C++
# headers will be compiled as C headers. You don&#39;t want that so ALWAYS specify
# a &quot;-std=&lt;something&gt;&quot;.
# For a C project, you would set this to something like &#39;c99&#39; instead of
# &#39;c++11&#39;.
, &#39;-std=c99&#39;
# ...and the same thing goes for the magic -x option which specifies the
# language that the files to be compiled are written in. This is mostly
# relevant for c++ headers.
# For a C project, you would set this to &#39;c&#39; instead of &#39;c++&#39;.
, &#39;c&#39;
, &#39;-isystem&#39;
, &#39;../BoostParts&#39;
, &#39;-isystem&#39;
# This path will only work on OS X, but extra paths that don&#39;t exist are not
# harmful
, &#39;/System/Library/Frameworks/Python.framework/Headers&#39;
, &#39;-isystem&#39;
, &#39;../llvm/include&#39;
, &#39;-isystem&#39;
, &#39;../llvm/tools/clang/include&#39;
, &#39;-I&#39;
, &#39;.&#39;
, &#39;-I&#39;
, &#39;./ClangCompleter&#39;
, &#39;-isystem&#39;
, &#39;./tests/gmock/gtest&#39;
, &#39;-isystem&#39;
, &#39;./tests/gmock/gtest/include&#39;
, &#39;-isystem&#39;
, &#39;./tests/gmock&#39;
, &#39;-isystem&#39;
, &#39;./tests/gmock/include&#39;
, &#39;-I&#39;
, &#39;/usr/include&#39;
, &#39;-I&#39;
, &#39;/usr/local/include&#39;
, &#39;-I&#39;
, &#39;./solution/app/include&#39;
, &#39;-I&#39;
, &#39;./solution/bsp/include/&#39;
, &#39;-I&#39;
, &#39;./solution/app/log/include&#39;
, &#39;-I&#39;
, &#39;./driver/gxcoreapi/ecos3.0/packages/isoinfra/v3_0/include&#39;
]

# Set this to the absolute path to the folder (NOT the file!) containing the
# compile_commands.json file to use that instead of &#39;flags&#39;. See here for
# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
#
# Most projects will NOT need to set this to anything; you can just change the
# &#39;flags&#39; list of compilation flags. Notice that YCM itself uses that approach.
compilation_database_folder = &#39;&#39;

if compilation_database_folder:
  database = ycm_core.CompilationDatabase( compilation_database_folder )
else:
  database = None


def DirectoryOfThisScript():
  return os.path.dirname( os.path.abspath( __file__ ) )


def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
  if not working_directory:
    return list( flags )
  new_flags = []
  make_next_absolute = False
  path_flags = [ &#39;-isystem&#39;, &#39;-I&#39;, &#39;-iquote&#39;, &#39;--sysroot=&#39; ]
  for flag in flags:
    new_flag = flag

    if make_next_absolute:
      make_next_absolute = False
      if not flag.startswith( &#39;/&#39; ):
        new_flag = os.path.join( working_directory, flag )

    for path_flag in path_flags:
      if flag == path_flag:
        make_next_absolute = True
        break

      if flag.startswith( path_flag ):
        path = flag[ len( path_flag ): ]
        new_flag = path_flag + os.path.join( working_directory, path )
        break

    if new_flag:
      new_flags.append( new_flag )
  return new_flags


def FlagsForFile( filename ):
  if database:
    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
    # python list, but a &quot;list-like&quot; StringVec object
    compilation_info = database.GetCompilationInfoForFile( filename )
    final_flags = MakeRelativePathsInFlagsAbsolute(
      compilation_info.compiler_flags_,
      compilation_info.compiler_working_dir_ )
  else:
    relative_to = DirectoryOfThisScript()
    final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )

  return {
    &#39;flags&#39;: final_flags,
    &#39;do_cache&#39;: True
  }</code></pre>
<hr>
<ol>
<li><a href="http://blog.marchtea.com/archives/161" target="_blank" rel="noopener">Vim自动补全神器–YouCompleteMe</a></li>
<li><a href="http://blog.marchtea.com/archives/175" target="_blank" rel="noopener">YouCompleteMe安装遇到的问题及解决办法</a></li>
<li><a href="http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/" target="_blank" rel="noopener">Vim 自动补全插件 YouCompleteMe 安装与配置</a></li>
<li><a href="https://github.com/robturtle/newycm_extra_conf.py" target="_blank" rel="noopener">newycm_extra_conf.py</a></li>
<li><a href="https://github.com/Valloric/YouCompleteMe#commands" target="_blank" rel="noopener">YouCompleteMe</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>youcompleteme</tag>
      </tags>
  </entry>
  <entry>
    <title>git通过lantern代理访问github</title>
    <url>/2016/07/18/git-with-lantern/</url>
    <content><![CDATA[<p>最近github可以使用ssh方式，https存在问题</p>
<pre><code class="bash">git clone https://github.com/Valloric/YouCompleteMe.git                         
正克隆到 &#39;YouCompleteMe&#39;...
fatal: unable to access &#39;https://github.com/Valloric/YouCompleteMe.git/&#39;: Failed to connect to github.com port 443: 拒绝连接</code></pre>
<p>修改为 <code>SSH</code> 方式可以解决问题 <a href="https://help.github.com/articles/changing-a-remote-s-url/" target="_blank" rel="noopener">Changing a remote’s<br>URL</a></p>
<p>但是vim 插件安装会使用 <code>https</code> ，尝试使用代理来解决问题：</p>
<pre><code class="bash">git config --global http.proxy 192.168.1.1:8083
git config --global http.proxy //查询
git config --global --unset http.proxy //取消</code></pre>
<p>启动lantern并找到PAC文件</p>
<pre><code class="bash">Jul 18 01:02:23.713 - 0m0s DEBUG flashlight: pac.go:155 Serving PAC file at
http://127.0.0.1:16823/proxy_on.pac</code></pre>
<p>打开浏览器输入该url可以得到PAC文件，如下：</p>
<pre><code class="pac">var bypassDomains = [&#39;ss1.baidu.com&#39;, &#39;static.zhihu.com&#39;,
    &#39;camo.githubusercontent.com&#39;, &#39;sugar.zhihu.com&#39;,
    &#39;pagead2.googlesyndication.com&#39;, &#39;ss0.baidu.com&#39;, &#39;link.zhihu.com&#39;,
    &#39;www.isupergeek.com&#39;, &#39;ss2.baidu.com&#39;, &#39;www.cnblogs.com&#39;, &#39;blog.marchtea.com&#39;,
    &#39;secure.gravatar.com&#39;, &#39;ocsp.startssl.com&#39;, &#39;pic2.zhimg.com&#39;,
    &#39;static.cnblogs.com&#39;, &#39;www.baidu.com&#39;, &#39;www.googletagservices.com&#39;,
    &#39;ss3.baidu.com&#39;, &#39;code.jquery.com&#39;, &#39;gn.symcd.com&#39;, &#39;www.zhihu.com&#39;,
    &#39;ssum-sec.casalemedia.com&#39;, &#39;zhstatic.zhihu.com&#39;, &#39;tpc.googlesyndication.com&#39;,
    &#39;sp2.baidu.com&#39;, &#39;ocsp.digicert.com&#39;, &#39;sp0.baidu.com&#39;,
    &#39;zhihu-web-analytics.zhihu.com&#39;, &#39;engine.adzerk.net&#39;, &#39;pic1.zhimg.com&#39;,
    &#39;collector.githubapp.com&#39;, &#39;api.ad.cnblogs.com&#39;, &#39;sync.xmarks.com&#39;,
    &#39;sp1.baidu.com&#39;, &#39;avatars3.githubusercontent.com&#39;, &#39;pic4.zhimg.com&#39;,
    &#39;cloud.xmarks.com&#39;, &#39;pixel.quantserve.com&#39;, &#39;stats.g.doubleclick.net&#39;];
    function FindProxyForURL(url, host) {
        if (isPlainHostName(host) // including localhost
                || shExpMatch(host, &quot;*.local&quot;)) {
            return &quot;DIRECT&quot;;
        }
        // only checks plain IP addresses to avoid leaking domain name
        if (/^[0-9.]+$/.test(host)) {
            if (isInNet(host, &quot;10.0.0.0&quot;, &quot;255.0.0.0&quot;) ||
                isInNet(host, &quot;172.16.0.0&quot;, &quot;255.240.0.0&quot;) ||
                isInNet(host, &quot;192.168.0.0&quot;, &quot;255.255.0.0&quot;) ||
                isInNet(host, &quot;127.0.0.0&quot;, &quot;255.255.255.0&quot;)) {
                return &quot;DIRECT&quot;;
            }
        }
        // Lantern desktop version proxies only http(s) and ws(s)
        if (url.substring(0, 4) != &#39;http&#39; &amp;&amp; (url.substring(0, 2) != &#39;ws&#39;)) {
            return &quot;DIRECT&quot;;
        }
        for (var d in bypassDomains) {
            if (host == bypassDomains[d]) {
                return &quot;DIRECT&quot;;
            }
        }
        return &quot;PROXY 127.0.0.1:8787; DIRECT&quot;;
}</code></pre>
<p>最后一行代理地址 <code>http://127.0.0.1:8787</code><br>获取了代理地址后就可以设置git的代理了，shell脚本如下：</p>
<pre><code class="bash">    git config --global http.proxy 127.0.0.1:8787
    git config --global https.proxy 127.0.0.1:8787</code></pre>
<hr>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
        <tag>lantern</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>vim文本对象</title>
    <url>/2016/07/14/vim-text-object/</url>
    <content><![CDATA[<h2 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h2><p><img src="/images/vim/vim-grammar.png" alt="vim-grammar"></p>
<ul>
<li>aw：一个词</li>
<li>as：一句。</li>
<li>ap：一段。</li>
<li>ab：一块（包含在圆括号中的）。</li>
</ul>
<p>y, d, c, v都可以跟文本对象。</p>
<a id="more"></a>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>所谓文本对象，简单来说就是以一定标准分隔符来标识一段文本，比如一个单词，一句话，一段话。</p>
<p>使用文本对象后你会发现你在vim中的移动和操作速度提升了不是一点半点。</p>
<p>在vim中编辑命令的结构如下：</p>
<pre><code class="bash">&lt;number&gt;&lt;command&gt;&lt;text object or motion&gt;</code></pre>
<p>可以看到文本对象和motion的操作是完全一致的，第一个是数字，比如3w，就向前移动三个单词。</p>
<p>文本对象大致有以下几种：</p>
<pre><code class="bash">w  s  p &#39;&#39; &quot;&quot;  &lt;&gt;  []  ()  {} &lt;tag&gt;</code></pre>
<p>其中w表示word，s表示句子，p表示段落，其他的就是包围符号，标签用t表示。</p>
<p>文本对象的<strong>操作范围</strong>有两种：</p>
<ul>
<li>一种用i表示,是inner的意思，即不包括单词边上的空格符，亦或是&lt;包围符号本身。</li>
<li>一种用a表示，是arround的意思，和i相反，使用a就包括了空格符或者包围符号本身。</li>
</ul>
<p>文本对象的编辑命令就是vim中的几个常用编辑命令，分别是</p>
<pre><code class="bash">`y：复制`，`d：删除`,`c：替换`，`v：选中`</code></pre>
<p>来几个例子相信大家就立刻理解了。（例子中*都是光标所在位置）</p>
<h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>比如：</p>
<pre><code class="bash">&lt;*h2&gt;Sample Title&lt;/h2&gt;</code></pre>
<p>按下cit,文本变为：</p>
<pre><code class="bash">&lt;h2&gt;*&lt;/h2&gt;</code></pre>
<h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>再比如：</p>
<pre><code class="bash">console.log(“stay hungry,” + “stay *foolish”)</code></pre>
<p>按下da”，文本变为：</p>
<pre><code class="bash">console.log(&quot;stay hungry,&quot; +*)</code></pre>
<p>再按下di)，文本变为：</p>
<pre><code class="bash">console.log()</code></pre>
<p>比如</p>
<pre><code class="bash">Hello Worl*d</code></pre>
<h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p>按下diw,文本变为：</p>
<pre><code class="bash">Hello</code></pre>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li>argtextobj</li>
<li>vim-surround</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/" target="_blank" rel="noopener">Vim Text Objects: The Definitive Guide</a></li>
<li><a href="http://vimcdoc.sourceforge.net/doc/index.html#objects" target="_blank" rel="noopener">文本对象</a></li>
<li><a href="http://foocoder.com/2014/04/18/mei-ri-vimcha-jian-kuai-su-xuan-ze-wen-ben-dui-xiang-wildfile-dot-vim/" target="_blank" rel="noopener">快速选择文本对象wildfile.vim</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用技巧汇总</title>
    <url>/2016/07/06/vim-tips/</url>
    <content><![CDATA[<h2 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h2><p><img src="/images/vim/vim-grammar.png" alt="vim-grammar"></p>
<ul>
<li>aw：一个词</li>
<li>as：一句。</li>
<li>ap：一段。</li>
<li>ab：一块（包含在圆括号中的）。</li>
</ul>
<p>y, d, c, v都可以跟文本对象。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ul>
<li>a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。</li>
<li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。<br>如”Ayy把当前行的内容追加到a寄存器中。</li>
<li>:reg 显示所有寄存器的内容。</li>
<li>“”：不加寄存器索引时，默认使用的寄存器。</li>
<li>“：当前选择缓冲区，”yy把当前行的内容放入当前选择缓冲区。</li>
<li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li>
</ul>
<h2 id="Insert-Mode"><a href="#Insert-Mode" class="headerlink" title="Insert Mode"></a>Insert Mode</h2><ul>
<li>ctrl-y，重复当前光标上一行的字符</li>
<li>C-r =，然后输入表达式，就能在 光标处得到计算结果</li>
</ul>
<h2 id="Normal-Mode"><a href="#Normal-Mode" class="headerlink" title="Normal Mode"></a>Normal Mode</h2><ul>
<li>gd，局部变量跳转</li>
<li>gf，文件跳转</li>
<li>ga，查看当前字符ascii码</li>
<li>zz，居中很方便</li>
<li>``, 可以在两个地方来回改</li>
<li>Ctrl+a, 自动把光标下的数字加1</li>
<li>“+p 让你不丢失格式地将内容从系统剪切板粘贴到vim中，* 和 + 这俩全局寄存器</li>
<li>di( 删除()中内容，类似(), {}, [], ‘’, “”</li>
<li>ci( 更改()中内容，类似(), {}, [], ‘’, “”</li>
<li>da( 删除包括()在内的内容，类似(), {}, [], ‘’, “”</li>
<li>ca( 更改包括()在内的内容，类似(), {}, [], ‘’, “”</li>
<li>ctrl + o 跳转到上一位置，像浏览器上的 后退 和 前进</li>
<li>ctrl + i 跳转下一位置（和ctrl + o配合在代码间跳转）</li>
<li>K 查询系统函数（unix、linux），在linux系统函数上用K跳转到man查询页面</li>
<li>cc 替换整行</li>
</ul>
<h2 id="Command-Mode"><a href="#Command-Mode" class="headerlink" title="Command Mode"></a>Command Mode</h2><ul>
<li>:Sex，水平分割一个窗口，浏览文件系统</li>
<li>:Vex, 垂直分割一个窗口，浏览文件系统</li>
<li>:r !pwd 输入当前路径</li>
<li>:%!xxd 转换16进制</li>
<li>:set list 显示不可见字符</li>
</ul>
<hr>
<ol>
<li><a href="http://gold.xitu.io/entry/56ea7eef731956005c1b6d3f" target="_blank" rel="noopener">老司机乱谈编辑器之神——vim</a></li>
<li><a href="http://rayninfo.co.uk/vimtips.html" target="_blank" rel="noopener">Best of Vim Tips</a></li>
<li><a href="http://www.zhihu.com/question/27478597" target="_blank" rel="noopener">Vim 有什么奇技淫巧</a></li>
<li><a href="http://vimgolf.com/" target="_blank" rel="noopener">VimGolf</a></li>
<li><a href="http://ningning.today/2014/11/02/Linux/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" target="_blank" rel="noopener">vim常用命令</a></li>
<li><a href="http://vimcasts.org/blog/2013/01/vim-london-january-in-review/" target="_blank" rel="noopener">Vim London January in review</a></li>
<li><a href="http://whileimautomaton.net/2008/11/vimm3/operator" target="_blank" rel="noopener">operator, the true power of Vim</a></li>
<li><a href="https://media.pragprog.com/titles/dnvim/vim.pdf" target="_blank" rel="noopener">Practical Vim</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>值得推荐的C/C++框架和库</title>
    <url>/2016/06/30/c-open-project/</url>
    <content><![CDATA[<h2 id="值得学习的C语言开源项目"><a href="#值得学习的C语言开源项目" class="headerlink" title="值得学习的C语言开源项目"></a>值得学习的C语言开源项目</h2><h3 id="Libev"><a href="#Libev" class="headerlink" title="Libev"></a><strong>Libev</strong></h3><p>libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。</p>
<p>下载链接：<a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="noopener">http://software.schmorp.de/pkg/libev.html</a></p>
<h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a><strong>Memcached</strong></h3><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。</p>
<p>下载地址：<a href="http://memcached.org/" target="_blank" rel="noopener">http://memcached.org/</a></p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。Redis支持的操作和数据类型比Memcached要多，现在主要用于缓存，支持主从同步机制，Redis的学习可以参考&lt;&lt;Redis设计与实现&gt;&gt;一书。</p>
<p>下载地址：<a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a></p>
<h3 id="Webbench"><a href="#Webbench" class="headerlink" title="Webbench"></a><strong>Webbench</strong></h3><p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。</p>
<p>下载链接：<a href="https://github.com/LippiOuYang/WebBench" target="_blank" rel="noopener">https://github.com/LippiOuYang/WebBenchl</a></p>
<h3 id="APR"><a href="#APR" class="headerlink" title="APR"></a><strong>APR</strong></h3><p>Apache Portable Runtime</p>
<p>这是由 Apache 社区维护的 C 开源库，主要提供操作系统相关的功能（文件系统、进程、线程、用户、IPC）。此外还提供了一些网络相关的功能。</p>
<p>APR 原先是 Apache Web 服务器的一个组成部分，后来独立出来，成为一个单独的开源项目。<br>主页：<a href="https://apr.apache.org/" target="_blank" rel="noopener">https://apr.apache.org</a></p>
<h3 id="Tinyhttpd"><a href="#Tinyhttpd" class="headerlink" title="Tinyhttpd"></a><strong>Tinyhttpd</strong></h3><p>tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。</p>
<p>下载链接：<a href="https://github.com/LippiOuYang/Tinyhttpd" target="_blank" rel="noopener">https://github.com/LippiOuYang/Tinyhttpd</a></p>
<h3 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a><strong>cJSON</strong></h3><p>cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。</p>
<p>cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。</p>
<p>项目主页:<a href="http://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">http://sourceforge.net/projects/cjson/</a></p>
<h3 id="CMockery"><a href="#CMockery" class="headerlink" title="CMockery"></a><strong>CMockery</strong></h3><p>cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。</p>
<p>主要特点：</p>
<ul>
<li>免费且开源，google提供技术支持；</li>
<li>轻量级的框架，使测试更加快速简单；</li>
<li>避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</li>
<li>并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用</li>
</ul>
<p>下载链接：<a href="http://code.google.com/p/cmockery/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/cmockery/downloads/list</a></p>
<h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><p>Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。</p>
<p>让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。</p>
<p>下载地址：<a href="http://www.lua.org/" target="_blank" rel="noopener">http://www.lua.org/</a></p>
<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a><strong>SQLite</strong></h3><p>SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。</p>
<p>下载地址：<a href="http://www.sqlite.org/" target="_blank" rel="noopener">http://www.sqlite.org/</a></p>
<h3 id="UNIX-v6"><a href="#UNIX-v6" class="headerlink" title="UNIX v6"></a><strong>UNIX v6</strong></h3><p>UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？</p>
<p>另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。</p>
<p>下载地址：<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6" target="_blank" rel="noopener">http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6</a></p>
<h3 id="NETBSD"><a href="#NETBSD" class="headerlink" title="NETBSD"></a><strong>NETBSD</strong></h3><p>NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。</p>
<p>下载地址：<a href="http://www.netbsd.org/" target="_blank" rel="noopener">http://www.netbsd.org/</a></p>
<h2 id="C-资源大全"><a href="#C-资源大全" class="headerlink" title="C++ 资源大全"></a>C++ 资源大全</h2><p>关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p>

<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>C++标准库，包括了STL容器，算法和函数等。</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank">C++ Standard Library</a>：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。</li>
<li><a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_blank">Standard Template Library</a>：标准模板库</li>
<li><a href="http://en.wikipedia.org/wiki/C_POSIX_library" target="_blank">C POSIX library</a> ： POSIX系统的C标准库规范</li>
<li><a href="https://github.com/cplusplus" target="_blank">ISO C++ Standards Committee</a> ：C++标准委员会</li>
</ul>

<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>C++通用框架和库</p>
<ul>
<li><a href="http://stdcxx.apache.org/" target="_blank">Apache C++ Standard Library</a>：是一系列算法，容器，迭代器和其他基本组件的集合</li>
<li><a href="http://stlab.adobe.com/" target="_blank">ASL</a> ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li>
<li><a href="https://github.com/boostorg" target="_blank">Boost</a> ：大量通用C++库的集合。</li>
<li><a href="https://github.com/bloomberg/bde" target="_blank">BDE</a> ：来自于彭博资讯实验室的开发环境。</li>
<li><a href="http://libcinder.org/" target="_blank">Cinder</a>：提供专业品质创造性编码的开源开发社区。</li>
<li><a href="http://ryan.gulix.cl/fossil.cgi/cxxomfort/" target="_blank">Cxxomfort</a>：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li>
<li><a href="http://dlib.net/" target="_blank">Dlib</a>：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li>
<li><a href="https://github.com/paulhodge/EASTL" target="_blank">EASTL</a> ：EA-STL公共部分</li>
<li><a href="https://github.com/sumeetchhetri/ffead-cpp" target="_blank">ffead-cpp</a> ：企业应用程序开发框架</li>
<li><a href="https://github.com/facebook/folly" target="_blank">Folly</a>：由Facebook开发和使用的开源C++库</li>
<li><a href="https://github.com/julianstorer/JUCE" target="_blank">JUCE</a> ：包罗万象的C++类库，用于开发跨平台软件</li>
<li><a href="https://github.com/facebook/libphenom" target="_blank">libPhenom</a>：用于构建高性能和高度可扩展性系统的事件框架。</li>
<li><a href="https://github.com/sourcey/libsourcey" target="_blank">LibSourcey</a> ：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li>
<li><a href="https://github.com/koanlogic/libu" target="_blank">LibU</a> ： C语言写的多平台工具库</li>
<li><a href="http://loki-lib.sourceforge.net/" target="_blank">Loki</a> ：C++库的设计，包括常见的设计模式和习语的实现。</li>
<li><a href="https://code.google.com/p/mili/" target="_blank">MiLi</a> ：只含头文件的小型C++库</li>
<li><a href="http://www.openframeworks.cc/" target="_blank">openFrameworks</a> ：开发C++工具包，用于创意性编码。</li>
<li><a href="http://qt-project.org/" target="_blank">Qt</a> ：跨平台的应用程序和用户界面框架</li>
<li><a href="http://code.google.com/p/reason/" target="_blank">Reason</a> ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li>
<li><a href="http://root.cern.ch/" target="_blank">ROOT</a> ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li>
<li><a href="http://www.stlport.org/" target="_blank">STLport</a>：是STL具有代表性的版本</li>
<li><a href="http://stxxl.sourceforge.net/" target="_blank">STXXL</a>：用于额外的大型数据集的标准模板库。</li>
<li><a href="http://www.ultimatepp.org/" target="_blank">Ultimate++</a> ：C++跨平台快速应用程序开发框架</li>
<li><a href="http://sourceforge.net/projects/wtl/" target="_blank">Windows Template Library</a>：用于开发Windows应用程序和UI组件的C++库</li>
<li><a href="https://github.com/jll63/yomm11" target="_blank">Yomm11</a> ：C++11的开放multi-methods.</li>
</ul>

<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><ul>
<li><a href="https://github.com/aigamedev/btsk" target="_blank">btsk</a> ：游戏行为树启动器工具</li>
<li><a href="http://eodev.sourceforge.net/" target="_blank">Evolving Objects</a>：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li>
<li><a href="https://github.com/andrometa/neu" target="_blank">Neu</a>：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li>
</ul>
<p>&nbsp;</p>
<h3>异步事件循环</h3>
<ul>
<li><a href="http://think-async.com/" target="_blank">Boost.Asio</a>：用于网络和底层I/O编程的跨平台的C++库。</li>
<li><a href="http://libev.schmorp.de/" target="_blank">libev</a> ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li>
<li><a href="http://libevent.org/" target="_blank">libevent</a> ：事件通知库</li>
<li><a href="https://github.com/joyent/libuv" target="_blank">libuv</a> ：跨平台异步I/O。</li>
</ul>
<p>&nbsp;</p>

<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>音频，声音，音乐，数字化音乐库</p>
<ul>
<li><a href="http://www.fmod.org/" target="_blank">FMOD</a> ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li>
<li><a href="https://github.com/micknoise/Maximilian" target="_blank">Maximilian</a> ：C++音频和音乐数字信号处理库</li>
<li><a href="http://www.openal.org/" target="_blank">OpenAL</a> ：开源音频库&#8212;跨平台的音频API</li>
<li><a href="http://opus-codec.org/" target="_blank">Opus</a>：一个完全开放的，免版税的，高度通用的音频编解码器</li>
<li><a href="http://www.speex.org/" target="_blank">Speex</a>：免费编解码器，为Opus所废弃</li>
<li><a href="https://github.com/TonicAudio/Tonic" target="_blank">Tonic</a>： C++易用和高效的音频合成</li>
<li><a href="http://xiph.org/vorbis/" target="_blank">Vorbis</a>： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li>
</ul>
<p>&nbsp;</p>
<h3>生态学</h3>
<p>生物信息，基因组学和生物技术</p>
<ul>
<li><a href="http://molpopgen.github.io/libsequence/" target="_blank">libsequence</a>：用于表示和分析群体遗传学数据的C++库。</li>
<li><a href="http://www.seqan.de/" target="_blank">SeqAn</a>：专注于生物数据序列分析的算法和数据结构。</li>
<li><a href="https://github.com/ekg/vcflib" target="_blank">Vcflib</a> ：用于解析和处理VCF文件的C++库</li>
<li><a href="https://github.com/jewmanchue/wham" target="_blank">Wham</a>：直接把联想测试应用到BAM文件的基因结构变异。</li>
</ul>
<p>&nbsp;</p>
<h3>压缩</h3>
<p>压缩和归档库</p>
<ul>
<li><a href="http://www.bzip.org/" target="_blank">bzip2</a>：一个完全免费，免费专利和高质量的数据压缩</li>
<li><a href="https://bitbucket.org/attila_afra/doboz/overview" target="_blank">doboz</a>：能够快速解压缩的压缩库</li>
<li><a href="https://icculus.org/physfs/" target="_blank">PhysicsFS</a>：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li>
<li><a href="https://projects.kde.org/projects/frameworks/karchive" target="_blank">KArchive</a>：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li>
<li><a href="https://code.google.com/p/lz4/" target="_blank">LZ4</a> ：非常快速的压缩算法</li>
<li><a href="https://code.google.com/p/lzham/" target="_blank">LZHAM</a> ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li>
<li><a href="http://www.7-zip.org/sdk.html" target="_blank">LZMA</a> ：7z格式默认和通用的压缩方法。</li>
<li><a href="http://www.matcode.com/lzmat.htm" target="_blank">LZMAT</a> ：及其快速的实时无损数据压缩库</li>
<li><a href="https://code.google.com/p/miniz/" target="_blank">miniz</a>：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li>
<li><a href="https://github.com/nmoinvaz/minizip" target="_blank">Minizip</a>：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li>
<li><a href="https://code.google.com/p/snappy/" target="_blank">Snappy</a> ：快速压缩和解压缩</li>
<li><a href="http://zlib.net/" target="_blank">ZLib</a> ：非常紧凑的数据流压缩库</li>
<li><a href="http://zziplib.sourceforge.net/" target="_blank">ZZIPlib</a>：提供ZIP归档的读权限。</li>
</ul>
<p>&nbsp;</p>
<h3>并发性</h3>
<p>并发执行和多线程</p>
<ul>
<li><a href="https://github.com/kylelutz/compute" target="_blank">Boost.Compute</a> ：用于OpenCL的C++GPU计算库</li>
<li><a href="https://github.com/HSA-Libraries/Bolt" target="_blank">Bolt</a> ：针对GPU进行优化的C++模板库</li>
<li><a href="https://github.com/schlangster/cpp.react" target="_blank">C++React</a> ：用于C++11的反应性编程库</li>
<li><a href="https://www.threadingbuildingblocks.org/" target="_blank">Intel TBB</a> ：Intel线程构件块</li>
<li><a href="https://github.com/libclsph/libclsph" target="_blank">Libclsph</a>：基于OpenCL的GPU加速SPH流体仿真库</li>
<li><a href="https://www.khronos.org/opencl/" target="_blank">OpenCL</a> ：并行编程的异构系统的开放标准</li>
<li><a href="http://openmp.org/" target="_blank">OpenMP</a>：OpenMP API</li>
<li><a href="http://thrust.github.io/" target="_blank">Thrust</a> ：类似于C++标准模板库的并行算法库</li>
<li><a href="https://github.com/STEllAR-GROUP/hpx/" target="_blank">HPX</a> ：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li>
<li><a href="https://github.com/ddemidov/vexcl" target="_blank">VexCL</a> ：用于OpenCL/CUDA 的C++向量表达式模板库。</li>
</ul>
<p>&nbsp;</p>
<h3>容器</h3>
<ul>
<li><a href="https://code.google.com/p/cpp-btree/" target="_blank">C++ B-tree</a> ：基于B树数据结构，实现命令内存容器的模板库</li>
<li><a href="https://github.com/goossaert/hashmap" target="_blank">Hashmaps</a>： C++中开放寻址哈希表算法的实现</li>
</ul>
<p>&nbsp;</p>
<h3>密码学</h3>
<ul>
<li><a href="http://bcrypt.sourceforge.net/" target="_blank">Bcrypt</a> ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li>
<li><a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank">BeeCrypt</a>：</li>
<li><a href="http://botan.randombit.net/" target="_blank">Botan</a>： C++加密库</li>
<li><a href="http://www.cryptopp.com/" target="_blank">Crypto++</a>：一个有关加密方案的免费的C++库</li>
<li><a href="https://www.gnupg.org/" target="_blank">GnuPG</a>： OpenPGP标准的完整实现</li>
<li><a href="http://www.gnutls.org/" target="_blank">GnuTLS</a> ：实现了SSL，TLS和DTLS协议的安全通信库</li>
<li><a href="http://www.gnu.org/software/libgcrypt/" target="_blank">Libgcrypt</a></li>
<li><a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank">libmcrypt</a></li>
<li><a href="http://www.libressl.org/" target="_blank">LibreSSL</a>：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支</li>
<li><a href="https://github.com/libtom/libtomcrypt" target="_blank">LibTomCrypt</a>：一个非常全面的，模块化的，可移植的加密工具</li>
<li><a href="https://github.com/jedisct1/libsodium" target="_blank">libsodium</a>：基于NaCI的加密库，固执己见，容易使用</li>
<li><a href="http://www.lysator.liu.se/~nisse/nettle/" target="_blank">Nettle</a> 底层的加密库</li>
<li><a href="http://www.openssl.org/" target="_blank">OpenSSL</a> ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。</li>
<li><a href="https://github.com/kokke/tiny-AES128-C" target="_blank">Tiny AES128 in C</a> ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li>
</ul>
<p>&nbsp;</p>

<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库，SQL服务器，ODBC驱动程序和工具</p>
<ul>
<li><a href="https://github.com/paulftw/hiberlite" target="_blank">hiberlite</a> ：用于Sqlite3的C++对象关系映射</li>
<li><a href="https://github.com/redis/hiredis" target="_blank">Hiredis</a>： 用于Redis数据库的很简单的C客户端库</li>
<li><a href="https://github.com/google/leveldb" target="_blank">LevelDB</a>： 快速键值存储库</li>
<li><a href="http://symas.com/mdb/" target="_blank">LMDB</a>：符合数据库四大基本元素的嵌入键值存储</li>
<li><a href="http://www.tangentsoft.net/mysql++/" target="_blank">MySQL++</a>：封装了MySql的C API的C++ 包装器</li>
<li><a href="https://github.com/facebook/rocksdb" target="_blank">RocksDB</a>：来自Facebook的嵌入键值的快速存储</li>
<li><a href="http://www.sqlite.org/" target="_blank">SQLite</a>：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</li>
</ul>
<p>&nbsp;</p>

<h3>调试</h3>

<p>调试库， 内存和资源泄露检测，单元测试</p>
<ul>
<li><a href="http://www.boost.org/doc/libs/master/libs/test/doc/html/index.html" target="_blank">Boost.Test</a>：Boost测试库</li>
<li><a href="https://github.com/philsquared/Catch" target="_blank">Catch</a>：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</li>
<li><a href="http://www.freedesktop.org/wiki/Software/cppunit/" target="_blank">CppUnit</a>：由JUnit移植过来的C++测试框架</li>
<li><a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" target="_blank">CTest</a>：CMake测试驱动程序</li>
<li><a href="http://code.google.com/p/googletest/" target="_blank">googletest</a>：谷歌C++测试框架</li>
<li><a href="https://github.com/deplinenoise/ig-debugheap" target="_blank">ig-debugheap</a>：用于跟踪内存错误的多平台调试堆</li>
<li><a href="https://github.com/zorgnax/libtap" target="_blank">libtap</a>：用C语言编写测试</li>
<li><a href="http://www.almostinfinite.com/memtrack.html" target="_blank">MemTrack</a> —用于C++跟踪内存分配</li>
<li><a href="https://bitbucket.org/jonasmeyer/microprofile/overview" target="_blank">microprofile</a>- 跨平台的网络试图分析器</li>
<li><a href="http://www.jera.com/techinfo/jtns/jtn002.html" target="_blank">minUnit</a> ：使用C写的迷你单元测试框架，只使用了两个宏</li>
<li><a href="https://github.com/Celtoys/Remotery" target="_blank">Remotery</a>：用于web视图的单一C文件分析器</li>
<li><a href="http://unittest-cpp.sourceforge.net/" target="_blank">UnitTest++</a>：轻量级的C++单元测试框架</li>
</ul>
<p>&nbsp;</p>
<h3>游戏引擎</h3>
<ul>
<li><a href="http://www.cocos2d-x.org/" target="_blank">Cocos2d-x</a> ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li>
<li><a href="http://gritengine.com/" target="_blank">Grit</a> ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li>
<li><a href="http://irrlicht.sourceforge.net/" target="_blank">Irrlicht</a> ：C++语言编写的开源高性能的实时#D引擎</li>
<li><a href="http://polycode.org/" target="_blank">Polycode</a>：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li>
</ul>
<p>&nbsp;</p>

<h3>图形用户界面</h3>

<ul>
<li><a href="http://cegui.org.uk/" target="_blank">CEGUI</a> ： 很灵活的跨平台GUI库</li>
<li><a href="http://www.fltk.org/index.php" target="_blank">FLTK</a> ：快速，轻量级的跨平台的C++GUI工具包。</li>
<li><a href="http://www.gtk.org/" target="_blank">GTK+</a>： 用于创建图形用户界面的跨平台工具包</li>
<li><a href="http://www.gtkmm.org/en/" target="_blank">gtkmm</a> ：用于受欢迎的GUI库GTK+的官方C++接口。</li>
<li><a href="https://github.com/ocornut/imgui" target="_blank">imgui</a>：拥有最小依赖关系的立即模式图形用户界面</li>
<li><a href="http://librocket.com/" target="_blank">libRocket</a> ：<a href="http://librocket.com/" target="_blank">libRocket</a> 是一个C++ HTML/CSS 游戏接口中间件</li>
<li><a href="http://mygui.info/" target="_blank">MyGUI</a> ：快速，灵活，简单的GUI</li>
<li><a href="http://invisible-island.net/ncurses/" target="_blank">Ncurses</a>：终端用户界面</li>
<li><a href="http://qcustomplot.com/" target="_blank">QCustomPlot</a> ：没有更多依赖关系的Qt绘图控件</li>
<li><a href="http://qwt.sourceforge.net/" target="_blank">Qwt</a> ：用户与技术应用的Qt 控件</li>
<li><a href="http://qwtplot3d.sourceforge.net/" target="_blank">QwtPlot3D</a> ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</li>
<li><a href="https://github.com/Twolewis/OtterUI" target="_blank">OtterUI</a> ：<a href="https://github.com/Twolewis/OtterUI" target="_blank">OtterUI</a> 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li>
<li><a href="http://pdcurses.sourceforge.net/" target="_blank">PDCurses</a> 包含源代码和预编译库的公共图形函数库</li>
<li><a href="http://wxwidgets.org/" target="_blank">wxWidgets</a> C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li>
</ul>
<p>&nbsp;</p>
<h3>图形</h3>
<ul>
<li><a href="https://github.com/bkaradzic/bgfx" target="_blank">bgfx</a>：跨平台的渲染库</li>
<li><a href="http://www.cairographics.org/" target="_blank">Cairo</a>：支持多种输出设备的2D图形库</li>
<li><a href="https://github.com/horde3d/Horde3D" target="_blank">Horde3D</a> 一个小型的3D渲染和动画引擎</li>
<li><a href="https://github.com/mosra/magnum" target="_blank">magnum</a> C++11和OpenGL 2D/3D 图形引擎</li>
<li><a href="http://www.ogre3d.org/" target="_blank">Ogre 3D</a> 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li>
<li><a href="http://www.openscenegraph.org/" target="_blank">OpenSceneGraph</a> 具有高性能的开源3D图形工具包</li>
<li><a href="http://www.panda3d.org/" target="_blank">Panda3D</a> 用于3D渲染和游戏开发的框架，用Python和C++编写。</li>
<li><a href="https://github.com/google/skia" target="_blank">Skia</a> 用于绘制文字，图形和图像的完整的2D图形库</li>
<li><a href="https://github.com/urho3d/Urho3D" target="_blank">urho3d</a> 跨平台的渲染和游戏引擎。</li>
</ul>
<p>&nbsp;</p>

<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><ul>
<li><a href="http://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html" target="_blank">Boost.GIL</a>：通用图像库</li>
<li><a href="http://cimg.sourceforge.net/" target="_blank">CImg</a> ：用于图像处理的小型开源C++工具包</li>
<li><a href="http://www.xdp.it/cximage.htm" target="_blank">CxImage</a> ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li>
<li><a href="http://freeimage.sourceforge.net/" target="_blank">FreeImage</a> ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li>
<li><a href="http://gdcm.sourceforge.net/wiki/index.php/Main_Page" target="_blank">GDCM</a>：Grassroots DICOM 库</li>
<li><a href="http://www.itk.org/" target="_blank">ITK</a>：跨平台的开源图像分析系统</li>
<li><a href="http://www.imagemagick.org/script/api.php" target="_blank">Magick++</a>：ImageMagick程序的C++接口</li>
<li><a href="http://www.imagemagick.org/script/api.php" target="_blank">MagickWnd</a>：ImageMagick程序的C++接口</li>
<li><a href="http://opencv.org/" target="_blank">OpenCV</a> ： 开源计算机视觉类库</li>
<li><a href="https://code.google.com/p/tesseract-ocr/" target="_blank">tesseract-ocr</a>：OCR引擎</li>
<li><a href="https://github.com/ukoethe/vigra" target="_blank">VIGRA</a> ：用于图像分析通用C++计算机视觉库</li>
<li><a href="http://www.vtk.org/" target="_blank">VTK</a> ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li>
</ul>
<p>&nbsp;</p>

<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><ul>
<li><a href="http://www.gnu.org/software/gettext/" target="_blank">gettext</a> ：GNU `gettext&#8217;</li>
<li><a href="http://site.icu-project.org/" target="_blank">IBM ICU</a>：提供Unicode 和全球化支持的C、C++ 和Java库</li>
<li><a href="http://www.gnu.org/software/libiconv/" target="_blank">libiconv</a> ：用于不同字符编码之间的编码转换库</li>
</ul>
<p>&nbsp;</p>
<h3>Jason</h3>
<ul>
<li><a href="https://github.com/cesanta/frozen" target="_blank">frozen</a> ： C/C++的Jason解析生成器</li>
<li><a href="https://github.com/akheron/jansson" target="_blank">Jansson</a> ：进行编解码和处理Jason数据的C语言库</li>
<li><a href="https://github.com/chrismanning/jbson" target="_blank">jbson</a> ：C++14中构建和迭代BSON data,和Json 文档的库</li>
<li><a href="https://github.com/jeaye/jeayeson" target="_blank">JeayeSON</a>：非常健全的C++ JSON库，只包含头文件</li>
<li><a href="https://github.com/hjiang/jsonxx" target="_blank">JSON++</a> ： C++ JSON 解析器</li>
<li><a href="https://github.com/udp/json-parser" target="_blank">json-parser</a>：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li>
<li><a href="https://github.com/dropbox/json11" target="_blank">json11</a> ：一个迷你的C++11 JSON库</li>
<li><a href="https://github.com/amir-s/jute" target="_blank">jute</a> ：非常简单的C++ JSON解析器</li>
<li><a href="https://github.com/vincenthz/libjson" target="_blank">ibjson</a>：C语言中的JSON解析和打印库，很容易和任何模型集成。</li>
<li><a href="http://sourceforge.net/projects/libjson/" target="_blank">libjson</a>：轻量级的JSON库</li>
<li><a href="https://github.com/kazuho/picojson" target="_blank">PicoJSON</a>：C++中JSON解析序列化，只包含头文件</li>
<li><a href="https://github.com/gaudecker/qt-json" target="_blank">qt-json</a> ：用于JSON数据和 QVariant层次间的相互解析的简单类</li>
<li><a href="https://github.com/flavio/qjson" target="_blank">QJson</a>：将JSON数据映射到QVariant对象的基于Qt的库</li>
<li><a href="https://github.com/miloyip/rapidjson" target="_blank">RapidJSON</a>： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li>
<li><a href="https://github.com/lloyd/yajl" target="_blank">YAJL</a> ：C语言中快速流JSON解析库</li>
</ul>
<p>&nbsp;</p>

<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li><a href="http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html" target="_blank">Boost.Log</a> ：设计非常模块化，并且具有扩展性</li>
<li><a href="https://github.com/easylogging/easyloggingpp" target="_blank">easyloggingpp</a>：C++日志库，只包含单一的头文件。</li>
<li><a href="http://log4cpp.sourceforge.net/" target="_blank">Log4cpp</a> ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li>
<li><a href="http://www.templog.org/" target="_blank">templog</a>：轻量级C++库，可以添加日志到你的C++应用程序中</li>
</ul>
<p>&nbsp;</p>

<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li><a href="https://github.com/BVLC/caffe" target="_blank">Caffe</a> ：快速的神经网络框架</li>
<li><a href="https://github.com/liuliu/ccv" target="_blank">CCV</a> ：以C语言为核心的现代计算机视觉库</li>
<li><a href="http://www.mlpack.org/" target="_blank">mlpack</a> ：可扩展的C++机器学习库</li>
<li><a href="https://github.com/Itseez/opencv" target="_blank">OpenCV</a>：开源计算机视觉库</li>
<li><a href="https://github.com/GHamrouni/Recommender" target="_blank">Recommender</a>：使用协同过滤进行产品推荐/建议的C语言库。</li>
<li><a href="https://github.com/shogun-toolbox/shogun" target="_blank">SHOGUN</a>：Shogun 机器学习工具</li>
<li><a href="https://code.google.com/p/sofia-ml/" target="_blank">sofia-ml</a> ：用于机器学习的快速增量算法套件</li>
</ul>
<p>&nbsp;</p>
<h3>数学</h3>
<ul>
<li><a href="http://arma.sourceforge.net/" target="_blank">Armadillo</a> ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li>
<li><a href="https://code.google.com/p/blaze-lib/" target="_blank">blaze</a>：高性能的C++数学库，用于密集和稀疏算法。</li>
<li><a href="http://ceres-solver.org/" target="_blank">ceres-solver</a> ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li>
<li><a href="http://www.cgal.org/" target="_blank">CGal</a>： 高效，可靠的集合算法集合</li>
<li><a href="http://cmldev.net/" target="_blank">cml</a> ：用于游戏和图形的免费C++数学库</li>
<li><a href="http://eigen.tuxfamily.org/" target="_blank">Eigen</a> ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</li>
<li><a href="http://ggt.sourceforge.net/" target="_blank">GMTL</a>：数学图形模板库是一组广泛实现基本图形的工具。</li>
<li><a href="https://gmplib.org/" target="_blank">GMP</a>：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</li>
</ul>
<p>&nbsp;</p>

<h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><ul>
<li><a href="http://gstreamer.freedesktop.org/" target="_blank">GStreamer</a> ：构建媒体处理组件图形的库</li>
<li><a href="http://www.live555.com/liveMedia/" target="_blank">LIVE555 Streaming Media</a> ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库</li>
<li><a href="https://wiki.videolan.org/LibVLC" target="_blank">libVLC</a> ：libVLC (VLC SDK)媒体框架</li>
<li><a href="https://github.com/wang-bin/QtAV" target="_blank">QtAv</a>：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li>
<li><a href="http://www.libsdl.org/" target="_blank">SDL</a> ：简单直控媒体层</li>
<li><a href="http://www.sfml-dev.org/" target="_blank">SFML</a> ：快速，简单的多媒体库</li>
</ul>
<p>&nbsp;</p>

<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li><a href="http://www.cs.wustl.edu/~schmidt/ACE.html" target="_blank">ACE</a>：C++面向对象网络变成工具包</li>
<li><a href="http://think-async.com/" target="_blank">Boost.Asio</a>：用于网络和底层I/O编程的跨平台的C++库</li>
<li><a href="http://casablanca.codeplex.com/" target="_blank">Casablanca</a>：C++ REST SDK</li>
<li><a href="http://cpp-netlib.org/" target="_blank">cpp-netlib</a>：高级网络编程的开源库集合</li>
<li><a href="https://github.com/rxi/dyad" target="_blank">Dyad.c</a>：C语言的异步网络</li>
<li><a href="http://curl.haxx.se/libcurl/" target="_blank">libcurl</a> :多协议文件传输库</li>
<li><a href="https://github.com/cesanta/mongoose" target="_blank">Mongoose</a><span style="text-decoration: underline;">：</span>非常轻量级的网络服务器</li>
<li><a href="https://github.com/chenshuo/muduo" target="_blank">Muduo</a> ：用于Linux多线程服务器的C++非阻塞网络库</li>
<li><a href="https://github.com/cesanta/net_skeleton" target="_blank">net_skeleton</a> ：C/C++的TCP 客户端/服务器库</li>
<li><a href="https://github.com/riolet/nope.c" target="_blank">nope.c</a> ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js</li>
<li><a href="https://github.com/davidmoreno/onion" target="_blank">Onion</a> :C语言HTTP服务器库，其设计为轻量级，易使用。</li>
<li><a href="https://github.com/pocoproject" target="_blank">POCO</a>：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li>
<li><a href="https://github.com/OculusVR/RakNet" target="_blank">RakNet</a>：为游戏开发人员提供的跨平台的开源C++网络引擎。</li>
<li><a href="https://github.com/vinipsmaker/tufao" target="_blank">Tuf o</a> ：用于Qt之上的C++构建的异步Web框架。</li>
<li><a href="https://github.com/zaphoyd/websocketpp" target="_blank">WebSocket++</a> ：基于C++/Boost Aiso的websocket 客户端/服务器库</li>
<li><a href="http://zeromq.org/" target="_blank">ZeroMQ</a> ：高速，模块化的异步通信库</li>
</ul>
<p>&nbsp;</p>
<h3>物理学</h3>
<p>动力学仿真引擎</p>
<ul>
<li><a href="https://code.google.com/p/box2d/" target="_blank">Box2D</a>：2D的游戏物理引擎。</li>
<li><a href="https://github.com/bulletphysics/bullet3" target="_blank">Bullet</a> ：3D的游戏物理引擎。</li>
<li><a href="https://github.com/slembcke/Chipmunk2D" target="_blank">Chipmunk</a> ：快速，轻量级的2D游戏物理库</li>
<li><a href="https://github.com/google/liquidfun" target="_blank">LiquidFun</a>：2D的游戏物理引擎</li>
<li><a href="http://www.ode.org/" target="_blank">ODE</a> ：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li>
<li><a href="https://github.com/vanderlin/ofxBox2d" target="_blank">ofxBox2d</a>：Box2D开源框架包装器。</li>
<li><a href="https://github.com/simbody/simbody" target="_blank">Simbody</a> ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li>
</ul>
<p>&nbsp;</p>
<h3>机器人学</h3>
<ul>
<li><a href="http://moos-ivp.org/" target="_blank">MOOS-IvP</a> ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li>
<li><a href="http://www.mrpt.org/" target="_blank">MRPT</a>：移动机器人编程工具包</li>
<li><a href="https://github.com/PointCloudLibrary/pcl" target="_blank">PCL</a> ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</li>
<li><a href="http://www.roboticslibrary.org/" target="_blank">Robotics Library (RL)</a>： 一个独立的C++库，包括机器人动力学，运动规划和控制。</li>
<li><a href="http://www.robwork.dk/jrobwork/" target="_blank">RobWork</a>：一组C++库的集合，用于机器人系统的仿真和控制。</li>
<li><a href="http://wiki.ros.org/" target="_blank">ROS</a> ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li>
</ul>
<p>&nbsp;</p>
<h3>科学计算</h3>
<ul>
<li><a href="http://www.fftw.org/" target="_blank">FFTW</a> :用一维或者多维计算DFT的C语言库。</li>
<li><a href="http://www.gnu.org/software/gsl/" target="_blank">GSL</a>：GNU科学库。</li>
</ul>
<p>&nbsp;</p>

<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul>
<li><a href="https://github.com/ChaiScript/ChaiScript/" target="_blank">ChaiScript</a> ：用于C++的易于使用的嵌入式脚本语言。</li>
<li><a href="http://www.lua.org/" target="_blank">Lua</a> ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。</li>
<li><a href="https://github.com/dafrito/luacxx" target="_blank">luacxx</a>：用于创建Lua绑定的C++ 11 API</li>
<li><a href="http://www.swig.org/" target="_blank">SWIG</a> ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器</li>
<li><a href="https://github.com/cesanta/v7" target="_blank">V7</a>：嵌入式的JavaScript 引擎。</li>
<li><a href="http://code.google.com/p/v8/" target="_blank">V8</a> ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</li>
</ul>
<p>&nbsp;</p>
<h3>序列化</h3>
<ul>
<li><a href="http://kentonv.github.io/capnproto/" target="_blank">Cap&#8217;n Proto</a> ：快速数据交换格式和RPC系统。</li>
<li><a href="https://github.com/USCiLab/cereal" target="_blank">cereal</a> ：C++11 序列化库</li>
<li><a href="https://github.com/google/flatbuffers" target="_blank">FlatBuffers</a> ：内存高效的序列化库</li>
<li><a href="https://github.com/msgpack/msgpack-c" target="_blank">MessagePack</a> ：C/C++的高效二进制序列化库，例如 JSON</li>
<li><a href="http://code.google.com/p/protobuf/" target="_blank">protobuf</a> ：协议缓冲，谷歌的数据交换格式。</li>
<li><a href="https://github.com/protobuf-c/protobuf-c" target="_blank">protobuf-c</a> ：C语言的协议缓冲实现</li>
<li><a href="https://github.com/real-logic/simple-binary-encoding" target="_blank">SimpleBinaryEncoding</a>：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li>
<li><a href="https://thrift.apache.org/" target="_blank">Thrift</a> ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</li>
</ul>
<p>&nbsp;</p>

<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li><a href="http://www.webmproject.org/code/" target="_blank">libvpx</a> ：VP8/VP9编码解码SDK</li>
<li><a href="https://www.ffmpeg.org/" target="_blank">FFmpeg</a> ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li>
<li><a href="https://github.com/strukturag/libde265" target="_blank">libde265</a> ：开放的h.265视频编解码器的实现。</li>
<li><a href="https://github.com/cisco/openh264" target="_blank">OpenH264</a>：开源H.364 编解码器。</li>
<li><a href="http://www.theora.org/" target="_blank">Theora</a> ：免费开源的视频压缩格式。</li>
</ul>
<p>&nbsp;</p>
<h3>虚拟机</h3>
<ul>
<li><a href="https://github.com/tekknolagi/carp" target="_blank">CarpVM</a>：C中有趣的VM，让我们一起来看看这个。</li>
<li><a href="https://github.com/micropython/micropython" target="_blank">MicroPython</a> ：旨在实现单片机上Python3.x的实现</li>
<li><a href="https://github.com/jakogut/tinyvm" target="_blank">TinyVM</a>：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li>
</ul>
<p>&nbsp;</p>
<h3>Web应用框架</h3>
<ul>
<li><a href="https://github.com/bel2125/civetweb" target="_blank">Civetweb</a> ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li>
<li><a href="http://cppcms.com/" target="_blank">CppCMS</a> ：免费高性能的Web开发框架（不是 CMS）.</li>
<li><a href="https://github.com/ipkn/crow" target="_blank">Crow</a> ：一个C++微型web框架（灵感来自于Python Flask）</li>
<li><a href="https://kore.io/" target="_blank">Kore</a> :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</li>
<li><a href="http://www.coralbits.com/libonion/" target="_blank">libOnion</a>：轻量级的库，帮助你使用C编程语言创建web服务器。</li>
<li><a href="https://github.com/jlaine/qdjango/" target="_blank">QDjango</a>：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。</li>
<li><a href="http://www.webtoolkit.eu/wt" target="_blank">Wt</a> ：开发Web应用的C++库。</li>
</ul>
<p>&nbsp;</p>
<h3>XML</h3>
<p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p>
<ul>
<li><a href="http://www.libexpat.org/" target="_blank">Expat</a> ：用C语言编写的xml解析库</li>
<li><a href="http://xmlsoft.org/" target="_blank">Libxml2</a> ：Gnome的xml C解析器和工具包</li>
<li><a href="http://libxmlplusplus.sourceforge.net/" target="_blank">libxml++</a> ：C++的xml解析器</li>
<li><a href="http://pugixml.org/" target="_blank">PugiXML</a> ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li>
<li><a href="http://rapidxml.sourceforge.net/" target="_blank">RapidXml</a> ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li>
<li><a href="http://sourceforge.net/projects/tinyxml/" target="_blank">TinyXML</a> ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li>
<li><a href="https://github.com/leethomason/tinyxml2" target="_blank">TinyXML2</a>：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li>
<li><a href="https://code.google.com/p/ticpp/" target="_blank">TinyXML++</a>：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li>
<li><a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces-C++</a> ：用可移植的C++的子集编写的XML验证解析器。</li>
</ul>
<p>&nbsp;</p>
<h3>多项混杂</h3>
<p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p>
<ul>
<li><a href="https://github.com/cppformat/cppformat" target="_blank">C++ Format</a> ：C++的小型，安全和快速格式化库</li>
<li><a href="https://code.google.com/p/casacore/" target="_blank">casacore</a> ：从aips++ 派生的一系列C++核心库</li>
<li><a href="https://github.com/louisdx/cxx-prettyprint" target="_blank">cxx-prettyprint</a>：用于C++容器的打印库</li>
<li><a href="http://www.dynaforms.com/" target="_blank">DynaPDF</a> ：易于使用的PDF生成库</li>
<li><a href="https://github.com/leafsr/gcc-poison" target="_blank">gcc-poison</a> ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</li>
<li><a href="http://code.google.com/p/googlemock/" target="_blank">googlemock</a>：编写和使用C++模拟类的库</li>
<li><a href="https://github.com/joyent/http-parser" target="_blank">HTTP Parser</a> ：C的http请求/响应解析器</li>
<li><a href="https://github.com/anrieff/libcpuid" target="_blank">libcpuid</a> ：用于x86 CPU检测盒特征提取的小型C库</li>
<li><a href="https://github.com/avati/libevil" target="_blank">libevil</a> ：许可证管理器</li>
<li><a href="http://www.libusb.org/" target="_blank">libusb</a>：允许移动访问USB设备的通用USB库</li>
<li><a href="http://pcre.org/" target="_blank">PCRE</a>：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li>
<li><a href="http://www.deltavsoft.com/" target="_blank">Remote Call Framework</a> ：C++的进程间通信框架。</li>
<li><a href="http://scintilla.org/" target="_blank">Scintilla</a> ：开源的代码编辑控件</li>
<li><a href="https://github.com/wjwwood/serial" target="_blank">Serial Communication Library</a> ：C++语言编写的跨平台，串口库。</li>
<li><a href="https://github.com/antirez/sds" target="_blank">SDS</a>：C的简单动态字符串库</li>
<li><a href="https://github.com/cesanta/sldr" target="_blank">SLDR</a> ：超轻的DNS解析器</li>
<li><a href="https://github.com/cesanta/slre" target="_blank">SLRE</a>： 超轻的正则表达式库</li>
<li><a href="https://github.com/rtv/Stage" target="_blank">Stage</a> ：移动机器人模拟器</li>
<li><a href="https://code.google.com/p/vartypes/" target="_blank">VarTypes</a>：C++/Qt4功能丰富，面向对象的管理变量的框架。</li>
<li><a href="http://zbar.sourceforge.net/" target="_blank">ZBar</a>：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li>
<li><a href="https://github.com/VerbalExpressions/CppVerbalExpressions" target="_blank">CppVerbalExpressions</a> ：易于使用的C++正则表达式</li>
<li><a href="https://github.com/VerbalExpressions/QtVerbalExpressions" target="_blank">QtVerbalExpressions</a>：基于C++ VerbalExpressions 库的Qt库</li>
<li><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP" target="_blank">PHP-CPP</a>：使用C++来构建PHP扩展的库</li>
<li><a href="http://bstring.sourceforge.net/" target="_blank">Better String</a> ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li>
</ul>
<p>&nbsp;</p>
<h3>软件</h3>
<p>用于创建开发环境的软件</p>
<h3>编译器</h3>
<p>C/C++编译器列表</p>
<ul>
<li><a href="http://clang.llvm.org/" target="_blank">Clang</a> :由苹果公司开发的</li>
<li><a href="https://gcc.gnu.org/" target="_blank">GCC</a>：GNU编译器集合</li>
<li><a href="https://software.intel.com/en-us/c-compilers" target="_blank">Intel C++ Compiler</a> ：由英特尔公司开发</li>
<li><a href="http://llvm.org/" target="_blank">LLVM</a> ：模块化和可重用编译器和工具链技术的集合</li>
<li><a href="http://msdn.microsoft.com/en-us/vstudio/hh386302.aspx" target="_blank">Microsoft Visual C++</a> ：MSVC，由微软公司开发</li>
<li><a href="http://www.openwatcom.org/index.php/Main_Page" target="_blank">Open WatCom</a> ：Watcom，C，C++和Fortran交叉编译器和工具</li>
<li><a href="http://bellard.org/tcc/" target="_blank">TCC</a> ：轻量级的C语言编译器</li>
</ul>
<p>&nbsp;</p>
<h3>在线编译器</h3>
<p>在线C/C++编译器列表</p>
<ul>
<li><a href="http://codepad.org/" target="_blank">codepad</a> ：在线编译器/解释器，一个简单的协作工具</li>
<li><a href="http://codetwist.com/" target="_blank">CodeTwist</a>：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li>
<li><a href="http://coliru.stacked-crooked.com/" target="_blank">coliru</a> ：在线编译器/shell， 支持各种C++编译器</li>
<li><a href="http://gcc.godbolt.org/" target="_blank">Compiler Explorer</a>：交互式编译器，可以进行汇编输出</li>
<li><a href="http://www.compileonline.com/compile_cpp11_online.php" target="_blank">CompileOnline</a>：Linux上在线编译和执行C++程序</li>
<li><a href="http://ideone.com/" target="_blank">Ideone</a> ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li>
</ul>
<p>&nbsp;</p>
<h3>调试器</h3>
<p>C/C++调试器列表</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Comparison_of_debuggers" target="_blank">Comparison of debuggers</a> ：来自维基百科的调试器列表</li>
<li><a href="https://www.gnu.org/software/gdb" target="_blank">GDB</a> ：GNU调试器</li>
<li><a href="http://valgrind.org/" target="_blank">Valgrind</a>：内存调试，内存泄露检测，性能分析工具。</li>
</ul>
<p>&nbsp;</p>
<h3>集成开发环境（IDE）</h3>
<p>C/C++集成开发环境列表</p>
<ul>
<li><a href="http://www.jetbrains.com/objc/" target="_blank">AppCode</a> ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li>
<li><a href="http://www.jetbrains.com/clion/" target="_blank">CLion</a>：来自JetBrains的跨平台的C/C++的集成开发环境</li>
<li><a href="http://www.codeblocks.org/" target="_blank">Code::Blocks</a> ：免费C，C++和Fortran的集成开发环境</li>
<li><a href="http://codelite.org/" target="_blank">CodeLite</a> ：另一个跨平台的免费的C/C++集成开发环境</li>
<li><a href="http://sourceforge.net/projects/orwelldevcpp/" target="_blank">Dev-C++</a>：可移植的C/C++/C++11集成开发环境</li>
<li><a href="http://www.eclipse.org/cdt/" target="_blank">Eclipse CDT</a>：基于Eclipse平台的功能齐全的C和C++集成开发环境</li>
<li><a href="http://www.geany.org/" target="_blank">Geany</a> ：轻量级的快速，跨平台的集成开发环境。</li>
<li><a href="http://www-03.ibm.com/software/products/en/visgen" target="_blank">IBM VisualAge</a> ：来自IBM的家庭计算机集成开发环境。</li>
<li><a href="https://github.com/Sarcasm/irony-mode" target="_blank">Irony-mode</a>：由libclang驱动的用于Emacs的C/C++微模式</li>
<li><a href="https://www.kdevelop.org/" target="_blank">KDevelop</a>：免费开源集成开发环境</li>
<li><a href="http://www.visualstudio.com/" target="_blank">Microsoft Visual Studio</a> ：来自微软的集成开发环境</li>
<li><a href="https://netbeans.org/" target="_blank">NetBeans</a> ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li>
<li><a href="http://qt-project.org/" target="_blank">Qt Creator</a>：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li>
<li><a href="https://github.com/Andersbakken/rtags" target="_blank">rtags</a>：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li>
<li><a href="https://developer.apple.com/xcode/" target="_blank">Xcode</a> ：由苹果公司开发</li>
<li><a href="https://valloric.github.io/YouCompleteMe/" target="_blank">YouCompleteMe</a>：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li>
</ul>
<p>&nbsp;</p>
<h3>构建系统</h3>
<ul>
<li><a href="https://github.com/rizsotto/Bear" target="_blank">Bear</a> ：用于为clang工具生成编译数据库的工具</li>
<li><a href="https://www.biicode.com/" target="_blank">Biicode</a>：基于文件的简单依赖管理器。</li>
<li><a href="http://www.cmake.org/" target="_blank">CMake</a> ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li>
<li><a href="https://github.com/iauns/cpm" target="_blank">CPM</a>：基于CMake和Git的C++包管理器</li>
<li><a href="http://www.fastbuild.org/docs/home.html" target="_blank">FASTBuild</a>：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li>
<li><a href="http://martine.github.io/ninja/" target="_blank">Ninja</a> ：专注于速度的小型构建系统</li>
<li><a href="http://www.scons.org/" target="_blank">Scons</a> ：使用Python scipt 配置的软件构建工具</li>
<li><a href="https://github.com/deplinenoise/tundra" target="_blank">tundra</a> ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li>
<li><a href="http://gittup.org/tup/" target="_blank">tup</a>：基于文件的构建系统，用于后台监控变化的文件。</li>
</ul>
<p>&nbsp;</p>
<h3>静态代码分析</h3>
<p>提高质量，减少瑕疵的代码分析工具列表</p>
<ul>
<li><a href="http://cppcheck.sourceforge.net/" target="_blank">Cppcheck</a> ：静态C/C++代码分析工具</li>
<li><a href="https://code.google.com/p/include-what-you-use/" target="_blank">include-what-you-use</a> ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li>
<li><a href="http://oclint.org/" target="_blank">OCLint</a> ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li>
<li><a href="http://clang-analyzer.llvm.org/index.html" target="_blank">Clang Static Analyzer</a>：查找C，C++和Objective-C程序bug的源代码分析工具</li>
<li><a href="http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B" target="_blank">List of tools for static code analysis</a> ：来自维基百科的静态代码分析工具列表</li>
</ul>

<hr>
<ol>
<li><a href="http://www.ezlippi.com/blog/2014/12/c-open-project.html" target="_blank" rel="noopener">值得推荐的C/C++框架和库</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>webs</tag>
      </tags>
  </entry>
  <entry>
    <title>python资源列表</title>
    <url>/2016/06/23/awesome-python/</url>
    <content><![CDATA[<ol>
<li><a href="https://github.com/jobbole/awesome-python-cn" target="_blank" rel="noopener">awesome-python-cn</a></li>
<li><a href="http://python.jobbole.com/84464/" target="_blank" rel="noopener">Python 资源大全</a></li>
<li><a href="https://www.zhihu.com/question/24590883" target="_blank" rel="noopener">哪些 Python 库让你相见恨晚</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>webs</tag>
      </tags>
  </entry>
  <entry>
    <title>python crawling</title>
    <url>/2016/06/23/python-crawling/</url>
    <content><![CDATA[<hr>
<ol>
<li><a href="http://www.tuicool.com/articles/vIJzUv" target="_blank" rel="noopener">Python爬虫框架-Scrapy中文文档翻译计划</a></li>
<li><a href="https://github.com/marchtea/scrapy_doc_chs" target="_blank" rel="noopener">marchtea/scrapy_doc_chs</a></li>
<li><a href="https://github.com/marchtea/mdtogh" target="_blank" rel="noopener">marchtea/mdtogh</a></li>
<li><a href="http://cuiqingcai.com/1052.html" target="_blank" rel="noopener">Python爬虫学习系列教程</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>webs</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>网络调试工具</title>
    <url>/2016/06/22/network-debug/</url>
    <content><![CDATA[<h2 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h2><p>Iperf 是一个 TCP/IP 和 UDP/IP 的性能测量工具，能够提供网络吞吐率信息，以及震动、丢包率、最大段和最大传输单元大小等统计信息；<br>从而能够帮助我们测试网络性能，定位网络瓶颈。</p>
<pre><code class="bash">$ iperf3 -h</code></pre>
<p>TCP 模式下 客户端&amp;服务器</p>
<p>在您需要测试启用 Iperf 服务器模式：</p>
<pre><code class="bash">$ iperf3 -s
-----------------------------------------------------------
Server listening on 5201
-----------------------------------------------------------</code></pre>
<p>使用客户端模式连接第一台服务器。</p>
<pre><code class="bash">$ iperf3 -c 127.0.0.1
Connecting to host 127.0.0.1, port 5201
[  4] local 127.0.0.1 port 50924 connected to 127.0.0.1 port 5201
[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd
[  4]   0.00-1.00   sec  3.74 GBytes  32.1 Gbits/sec    0   1.12 MBytes       
[  4]   1.00-2.00   sec  3.80 GBytes  32.7 Gbits/sec    0   1.25 MBytes       
[  4]   2.00-3.00   sec  3.65 GBytes  31.3 Gbits/sec    0   1.62 MBytes     </code></pre>
<p>server有类似输出：</p>
<pre><code class="bash">[  5] local 127.0.0.1 port 5201 connected to 127.0.0.1 port 50924
[ ID] Interval           Transfer     Bandwidth
[  5]   0.00-1.00   sec  3.60 GBytes  30.9 Gbits/sec                  
[  5]   1.00-2.00   sec  3.80 GBytes  32.6 Gbits/sec                  
[  5]   2.00-3.00   sec  3.65 GBytes  31.3 Gbits/sec                  
[  5]   3.00-4.00   sec  3.97 GBytes  34.1 Gbits/sec                  
[  5]   4.00-5.00   sec  3.91 GBytes  33.6 Gbits/sec                  
[  5]   5.00-6.00   sec  3.90 GBytes  33.5 Gbits/sec                  
[  5]   5.00-6.00   sec  3.90 GBytes  33.5 Gbits/sec                  
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  5]   0.00-6.00   sec  0.00 Bytes  0.00 bits/sec                  sender
[  5]   0.00-6.00   sec  25.7 GBytes  36.8 Gbits/sec                  receiver
iperf3: the client has terminated
-----------------------------------------------------------
Server listening on 5201</code></pre>
<p>测试 <code>UDP</code> 使用参数 <code>-u</code></p>
<p>双向测试使用参数 <code>-d</code></p>
<h2 id="netperf"><a href="#netperf" class="headerlink" title="netperf"></a>netperf</h2><p>与iperf类似，也使用client/server方式工作。<br>server端是netserver，用来侦听来自client端的连接，client端是netperf，用来向server发起网络测试。<br>在client与server之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果；<br>在控制连接建立并传递了测试配置信息以后，client与server之间会再建立一个测试连接，用来来回传递着特殊的流量模式，以测试网络的性能。</p>
<ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-netperf/" target="_blank" rel="noopener">netperf 与网络性能测量</a></li>
</ol>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>TcpDump可以将网络中传送的数据包的“头”完全截获下来提供分析。<br>它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<pre><code class="bash">tcpdump tcp port 23 host 172.16.14.107 
tcpdump -w /path/to/log -i eth0 host &lt;CLIENTIP&gt; and port 80</code></pre>
<h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。</p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>用于查询DNS的工具，它通过常转换指定主机名称的主机名称为IP地址。当不指定参数时，它显示host命令的帮助信息</p>
<pre><code class="bash">$ host -a www.baidu.com
Trying &quot;www.baidu.com&quot;
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 57765
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 4

;; QUESTION SECTION:
;www.baidu.com.INANY

;; ANSWER SECTION:
www.baidu.com.459INCNAMEwww.a.shifen.com.

;; ADDITIONAL SECTION:
www.a.shifen.com.115INA115.239.211.112
www.a.shifen.com.115INA115.239.210.27
www.a.shifen.com.115INA180.97.33.108
www.a.shifen.com.115INA180.97.33.107

Received 122 bytes from 127.0.1.1#53 in 2 ms</code></pre>
<h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p>用于查找域名服务器的程序，nslookup有两种模式：互交和非互交</p>
<pre><code class="bash">$ nslookup www.baidu.com
Server:127.0.1.1
Address:127.0.1.1#53

Non-authoritative answer:
www.baidu.comcanonical name = www.a.shifen.com.
Name:www.a.shifen.com
Address: 180.97.33.108
Name:www.a.shifen.com
Address: 180.97.33.107

$ nslookup 
&gt; www.baidu.com
Server:127.0.1.1
Address:127.0.1.1#53

Non-authoritative answer:
www.baidu.comcanonical name = www.a.shifen.com.
Name:www.a.shifen.com
Address: 180.97.33.107
Name:www.a.shifen.com
Address: 180.97.33.108
&gt; set all
Default server: 127.0.1.1
Address: 127.0.1.1#53

Set options:
novcnodebugnod2
searchrecurse
timeout = 0retry = 3  port = 53ndots = 1
querytype = A           class = IN
srchlist = 
&gt; exit</code></pre>
<h2 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h2><p>是一个功能类似nslookup命令的工具。能得到更详细的DNS解析报告。在使用上要比 nslookup方便。可以作为网络故障的诊断工具</p>
<p><strong>必要参数</strong>：@DNSserver DNS服务器地址  (默认：/etc/resolv.conf 文件查询)</p>
<pre><code class="bash">$ dig @127.0.1.1 www.baidu.com

; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; @127.0.1.1 www.baidu.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 46874
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 5, ADDITIONAL: 6

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;www.baidu.com.INA

;; ANSWER SECTION:
www.baidu.com.817INCNAMEwww.a.shifen.com.
www.a.shifen.com.213INA115.239.210.27
www.a.shifen.com.213INA115.239.211.112

;; AUTHORITY SECTION:
a.shifen.com.1094INNSns1.a.shifen.com.
a.shifen.com.1094INNSns2.a.shifen.com.
a.shifen.com.1094INNSns5.a.shifen.com.
a.shifen.com.1094INNSns4.a.shifen.com.
a.shifen.com.1094INNSns3.a.shifen.com.

;; ADDITIONAL SECTION:
ns1.a.shifen.com.43INA61.135.165.224
ns2.a.shifen.com.274INA180.149.133.241
ns3.a.shifen.com.43INA61.135.162.215
ns4.a.shifen.com.558INA115.239.210.176
ns5.a.shifen.com.204INA119.75.222.17

;; Query time: 3 msec
;; SERVER: 127.0.1.1#53(127.0.1.1)
;; WHEN: Fri Jun 24 15:04:24 CST 2016
;; MSG SIZE  rcvd: 271</code></pre>
<p>用 dig 查看反向解析</p>
<pre><code class="bash">dig -x 210.52.83.228 @server</code></pre>
<p>查找一个域的授权 dns 服务器</p>
<pre><code class="bash">dig xmgd.com. +nssearch</code></pre>
<p>从根服务器开始追踪一个域名的解析过程</p>
<pre><code class="bash">dig xmgd.com +trace</code></pre>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>netstat命令主要用于显示与IP、TCP、UDP和ICMP协议相关的统计数据及网络相关信息，例如可以用于检验本机各端口的网络连接情况。</p>
<p>当你想看看哪个端口被哪个程序占用了；<br>当你想查看TCP连接状态；当你想统计网络连接信息时，这些都可以用netstat命令来搞定，这就是netstat。</p>
<ul>
<li>列出所有端口（包括监听和未监听的）</li>
</ul>
<pre><code class="bash">netstat -a      # 列出所有端口
netstat -at     # 列出所有TCP端口
netstat -au     # 列出所有UDP端口</code></pre>
<ul>
<li>列出所有处于监听状态的Sockets</li>
</ul>
<pre><code class="bash">netstat -l      # 只显示监听端口
netstat -lt     # 只列出所有监听TCP端口
netstat -lu     # 只列出所有监听UDP端口
netstat -lx     # 只列出所有监听UNIX端口</code></pre>
<ul>
<li>显示所有端口的统计信息</li>
</ul>
<pre><code class="bash">netstat -s      # 显示所有端口的统计信息
netstat -st     # 显示TCP端口的统计信息
netstat -su     # 显示UDP端口的统计信息</code></pre>
<ul>
<li>显示路由信息</li>
</ul>
<pre><code class="bash">netstat -r</code></pre>
<p>netstat是一个非常强大的命令，特别是和其它命令进行结合时，更能体现出它的强大性，比如统计TCP每个连接状态的数据：</p>
<pre><code class="bash">netstat -n | awk &#39;/^tcp/ {++state[$NF]}; END {for(key in state) print key,&quot;\t&quot;,state[key]}&#39;</code></pre>
<p>又比如查找请求数量排名前20的IP：</p>
<pre><code class="bash">netstat -anlp|grep 80|grep tcp|awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -n20</code></pre>
<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>ss命令用于显示socket状态.<br>他可以显示PACKET sockets, TCP sockets, UDP sockets, DCCP sockets, RAW sockets, Unix domain sockets等等统计.<br>它比其他工具展示等多tcp和state信息. 它是一个非常实用、快速、有效的跟踪IP连接和sockets的新工具</p>
<p>常用ss命令：</p>
<pre><code>ss -l 显示本地打开的所有端口
ss -pl 显示每个进程具体打开的socket
ss -t -a 显示所有tcp socket
ss -u -a 显示所有的UDP Socekt
ss -o state established &#39;( dport = :smtp or sport = :smtp )&#39; 显示所有已建立的SMTP连接
ss -o state established &#39;( dport = :http or sport = :http )&#39; 显示所有已建立的HTTP连接
ss -x src /tmp/.X11-unix/* 找出所有连接X服务器的进程
ss -s 列出当前socket详细信息:</code></pre><p>显示sockets简要信息，列出当前已经连接，关闭，等待的tcp连接</p>
<pre><code>$ ss -s
Total: 1105 (kernel 0)
TCP:   201 (estab 95, closed 4, orphaned 5, synrecv 0, timewait 2/0), ports 0

Transport Total     IP        IPv6
*     0         -         -        
RAW  2         0         2        
UDP  40        27        13       
TCP  197       187       10       
INET  239       214       25       
FRAG  0         0         0        </code></pre><p>ss使用IP地址筛选</p>
<pre><code>ss src ADDRESS_PATTERN
src：表示来源
ADDRESS_PATTERN：表示地址规则

如下：
ss src 120.33.31.1 # 列出来之20.33.31.1的连接

＃　列出来至120.33.31.1,80端口的连接
ss src 120.33.31.1:http
ss src 120.33.31.1:80</code></pre><p>ss使用端口筛选</p>
<pre><code>ss dport OP PORT
OP:是运算符
PORT：表示端口
dport：表示过滤目标端口、相反的有sport</code></pre><p>OP运算符如下：</p>
<pre><code>&lt;= or le : 小于等于 &gt;= or ge : 大于等于
== or eq : 等于
!= or ne : 不等于端口
&lt; or lt : 小于这个端口 &gt; or gt : 大于端口</code></pre><p>OP实例</p>
<pre><code>ss sport = :http 也可以是 ss sport = :80
ss dport = :http
ss dport \&gt; :1024
ss sport \&gt; :1024
ss sport \&lt; :32000
ss sport eq :22
ss dport != :22
ss state connected sport = :http
ss \( sport = :http or sport = :https \)
ss -o state fin-wait-1 \( sport = :http or sport = :https \) dst 192.168.1/24</code></pre><h2 id="netem-amp-tc"><a href="#netem-amp-tc" class="headerlink" title="netem &amp; tc"></a>netem &amp; tc</h2><p>netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。<br>该功能模块可以用来在性能良好的局域网中,模拟出复杂的互联网传输性能,诸如低带宽、传输延迟、丢包等等情况。<br>使用 Linux 2.6 (或以上) 版本内核的很多发行版 Linux 都开启了该内核功能,<br>比如 Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian 等等。</p>
<p>tc 是Linux 系统中的一个工具,全名为 traffic control(流量控制)。<br>tc 可以用来控制 netem 的工作模式,也就是说,如果想使用 netem ,需要至少两个条件,一个是内核中的 netem 功能被包含,另一个是要有 tc 。</p>
<p>将 eth0 网卡的传输设置为 100ms ,同时,大约有 30% 的包会延迟 ± 10ms 发送</p>
<pre><code class="bash">$  tc qdisc add dev eth0 root netem delay 100ms 10ms 30%</code></pre>
<p>将 eth0 网卡的传输设置为随机丢掉 1% 的数据包</p>
<pre><code class="bash">$ tc qdisc add dev eth0 root netem loss 1%</code></pre>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>检测丢包</p>
<p>何判断网络是否存在丢包呢？非常简单，通过常用的「ping」命令即可：</p>
<pre><code class="bash">$ ping -f &lt;IP&gt;</code></pre>
<p>关于其中的「-f」选项，在手册中是这样解释的：</p>
<blockquote>
<p>Flood ping. For every ECHO_REQUEST sent a period “.” is printed, while for ever ECHO_REPLY received a backspace is printed.  This provides a rapid display of how many packets are being dropped. If interval is not given, it sets interval to zero and outputs packets as fast as they come back or one hundred times per second, whichever is more. Only the super-user may use this option with zero interval.</p>
</blockquote>
<p>简单点说：发送洪水请求，每个请求打印一个点，每个响应删除一个点。<br>如果网络存在丢包，那么会呈现出一长串不断增加的点，简单易用，童叟无欺。</p>
<pre><code class="bash">$ ping -f -i .2 www.baidu.com
PING www.a.shifen.com (115.239.211.112) 56(84) bytes of data.
......^C
--- www.a.shifen.com ping statistics ---
259 packets transmitted, 253 received, 2% packet loss, time 51837ms
rtt min/avg/max/mdev = 2.948/4.136/15.631/1.465 ms, ipg/ewma 200.920/4.055 ms</code></pre>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>通过Traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。<br>当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，<br>但基本上来说大部分时候所走的路由是相同的。<br>UNIX系统中，我们称之为Traceroute,MS Windows中为Tracert。<br>Traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。<br>一条路径上的每个设备Traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。</p>
<pre><code class="bash">$ traceroute www.baidu.com
traceroute to www.baidu.com (115.239.210.27), 30 hops max, 60 byte packets
1  192.168.110.1 (192.168.110.1)  0.673 ms  0.653 ms  0.655 ms
2  * * *
3  192.168.3.1 (192.168.3.1)  1.267 ms  1.611 ms  1.609 ms
4  * * *
5  115.236.90.217 (115.236.90.217)  13.796 ms  13.775 ms  13.787 ms
6  220.191.159.125 (220.191.159.125)  17.639 ms 61.164.3.241 (61.164.3.241)  3.710 ms 61.164.8.45 (61.164.8.45)  3.654 ms
7  61.164.31.218 (61.164.31.218)  6.728 ms * *
8  * * *
9  115.239.209.10 (115.239.209.10)  11.003 ms 115.239.209.30 (115.239.209.30)  10.396 ms 115.239.209.14 (115.239.209.14)  11.438 ms
10  * * *
30  * * *</code></pre>
<p>记录按序列号从1开始，每个纪录就是一跳，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。<br>探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 <a href="http://www.58.com" target="_blank" rel="noopener">www.58.com</a> ，表示向每个网关发送4个数据包。</p>
<p><strong>有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。</strong></p>
<hr>
<ol>
<li><a href="http://blog.sina.com.cn/s/blog_669638e10100h9ov.html" target="_blank" rel="noopener">iperf交叉编译和 使用</a></li>
<li><a href="http://blog.csdn.net/mistyeyed/article/details/5918610" target="_blank" rel="noopener">iperf for Linux 在TOP6410上的交叉编译和使用</a></li>
<li><a href="http://www.latelee.org/using-gnu-linux/compile-iperf.html" target="_blank" rel="noopener">网络性能测试工具iperf编译记录</a></li>
<li><a href="http://luodw.cc/2015/12/27/dns03/" target="_blank" rel="noopener">域名解析之dig,host,nslookup命令</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>tools</tag>
        <tag>tcpdump</tag>
        <tag>wireshark</tag>
        <tag>iperf</tag>
        <tag>nslookup</tag>
      </tags>
  </entry>
  <entry>
    <title>使用clang-format格式化你的代码</title>
    <url>/2016/06/22/clang-format/</url>
    <content><![CDATA[<ul>
<li>toc<br>{:toc}</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>clang-format是一个格式化代码的工具, 支持多种代码风格。有两种方式使用：</p>
<p>安装：</p>
<pre><code class="bash">sudo apt-get install clang-format</code></pre>
<ul>
<li>vim插件</li>
</ul>
<pre><code class="vimrc">Bundle &#39;rhysd/vim-clang-format&#39;                                                                                                   

let g:clang_format#style_options = {
    \ &quot;AccessModifierOffset&quot; : -4,
    \ &quot;AllowShortIfStatementsOnASingleLine&quot; : &quot;true&quot;,
    \ &quot;AlwaysBreakTemplateDeclarations&quot; : &quot;true&quot;,
    \ &quot;Standard&quot; : &quot;C++11&quot;}</code></pre>
<p><code>clang_format#style_options</code> 可以在<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">Clang-Format Style Options</a>查找配置</p>
<ul>
<li>直接使用Clang-Format</li>
</ul>
<p>在 <code>.vimrc</code> 中映射快捷键</p>
<pre><code class="vimrc">map &lt;C-K&gt; :pyf &lt;path-to-this-file&gt;/clang-format.py&lt;cr&gt;
imap &lt;C-K&gt; &lt;c-o&gt;:pyf &lt;path-to-this-file&gt;/clang-format.py&lt;cr&gt;</code></pre>
<p>需要在目录下建一个名为.clang-format的文件, 通过</p>
<pre><code class="bash">clang-format -style=llvm -dump-config &gt; .clang-format</code></pre>
<p>可以获得一个模板 .clang-format 文件, 根据自己的需求修改即可</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>获得模板</p>
<pre><code class="bash">clang-format -style=llvm -dump-config &gt; .clang-format</code></pre>
<p>修改参考<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">options</a></p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol>
<li><a href="http://hokein.me/2016/01/30/clang-format/" target="_blank" rel="noopener">使用clang-format格式化你的代码</a></li>
<li><a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">Clang-Format Style Options</a></li>
<li><a href="http://qiufeng.me/xcode-format" target="_blank" rel="noopener">Objective-C代码自动格式化</a></li>
<li><a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">Clang-Format Style Options</a></li>
<li><a href="https://github.com/rhysd/vim-clang-format" target="_blank" rel="noopener">rhysd/vim-clang-format</a></li>
<li><a href="http://clang.llvm.org/docs/ClangFormat.html#vim-integration" target="_blank" rel="noopener">Vim Integration</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>vim</tag>
        <tag>style</tag>
        <tag>clang-format</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++推荐工具</title>
    <url>/2016/06/21/c-c++-tools/</url>
    <content><![CDATA[<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ul>
<li>vim</li>
<li>emacs</li>
<li>kate（KDE下一个功能强大的编辑器）</li>
<li>Sublime text 3</li>
</ul>
<h2 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h2><ul>
<li>AppCode ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li>
<li>CLion：来自JetBrains的跨平台的C/C++的集成开发环境</li>
<li>Code::Blocks ：免费C，C++和Fortran的集成开发环境</li>
<li>CodeLite ：另一个跨平台的免费的C/C++集成开发环境</li>
<li>Dev-C++：可移植的C/C++/C++11集成开发环境</li>
<li>Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境</li>
<li>Geany ：轻量级的快速，跨平台的集成开发环境。</li>
<li>IBM VisualAge ：来自IBM的家庭计算机集成开发环境。</li>
<li>Irony-mode：由libclang驱动的用于Emacs的C/C++微模式</li>
<li>KDevelop：免费开源集成开发环境</li>
<li>Microsoft Visual Studio ：来自微软的集成开发环境</li>
<li>NetBeans ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li>
<li>Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li>
<li>rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li>
<li>Xcode ：由苹果公司开发</li>
<li>YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li>
</ul>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><ul>
<li>make</li>
<li>CMake ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li>
<li>Bear ：用于为clang工具生成编译数据库的工具</li>
<li>Biicode：基于文件的简单依赖管理器。</li>
<li>CPM：基于CMake和Git的C++包管理器</li>
<li>FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li>
<li>Ninja ：专注于速度的小型构建系统</li>
<li>Scons ：使用Python scipt 配置的软件构建工具</li>
<li>tundra ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li>
<li>tup：基于文件的构建系统，用于后台监控变化的文件。</li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><ul>
<li>Cppcheck ：静态C/C++代码分析工具</li>
<li>include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li>
<li>OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li>
<li>Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具</li>
<li>Purify</li>
<li>Valgrind工具集(包括剖析工具Callgrind和线程分析工具Helgrind等)</li>
<li>KCachegrind</li>
<li>gprof开源剖析工具，通常作为gcc编译器的一部分</li>
<li>gprof2dot</li>
<li>Luke StackWalker ，查找程序性能瓶颈的工具</li>
<li>gperftools</li>
</ul>
<h2 id="代码工具"><a href="#代码工具" class="headerlink" title="代码工具"></a>代码工具</h2><ul>
<li>nm 列出来自对象文件的符号</li>
<li>objdump 显示对象文件信息</li>
<li>strings 列出二进制文件中可输出的字符串</li>
<li>strip 删除来自对象文件的符号</li>
<li>m4 宏处理程序</li>
<li>indent 代码格式化工具</li>
</ul>
<h2 id="检测工具"><a href="#检测工具" class="headerlink" title="检测工具"></a>检测工具</h2><ul>
<li>time 计时工具</li>
<li>ps 显示运行进程的当前状态</li>
<li>top 给出系统的详细信息</li>
<li>strace 记录对操作系统的所有访问，例如内存分配、文件I/O、系统调用和子进程的启动</li>
</ul>
<hr>
<!--
1. [C/C++ 编程有哪些值得推荐的工具](https://www.zhihu.com/question/23357089)
-->

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>sdk</tag>
        <tag>editor</tag>
        <tag>analyser</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法代码</title>
    <url>/2016/06/05/programmer-sorting-algo-sourcecode/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序算法的运作如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<pre><code class="c">void bubble_sort(int arr[], int len) {
    int i, j, temp;
    for (i = 0; i &lt; len - 1; i++) {
        for (j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}</code></pre>
<p><strong>改进算法</strong></p>
<p>冒泡排序是与<strong>插入排序</strong>拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。<br>在最好的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。<br>冒泡排序的实现通常会对已经排序好的数列拙劣地运行（O(n^2)），而插入排序在这个例子只需要O(n)个运算。<br><strong>因此很多现代的算法教科书避免使用冒泡排序，而用插入排序替换之。</strong><br>冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最好的复杂度降低到O(n)。<br>在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。<br>有时候称为<strong>鸡尾酒排序</strong>，因为算法会从数列的一端到另一端之间穿梭往返。</p>
<p><strong>改进代码</strong>，使用一个旗标来表示有无需要交换的可能</p>
<pre><code class="c">void bubble_sort(int arr[], int len) {
    int i, j, temp;
    bool flag = true;
    for (i = 0; i &lt; len - 1; i++) {
        flag = false;
        for (j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = true;
            }
        }

        if(!flag)
            break;
    }
}</code></pre>
<p><strong>进一步优化</strong>，如果R[0..i]已是有序区间，上次的扫描区间是R[i..n]，<br>记上次扫描时最后一次执行交换的位置为lastSwapPos，则lastSwapPos在i与n之间，<br>不难发现R[i..lastSwapPos]区间也是有序的，否则这个区间也会发生交换；<br>所以下次扫描区间就可以由R[i..n] 缩减到[lastSwapPos..n]。</p>
<pre><code class="c">void bubble_sort(int arr[], int len) {
    int i, j, temp;
    int lastSwapPos = 0, lastSwapPosTemp = 0;
    for (i = 0; i &lt; len - 1; i++) {
        lastSwapPos = lastSwapPosTemp;
        for (j = lastSwapPosTemp; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                lastSwapPosTemp = j;
            }
        }

        if(lastSwapPos == lastSwapPosTemp)
            break;
    }
}</code></pre>
<h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>鸡尾酒排序，也就是<strong>定向冒泡排序</strong>，是冒泡排序的一种变形。<br>此算法与冒泡排序的不同处在于<strong>排序时是以双向在序列中进行排序</strong>。<br>鸡尾酒排序等于是冒泡排序的轻微变形。<strong>不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。</strong></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置中</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot），</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。<br>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>#归并排序</p>
<p><strong>归并排序</strong>是建立在归并操作上的一种有效的排序算法。<br>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p>
<p><strong>步骤：</strong></p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆积排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。<br>堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ol>
<li>首先在未排序序列中找到最小元素，存放到排序序列的起始位置，</li>
<li>然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位&gt;</li>
</ol>
<h2 id="梳排序"><a href="#梳排序" class="headerlink" title="梳排序"></a>梳排序</h2><p>梳排序是改良自冒泡排序和快速排序。</p>
<p>在冒泡排序算法中，只比较阵列中相邻的二项，即比较的二项的间距(Gap)是1，<br>梳排序提出此间距其实可大于1，<strong>改自插入排序的希尔排序同样提出相同观点。</strong><br>梳排序中，开始时的间距设定为阵列长度，并在循环中以固定比率递减，通常递减率设定为1.24。<br>在一次循环中，梳排序如同冒泡排序一样把阵列从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于1。<br>如果间距递减至1，梳排序假定输入阵列大致排序好，并以冒泡排序作最后检查及修正。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://functionspace.com/topic/3774/GIFs-of-sorting-algorithms" target="_blank" rel="noopener">GIFs of sorting algorithms</a></li>
<li><a href="http://www.sorting-algorithms.com/" target="_blank" rel="noopener">Sorting Algorithm Animations</a></li>
<li><a href="https://www.reddit.com/r/oddlysatisfying/comments/2gnqtp/this_gif_visualizing_a_sorting_algorithm/" target="_blank" rel="noopener">This gif, visualizing a sorting algorithm</a></li>
<li><a href="https://www.youtube.com/watch?v=kPRA0W1kECg" target="_blank" rel="noopener">15 Sorting Algorithms in 6 Minutes</a></li>
<li><a href="http://www.wtoutiao.com/p/98aDH0.html" target="_blank" rel="noopener">视觉直观感受 7 种常用的排序算法</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">排序算法</a></li>
<li><a href="http://blog.csdn.net/cjf_iceking/article/details/7916194" target="_blank" rel="noopener">插入排序</a></li>
<li><a href="https://github.com/cdmh/sorting_algorithms" target="_blank" rel="noopener">sorting algorithms</a></li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">comparisonSort</a></li>
<li><a href="http://visualgo.net/sorting" target="_blank" rel="noopener">visualgo</a></li>
<li><a href="http://sorting.at/" target="_blank" rel="noopener">sort algo</a></li>
<li><a href="http://sortvis.org/index.html" target="_blank" rel="noopener">sortvis</a></li>
<li><a href="http://www.codeproject.com/Articles/132757/Visualization-and-Comparison-of-sorting-algorithms" target="_blank" rel="noopener">sort vis tool</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>sorting</tag>
        <tag>algor</tag>
      </tags>
  </entry>
  <entry>
    <title>FontCreator编辑字库</title>
    <url>/2016/05/11/how-to-use-fontcreator/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>FreeType 中函数 <code>FT_Get_Kerning</code></p>
<ul>
<li><strong>Backtrack(后迹)</strong> — This is the sequence of things that occur before the target in the rule.<br>This sequence can be composed of glyphs, classes or a mix of both.</li>
<li><strong>Lookahead(前瞻)</strong> — This is the sequence of glyphs that occur after the target in the rule.<br>Like the backtrack, this sequence can be composed of glyphs, classes or a mix of both.</li>
</ul>
<hr>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a><strong>名词</strong></h2><p><strong>FontCreator</strong>字库编辑工具，使用Ctrl-F8（OpenType设计工具）可以编辑TTF字库相关信息：</p>
<h3 id="GSUB"><a href="#GSUB" class="headerlink" title="GSUB"></a><strong>GSUB</strong></h3><p>The OpenType Layout Feature specification<br><strong>describes eight types of substitution lookups in the glyph substitution table (GSUB)</strong>.<br>The following table shows those currently supported by FontCreator:</p>
<ol>
<li>Single Substitute a single glyph by another single glyph (a -&gt; b)</li>
<li>Multiple Substitute a single glyph by other multiple glyphs (a -&gt; xyz)</li>
<li>Alternate Substitute a single glyph by one of multiple alternates (a -&gt; x or y or z)</li>
<li>Ligature Substitute multiple glyphs by a single ligature (f f i -&gt; ffi)</li>
<li>Context Substitute one or more glyphs in context</li>
<li>Chaining Context Substitute context specific glyphs (3rd -&gt; 3rd)</li>
<li>Extension Substitution </li>
<li>Reverse chaining context Applied in reverse order, replace single glyph in chaining context</li>
</ol>
<h3 id="GPOS"><a href="#GPOS" class="headerlink" title="GPOS"></a><strong>GPOS</strong></h3><p>The OpenType Layout Feature specification<br><strong>describes nine types of positioning lookups in the glyph positioning table (GPOS)</strong>.<br>The following table shows those currently supported by FontCreator:</p>
<ol>
<li>Single adjustment Change the position of a single glyph (sub/superscript)</li>
<li>Pair adjustment Mostly used to define kerning pairs</li>
<li>Cursive attachment </li>
<li>Mark to base attachment Attach a combining mark such as a diacritic to a base glyph</li>
<li>Mark to ligature attachment Attach a combining mark to a ligature</li>
<li>Mark to mark attachment Attach a combining mark to another mark</li>
<li>Context Positioning Position one or more glyphs in context</li>
<li>Chained Context Positioning Position one or more glyphs in chained context</li>
<li>Extension Substitution</li>
</ol>
<ol>
<li><a href="http://www.high-logic.com/fontcreator/manual/index.html?kerning_overview.html" target="_blank" rel="noopener">FontCreator Help</a></li>
<li><a href="http://www.high-logic.com/fontcreator/manual9/index.html?otlfsupportedsubstitutions.html" target="_blank" rel="noopener">OpenType Layout Features - Supported types of substitution and positioning</a></li>
<li><a href="https://www.microsoft.com/typography/otfntdev/khmerot/features.aspx" target="_blank" rel="noopener">Developing OpenType Fonts for Khmer Script (3 of 3): Features</a></li>
<li><a href="http://www.high-logic.com/fontcreator/manual9/index.html?otlfsupportedsubstitutions.html" target="_blank" rel="noopener">OpenType Designer</a></li>
<li><a href="https://www.microsoft.com/typography/otspec/gsub.htm" target="_blank" rel="noopener">GSUB - The Glyph Substitution Table</a></li>
<li><a href="http://opentypecookbook.com/rules.html" target="_blank" rel="noopener">opentypecookbook</a></li>
<li><a href="https://www.microsoft.com/typography/otspec/recom.htm" target="_blank" rel="noopener">Recommendations for OpenType Fonts</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Font</category>
      </categories>
      <tags>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2016/05/09/http-status-code/</url>
    <content><![CDATA[<img src="/images/http/http-status-code.jpg" height="600" width="800" />

<hr>
<p>用<strong>Fiddler工具</strong>可以查看HTTP Request和Response,<br>还可以方便地查看Response中的状态码，<br>如果不熟悉这个工具，可以先参考<a href="http://kb.cnblogs.com/page/130367/" target="_blank" rel="noopener">Fiddler教程</a></p>
<p>为了重现HTTP 状态码，本文会使用Fiddler Composer来创建“特殊的HTTP Request”.<br>可以参考<a href="http://www.cnblogs.com/syf/archive/2013/01/12/2857276.html" target="_blank" rel="noopener">Fiddler Composer创建和发送HTTP Request</a></p>
<p><strong>常见的状态码:</strong></p>
<ul>
<li>200 OK 服务器成功处理了请求（这个是我们见到最多的）</li>
<li>301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</li>
<li>304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存</li>
<li>404 Not Found 未找到资源</li>
<li>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</li>
</ul>
<hr>
<h2 id="1XX-信息性状态码"><a href="#1XX-信息性状态码" class="headerlink" title="1XX 信息性状态码"></a><strong>1XX 信息性状态码</strong></h2><p>这些状态码是HTTP 1.1引入的。对于这些状态码的价值还存在争论。</p>
<ul>
<li>100 收到了请求的起始部分，客户端应该继续请求</li>
<li>101 服务器正根据客户端的指示将协议切换成Update Header列出的协议</li>
</ul>
<h2 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a><strong>2XX 成功状态码</strong></h2><ul>
<li>200 服务器成功处理了请求</li>
<li>201 对于那些要服务器创建对象的请求来说，资源已创建完毕</li>
<li>202 请求已接受， 但服务器尚未处理</li>
<li>203 服务器已将事务成功处理，只是实体Header包含的信息不是来自原始服务器，而是来自资源的副本</li>
<li>204 Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）</li>
<li>205 另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的HTML表单</li>
<li>206 部分请求成功</li>
</ul>
<h2 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a><strong>3XX 重定向状态码</strong></h2><p>重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动，<br>Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。</p>
<p>浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。</p>
<p>301和302 非常相似，  一个是永久转移，一个是临时转移。   （在我们看来， 这两个没太大区别）</p>
<p>302，303，307 是一样。<br>这是因为302是HTTP 1.0定义的， HTTP1.1中使用303,307.<br>同时又保留了302.  （但在现实中，我们还是用302，我是没见过303和307）<br>所以这一节， 我们只需要掌握302， 304 就可以了</p>
<ul>
<li>300 客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了 </li>
<li>301 请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置状态码301</li>
<li>302 与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP requestHTTP协议详解-302</li>
<li>303 类似302 </li>
<li>304 客户的缓存资源是最新的， 要客户端使用缓存HTTP协议之缓存-304</li>
<li>305 必须通过代理访问资源， 代理的地址在Response 的Location中 </li>
<li>306 这个状态码当前没使用 </li>
<li>307 临时重定向类似302</li>
</ul>
<h2 id="4XX-客户端错误状态码"><a href="#4XX-客户端错误状态码" class="headerlink" title="4XX 客户端错误状态码"></a><strong>4XX 客户端错误状态码</strong></h2><ul>
<li>400 Bad Request（坏请求）告诉客户端，它发送了一个错误的请求。状态码400</li>
<li>401 Unauthorized（未授权）需要客户端对自己认证HTTP协议之基本认证-401</li>
<li>402 Payment Required（要求付款）这个状态还没被使用， 保留给将来用 </li>
<li>403 Forbidden（禁止）请求被服务器拒绝了状态码403</li>
<li>404 Not Found（未找到）未找到资源HTTP协议详解-404</li>
<li>405 Method Not Allowed（不允许使用的方法）不支持该Request的方法。状态码405</li>
<li>406 Not Acceptable（无法接受）  </li>
<li>407 Proxy Authentication Required(要求进行代理认证)与状态码401类似， 用于需要进行认证的代理服务器HTTP协议之代理-407</li>
<li>408 Request Timeout（请求超时） 如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接 </li>
<li>409 Conflict（冲突）发出的请求在资源上造成了一些冲突 </li>
<li>410 Gone（消失了）服务器曾经有这个资源，现在没有了， 与状态码404类似 </li>
<li>411 Length Required（要求长度指示）服务器要求在Request中包含Content-Length。状态码411</li>
<li>412 Precondition Failed（先决条件失败）  </li>
<li>413 Request Entity Too Large（请求实体太大）客户端发送的实体主体部分比服务器能够或者希望处理的要大状态码413</li>
<li>414 Request URI Too Long（请求URI太长）客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度状态码414</li>
<li>415 Unsupported Media Type（不支持的媒体类型）服务器无法理解或不支持客户端所发送的实体的内容类型 </li>
<li>416 Requested Range Not Satisfiable（所请求的范围未得到满足）  </li>
<li>417 Expectation Failed（无法满足期望）</li>
</ul>
<h2 id="5XX-服务器错误状态码"><a href="#5XX-服务器错误状态码" class="headerlink" title="5XX 服务器错误状态码"></a><strong>5XX 服务器错误状态码</strong></h2><ul>
<li>500 Internal Server Error(内部服务器错误)服务器遇到一个错误，使其无法为请求提供服务状态码500</li>
<li>501 Not Implemented（未实现）客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。状态码501</li>
<li>502 Bad Gateway（网关故障）代理使用的服务器遇到了上游的无效响应状态码502</li>
<li>503 Service Unavailable（未提供此服务）服务器目前无法为请求提供服务，但过一段时间就可以恢复服务 </li>
<li>504 Gateway Timeout（网关超时）与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时 </li>
<li>505 HTTP Version Not Supported（不支持的HTTP版本）服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</li>
</ul>
<ol>
<li><a href="http://kb.cnblogs.com/page/168720/" target="_blank" rel="noopener">HTTP协议之状态码详解</a></li>
<li><a href="http://kb.cnblogs.com/page/168720/#code2xx" target="_blank" rel="noopener">2XX</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基本功系列：总目录</title>
    <url>/2016/05/08/network-basic-information/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<ul>
<li><a href="https://community.emc.com/thread/197851" target="_blank" rel="noopener">网络传输</a></li>
<li><a href="https://community.emc.com/message/832621#832621" target="_blank" rel="noopener">交换机</a></li>
<li><a href="https://community.emc.com/message/834012#834012" target="_blank" rel="noopener">VLAN与Trunk</a></li>
<li><a href="https://community.emc.com/message/835157#835157" target="_blank" rel="noopener">路由(上)</a></li>
<li><a href="https://community.emc.com/message/836518#836518" target="_blank" rel="noopener">路由(下)</a></li>
<li><a href="https://community.emc.com/message/837741#837741" target="_blank" rel="noopener">链路聚合</a></li>
<li><a href="https://community.emc.com/message/838932#838932" target="_blank" rel="noopener">IP地址与子网</a></li>
<li><a href="https://community.emc.com/message/856307#856307" target="_blank" rel="noopener">NAT原理与配置</a></li>
<li><a href="https://community.emc.com/message/857413#857413" target="_blank" rel="noopener">ICMP与ARP</a></li>
<li><a href="https://community.emc.com/message/840427#840427" target="_blank" rel="noopener">TCP滑动窗口</a></li>
<li><a href="https://community.emc.com/message/842129#842129" target="_blank" rel="noopener">TCP重传</a></li>
<li><a href="https://community.emc.com/message/842879#842879" target="_blank" rel="noopener">TCP确认机制</a></li>
<li><a href="https://community.emc.com/message/843667#843667" target="_blank" rel="noopener">TCP窗口调整与流控</a></li>
<li><a href="https://community.emc.com/message/861019#861019" target="_blank" rel="noopener">Wireshark抓包实例诊断TCP连接问题</a></li>
<li><a href="https://community.emc.com/message/862231#862231" target="_blank" rel="noopener">Wireshark抓包实例诊断TCP重传</a></li>
<li><a href="https://community.emc.com/message/863284#863284" target="_blank" rel="noopener">Wireshark抓包实例诊断TCP重复ACK与乱序</a></li>
<li><a href="https://community.emc.com/message/867817#867817" target="_blank" rel="noopener">Wireshark抓包实例诊断TCP窗口与reset</a></li>
<li><a href="https://community.emc.com/message/870552#870552" target="_blank" rel="noopener">Wireshark抓包实例诊断HTTP问题</a></li>
<li><a href="https://community.emc.com/message/872167#872167" target="_blank" rel="noopener">Wireshark抓包实例诊断数据库问题</a></li>
<li><a href="https://community.emc.com/message/858387#858387" target="_blank" rel="noopener">HTTP(上)</a></li>
<li><a href="https://community.emc.com/message/859697#859697" target="_blank" rel="noopener">HTTP(下)</a></li>
<li><a href="https://community.emc.com/message/873899#873899" target="_blank" rel="noopener">DNS（上）</a></li>
<li><a href="https://community.emc.com/message/846116#846116" target="_blank" rel="noopener">细说Linux网络配置（上）</a></li>
<li><a href="https://community.emc.com/message/846990#846990" target="_blank" rel="noopener">细说Linux网络配置（下）</a></li>
<li><a href="https://community.emc.com/message/848168#848168" target="_blank" rel="noopener">常用诊断工具：ping</a></li>
<li><a href="https://community.emc.com/message/850742#850742" target="_blank" rel="noopener">网络性能监测与实例（上）</a></li>
<li><a href="https://community.emc.com/message/852040#852040" target="_blank" rel="noopener">网络性能监测与实例（下）</a></li>
<li><a href="https://community.emc.com/message/854940#854940" target="_blank" rel="noopener">tcpdump的妙用  (上)</a></li>
<li><a href="https://community.emc.com/message/855799#855799" target="_blank" rel="noopener">tcpdump的妙用（下）</a></li>
</ul>
<hr>
<ol>
<li><a href="https://community.emc.com/thread/197851" target="_blank" rel="noopener">网络基本功系列</a></li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
        <category>网络基本功</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>webs</tag>
        <tag>tcpdump</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员必备的代码审查（Code Review）清单</title>
    <url>/2016/05/08/code-review-list/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>软件工程学院的研究表明，程序员们会犯15-20种常见的错误。<br>所以，通过把这些错误加入到检查清单当中，你可以确保不论什么时候，<br>只要这些错误发生了，你就能发现它们，并且可以帮助你杜绝这些错误。</p>
<p>为了帮助你开始创建一个清单，这里列出了一些典型的内容：代码审查清单。</p>
<h2 id="常规项"><a href="#常规项" class="headerlink" title="常规项"></a><strong>常规项</strong></h2><ul>
<li>代码能够工作么？它有没有实现预期的功能，逻辑是否正确等。</li>
<li>所有的代码是否简单易懂？</li>
<li>代码符合你所遵循的编程规范么？这通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。</li>
<li>是否存在多余的或是重复的代码？</li>
<li>代码是否尽可能的模块化了？</li>
<li>是否有可以被替换的全局变量？</li>
<li>是否有被注释掉的代码？</li>
<li>循环是否设置了长度和正确的终止条件？</li>
<li>是否有可以被库函数替代的代码？</li>
<li>是否有可以删除的日志或调试代码？</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a><strong>安全</strong></h2><ul>
<li>所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？</li>
<li>在哪里使用了第三方工具，返回的错误是否被捕获？</li>
<li>输出的值是否进行了检查并且编码？</li>
<li>无效的参数值是否能够处理？</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a><strong>文档</strong></h2><ul>
<li>是否有注释，并且描述了代码的意图？</li>
<li>所有的函数都有注释吗？</li>
<li>对非常规行为和边界情况处理是否有描述？</li>
<li>第三方库的使用和函数是否有文档？</li>
<li>数据结构和计量单位是否进行了解释？</li>
<li>是否有未完成的代码？如果是的话，是不是应该移除，或者用合适的标记进行标记比如‘TODO’？</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><ul>
<li>代码是否可以测试？比如，不要添加太多的或是隐藏的依赖关系，不能够初始化对象，测试框架可以使用方法等。</li>
<li>是否存在测试，它们是否可以被理解？比如，至少达到你满意的代码覆盖(code coverage)。</li>
<li>单元测试是否真正的测试了代码是否可以完成预期的功能？</li>
<li>是否检查了数组的“越界“错误？</li>
<li>是否有可以被已经存在的API所替代的测试代码？</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>你同样需要把特定语言中有可能引起错误的问题添加到清单中。</p>
<p>这个清单故意没有详尽的列出所有可能会发生的错误。<br>你不希望你的清单是这样的，太长了以至于从来没人会去用它。仅仅包含常见的问题会比较好。</p>
<h2 id="优化你的清单"><a href="#优化你的清单" class="headerlink" title="优化你的清单"></a><strong>优化你的清单</strong></h2><p>把使用清单作为你的起点，针对特定的使用案例，你需要对其进行优化。<br>一个比较棒的方式就是让你的团队记录下那些在代码审查过程中临时发现的问题，<br>有了这些数据，你就能够确定你的团队常犯的错误，然后你就可以量身定制一个审查清单。<br>确保你删除了那些没有出现过的错误。（你也可以保留那些出现概率很小，但是非常关键的项目，比如安全相关的问题）。</p>
<h2 id="得到认可并且保持更新"><a href="#得到认可并且保持更新" class="headerlink" title="得到认可并且保持更新"></a><strong>得到认可并且保持更新</strong></h2><p>基本规则是，清单上的任何条目都必须明确，而且，如果可能的话，对于一些条目你可以对其进行二元判定。<br>这样可以防止判断的不一致。和你的团队分享这份清单并且让他们认同你清单的内容是个好主意。<br>同样的，要定期检查你的清单，以确保各条目仍然是有意义的。</p>
<p>有了一个好的清单，可以提高你在代码审查过程中发现的缺陷个数。<br>这可以帮助你提高代码标准，避免质量参差不齐的代码审查。</p>
<ol>
<li><a href="http://blog.jobbole.com/83595/" target="_blank" rel="noopener">程序员必备的代码审查清单</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git中的撤销操作</title>
    <url>/2016/04/29/git-rebase/</url>
    <content><![CDATA[<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a><strong>git rebase</strong></h2><p><strong>git rebase是对commit history的改写</strong>。<br>当你要改写的commit history还没有被提交到远程repo的时候，<br>也就是说，<strong>还没有与他人共享之前，commit history是你私人所有的，那么想怎么改写都可以</strong>。</p>
<p>而<strong>一旦被提交到远程后，这时如果再改写history，那么势必和他人的history长的就不一样了</strong>。<br>git push的时候，git会比较commit history，如果不一致，<br>commit动作会被拒绝，唯一的办法就是带上-f参数，<br>强制要求commit，这时git会以committer的history覆写远程repo，<br>从而完成代码的提交。虽然代码提交上去了，<br>但是<strong>这样可能会造成别人工作成果的丢失，所以使用-f参数要慎重</strong>。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h2><ol>
<li>除非只有自己一个人用，不然用 push –force 的都该去死</li>
<li>慎用 push -f！</li>
<li>每个人提交前，都应该把自己的修改rebase到服务器的最新代码之上，遵守这个规则就不会有任何问题。<br>如果你需要force push，说明你做反了，把服务器代码rebase到你本地分支之上才会需要force push，这是错误的用法。</li>
<li>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作</li>
<li>如果 rebase 完后，需要使用 push -f 的话，一定代表该 rebase 操作是不合适。除非你是有意在修改提交历史</li>
<li>除非某个分支只有你自己搞，你怎么rebase都是没有问题的，但是如果你在master或者develop这种分支上来rebase，<br>估计团队里每个人都想拍死你</li>
<li>当你在某个分支进行团队合作的时候， 常用rebase真的是不合理。而且容易出问题。慎用 push –force</li>
<li>git rebase 一般自己一个人开发时使用，用来保持提交记录的整洁。一旦上传到github后，不应该使用git rebase</li>
<li><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。<br>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你</strong></li>
<li>不需要push -f啊，如果分支落后就用pull –rebase</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h2><p>假设楼主的team中有两个developer：tom和jerry，他们共同使用一个远程repo，<br>并各自clone到自己的机器上，为了简化描述，这里假设只有一个branch：master。</p>
<p>这时tom机器的repo有两个branch: <strong>master, origin/master</strong></p>
<p>而jerry的机器上也是有两个branch: <strong>master, origin/master</strong></p>
<p>均如下图所示</p>
<p><img src="http://segmentfault.com/img/bVb0wO" alt="1"></p>
<p>tom和jerry分别各自开发自己的新feature，<br>不断有新的commit提交到他们各自私有的commit history中，<br>所以他们的master指针不断的向前推移，分别指向不同的commit。<br><strong>而又由于他们都没有git fetch和git push，所以他们的origin/master都维持不变</strong>。</p>
<p>jerry的repo如下</p>
<p><img src="http://segmentfault.com/img/bVb0wQ" alt="2"></p>
<p>tom的repo如下，注意T1和上图的J1，分别是两个不同的commit</p>
<p><img src="http://segmentfault.com/img/bVb0wR" alt="3"></p>
<p>这时Tom首先把他的commit提交的远程repo中，那么他本机origin/master指针则会前进，和master指针保持一致，如下</p>
<p><img src="http://segmentfault.com/img/bVb0wT" alt="4"></p>
<p>远程repo如下</p>
<p><img src="http://segmentfault.com/img/bVb0wS" alt="5"></p>
<p>现在jerry也想把他的commit提交到远程repo上去，<br><strong>运行git push，毫无意外的失败了，所以他git fetch了一下，把远程repo，也就是之前tom提交的T1给拉到了他本机repo中</strong>，如下</p>
<p><img src="http://segmentfault.com/img/bVb0wU" alt="6"></p>
<p>commit history出现了分叉，要想把tom之前提交的内容包含到自己的工作中来，<br>有一个方法就是<strong>git merge，它会自动生成一个commit，既包含tom的提交，也包含jerry的提交</strong>，<br>这样就把两个分叉的commit重新又合并在一起。但是<strong>这个自动生成的commit会有两个parent</strong>，<br>review代码的时候必须要比较两次，很不方便。</p>
<p>jerry<strong>为了保证commit history的线性</strong>，决定采用另外一种方法，就是<strong>git rebase</strong>。<br>jerry的<strong>提交J1这时还没有被提交到远程repo上去，也就是他完全私有的一个commit，<br>所以使用git rebase改写J1的history完全没有问题</strong>，改写之后，如下</p>
<p><img src="http://segmentfault.com/img/bVb0wV" alt="7"></p>
<p>注意J1被改写到T1后面了，变成了J1`</p>
<p>git push后，本机repo</p>
<p><img src="http://segmentfault.com/img/bVb0wW" alt="8"></p>
<p>而远程repo</p>
<p><img src="http://segmentfault.com/img/bVb0wX" alt="9"></p>
<p>异常的轻松，一条直线，没有-f</p>
<p>所以，<strong>在不用-f的前提下，想维持树的整洁，方法就是：在git push之前，先git fetch，再git rebase</strong>。</p>
<pre><code>git fetch origin master
git rebase origin/master
git push</code></pre><ol>
<li><a href="http://www.oschina.net/translate/10-tips-git-next-level" target="_blank" rel="noopener">10 个迅速提升你 Git 水平的提示</a></li>
<li><a href="https://segmentfault.com/q/1010000000430041" target="_blank" rel="noopener">团队开发里频繁使用 git rebase 来保持树的整洁好吗?</a></li>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">a-successful-git-branching-model</a></li>
<li><a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88" target="_blank" rel="noopener">Git-分支-分支的衍合</a></li>
<li><a href="http://codecampo.com/topics/379?comment_id=1354#comment-1354" target="_blank" rel="noopener">构造干净的 Git 历史线索</a></li>
<li><a href="http://guides.github.com/overviews/flow/" target="_blank" rel="noopener">Github workflow</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法可视化实现</title>
    <url>/2016/04/27/programmer-sorting-algorithms/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>


<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="/images/sort/Bubble-sort-example-300px.gif" alt="bubble1"></p>
<p><img src="/images/sort/bubble.gif" alt="bubble2"></p>
<p>冒泡排序是与<strong>插入排序</strong>拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。<br>在最好的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。<br>冒泡排序的实现通常会对已经排序好的数列拙劣地运行（O(n^2)），而插入排序在这个例子只需要O(n)个运算。<br><strong>因此很多现代的算法教科书避免使用冒泡排序，而用插入排序替换之。</strong><br>冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最好的复杂度降低到O(n)。<br>在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。<br>有时候称为<strong>鸡尾酒排序</strong>，因为算法会从数列的一端到另一端之间穿梭往返。</p>
<h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a><strong>鸡尾酒排序</strong></h2><p>鸡尾酒排序，也就是<strong>定向冒泡排序</strong>，是冒泡排序的一种变形。<br>此算法与冒泡排序的不同处在于<strong>排序时是以双向在序列中进行排序</strong>。<br>鸡尾酒排序等于是冒泡排序的轻微变形。<strong>不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。</strong></p>
<p><img src="/images/sort/Sorting_shaker_sort_anim.gif" alt="shaker"></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置中</li>
<li>重复步骤2~5</li>
</ol>
<p><img src="/images/sort/220px-Insertion-sort-example-300px.gif" alt="Insertion"></p>
<p><img src="/images/sort/Insertion_sort_animation.gif" alt="Insertion"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h2><ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot），</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。<br>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p><strong>排序效果：</strong></p>
<p><img src="/images/sort/quick.gif" alt="quick"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h2><p><strong>归并排序</strong>是建立在归并操作上的一种有效的排序算法。<br>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p>
<p><strong>步骤：</strong></p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p><img src="/images/sort/220px-Merge_sort_animation2.gif" alt="merge"></p>
<p><img src="/images/sort/Merge-sort-example-300px.gif" alt="merge"></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h2><p>堆积排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。<br>堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><img src="/images/sort/heap.gif" alt="heap"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h2><ol>
<li>首先在未排序序列中找到最小元素，存放到排序序列的起始位置，</li>
<li>然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<p><img src="/images/sort/selection.gif" alt="selection"></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位&gt;</li>
</ol>
<p><img src="/images/sort/shell.gif" alt="shell"></p>
<h2 id="梳排序"><a href="#梳排序" class="headerlink" title="梳排序"></a><strong>梳排序</strong></h2><p>梳排序是改良自冒泡排序和快速排序。</p>
<p>在冒泡排序算法中，只比较阵列中相邻的二项，即比较的二项的间距(Gap)是1，<br>梳排序提出此间距其实可大于1，<strong>改自插入排序的希尔排序同样提出相同观点。</strong><br>梳排序中，开始时的间距设定为阵列长度，并在循环中以固定比率递减，通常递减率设定为1.24。<br>在一次循环中，梳排序如同冒泡排序一样把阵列从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于1。<br>如果间距递减至1，梳排序假定输入阵列大致排序好，并以冒泡排序作最后检查及修正。</p>
<p><img src="/images/sort/Comb_sort_demo.gif" alt="comb"></p>
<ol>
<li><a href="http://functionspace.com/topic/3774/GIFs-of-sorting-algorithms" target="_blank" rel="noopener">GIFs of sorting algorithms</a></li>
<li><a href="http://www.sorting-algorithms.com/" target="_blank" rel="noopener">Sorting Algorithm Animations</a></li>
<li><a href="https://www.reddit.com/r/oddlysatisfying/comments/2gnqtp/this_gif_visualizing_a_sorting_algorithm/" target="_blank" rel="noopener">This gif, visualizing a sorting algorithm</a></li>
<li><a href="https://www.youtube.com/watch?v=kPRA0W1kECg" target="_blank" rel="noopener">15 Sorting Algorithms in 6 Minutes</a></li>
<li><a href="http://www.wtoutiao.com/p/98aDH0.html" target="_blank" rel="noopener">视觉直观感受 7 种常用的排序算法</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">排序算法</a></li>
<li><a href="http://blog.csdn.net/cjf_iceking/article/details/7916194" target="_blank" rel="noopener">插入排序</a></li>
<li><a href="https://github.com/cdmh/sorting_algorithms" target="_blank" rel="noopener">sorting algorithms</a></li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">comparisonSort</a></li>
<li><a href="http://visualgo.net/sorting" target="_blank" rel="noopener">visualgo</a></li>
<li><a href="http://sorting.at/" target="_blank" rel="noopener"><strong>sort algo</strong></a></li>
<li><a href="http://sortvis.org/index.html" target="_blank" rel="noopener">sortvis</a></li>
<li><a href="http://www.codeproject.com/Articles/132757/Visualization-and-Comparison-of-sorting-algorithms" target="_blank" rel="noopener">sort vis tool</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>sorting</tag>
        <tag>algor</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数你应该知道的基础知识</title>
    <url>/2016/04/25/programmer-float/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>


<p>作者：卢钧轶(cenalulu) 本文原文地址：<a href="http://cenalulu.github.io/linux/about-denormalized-float-number/" target="_blank" rel="noopener">http://cenalulu.github.io/linux/about-denormalized-float-number/</a></p>
<p>本文从一个有趣而又令人意外的实验展开，介绍一些关于浮点数你应该知道的基础知识</p>
<h2 id="一个有趣的实验"><a href="#一个有趣的实验" class="headerlink" title="一个有趣的实验"></a>一个有趣的实验</h2><p>本文从一个有趣而诡异的实验开始。最早这个例子博主是从 Stackoverflow上的一个问题中看到的。<br>为了提高可读性，博主这里做了改写，简化成了以下两段代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    const float x=1.1;
    const float z=1.123;
    float y=x;
    for(int j=0;j&lt;90000000;j++)
    {
        y*=x;
        y/=z;
        y+=0.1f;
        y-=0.1f;
    }
    return 0;
}


#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    const float x=1.1;
    const float z=1.123;
    float y=x;
    for(int j=0;j&lt;90000000;j++)
    {
        y*=x;
        y/=z;
        y+=0;
        y-=0;
    }
    return 0;
}</code></pre><p>上面两段代码的唯一差别就是第一段代码中y+=0.1f，而第二段代码中是y+=0。<br>由于y会先加后减同样一个数值，照理说这两段代码的作用和效率应该是完全一样的,当然也是没有任何逻辑意义的。<br>假设现在我告诉你：其中一段代码的效率要比另一段慢7倍。想必读者会认为一定是y+=0.1f的那段慢，毕竟它和y+=0相比看上去要多一些运算。<br><strong>但是，实验结果，却出乎意料， y+=0的那段代码比y+=0.1f足足慢了7倍。</strong><br>世界观被颠覆了有木有？博主是在自己的Macbook Pro上进行的测试，有兴趣的读者也可以在自己的笔记本上试试。<br>（只要是支持SSE2指令集的CPU都会有相似的结果）。</p>
<pre><code>shell&gt; g++ code1.c -o test1
shell&gt; g++ code2.c -o test2
shell&gt; time ./test1

real    0m1.490s
user    0m1.483s
sys     0m0.003s

shell&gt; time ./test2

real    0m9.895s
user    0m9.871s
sys     0m0.009s</code></pre><p>当然 原文中的投票最高的回答解释的非常好，但博主第一次看的时候是一头雾水，因为大部分基础知识已经还给大学老师了。<br>所以，本着知其然还要知其所以然的态度，博主做了一个详尽的分析和思路整理过程。也希望读者能够从0开始解释这个诡异现象的原因。</p>
<h2 id="复习浮点数的二进制转换"><a href="#复习浮点数的二进制转换" class="headerlink" title="复习浮点数的二进制转换"></a>复习浮点数的二进制转换</h2><p>现在让我们复习大学计算机基础课程。<br>如果你熟练掌握了浮点数向二进制表达式转换的方法，那么你可以跳过这节。<br>我们先来看下浮点数二进制表达的三个组成部分。</p>
<p><img src="/images/float/float.png" alt="mmap" title="wizard"></p>
<p>三个主要成分是：</p>
<ul>
<li>Sign（1bit）：表示浮点数是正数还是负数。0表示正数，1表示负数</li>
<li>Exponent（8bits）：指数部分。类似于科学技术法中的M*10^N中的N，只不过这里是以2为底数而不是10。<br>需要注意的是，这部分中是以2^7-1即127，也即01111111代表2^0，转换时需要根据127作偏移调整。</li>
<li>Mantissa（23bits）：基数部分。浮点数具体数值的实际表示。</li>
</ul>
<p>下面我们来看个实际例子来解释下转换过程。 </p>
<ul>
<li>Step 1 改写整数部分 以数值<code>5.2</code>为例。先不考虑指数部分，我们先单纯的将十进制数改写成二进制。 整数部分很简单，<code>5.</code>即<code>101.</code>。</li>
<li>Step 2 改写小数部分 小数部分我们相当于拆成是<code>2^-1</code>一直到<code>2^-N</code>的和。<br>例如： <code>0.2 = 0.125+0.0625+0.007825+0.00390625</code>即<code>2^-3+2^-4+2^-7+2^-8....</code>，也即<code>.00110011001100110011</code></li>
<li>Step 3 规格化 现在我们已经有了这么一串二进制<code>101.00110011001100110011</code>。<br>然后我们要将它规格化，也叫<strong>Normalize</strong>。其实原理很简单就是保证小数点前只有一个bit。<br>于是我们就得到了以下表示：<code>1.0100110011001100110011 * 2^2</code>。<br>到此为止我们已经把改写工作完成，接下来就是要把bit填充到三个组成部分中去了。</li>
<li>Step 4 填充 指数部分（Exponent）：之前说过需要以127作为偏移量调整。<br>因此2的2次方，指数部分偏移成2+127即129，表示成<code>10000001</code>填入。<br>整数部分（Mantissa）：除了简单的填入外，需要特别解释的地方是<code>1.010011</code>中的整数部分1在填充时被舍去了。<br>因为规格化后的数值整部部分总是为1。<br>那大家可能有疑问了，省略整数部分后岂不是<code>1.010011</code>和<code>0.010011</code>就混淆了么？<br>其实并不会，如果你仔细看下后者：会发现他并不是一个规格化的二进制，可以改写成<code>1.0011 * 2^-2</code>。<br>所以省略小数点前的一个bit不会造成任何两个浮点数的混淆。 具体填充后的结果见下图</li>
</ul>
<p><img src="/images/float/float2.png" alt="mmap" title="build"></p>
<p>练习：如果想考验自己是否充分理解这节内容的话，可以随便写一个浮点数尝试转换。通过 浮点二进制转换工具可以验证答案。</p>
<h2 id="什么是Denormalized-Number"><a href="#什么是Denormalized-Number" class="headerlink" title="什么是Denormalized Number"></a>什么是Denormalized Number</h2><p>了解完浮点数的表达以后，不难看出浮点数的精度和指数范围有很大关系。<br>最低不能低过<code>2^-7-1</code>最高不能高过<code>2^8-1</code>（其中剔除了指数部分全0和全1的特殊情况）。<br>如果超出表达范围那么不得不舍弃末尾的那些小数，我们成为overflow和underflow。<br>甚至有时舍弃都无法表示，例如当我们要表示一个：<code>1.00001111*2^-7</code>这样的超小数值的时候就无法用规格化数值表示，<br>如果不想点其他办法的话，CPU内部就只能把它当做0来处理。<br>那么，这样做有什么问题呢？最显然易见的一种副作用就是：当多次做低精度浮点数舍弃的后，就会出现除数为0的exception，导致异常。<br>当然精度失准严重起来也可以要人命，以下这个事件摘自wikipedia</p>
<pre><code>On 25 February 1991, a loss of significance in a MIM-104 Patriot missile battery prevented 
it intercepting an incoming Scud missile in Dhahran, Saudi Arabia, 
contributing to the death of 28 soldiers from the U.S. 
Army’s 14th Quartermaster Detachment.[25] See also: Failure at Dhahran</code></pre><p>于是乎就出现了<strong>Denormalized Number（后称非规格化浮点）</strong>。<br>他和规格浮点的区别在于，<strong>规格浮点约定小数点前一位默认是1。而非规格浮点约定小数点前一位可以为0</strong>，<br>这样小数精度就相当于多了最多<code>2^22</code>范围。</p>
<p>但是，精度的提升是有代价的。由于CPU硬件只支持，或者默认对一个32bit的二进制使用规格化解码。<br>因此需要支持32bit非规格数值的转码和计算的话，需要额外的编码标识，也就是需要额外的硬件或者软件层面的支持。<br>以下是wiki上的两端摘抄，说明了非规格化计算的效率非常低。<br>一般来说，由软件对非规格化浮点数进行处理将带来极大的性能损失，而由硬件处理的情况会稍好一些，<br>但在多数现代处理器上这样的操作仍是缓慢的。<strong>极端情况下，规格化浮点数操作可能比硬件支持的非规格化浮点数操作快100倍。</strong></p>
<pre><code>For example when using NVIDIA’s CUDA platform, on gaming cards, 
calculations with double precision take 3 to 24 times longer to complete than calculations using single precision.</code></pre><p>如果要解释为什么有如此大的性能损耗，那就要需要涉及电路设计了，超出了博主的知识范围。<br>当然万能的wiki也是有答案的，有兴趣的读者可以自行查阅。</p>
<h2 id="回到实验"><a href="#回到实验" class="headerlink" title="回到实验"></a>回到实验</h2><p>总上面的分析中我们得出了以下结论：</p>
<ul>
<li>浮点数表示范围有限，精度受限于指数和底数部分的长度，超过精度的小数部分将会被舍弃（underflow）</li>
<li>为了表示更高精度的浮点数，出现了非规格化浮点数，但是他的计算成本非常高。</li>
<li>于是我们就可以发现通过几十上百次的循环后，y中存放的数值无限接近于零。<br>CPU将他表示为精度更高的非规格化浮点。<br>而当<code>y+0.1f</code>时为了保留跟重要的底数部分，之后无限接近0（也即y之前存的数值）被舍弃，当<code>y-0.1f</code>后，y又退化为了规格化浮点数。<br>并且之后的每次<code>y*x</code>和<code>y/z</code>时，CPU都执行的是规划化浮点运算。<br>而当<code>y+0</code>，由于加上0值后的y仍然可以被表示为非规格化浮点，因此整个循环的四次运算中CPU都会使用非规格浮点计算，效率就大大降低了。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然，也有在程序内部也是有办法控制非规范化浮点的使用的。<br>在相关程序的上下文中加上<code>fesetenv(FE_DFL_DISABLE_SSE_DENORMS_ENV)</code>;<br>就可以迫使CPU放弃使用非规范化浮点计算，提高性能。<br>我们用这种办法修改上面实验中的代码后，<code>y+=0</code>的效率就和<code>y+=0.1f</code>就一样了。<br>甚至还比y+=0.1f更快了些，世界观又端正了不是么:) 修改后的代码如下</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fenv.h&gt;
using namespace std;

int main() {
    fesetenv(FE_DFL_DISABLE_SSE_DENORMS_ENV);
    const float x=1.1;
    const float z=1.123;
    float y=x;
    for(int j=0;j&lt;90000000;j++)
    {
        y*=x;
        y/=z;
        y+=0;
        y-=0;
    }
    return 0;
}</code></pre><p>Reference</p>
<p>什么是非规格化浮点数<br><a href="http://stackoverflow.com/questions/9314534/why-does-changing-0-1f-to-0-slow-down-performance-by-10x" target="_blank" rel="noopener">Why does changing 0.1f to 0 slow down performance by 10x? IEEE floating point Floating point Denormal number</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全Vim快捷键键位图 -- 入门到进阶</title>
    <url>/2016/04/25/programmer-vim-cheatsheat/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<p>作者：卢钧轶(cenalulu) 本文原文地址：<a href="http://cenalulu.github.io/linux/all-vim-cheatsheat/" target="_blank" rel="noopener">http://cenalulu.github.io/linux/all-vim-cheatsheat/</a></p>
<h2 id="经典版"><a href="#经典版" class="headerlink" title="经典版"></a>经典版</h2><p>下面这个键位图应该是大家最常看见的经典版了。<br>其实这个版本是一系列的入门教程键位图的组合结果。<br>要查看不同编辑模式下的键位图，可以看<a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html" target="_blank" rel="noopener">这里打包下载</a><br>此外，这里还有简体中文版。</p>
<img src="/images/vim/classic.gif" height="400" width="600" />


<hr>
<h2 id="入门版"><a href="#入门版" class="headerlink" title="入门版"></a>入门版</h2><p>基本操作的入门版。<br><a href="https://github.com/ahrencode/Miscellaneous" target="_blank" rel="noopener">原版出处</a>还有keynote版本可供DIY以及其他相关有用的cheatsheet。</p>
<img src="/images/vim/entry.png" height="400" width="600" />

<hr>
<h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p>下图是300DPI的超清大图，<br>另外<a href="http://michael.peopleofhonoronly.com/vim/" target="_blank" rel="noopener">查看原文</a>还有更多版本：黑白，低分辨率，色盲等</p>
<img src="/images/vim/advanced.png" height="400" width="600" />


<hr>
<h2 id="增强版"><a href="#增强版" class="headerlink" title="增强版"></a>增强版</h2><p>下图是一个更新时间较新的现代版，含有的信息也更丰富。<br><a href="http://vimcheatsheet.com/" target="_blank" rel="noopener">原文链接</a></p>
<img src="/images/vim/morden.png" height="400" width="600" />


<hr>
<h2 id="文字版"><a href="#文字版" class="headerlink" title="文字版"></a>文字版</h2><p><a href="http://tnerual.eriogerg.free.fr/vimqrc.pdf" target="_blank" rel="noopener">原文链接</a></p>
<img src="/images/vim/text.png" height="400" width="600" />
<img src="/images/vim/text2.png" height="400" width="600" />



]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>程序优化</title>
    <url>/2016/04/24/programmer-optimize/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>


<p>程序优化是指程序效率的优化。一般来说，程序优化主要是以下三个步骤：</p>
<ol>
<li>算法优化</li>
<li>代码优化</li>
<li>指令优化</li>
</ol>
<h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a><strong>算法优化</strong></h2><p>算法上的优化是必须首要考虑的，也是最重要的一步。<br>一般我们需要分析算法的时间复杂度，即处理时间与输入数据规模的一个量级关系，<br>一个优秀的算法可以将算法复杂度降低若干量级，<br>那么同样的实现，其平均耗时一般会比其他复杂度高的算法少（这里不代表任意输入都更快）。</p>
<p>比如说排序算法，快速排序的时间复杂度为O(nlogn)，<br>而插入排序的时间复杂度为O(n*n)，那么在统计意义下，快速排序会比插入排序快，<br>而且随着输入序列长度n的增加，两者耗时相差会越来越大。<br>但是，假如输入数据本身就已经是升序(或降序)，那么实际运行下来，快速排序会更慢。</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a><strong>代码优化</strong></h2><p>代码优化一般需要与算法优化同步进行，代码优化主要是涉及到具体的编码技巧。<br>同样的算法与功能，不同的写法也可能让程序效率差异巨大。<br>一般而言，代码优化主要是针对循环结构进行分析处理。</p>
<h3 id="避免循环内部的乘-除-法以及冗余计算"><a href="#避免循环内部的乘-除-法以及冗余计算" class="headerlink" title="避免循环内部的乘(除)法以及冗余计算"></a><strong>避免循环内部的乘(除)法以及冗余计算</strong></h3><p>能把运算放在循环外的尽量提出去放在外部，循环内部不必要的乘除法可使用加法来替代等。</p>
<h3 id="避免循环内部有过多依赖和跳转，使cpu能流水起来"><a href="#避免循环内部有过多依赖和跳转，使cpu能流水起来" class="headerlink" title="避免循环内部有过多依赖和跳转，使cpu能流水起来"></a><strong>避免循环内部有过多依赖和跳转，使cpu能流水起来</strong></h3><p>关于CPU流水线技术可google/baidu，循环结构内部计算或逻辑过于复杂，将导致cpu不能流水，<br>那这个循环就相当于拆成了n段重复代码的效率。</p>
<pre><code>for(int i = 0; i &lt; N; i++)
{
    if(i &lt; 100) a[i] += 5;
    else if(i &lt; 200) a[i] += 10;
    else a[i] += 20;
}</code></pre><p>优化为：</p>
<pre><code>for(int i = 0; i &lt; 100; i++)
{
    a[i] += 5;
}
for(int i = 100; i &lt; 200; i++)
{
    a[i] += 10;
}
for(int i = 200; i &lt; N; i++)
{
    a[i] += 20;
}</code></pre><h3 id="定点化"><a href="#定点化" class="headerlink" title="定点化"></a><strong>定点化</strong></h3><p>定点化的思想是将浮点运算转换为整型运算，<br>定点化的做法是将数据乘上一个很大的数后，将所有运算转换为整数计算。<br>例如某个乘法我只关心小数点后3位，那把数据都乘上10000后，进行整型运算的结果也就满足所需的精度了。</p>
<h3 id="以空间换时间"><a href="#以空间换时间" class="headerlink" title="以空间换时间"></a><strong>以空间换时间</strong></h3><p>空间换时间最经典的就是查表法了，某些计算相当耗时，但其自变量的值域是比较有限的，<br>这样的情况可以预先计算好每个自变量对应的函数值，存在一个表格中，每次根据自变量的值去索引对应的函数值即可。</p>
<h3 id="预分配内存"><a href="#预分配内存" class="headerlink" title="预分配内存"></a><strong>预分配内存</strong></h3><p>预分配内存主要是针对需要循环处理数据的情况的。<br>比如视频处理，每帧图像的处理都需要一定的缓存，如果每帧申请释放，则势必会降低算法效率</p>
<h2 id="指令优化"><a href="#指令优化" class="headerlink" title="指令优化"></a><strong>指令优化</strong></h2><p>略。</p>
<h2 id="如何定位程序热点"><a href="#如何定位程序热点" class="headerlink" title="如何定位程序热点"></a><strong>如何定位程序热点</strong></h2><p>程序热点是指程序中最耗时的部分，一般程序优化工作都是优先去优化热点部分，那么如何来定位程序热点呢？</p>
<p>一般而言，主要有2种方法，一种是通过观察与分析，通过分析算法，自然能知道程序热点；<br>另一方面，观察代码结构，一般具有最大循环的地方就是热点，这也是前面那些优化手段都针对循环结构的原因。<br>另一种方法就是利用工具来找程序热点。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Prof</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>堆和栈</title>
    <url>/2016/04/24/programmer-stack-and-heap/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><p>编程语言书籍中经常解释值类型被创建在栈上，引用类型被创建在堆上，但是并没有本质上解释这堆和栈是什么。<br>我仅有高级语言编程经验，没有看过对此更清晰的解释。<br>我的意思是我理解什么是栈，但是它们到底是什么，在哪儿呢（站在实际的计算机物理内存的角度上看）？<br>在通常情况下由操作系统（OS）和语言的运行时（runtime）控制吗？<br>它们的作用范围是什么？<br>它们的大小由什么决定？<br>哪个更快？</p>
<h2 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a><strong>答案一</strong></h2><p>栈是为执行线程留出的内存空间。当函数被调用的时候，栈顶为局部变量和一些 bookkeeping 数据预留块。<br>当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。<br>栈通常用后进先出（LIFO）的方式预留空间；<br>因此最近的保留块（reserved block）通常最先被释放。<br>这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。</p>
<p>堆（heap）是为动态分配预留的内存空间。<br>和栈不一样，从堆上分配和重新分配块没有固定模式；<br>你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；<br>有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。</p>
<p>每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。</p>
<p>直接回答你的问题： </p>
<ol>
<li>当线程创建的时候，操作系统（OS）为每一个系统级（system-level）的线程分配栈。<br>通常情况下，操作系统通过调用语言的运行时（runtime）去为应用程序分配堆。 </li>
<li>栈附属于线程，因此当线程结束时栈被回收。<br>堆通常通过运行时在应用程序启动时被分配，当应用程序（进程）退出时被回收。 </li>
<li>当线程被创建的时候，设置栈的大小。<br>在应用程序启动的时候，设置堆的大小，但是可以在需要的时候扩展（分配器向操作系统申请更多的内存）。 </li>
<li>栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算），<br>然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。<br>另外，在栈上的每个字节频繁的被复用也就意味着它可能映射到处理器缓存中，所以很快（译者注：局部性原理）。</li>
</ol>
<h2 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a><strong>答案二</strong></h2><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><strong>Stack</strong></h3><ul>
<li>和堆一样存储在计算机 RAM 中。</li>
<li>在栈上创建变量的时候会扩展，并且会自动回收。</li>
<li>相比堆而言在栈上分配要快的多。</li>
<li>用数据结构中的栈实现。</li>
<li>存储局部数据，返回地址，用做参数传递。</li>
<li>当用栈过多时可导致栈溢出（无穷次（大量的）的递归调用，或者大量的内存分配）。</li>
<li>在栈上的数据可以直接访问（不是非要使用指针访问）。</li>
<li>如果你在编译之前精确的知道你需要分配数据的大小并且不是太大的时候，可以使用栈。</li>
<li>当你程序启动时决定栈的容量上限。</li>
</ul>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a><strong>Heap</strong></h3><ul>
<li>和栈一样存储在计算机RAM。</li>
<li>在堆上的变量必须要手动释放，不存在作用域的问题。数据可用 delete, delete[] 或者 free 来释放。</li>
<li>相比在栈上分配内存要慢。</li>
<li>通过程序按需分配。</li>
<li>大量的分配和释放可造成内存碎片。</li>
<li>在 C++ 中，在堆上创建数的据使用指针访问，用 new 或者 malloc 分配内存。</li>
<li>如果申请的缓冲区过大的话，可能申请失败。</li>
<li>在运行期间你不知道会需要多大的数据或者你需要分配大量的内存的时候，建议你使用堆。</li>
<li>可能造成内存泄露。</li>
</ul>
<h2 id="答案三"><a href="#答案三" class="headerlink" title="答案三"></a><strong>答案三</strong></h2><p>堆和栈是两种内存分配的两个统称。可能有很多种不同的实现方式，但是实现要符合几个基本的概念:</p>
<ol>
<li>对栈而言，栈中的新加数据项放在其他数据的顶部，移除时你也只能移除最顶部的数据（不能越位获取）。</li>
<li>对堆而言，数据项位置没有固定的顺序。你可以以任何顺序插入和删除，因为他们没有“顶部”数据这一概念。</li>
</ol>
<h3 id="在通常情况下由操作系统（OS）和语言的运行时（runtime）控制吗？"><a href="#在通常情况下由操作系统（OS）和语言的运行时（runtime）控制吗？" class="headerlink" title="在通常情况下由操作系统（OS）和语言的运行时（runtime）控制吗？"></a><strong>在通常情况下由操作系统（OS）和语言的运行时（runtime）控制吗？</strong></h3><p>如前所述，堆和栈是一个统称，可以有很多的实现方式。<br>计算机程序通常有一个栈叫做调用栈，<br>用来存储当前函数调用相关的信息（比如：主调函数的地址，局部变量），<br>因为函数调用之后需要返回给主调函数。<br>栈通过扩展和收缩来承载信息。<br>实际上，程序不是由运行时来控制的，它由编程语言、操作系统甚至是系统架构来决定。</p>
<p>堆是在任何内存中动态和随机分配的（内存的）统称；<br>也就是无序的。内存通常由操作系统分配，通过应用程序调用 API 接口去实现分配。<br>在管理动态分配内存上会有一些额外的开销，不过这由操作系统来处理。</p>
<h3 id="它们的作用范围是什么？"><a href="#它们的作用范围是什么？" class="headerlink" title="它们的作用范围是什么？"></a><strong>它们的作用范围是什么？</strong></h3><p>调用栈是一个低层次的概念，就程序而言，它和“作用范围”没什么关系。<br>如果你反汇编一些代码，你就会看到指针引用堆栈部分。<br>就高级语言而言，语言有它自己的范围规则。<br>一旦函数返回，函数中的局部变量会直接直接释放。你的编程语言就是依据这个工作的。</p>
<p>在堆中，也很难去定义。<br>作用范围是由操作系统限定的，但是你的编程语言可能增加它自己的一些规则，去限定堆在应用程序中的范围。<br>体系架构和操作系统是使用虚拟地址的，然后由处理器翻译到实际的物理地址中，还有页面错误等等。<br>它们记录那个页面属于那个应用程序。不过你不用关心这些，<br>因为你仅仅在你的编程语言中分配和释放内存，和一些错误检查（出现分配失败和释放失败的原因）。</p>
<h3 id="它们的大小由什么决定？"><a href="#它们的大小由什么决定？" class="headerlink" title="它们的大小由什么决定？"></a><strong>它们的大小由什么决定？</strong></h3><p>依旧，依赖于语言，编译器，操作系统和架构。<br>栈通常提前分配好了，因为栈必须是连续的内存块。<br>语言的编译器或者操作系统决定它的大小。<strong>不要在栈上存储大块数据，这样可以保证有足够的空间不会溢出</strong>，<br>除非出现了无限递归的情况（额，栈溢出了）或者其它不常见了编程决议。</p>
<p>堆是任何可以动态分配的内存的统称。<br>这要看你怎么看待它了，它的大小是变动的。<br>在现代处理器中和操作系统的工作方式是高度抽象的，<br>因此你在正常情况下不需要担心它实际的大小，除非你必须要使用你还没有分配的内存或者已经释放了的内存。</p>
<h3 id="哪个更快一些？"><a href="#哪个更快一些？" class="headerlink" title="哪个更快一些？"></a><strong>哪个更快一些？</strong></h3><p>栈更快因为所有的空闲内存都是连续的，因此不需要对空闲内存块通过列表来维护。<br>只是一个简单的指向当前栈顶的指针。<br>编译器通常用一个专门的、快速的寄存器来实现。<br>更重要的一点事是，随后的栈上操作通常集中在一个内存块的附近，这样的话有利于处理器的高速访问（译者注：局部性原理）。</p>
<h2 id="答案四"><a href="#答案四" class="headerlink" title="答案四"></a><strong>答案四</strong></h2><p>你问题的答案是依赖于实现的，根据不同的编译器和处理器架构而不同。下面简单的解释一下：</p>
<ol>
<li>栈和堆都是用来从底层操作系统中获取内存的。</li>
<li>在多线程环境下每一个线程都可以有他自己完全的独立的栈，但是他们共享堆。并行存取被堆控制而不是栈。</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h3><ol>
<li><strong>堆包含一个链表来维护已用和空闲的内存块。</strong><br>在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块。<br>这个操作会更新堆中的块链表。这些元信息也存储在堆上，经常在每个块的头部一个很小区域。</li>
<li><strong>堆的增加通常从低地址向高地址扩展。因此你可以认为堆随着内存分配而不断的增加大小。</strong><br>如果申请的内存大小很小的话，通常从底层操作系统中得到比申请大小要多的内存。</li>
<li>申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。<br>进而申请大块内存失败，虽然空闲块的总和足够，但是空闲的小块是零散的，不能满足申请的大小。这叫做“堆碎片”。</li>
<li>当旁边有空闲块的已用块被释放时，新的空闲块可能会与相邻的空闲块合并为一个大的空闲块，这样可以有效的减少“堆碎片”的产生。</li>
</ol>
<p><img src="/images/stack_heap/0" alt="Heap"></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h3><ol>
<li>栈经常与 sp 寄存器（译者注：”stack pointer”，了解汇编的朋友应该都知道）一起工作，最初 sp 指向栈顶（栈的高地址）。</li>
<li>CPU 用 push 指令来将数据压栈，用 pop 指令来弹栈。</li>
</ol>
<p><strong>当用 push 压栈时，sp 值减少（向低地址扩展）。当用 pop 弹栈时，sp 值增大。</strong>存储和获取数据都是 CPU 寄存器的值。<br>3. 当函数被调用时，CPU使用特定的指令把当前的 IP （译者注：“instruction pointer”，是一个寄存器，用来记录 CPU 指令的位置）压栈。<br>即执行代码的地址。CPU 接下来将调用函数地址赋给 IP ，进行调用。当函数返回时，旧的 IP 被弹栈，CPU 继续去函数调用之前的代码。<br>4. 当进入函数时，sp 向下扩展，扩展到确保为函数的局部变量留足够大小的空间。<br>如果函数中有一个 32-bit 的局部变量会在栈中留够四字节的空间。当函数返回时，sp 通过返回原来的位置来释放空间。<br>5. 如果函数有参数的话，在函数调用之前，会将参数压栈。函数中的代码通过 sp 的当前位置来定位参数并访问它们。<br>6. 函数嵌套调用和使用魔法一样，每一次新调用的函数都会分配函数参数，<br>返回值地址、局部变量空间、嵌套调用的活动记录都要被压入栈中。函数返回时，按照正确方式的撤销。<br>7. <strong>栈要受到内存块的限制，不断的函数嵌套/为局部变量分配太多的空间，可能会导致栈溢出。</strong><br>当栈中的内存区域都已经被使用完之后继续向下写（低地址），会触发一个 CPU 异常。<br>这个异常接下会通过语言的运行时转成各种类型的栈溢出异常。</p>
<p><img src="/images/stack_heap/1" alt="Stack"></p>
<h3 id="函数的分配可以用堆来代替栈吗？"><a href="#函数的分配可以用堆来代替栈吗？" class="headerlink" title="函数的分配可以用堆来代替栈吗？"></a><strong>函数的分配可以用堆来代替栈吗？</strong></h3><p>不可以的，函数的活动记录（即局部或者自动变量）被分配在栈上， 这样做不但存储了这些变量，而且可以用来嵌套函数的追踪。</p>
<p>堆的管理依赖于运行时环境，C 使用 malloc ，C++ 使用 new ，但是很多语言有垃圾回收机制。</p>
<p><strong>栈是更低层次的特性与处理器架构紧密的结合到一起。<br>当堆不够时可以扩展空间，这不难做到，因为可以有库函数可以调用。<br>但是，扩展栈通常来说是不可能的，因为在栈溢出的时候，执行线程就被操作系统关闭了，这已经太晚了。</strong></p>
<p>1.<a href="http://mp.weixin.qq.com/s?__biz=MjM5OTA1MDUyMA==&mid=206795684&idx=1&sn=c0edf55884ce6145540dcfe8309d1706#rd" target="_blank" rel="noopener">什么是堆和栈，它们在哪儿？</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>C</category>
        <category>Memory</category>
        <category>MM</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>stack</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Git详解系列</title>
    <url>/2016/04/20/git-lists/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ol start="0">
<li><a href="https://github.com/GitbookIO/git/blob/master/zh/SUMMARY.md" target="_blank" rel="noopener">Scott Chacon’s book: Pro Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069609436.html" target="_blank" rel="noopener">Git详解之一 Git起步</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069733264.html" target="_blank" rel="noopener">Git详解之二 Git基础</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069889514.html" target="_blank" rel="noopener">Git详解之三 Git分支</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069988843.html" target="_blank" rel="noopener">Git详解之四 服务器上的Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070090108.html" target="_blank" rel="noopener">Git详解之五 分布式Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070367499.html" target="_blank" rel="noopener">Git详解之六 Git工具</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070404827.html" target="_blank" rel="noopener">Git详解之七 自定义Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070454218.html" target="_blank" rel="noopener">Git详解之八 Git与其他系统</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070620202.html" target="_blank" rel="noopener">Git详解之九 Git内部原理</a></li>
</ol>
<p>##</p>
<ol>
<li><a href="http://www.open-open.com/lib/view/open1427092544277.html" target="_blank" rel="noopener">Git 基本原理与常用命令</a></li>
<li><a href="http://www.open-open.com/lib/view/open1449149989405.html" target="_blank" rel="noopener">高质量的Git中文教程</a></li>
<li><a href="http://www.open-open.com/lib/view/open1402748724087.html" target="_blank" rel="noopener">Git远程操作详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>webs</tag>
      </tags>
  </entry>
  <entry>
    <title>git pull与git fetch区别</title>
    <url>/2016/04/20/git-pull-and-fetch/</url>
    <content><![CDATA[<p>Git中从远程的分支获取最新的版本到本地有这样2个命令：</p>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>相当于是从远程获取最新版本到本地，不会自动merge</p>
<pre><code>git fetch origin master
git log -p master..origin/master
git merge origin/master</code></pre><p>以上命令的含义：</p>
<ul>
<li>首先从远程的origin的master主分支下载最新的版本到origin/master分支上</li>
<li>然后比较本地的master分支和origin/master分支的差别</li>
<li>最后进行合并</li>
</ul>
<p>上述过程其实可以用以下更清晰的方式来进行：</p>
<pre><code>git fetch origin master:tmp
git diff tmp 
git merge tmp</code></pre><p>从远程获取最新的版本到本地的test分支上，之后再进行比较合并</p>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>相当于是从远程获取最新版本并merge到本地</p>
<pre><code>git pull origin master</code></pre><p>上述命令其实相当于</p>
<pre><code>git fetch 
git merge</code></pre><p>在实际使用中，git fetch更安全一些<br>因为在merge前，我们可以查看更新情况，然后再决定是否合并</p>
<ol>
<li><a href="http://www.cnblogs.com/flying_bat/p/3408634.html" target="_blank" rel="noopener">Git 少用 Pull 多用 Fetch 和 Merge</a></li>
<li><a href="http://blog.csdn.net/a19881029/article/details/42245955" target="_blank" rel="noopener">git fetch和git pull之间的区别</a></li>
<li><a href="http://www.cnblogs.com/ToDoToTry/p/4095626.html" target="_blank" rel="noopener">真正理解 git fetch, git pull 以及 FETCH_HEAD</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中的撤销操作</title>
    <url>/2016/04/18/git-undo/</url>
    <content><![CDATA[<p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，<br>当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<hr>
<h2 id="撤销一个已提交修改"><a href="#撤销一个已提交修改" class="headerlink" title="撤销一个已提交修改"></a><strong>撤销一个已提交修改</strong></h2><p>撤销某次提交，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交</p>
<pre><code>git revert HEAD   撤销前一次 commit
git revert HEAD^  撤销前前一次 commit
git revert commit （比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。</code></pre><p>git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容</p>
<h2 id="修改最近一次的提交信息"><a href="#修改最近一次的提交信息" class="headerlink" title="修改最近一次的提交信息"></a><strong>修改最近一次的提交信息</strong></h2><p>提交时，可能没写好或者误操作导致提交的信息不合适，但你还没有 push 到远程分支时，修改上一次的提交信息。</p>
<pre><code>git commit –amend或git commit --amend -m &quot;Fixes bug #42&quot;</code></pre><p>如果需要修改已push的文件，需要如下操作：</p>
<pre><code>git rebase -i HEAD~3 
git commit -amend 
git rebase --continue</code></pre><h2 id="撤销本地修改"><a href="#撤销本地修改" class="headerlink" title="撤销本地修改"></a><strong>撤销本地修改</strong></h2><pre><code>git checkout -- file</code></pre><p><code>git checkout -- file</code>可以丢弃工作区的修改，把file文件在工作区的修改全部撤销，这里有两种情况：</p>
<ol>
<li>一种是自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ol>
<p>总之，就是<strong>让这个文件回到最近一次git commit或git add时的状态。</strong></p>
<h2 id="重置修改"><a href="#重置修改" class="headerlink" title="重置修改"></a><strong>重置修改</strong></h2><p>已经使用<code>git add</code>，但是没有使用<code>git commit</code>，需要修改暂存区内容：</p>
<pre><code>git reset HEAD file</code></pre><p>仅用HEAD指向的目录树充值暂存区，工作区不受影响。相当于把git add命令更新到暂存区的内容撤出暂存区</p>
<pre><code>git reset --hard HEAD^</code></pre><p>把版本库、暂存区和工作区都回退到HEAD的前一个版本。head版本的提交全部丢失。慎用！</p>
<pre><code>git reset --hard HEAD</code></pre><p>等价与：</p>
<pre><code>git reset HEAD file
git checkout -- file</code></pre><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><strong>版本回退</strong></h2><pre><code>git reset --hard HEAD^
git reset --hard commit_id</code></pre><h2 id="撤销本地后重做"><a href="#撤销本地后重做" class="headerlink" title="撤销本地后重做"></a><strong>撤销本地后重做</strong></h2><p>已经提交了一些内容，并使用git reset –hard撤销了这些更改（见上面），突然意识到：你想还原这些修改！</p>
<pre><code>git reflog</code></pre><p>git reflog是一个用来恢复项目历史记录的好办法。你可以通过git reflog恢复几乎任何已提交的内容。<br>git reflog与git log类似，只不过git reflog显示的是HEAD变更次数的列表。</p>
<p>具体一个例子，假设有三个commit， </p>
<pre><code>git st:
commit3: add test3.c
commit2: add test2.c
commit1: add test1.c</code></pre><p>如果执行git reset –hard HEAD~1则 删除了commit3，如果发现删除错误了，需要恢复commit3，这个时候就要使用</p>
<pre><code>git reflog
HEAD@{0}: HEAD~1: updating HEAD
63ee781 HEAD@{1}: commit: test3:q</code></pre><p>运行git log则没有这一行记录，可以使用git reset –hard 63ee781将红色记录删除，则恢复了cmmit3，运行git log后可以看到：</p>
<pre><code>git reset --hard 63ee781
git log
commit3: add test3.c
commit2: add test2.c
commit1: add test1.c</code></pre><h2 id="停止跟踪一个已被跟踪的文件"><a href="#停止跟踪一个已被跟踪的文件" class="headerlink" title="停止跟踪一个已被跟踪的文件"></a><strong>停止跟踪一个已被跟踪的文件</strong></h2><p>场景：你意外将application.log添加到仓库中，现在你每次运行程序，Git都提示application.log中有unstaged的提交。<br>你在.gitignore中写上”*.log”，但仍旧没用——怎样告诉Git“撤销”跟踪这个文件的变化呢？</p>
<pre><code>git rm --cached application.log</code></pre><p>发生了什么：尽管.gitignore阻止Git跟踪文件的变化，甚至是之前没被跟踪的文件是否存在，<br>但是，一旦文件被add或者commit，Git会开始持续跟踪这 个文件的变化。<br>类似的，如果你用git add –f来“强制”add，或者覆盖.gitignore，Git还是会继续监视变化。所以以后最好不要使用 –f来add .gitignore文件。</p>
<p>如果你希望移除那些应当被忽略的文件，git rm –cached可以帮助你，并将这些文件保留在磁盘上。<br>因为这个文件现在被忽略了，你将不会在git status中看到它，也不会再把这个文件commit了。</p>
<h2 id="git-reset-与-git-revert"><a href="#git-reset-与-git-revert" class="headerlink" title="git reset 与 git revert"></a>git reset 与 git revert</h2><p><strong>git revert</strong> 是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留</p>
<p><strong>git reset</strong> 是回到某次提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区</p>
<p>假设有三个commit， </p>
<pre><code>git st
commit3: add test3.c
commit2: add test2.c
commit1: add test1.c</code></pre><p>当执行git revert HEAD~1时， commit2被撤销了，git log可以看到：</p>
<p>revert “commit2”:this reverts commit 5fe21s2…<br>commit3: add test3.c<br>commit2: add test2.c<br>commit1: add test1.c</p>
<p><strong>git status 没有任何变化</strong>，如果换做执行git reset –soft(默认) HEAD~1后，运行git log</p>
<pre><code>commit2: add test2.c
commit1: add test1.c</code></pre><p><strong>运行git status， 则test3.c处于暂存区，准备提交。</strong></p>
<p>如果换做执行git reset –hard HEAD~1后，</p>
<p>显示：HEAD is now at commit2，运行git log</p>
<pre><code>commit2: add test2.c
commit1: add test1.c</code></pre><p><strong>运行git st， 没有任何变化，工作目录文件也不存在</strong></p>
<ol>
<li><a href="http://www.open-open.com/lib/view/open1434097780473.html" target="_blank" rel="noopener">如何在Git中撤销一切</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000" target="_blank" rel="noopener">撤销修改</a></li>
<li><a href="http://www.oschina.net/translate/10-tips-git-next-level" target="_blank" rel="noopener">10 个迅速提升你 Git 水平的提示</a></li>
<li><a href="https://segmentfault.com/q/1010000000430041" target="_blank" rel="noopener">团队开发里频繁使用 git rebase 来保持树的整洁好吗?</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandoc 实现 markdown 多格式自由转换</title>
    <url>/2016/04/18/markdown-to-html/</url>
    <content><![CDATA[<p>Pandoc 是由 John MacFarlane 开发的标记语言转换工具，可实现不同标记语言间的格式转换</p>
<a id="more"></a>

<h2 id="pandoc安装"><a href="#pandoc安装" class="headerlink" title="pandoc安装"></a>pandoc安装</h2><ul>
<li><a href="https://github.com/jgm/pandoc" target="_blank" rel="noopener">GitHub</a></li>
<li><a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md" target="_blank" rel="noopener">Installing pandoc</a></li>
<li><a href="https://github.com/jgm/pandoc/releases/tag/2.9.2" target="_blank" rel="noopener">Latest release</a></li>
</ul>
<p>除了各个操作系统软件仓库之外可以使用 <code>Haskell</code> 平台安装</p>
<pre><code class="bash">cabal update
cabal install pandoc</code></pre>
<p>或安装包</p>
<pre><code class="bash">sudo dpkg -i $DEB</code></pre>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><a href="https://pandoc.org/MANUAL.html" target="_blank" rel="noopener">Pandoc User’s Guide</a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://pandoc.org/demos.html" target="_blank" rel="noopener">Examples</a></p>
<ol>
<li>HTML fragment:<pre><code>pandoc MANUAL.txt -o example1.html</code></pre></li>
<li>Standalone HTML file:<pre><code>pandoc -s MANUAL.txt -o example2.html</code></pre></li>
<li>HTML with table of contents, CSS, and custom footer:<pre><code>pandoc -s --toc -c pandoc.css -A footer.html MANUAL.txt -o example3.html</code></pre></li>
<li>LaTeX:<pre><code>pandoc -s MANUAL.txt -o example4.tex</code></pre></li>
<li>From LaTeX to markdown:<pre><code>pandoc -s example4.tex -o example5.text</code></pre></li>
<li>Man page:<pre><code>pandoc -s -t man pandoc.1.md -o example10.1</code></pre></li>
<li>Converting a web page to markdown:<pre><code>pandoc -s -r html http://www.gnu.org/software/make/ -o example12.text</code></pre></li>
<li>From markdown to PDF:<pre><code>pandoc MANUAL.txt --pdf-engine=xelatex -o example13.pdf</code></pre></li>
<li>HTML slide shows: DZSlides演示框架幻灯片<pre><code>pandoc -s --mathml -i -t dzslides SLIDES -o example16a.html
pandoc -s --webtex -i -t slidy SLIDES -o example16b.html
pandoc -s --mathjax -i -t revealjs SLIDES -o example16d.html</code></pre></li>
<li>TeX math in HTML:<pre><code>pandoc math.text -s -o mathDefault.html
pandoc math.text -s --mathml  -o mathMathML.html
pandoc math.text -s --webtex  -o mathWebTeX.html
pandoc math.text -s --mathjax -o mathMathJax.html
pandoc math.text -s --katex   -o mathKaTeX.html</code></pre></li>
<li>Word docx:<pre><code>pandoc -s MANUAL.txt -o example29.docx</code></pre></li>
<li>LaTeX math to docx:<pre><code>pandoc -s math.tex -o example30.docx</code></pre></li>
<li>DocBook to markdown:<pre><code>pandoc -f docbook -t markdown -s howto.xml -o example31.text</code></pre></li>
<li>Docx with a reference docx:<pre><code>pandoc --reference-doc twocolumns.docx -o UsersGuide.docx MANUAL.txt</code></pre></li>
</ol>
<h2 id="Pandoc-编辑器"><a href="#Pandoc-编辑器" class="headerlink" title="Pandoc 编辑器"></a>Pandoc 编辑器</h2><p><a href="https://github.com/vim-pandoc/vim-pandoc" target="_blank" rel="noopener">vim-pandoc</a><br><a href="https://github.com/textmate/textmate" target="_blank" rel="noopener">textmate osx</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://www.yangzhiping.com/tech/pandoc.html" target="_blank" rel="noopener">Markdown写作进阶：Pandoc入门浅谈</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Pandoc" target="_blank" rel="noopener">Pandoc</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>markdown</tag>
        <tag>html</tag>
        <tag>pandoc</tag>
      </tags>
  </entry>
  <entry>
    <title>minicom高级用法及自动发送数据</title>
    <url>/2016/04/05/minicom/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="minicom选项"><a href="#minicom选项" class="headerlink" title="minicom选项"></a>minicom选项</h2><h3 id="支持颜色显示"><a href="#支持颜色显示" class="headerlink" title="支持颜色显示"></a>支持颜色显示</h3><pre><code>minicom -c on</code></pre><h3 id="支持中文显示"><a href="#支持中文显示" class="headerlink" title="支持中文显示"></a>支持中文显示</h3><pre><code>env LANG=en_US minicom</code></pre><h3 id="支持数据十六进制显示"><a href="#支持数据十六进制显示" class="headerlink" title="支持数据十六进制显示"></a>支持数据十六进制显示</h3><pre><code>minicom -H</code></pre><h3 id="支持脚本"><a href="#支持脚本" class="headerlink" title="支持脚本"></a>支持脚本</h3><pre><code>minicom -S</code></pre><h3 id="支持回显"><a href="#支持回显" class="headerlink" title="支持回显"></a>支持回显</h3><pre><code>minicom
Ctrl+A-&gt;Z
E local Echo on/off..E</code></pre><h2 id="minicom自动发送数据"><a href="#minicom自动发送数据" class="headerlink" title="minicom自动发送数据"></a>minicom自动发送数据</h2><p>首先需要设置：</p>
<pre><code>-&gt; minicom 
-&gt; Ctrl+A-&gt;O 
-&gt; 回车 
-&gt; 选D- Script Program 
-&gt; 设置为 /bin/bash
-&gt; 保存为默认设置 dfl
-&gt; Ctrl+A , Q 退出minicom</code></pre><h3 id="通过启动时指定脚本来实现"><a href="#通过启动时指定脚本来实现" class="headerlink" title="通过启动时指定脚本来实现"></a>通过启动时指定脚本来实现</h3><pre><code>minicom -S autosend.sh</code></pre><p>脚本如下：</p>
<pre><code>#!/bin/bash

while [ 1 -ne 0  ]
do
    echo 12345678
    sleep 1
done</code></pre><h3 id="启动之后，指定脚本路径来执行"><a href="#启动之后，指定脚本路径来执行" class="headerlink" title="启动之后，指定脚本路径来执行"></a>启动之后，指定脚本路径来执行</h3><pre><code>minicom -H
Ctrl+A-&gt;Z
回车
G run script (Go)
C Name of script 绝对路径
回车运行脚本</code></pre><h3 id="使用外部脚本"><a href="#使用外部脚本" class="headerlink" title="使用外部脚本"></a>使用外部脚本</h3><p>不通过minicom执行相关脚本，直接在其他窗口执行脚本如下：</p>
<pre><code>#!/bin/bash

while [ 1 -ne 0  ]
do
    echo 12345678 &gt; /dev/ttyUSB0
    sleep 1
done</code></pre><h2 id="串口与Shell编程"><a href="#串口与Shell编程" class="headerlink" title="串口与Shell编程"></a>串口与Shell编程</h2><p>在这之前先介绍一下stty,stty(set tty)命令用于检查和修改当前注册的终端的通信参数。</p>
<pre><code>stty -a 查看当前注册端口的设置情况：
stty -ixon将流控制设置为OFF，而命令
stty ixon则将流控其置为ON。</code></pre><p>在stty命令中可以同时设置多个选项：stty ixon 1200<br>设置波特率为1200 并且设置流控为on<br>具体更多的参数设置可以使用man指令查看。<br>下面说下如何通过shell来实现数据的读取，这里主要是使用的cat指令：</p>
<pre><code>cat /dev/ttyUSB0</code></pre><p>但在如果执行上面命令，程序会一直停止在读取的界面，如果我们的要求是想读取一段一段的数据，<br>即分批次读取一定之间内的数据，保存并处理，那应该怎么办呢？<br>我们就需要先用stty将模式设置成raw 并且设置最大连接时间：</p>
<pre><code>stty -F /dev/ttyUSB0 raw speed 9600 min 0 time 10</code></pre><p>然后我们可以把每次读取到的数据存储到一个临时文件中，然后对其进行处理：</p>
<pre><code>cat /dev/ttyUSB0 &gt;&gt; “tmpFile”</code></pre><p>完成的代码如下：</p>
<pre><code>stty -F /dev/ttyUSB0 raw speed 9600 min 0 time 10
while [ 1 -eq 1  ]
do
    cat /dev/ttyUSB0 &gt;&gt; &quot;tmpFile&quot;
    echo `date`
done</code></pre>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>minicom</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile根据文件目录来生成库</title>
    <url>/2016/03/16/makefile-automake-libs/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><strong>根据src下目录名称来生成对应的库，不需要修改makefile，只需要添加文件夹从而生成新的库。</strong></p>
<p>相关知识点：<a href="http://breezetemple.github.io/2015/10/makefile-and-shell/" target="_blank" rel="noopener">Makefile中嵌入一段shell脚本及函数列表</a></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>SRC = $(shell find . -iname &quot;*.c&quot;)
DIRS = $(shell ls -I include ./src)

.PHONY : clean install

all : objects libs

objects:$(SRC)
    @echo &quot;making objects dir&quot;
    @mkdir -p $(objects_dir)
    @echo &quot;Generating new objects file...&quot;;
    @for f in $(SRC); do \
        OBJ=$(objects_dir)/`basename $$f|sed -e &#39;s/\.c/\.o/&#39;`; \
        echo &quot;compiling \033[032m[$(CC)]\033[0m&quot;: $$f; \
        $(CC) $(CFLAGS) -c $$f -o $$OBJ; \
    done

libs:
    @echo &quot;\nmaking libs ...&quot;
    @for subdir in $(DIRS); do \
        target=$(addprefix lib, $(addsuffix .a, $$subdir)); \
        objs=`ls ./src/$$subdir|sed -e &#39;s/\.c/\.o/&#39;|sed -e &#39;s#^#./$(objects_dir)/#&#39;`; \
        $(AR) -rcs $$target $$objs; \
        echo &quot;In subdir\033[32m&quot; [$$subdir] &quot;\033[0mGenerating new lib\033[31m&quot;: $$target&quot;\033[0m&quot;; \
    done

clean :
    @echo [Clean all]
    @rm -rf $(objects_dir)
    @rm -rf $(install_dir)
    @find -name &quot;*.o&quot; | xargs rm -rf
    @rm -rf *.a

install : *.a
    @echo &quot;making install dir&quot;
    @mkdir -p $(install_dir)
    @mv *.a $(install_dir)
    @cp include/*.h $(install_dir)
    @cp porting/*.h $(install_dir)</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a><strong>addprefix</strong></h3><pre><code>target=$(addprefix lib, $(addsuffix .a, $$subdir))</code></pre><p>addprefix在shell脚本片段中，处理的文本为多个时会失败，具体原因未知…</p>
<h3 id="shell变量与makefile变量"><a href="#shell变量与makefile变量" class="headerlink" title="shell变量与makefile变量"></a><strong>shell变量与makefile变量</strong></h3><p>$(objects_dir)为shell变量，$$target为makefile变量</p>
<h3 id="shell与-反引号"><a href="#shell与-反引号" class="headerlink" title="shell与``[反引号]"></a><strong>shell与``[反引号]</strong></h3><p>在for循环中，使用类似：</p>
<pre><code>objs=$(shell ls ./src/$$subdir|sed -e &#39;s/\.c/\.o/&#39;|sed -e &#39;s#^#./$(objects_dir)/#&#39;); \ </code></pre><p>执行不成功：</p>
<pre><code>/bin/sh: 3: ./output/objects/cmm: not found</code></pre><p>修改为：</p>
<pre><code>objs=`ls ./src/$$subdir|sed -e &#39;s/\.c/\.o/&#39;|sed -e &#39;s#^#./$(objects_dir)/#&#39;`; \</code></pre>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>gcc</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 远程操作详解[转载]</title>
    <url>/2016/02/23/git-remote/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<p>作者： 阮一峰<br>日期： 2014年6月12日<br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">原文</a></p>
<p>Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。<br>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p>
<ul>
<li><strong>git clone</strong></li>
<li><strong>git remote</strong></li>
<li><strong>git fetch</strong></li>
<li><strong>git pull</strong></li>
<li><strong>git push</strong></li>
</ul>
<p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。<br>同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p>
<p><img src="/images/git/git_remote.jpg" alt="Git Remote" title="git remote"></p>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a><strong>git clone</strong></h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p>
<pre><code>$ git clone &lt;版本库的网址&gt;</code></pre><p>比如，克隆jQuery的版本库。</p>
<pre><code>$ git clone https://github.com/jquery/jquery.git</code></pre><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p>
<pre><code>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code></pre><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>
<pre><code>$ git clone http[s]://example.com/path/to/repo.git/
$ git clone ssh://example.com/path/to/repo.git/
$ git clone git://example.com/path/to/repo.git/
$ git clone /opt/git/project.git 
$ git clone file:///opt/git/project.git
$ git clone ftp[s]://example.com/path/to/repo.git/
$ git clone rsync://example.com/path/to/repo.git/</code></pre><p>SSH协议还有另一种写法。</p>
<pre><code>$ git clone [user@]example.com:path/to/repo.git/</code></pre><p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><strong>git remote</strong></h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。<br>不带选项的时候，git remote命令列出所有远程主机。</p>
<pre><code>$ git remote
origin</code></pre><p>使用-v选项，可以参看远程主机的网址。</p>
<pre><code>$ git remote -v
origin  git@github.com:jquery/jquery.git (fetch)
origin  git@github.com:jquery/jquery.git (push)</code></pre><p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。<br>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p>
<pre><code>$ git clone -o jQuery https://github.com/jquery/jquery.git
$ git remote
jQuery</code></pre><p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>
<p>git remote show命令加上主机名，可以查看该主机的详细信息。</p>
<pre><code>$ git remote show &lt;主机名&gt;</code></pre><p>git remote add命令用于添加远程主机。</p>
<pre><code>$ git remote add &lt;主机名&gt; &lt;网址&gt;</code></pre><p>git remote rm命令用于删除远程主机。</p>
<pre><code>$ git remote rm &lt;主机名&gt;</code></pre><p>git remote rename命令用于远程主机的改名。</p>
<pre><code>$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a><strong>git fetch</strong></h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p>
<pre><code>$ git fetch &lt;远程主机名&gt;</code></pre><p>上面命令将某个远程主机的更新，全部取回本地。<br>git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。<br>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<pre><code>$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><p>比如，取回origin主机的master分支。</p>
<pre><code>$ git fetch origin master</code></pre><p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。<br>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p>
<pre><code>$ git branch -r
origin/master

$ git branch -a
* master
  remotes/origin/master</code></pre><p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。<br>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p>
<pre><code>$ git checkout -b newBrach origin/master</code></pre><p>上面命令表示，在origin/master的基础上，创建一个新分支。<br>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p>
<pre><code>$ git merge origin/master
$ git rebase origin/master</code></pre><p>上面命令表示在当前分支上，合并origin/master。</p>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><strong>git pull</strong></h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>
<pre><code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p>
<pre><code>$ git pull origin next:master</code></pre><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<pre><code>$ git pull origin next</code></pre><p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p>
<pre><code>$ git fetch origin
$ git merge origin/next</code></pre><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。<br>比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，<br>也就是说，本地的master分支自动”追踪”origin/master分支。<br>Git也允许手动建立追踪关系。</p>
<pre><code>git branch --set-upstream master origin/next</code></pre><p>上面命令指定master分支追踪origin/next分支。<br><strong>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</strong></p>
<pre><code>$ git pull origin</code></pre><p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。<br>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>
<pre><code>$ git pull</code></pre><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。<br>如果合并需要采用rebase模式，可以使用–rebase选项。</p>
<pre><code>$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。<br>这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。<br>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>
<pre><code>$ git pull -p
# 等同于下面的命令
$ git fetch --prune origin 
$ git fetch -p</code></pre><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><strong>git push</strong></h2><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p>
<pre><code>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。<br>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<pre><code>$ git push origin master</code></pre><p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。<br>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<pre><code>$ git push origin :master
# 等同于
$ git push origin --delete master</code></pre><p>上面命令表示删除origin主机的master分支。<br>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<pre><code>$ git push origin</code></pre><p>上面命令表示，将当前分支推送到origin主机的对应分支。<br>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>
<pre><code>$ git push</code></pre><p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p>
<pre><code>$ git push -u origin master</code></pre><p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。<br>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。<br>此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。<br>Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p>
<pre><code>$ git config --global push.default matching
# 或者
$ git config --global push.default simple</code></pre><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>
<pre><code>$ git push --all origin</code></pre><p>上面命令表示，将所有本地分支都推送到origin主机。<br>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。<br>这时，如果你一定要推送，可以使用–force选项。</p>
<pre><code>$ git push --force origin </code></pre><p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。<br>除非你很确定要这样做，否则应该尽量避免使用–force选项。<br>最后，git push不会推送标签（tag），除非使用–tags选项。</p>
<pre><code>$ git push origin --tags</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 Git 命令清单[转载]</title>
    <url>/2016/02/23/git-cheat-sheet/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<p>作者： 阮一峰<br>日期： 2014年6月12日<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">原文</a></p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="/images/git/git_remote.jpg" alt="Git Remote" title="git remote"></p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<pre><code>Workspace：工作区
Index / Stage：暂存区
Repository：仓库区（或本地仓库）
Remote：远程仓库</code></pre><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><pre><code># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<pre><code># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><pre><code># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]</code></pre><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><pre><code># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre><code># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]</code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog</code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code># 生成一个可供发布的压缩包
$ git archive</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 工作流程[转载]</title>
    <url>/2016/02/23/git-workflow/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<p>作者： 阮一峰<br>日期： 2015年12月24日<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">原文</a></p>
<p>Git 作为一个源码管理系统，不可避免涉及到多人协作。<br>协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。<br>“工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。</p>
<p><img src="/images/git/git_workflow.png" alt="Git Workflow" title="git workflow"></p>
<p>本文介绍三种广泛使用的工作流程：</p>
<ul>
<li><strong>Git flow</strong></li>
<li><strong>Github flow</strong></li>
<li><strong>Gitlab flow</strong></li>
</ul>
<p>如果你对Git还不是很熟悉，可以先阅读下面的文章。</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">《Git 使用规范流程》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">《常用 Git 命令清单》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">《Git 远程操作详解》</a></li>
</ul>
<h2 id="功能驱动"><a href="#功能驱动" class="headerlink" title="功能驱动"></a>功能驱动</h2><p>本文的三种工作流程，有一个共同点：都采用<a href="https://en.wikipedia.org/wiki/Feature-driven_development" target="_blank" rel="noopener">“功能驱动式开发”</a>（Feature-driven development，简称FDD）。</p>
<p>它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。<br>完成开发后，该分支就合并到主分支，然后被删除。</p>
<h2 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git flow"></a>Git flow</h2><p>最早诞生、并得到广泛采用的一种工作流程，就是Git flow 。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>它最主要的特点有两个。</p>
<p><img src="/images/git/gitflow.png" alt="gitflow" title="gitflow"></p>
<p>首先，项目存在两个长期分支。</p>
<ul>
<li><strong>主分支master</strong></li>
<li><strong>开发分支develop</strong></li>
</ul>
<p>前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。</p>
<p>其次，项目存在三种短期分支。</p>
<ul>
<li><strong>功能分支（feature branch）</strong></li>
<li><strong>补丁分支（hotfix branch）</strong></li>
<li><strong>预发分支（release branch）</strong></li>
</ul>
<p>一旦完成开发，它们就会被合并进develop或master，然后被删除。<br>Git flow 的详细介绍，请阅读我翻译的中文版<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">《Git 分支管理策略》</a>。</p>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>Git flow的优点是清晰可控，缺点是相对复杂，需要同时维护两个长期分支。<br>大多数工具都将master当作默认分支，可是开发是在develop分支进行的，这导致经常要切换分支，非常烦人。<br>更大问题在于，这个模式是基于”版本发布”的，目标是一段时间以后产出一个新版本。<br>但是，很多网站项目是”持续发布”，代码一有变动，就部署一次。<br>这时，master分支和develop分支的差别不大，没必要维护两个长期分支。</p>
<h2 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github flow"></a>Github flow</h2><p>Github flow 是Git flow的简化版，专门配合”持续发布”。它是 Github.com 使用的工作流程。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>它只有一个长期分支，就是master，因此用起来非常简单。<br>官方推荐的<a href="https://guides.github.com/introduction/flow/index.html" target="_blank" rel="noopener">流程</a>如下。</p>
<p><img src="/images/git/github_flow.png" alt="github flow" title="github flow"></p>
<ol>
<li>根据需求，从master拉出新分支，不区分功能分支或补丁分支。</li>
<li>新分支开发完成后，或者需要讨论的时候，就向master发起一个<a href="https://help.github.com/articles/using-pull-requests/" target="_blank" rel="noopener">pull request</a>（简称PR）。</li>
<li>Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。</li>
<li>你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</li>
</ol>
<h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><p>Github flow 的最大优点就是简单，对于”持续发布”的产品，可以说是最合适的流程。<br>问题在于它的假设：master分支的更新与产品的发布是一致的。也就是说，master分支的最新代码，默认就是当前的线上代码。<br>可是，有些时候并非如此，代码合并进入master分支，并不代表它就能立刻发布。<br>比如，苹果商店的APP提交审核以后，等一段时间才能上架。<br>这时，如果还有新的代码提交，master分支就会与刚发布的版本不一致。<br>另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于master分支。<br>上面这种情况，只有master一个主分支就不够用了。<br>通常，你不得不在master分支以外，另外新建一个production分支跟踪线上版本。</p>
<h2 id="Gitlab-flow"><a href="#Gitlab-flow" class="headerlink" title="Gitlab flow"></a>Gitlab flow</h2><p>Gitlab flow 是 Git flow 与 Github flow 的综合。<br>它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。<br>它是 Gitlab.com 推荐的做法。</p>
<h3 id="上游优先"><a href="#上游优先" class="headerlink" title="上游优先"></a>上游优先</h3><p>Gitlab flow 的最大原则叫做”上游优先”（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。<br>只有上游分支采纳的代码变化，才能应用到其他分支。</p>
<p><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/upstream-first" target="_blank" rel="noopener">Chromium项目</a>就是一个例子，<br>它明确规定，上游分支依次为：</p>
<ul>
<li><strong>Linus Torvalds的分支</strong></li>
<li><strong>子系统（比如netdev）的分支</strong></li>
<li><strong>设备厂商（比如三星）的分支</strong></li>
</ul>
<h3 id="持续发布"><a href="#持续发布" class="headerlink" title="持续发布"></a>持续发布</h3><p>Gitlab flow 分成两种情况，适应不同的开发流程。</p>
<p><img src="/images/git/gitlab_flow1.png" alt="gitlab flow" title="gitlab flow"></p>
<p>对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。<br>比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。</p>
<p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。<br>代码的变化，必须由”上游”向”下游”发展。<br>比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，<br>再cherry-pick到pre-production，这一步也没有问题，才进入production。<br>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p>
<h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p><img src="/images/git/gitlab_release.png" alt="gitlab release" title="gitlab release"></p>
<p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。<br>以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。</p>
<h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h3><p><img src="/images/git/merge.png" alt="merge" title="merge"></p>
<p>功能分支合并进master分支，必须通过Pull Request（Gitlab里面叫做 Merge Request）。</p>
<p><img src="/images/git/request.png" alt="request" title="request"></p>
<p>前面说过，Pull Request本质是一种对话机制，你可以在提交的时候，<br>@相关<a href="https://github.com/blog/1004-mention-autocompletion" target="_blank" rel="noopener">人员</a>或<a href="https://github.com/blog/1121-introducing-team-mentions" target="_blank" rel="noopener">团队</a>，引起他们的注意。</p>
<h3 id="Protected-branch"><a href="#Protected-branch" class="headerlink" title="Protected branch"></a>Protected branch</h3><p>master分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 Pull Request 的权力。</p>
<p><a href="https://help.github.com/articles/about-protected-branches/" target="_blank" rel="noopener">Github</a><br>和 <a href="http://doc.gitlab.com/ce/permissions/permissions.html" target="_blank" rel="noopener">Gitlab</a> 都提供”保护分支”（Protected branch）这个功能。</p>
<h3 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h3><p>Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。<br>功能分支的名称，可以与issue的名字保持一致，并且以issue的编号起首，比如”15-require-a-password-to-change-it”。</p>
<p>开发完成后，在提交说明里面，可以写上”fixes #14”或者”closes #67”。<br>Github规定，只要commit message里面有下面这些<a href="https://help.github.com/articles/closing-issues-via-commit-messages/" target="_blank" rel="noopener">动词</a> + 编号，<br>就会关闭对应的issue。</p>
<ul>
<li>close</li>
<li>closes</li>
<li>closed</li>
<li>fix</li>
<li>fixes</li>
<li>fixed</li>
<li>resolve</li>
<li>resolves</li>
<li>resolved</li>
</ul>
<p>这种方式还可以一次关闭多个issue，或者关闭其他代码库的issue，格式是username/repository#issue_number。<br>Pull Request被接受以后，issue关闭，原始分支就应该删除。如果以后该issue重新打开，新分支可以复用原来的名字。</p>
<h3 id="Merge节点"><a href="#Merge节点" class="headerlink" title="Merge节点"></a>Merge节点</h3><p>Git有两种合并：一种是”直进式合并”（fast forward），不生成单独的合并节点；<br>另一种是”非直进式合并”（none fast-forword），会生成单独节点。</p>
<p>前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用–no-ff参数）。<br>只要发生合并，就要有一个单独的合并节点。</p>
<h3 id="Squash-多个commit"><a href="#Squash-多个commit" class="headerlink" title="Squash 多个commit"></a>Squash 多个commit</h3><p>为了便于他人阅读你的提交，也便于cherry-pick或撤销代码变化，在发起Pull Request之前，应该把多个commit合并成一个。<br>（前提是，该分支只有你一个人开发，且没有跟master合并过。）</p>
<p>这可以采用rebase命令附带的squash操作，具体方法请参考我写的<a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">《Git 使用规范流程》</a>。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用规范流程[转载]</title>
    <url>/2016/02/23/how-to-use-git/</url>
    <content><![CDATA[<ul>
<li>toc<br>{:toc}</li>
</ul>
<p>作者： 阮一峰<br>日期： 2015年8月 5日<br><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">原文</a></p>
<p>团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。<br>否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。<br>下面是<a href="https://github.com/thoughtbot/guides/tree/master/protocol/git" target="_blank" rel="noopener">ThoughtBot</a> 的Git使用规范流程。<br>我从中学到了很多，推荐你也这样使用Git。</p>
<p><img src="/images/git/git_process.png" alt="Git Process" title="git process"></p>
<h2 id="第一步：新建分支"><a href="#第一步：新建分支" class="headerlink" title="第一步：新建分支"></a>第一步：新建分支</h2><p>首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">《Git分支管理策略》</a>）。</p>
<pre><code># 获取主干最新代码
$ git checkout master
$ git pull

# 新建一个开发分支myfeature
$ git checkout -b myfeature</code></pre><h2 id="第二步：提交分支commit"><a href="#第二步：提交分支commit" class="headerlink" title="第二步：提交分支commit"></a>第二步：提交分支commit</h2><p>分支修改后，就可以提交commit了。</p>
<pre><code>$ git add --all
$ git status
$ git commit --verbose</code></pre><p>git add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。<br>从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。<br>git status 命令，用来查看发生变动的文件。<br>git commit 命令的verbose参数，会列出 diff 的结果。</p>
<h2 id="第三步：撰写提交信息"><a href="#第三步：撰写提交信息" class="headerlink" title="第三步：撰写提交信息"></a>第三步：撰写提交信息</h2><p>提交commit时，必须给出完整扼要的提交信息，下面是一个范本。</p>
<pre><code>Present-tense summary under 50 characters

* More information about commit (under 72 characters).
* More information about commit (under 72 characters).

http://project.management-system.com/ticket/123</code></pre><p>第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。<br>最后，提供对应的网址（比如Bug ticket）。</p>
<h2 id="第四步：与主干同步"><a href="#第四步：与主干同步" class="headerlink" title="第四步：与主干同步"></a>第四步：与主干同步</h2><p>分支的开发过程中，要经常与主干保持同步。</p>
<pre><code>$ git fetch origin
$ git rebase origin/master</code></pre><h2 id="第五步：合并commit"><a href="#第五步：合并commit" class="headerlink" title="第五步：合并commit"></a>第五步：合并commit</h2><p>分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。<br>那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。</p>
<pre><code>$ git rebase -i origin/master</code></pre><p>git rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。<br>下面采用<a href="https://robots.thoughtbot.com/git-interactive-rebase-squash-amend-rewriting-history" target="_blank" rel="noopener">Tute Costa</a> 的例子，来解释怎么合并commit。</p>
<pre><code>pick 07c5abd Introduce OpenPGP and teach basic usage
pick de9b1eb Fix PostChecker::Post#urls
pick 3e7ee36 Hey kids, stop all the highlighting
pick fa20af3 git interactive rebase, squash, amend

# Rebase 8db7e8b..fa20af3 onto 8db7e8b
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</code></pre><p>上面的互动界面，先列出当前分支最新的4个commit（越下面越新）。<br>每个commit前面有一个操作命令，默认是pick，表示该行commit被选中，要进行rebase操作。<br>4个commit的下面是一大堆注释，列出可以使用的命令。</p>
<ul>
<li>pick：正常选中</li>
<li>reword：选中，并且修改提交信息；</li>
<li>edit：选中，rebase时会暂停，允许你修改这个commit（参考这里）</li>
<li>squash：选中，会将当前commit与上一个commit合并</li>
<li>fixup：与squash相同，但不会保存当前commit的提交信息</li>
<li>exec：执行其他shell命令</li>
</ul>
<p>上面这6个命令当中，squash和fixup可以用来合并commit。先把需要合并的commit前面的动词，改成squash（或者s）。</p>
<pre><code>pick 07c5abd Introduce OpenPGP and teach basic usage
s de9b1eb Fix PostChecker::Post#urls
s 3e7ee36 Hey kids, stop all the highlighting
pick fa20af3 git interactive rebase, squash, amend</code></pre><p>这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。<br>提交信息会同时包含，这三个commit的提交信息。</p>
<pre><code># This is a combination of 3 commits.
# The first commit&#39;s message is:
Introduce OpenPGP and teach basic usage

# This is the 2nd commit message:
Fix PostChecker::Post#urls

# This is the 3rd commit message:
Hey kids, stop all the highlighting</code></pre><p>如果将第三行的squash命令改成fixup命令。</p>
<pre><code>pick 07c5abd Introduce OpenPGP and teach basic usage
s de9b1eb Fix PostChecker::Post#urls
f 3e7ee36 Hey kids, stop all the highlighting
pick fa20af3 git interactive rebase, squash, amend</code></pre><p>运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。<br>但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。</p>
<pre><code># This is a combination of 3 commits.
# The first commit&#39;s message is:
Introduce OpenPGP and teach basic usage

# This is the 2nd commit message:
Fix PostChecker::Post#urls

# This is the 3rd commit message:
# Hey kids, stop all the highlighting</code></pre><p>Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。</p>
<pre><code>$ git reset HEAD~5
$ git add .
$ git commit -am &quot;Here&#39;s the bug fix that closes #28&quot;
$ git push --force</code></pre><p>squash和fixup命令，还可以当作命令行参数使用，自动合并commit。</p>
<pre><code>$ git commit --fixup  
$ git rebase -i --autosquash </code></pre><p>这个用法请参考<a href="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html" target="_blank" rel="noopener">这篇文章</a>，这里就不解释了。</p>
<h2 id="第六步：推送到远程仓库"><a href="#第六步：推送到远程仓库" class="headerlink" title="第六步：推送到远程仓库"></a>第六步：推送到远程仓库</h2><p>合并commit后，就可以推送当前分支到远程仓库了。</p>
<pre><code>$ git push --force origin myfeature</code></pre><p>git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送（<a href="http://willi.am/blog/2014/08/12/the-dark-side-of-the-force-push/" target="_blank" rel="noopener">参见这里</a>）。</p>
<h2 id="第七步：发出Pull-Request"><a href="#第七步：发出Pull-Request" class="headerlink" title="第七步：发出Pull Request"></a>第七步：发出Pull Request</h2><p>提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Modules分析</title>
    <url>/2015/12/03/linux-modules/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>源码：</p>
<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;

static int __init hello_init(void)
{
    printk(&quot;Hello, world!\n&quot;);
    return 0;
}

static void __exit hello_exit(void)
{
    printk(&quot;Goodbye, world!\n&quot;);
}

module_init(hello_init);
module_exit(hello_exit);

MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;printk&quot;);
MODULE_DESCRIPTION(&quot;\&quot;Hello, world!\&quot;&quot;);
MODULE_VERSION(&quot;printk&quot;);     </code></pre><p>使用的交叉编译，Makefile：</p>
<pre><code>ARCH=xxx
CROSS_COMPILE=$(ARCH)-linux-
obj-m := printk.o

KDIR := /home/workspace/kernel/2.6.27.55
PWD   := $(shell pwd)

default:
    $(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules

clean:
    $(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) clean    </code></pre><p><strong>obj-m := printk.o 是kbuild Makefile中的目标定义部分</strong>，同时目标定义部分也是kbuild Makefile的重要组成部分。<br>该例子告诉Kbuild在这目录里，有一个名为printk.o的目标文件。<br>将会编译成一个可加载的模块而不是直接编译进内核</p>
<h3 id="makefiles-txt"><a href="#makefiles-txt" class="headerlink" title="makefiles.txt"></a><strong>makefiles.txt</strong></h3><p>根据Linux内核文档<strong>makefiles.txt</strong>的说明：</p>
<ol>
<li><strong>obj-y Built-in object goals 对应内核配置[Y]</strong></li>
<li><strong>obj-m Loadable module goals 对应内核配置[M]</strong></li>
</ol>
<p>obj-m由单个文件构成，其中$(CONFIG_ISDN_PPP_BSDCOMP)为配置系统配置为‘m’，示例：</p>
<pre><code>obj-$(CONFIG_ISDN_PPP_BSDCOMP) += isdn_bsdcomp.o</code></pre><p>obj-m由多个文件构成，其中$(CONFIG_ISDN)为配置系统配置为‘m’，示例：</p>
<pre><code>obj-$(CONFIG_ISDN) += isdn.o
isdn-objs := isdn_net_lib.o isdn_v110.o isdn_common.o</code></pre><p>如果.config中存在以下配置<code>CONFIG_SCSI=y</code>，那么drivers/Makefile中存在以下配置<code>obj-$(CONFIG_SCSI) += scsi/</code>，示例：</p>
<pre><code>obj-y               += base/ block/ misc/ mfd/ net/ media/
obj-$(CONFIG_NUBUS)     += nubus/
obj-$(CONFIG_ATM)       += atm/
obj-y               += macintosh/
obj-$(CONFIG_IDE)       += ide/
obj-$(CONFIG_SCSI)      += scsi/                                                                                                    
obj-$(CONFIG_ATA)       += ata/
obj-$(CONFIG_FUSION)        += message/</code></pre><p><strong>当将模块配置为build-in时，即表示要将这些代码的相关目录放入编译目录中！</strong></p>
<h3 id="Linux-Makefile"><a href="#Linux-Makefile" class="headerlink" title="Linux Makefile"></a><strong>Linux Makefile</strong></h3><p>Kernel/Documentation/kbuild/makefiles.txt 中描述Linux Makefile包含五部分：</p>
<ol>
<li>Makefile        the top Makefile.</li>
<li>.config         the kernel configuration file.                                                                                 </li>
<li>arch/$(ARCH)/Makefile   the arch Makefile.</li>
<li>scripts/Makefile.*  common rules etc. for all kbuild Makefiles.</li>
<li>kbuild Makefiles    there are about 500 of these.</li>
</ol>
<p>各个部分的作用：</p>
<ol>
<li>顶层Makefile读取.config内核配置文件，顶层Makefile负责编译两个主要的镜像文件：vmlinux（驻留内核镜像）和 内核模块，<br>它通过递归便利内核源码树的子目录来编译这些目标文件，访问的子目录列表取决于内核的配置。</li>
<li>.config内核配置文件</li>
<li>顶层Makefile还会包含arch/$(ARCH)/Makefile，这些平台Makefile向顶层Makefile提供架构特性信息</li>
<li>每一个子目录下有一个kbulid Makefile会展开从上面传下来的命令，<br>kbulid Makefile利用来自.config的配置信息通过kbulid构建各种不同的文件编译内置或是模块可加载的目标</li>
<li>scripts/Makefile.* 包含了所有的定义、规则等等，他们在kbulid makefiles的基础上构建内核</li>
</ol>
<h3 id="Makefile-modpost"><a href="#Makefile-modpost" class="headerlink" title="Makefile.modpost"></a><strong>Makefile.modpost</strong></h3><p>在script目录下有许多Makefile文件，由于各种情况；其中，Makefile.modpost由于module的生成。</p>
<p>第一步：</p>
<ol>
<li>编译驱动的每个.o文件。</li>
<li>将每个.o文件链接到.o。</li>
<li>在$(MODVERDIR)/生成一个.mod文件，列出.ko及每个.o文件。</li>
</ol>
<p>第二步：</p>
<ol>
<li>找出所有在$(MODVERDIR)/的modules。</li>
<li>接着使用modpost</li>
<li>为每个module创建.mod.c</li>
<li>创建一个Module.symvers文件，保存了所有引出符号及其CRC校验。</li>
<li>编译全部 .mod.c文件。</li>
<li>链接所有的module成为一个文件。</li>
</ol>
<p>第三步：替换module里一些ELF段，包括：</p>
<p>Version magic (see include/vermagic.h for full details)</p>
<ul>
<li>Kernel release</li>
<li>SMP is CONFIG_SMP</li>
<li>PREEMPT is CONFIG_PREEMPT</li>
<li>GCC Version</li>
</ul>
<p>Module info</p>
<ul>
<li>Module version (MODULE_VERSION)</li>
<li>Module alias’es (MODULE_ALIAS)</li>
<li>Module license (MODULE_LICENSE)</li>
<li>See include/linux/module.h for more details</li>
</ul>
<p>第四步：</p>
<p>Step 4 is solely used to allow module versioning in external modules,<br>where the CRC of each module is retrieved from the Module.symers file.<br>KBUILD_MODPOST_WARN can be set to avoid error out in case of undefined<br>symbols in the final module linking stage<br>KBUILD_MODPOST_NOFINAL can be set to skip the final link of modules.<br>This is solely usefull to speed up test compiles</p>
<h3 id="编译及结果"><a href="#编译及结果" class="headerlink" title="编译及结果"></a><strong>编译及结果</strong></h3><p>源码结构：</p>
<pre><code>.
├── hello_printk.c
└── Makefile</code></pre><p>编译过程：</p>
<pre><code>make ARCH=xxx CROSS_COMPILE=xxx-linux- -C /home/workspace/kernel/2.6.27.55 M=/data/linux_drivers/hello_printk modules
make[1]: Entering directory &#39;/home/workspace/kernel/2.6.27.55&#39;
CC [M]  /data/linux_drivers/hello_printk/hello_printk.o
Building modules, stage 2.
MODPOST 1 modules
CC      /data/linux_drivers/hello_printk/hello_printk.mod.o
LD [M]  /data/linux_drivers/hello_printk/hello_printk.ko
make[1]: Leaving directory &#39;/home/workspace/kernel/2.6.27.55&#39;</code></pre><p>结构：</p>
<pre><code>.
├── hello_printk.c
├── hello_printk.ko
├── .hello_printk.ko.cmd
├── hello_printk.mod.c
├── hello_printk.mod.o
├── .hello_printk.mod.o.cmd
├── hello_printk.o
├── .hello_printk.o.cmd
├── Makefile
├── modules.order
├── Module.symvers
└── .tmp_versions
    └── hello_printk.mod</code></pre><p>其中生成<code>&lt;module&gt;.mod.c</code>文件， 内容如下：</p>
<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/vermagic.h&gt;
#include &lt;linux/compiler.h&gt;

MODULE_INFO(vermagic, VERMAGIC_STRING);

struct module __this_module
__attribute__((section(&quot;.gnu.linkonce.this_module&quot;))) = {
    .name = KBUILD_MODNAME,
    .init = init_module,
#ifdef CONFIG_MODULE_UNLOAD
    .exit = cleanup_module,
#endif                                                                                                                              
    .arch = MODULE_ARCH_INIT,
};



static const char __module_depends[]
__used
__attribute__((section(&quot;.modinfo&quot;))) =
&quot;depends=&quot;;


MODULE_INFO(srcversion, &quot;D9CAF6BFCBD9B121FB4765D&quot;);</code></pre><p><strong>其实就是在生成的文件里加入<code>.gnu.linkonce.this_module</code>这样一个段，<br>驱动加裁时会找到这个段并调用<code>.init</code>函数，卸载时调用<code>.exit</code>函数。</strong></p>
<p>定义一个module结构类型的变量<code>struct module __this_module</code>，<br>这个变量是放在ELF文件的段名为<code>.gnu.linkonce.this_module</code>的段中，通过readelf工具也可以看到相关的段：</p>
<pre><code>$ readelf -S hello_printk.mod.o
共有 11 个节头，从偏移量 0x218 开始：

节头：
    [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
    [ 0]                   NULL            00000000 000000 000000 00      0   0  0
    [ 1] .text             PROGBITS        00000000 000034 000000 00  AX  0   0  1
    [ 2] .data             PROGBITS        00000000 000034 000000 00  WA  0   0  1
    [ 3] .bss              NOBITS          00000000 000034 000000 00  WA  0   0  1
    [ 4] .gnu.linkonce.thi PROGBITS        00000000 000034 0000f4 00  WA  0   0  4
    [ 5] .rela.gnu.linkonc RELA            00000000 000524 000018 0c      9   4  4
    [ 6] .modinfo          PROGBITS        00000000 000128 00004f 00   A  0   0  4
    [ 7] .comment          PROGBITS        00000000 000177 000043 01  MS  0   0  1
    [ 8] .shstrtab         STRTAB          00000000 0001ba 00005d 00      0   0  1
    [ 9] .symtab           SYMTAB          00000000 0003d0 0000e0 10     10  11  4
    [10] .strtab           STRTAB          00000000 0004b0 000071 00      0   0  1
Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings)
    I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
    O (extra OS processing required) o (OS specific), p (processor specific)</code></pre><p>最后将<strong><code>hello_printk.mod.o</code></strong>和<strong><code>hello_printk.o</code></strong>链接为ko，ko符号表如下：</p>
<pre><code>nm hello_printk.ko
00000000 T cleanup_module
00000000 t hello_exit
00000000 t hello_init
00000000 T init_module
0000003c r __mod_author59
00000010 r __mod_description60
00000060 r __mod_license58
0000006c r __mod_srcversion23
00000090 r __module_depends
0000009c r __mod_vermagic5
00000000 r __mod_version61
U printk
00000000 D __this_module</code></pre><p>module中可以使用的符号表为<strong><code>cleanup_module</code></strong>和<strong><code>init_module</code></strong>，其他为局部符号，对外不可见。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux设备驱动程序基础</title>
    <url>/2015/12/02/linux-device_drivers/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="Linux设备驱动程序示例"><a href="#Linux设备驱动程序示例" class="headerlink" title="Linux设备驱动程序示例"></a>Linux设备驱动程序示例</h2><p>源代码：</p>
<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/vmalloc.h&gt;

static int num = 1;                                                                                                                 
static char *mode = &quot;show&quot;;

static int __init hello_module_init(void)
{
    printk(&quot;Hello,world\n&quot;);
}

static void __exit hello_module_exit(void)
{
    printk(&quot;Good Bye\n&quot;);
}

module_init(hello_module_init);
module_exit(hello_module_exit);
module_param(mode, charp, S_IRUGO);
module_param(num, int, S_IRUGO);

MODULE_DESCRIPTION(&quot;driver for the Hello World.&quot;);
MODULE_AUTHOR(&quot;Hello&quot;);
MODULE_LICENSE(&quot;GPL&quot;);</code></pre><p>Makefile：</p>
<pre><code>obj-m += hello.o    #设置模块名
hello-objs := bsp_hello.o hello_mod_linux.o

all:
    $(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KERNEL_PATH) SUBDIRS=`pwd`

clean:
    rm -rf *.ko *.o *.mod.c .tmp_versions Module.symvers modules.order .tmp_versions
    find ../ -name &quot;*.cmd&quot; -delete

install:
    cp $(HELLO_TARGET) $(OUTDIR) -f</code></pre><p><strong>Tips:obj-m += (module name).o</strong></p>
<h2 id="相关宏定义"><a href="#相关宏定义" class="headerlink" title="相关宏定义"></a>相关宏定义</h2><p>Linux设备驱动编译时，如果<strong>MODULE</strong>未定义，表明设备驱动是<strong>build-in</strong>模式。<br>相应的<strong>module_init/module_exit</strong>宏定义展开不同。</p>
<p>linux对只需要初始化运行一次的函数都加上<strong>init属性，<br>__init 宏告诉编译器如果这个模块被编译到内核则把这个函数放到（.init.text）段，<br>module_exit的参数卸载时同</strong>init类似，如果驱动被编译进内核，<br>则<strong>exit宏会忽略清理函数，因为编译进内核的模块不需要做清理工作，<br>**显然</strong>init和__exit对动态加载的模块是无效的，只支持完全编译进内核**。</p>
<p>在kernel初始化后期，释放所有这些函数代码所占的内存空间。<br>连接器把带__init属性的函数放在同一个section里，在用完以后，把整个section释放掉。<br>当函数初始化完成后这个区域可以被清除掉以节约系统内存。<br>Kenrel启动时看到的消息“Freeing unused kernel memory: xxxk freed”同它有关。</p>
<p>start_kernel-&gt;rest_init-&gt;kernel_init-&gt;init_post-&gt;free_initmem()来释放初始化代码和数据。</p>
<h3 id="特殊宏定义"><a href="#特殊宏定义" class="headerlink" title="特殊宏定义"></a>特殊宏定义</h3><ul>
<li>MODULE_LICENSE(license)           代码使用的许可证</li>
<li>MODULE_AUTHOR(author)             描述模块作者</li>
<li>MODULE_DESCRIPTION(description)   说明模块用途的简短描述</li>
<li>MODULE_VERSION(version_string)    代码修订号</li>
<li>MODULE_DEVICE_TABLE(table_info)   告诉用户空间模块所支持的设备</li>
<li>MODULE_ALIAS(alternate_name)      模块的别名</li>
</ul>
<h3 id="加载函数宏定义module-init"><a href="#加载函数宏定义module-init" class="headerlink" title="加载函数宏定义module_init()"></a>加载函数宏定义<strong>module_init()</strong></h3><p>module_init定义如下：</p>
<pre><code>include/linux/init.h
#ifndef MODULE
/**
 * module_init() - driver initialization entry point
 * @x: function to be run at kernel boot time or module insertion
 * 
 * module_init() will either be called during do_initcalls() (if
 * builtin) or at module insertion time (if a module).  There can only
 * be one per module.
 */
#define module_init(x)  __initcall(x);
#else /* MODULE */
/* Each module must use one module_init(). */
#define module_init(initfn)                     \
    static inline initcall_t __inittest(void)   \
    { return initfn;  }                         \                                                                                           
    int init_module(void) __attribute__((alias(#initfn)));
#endif</code></pre><h4 id="build-in分支"><a href="#build-in分支" class="headerlink" title="build-in分支"></a><strong>build-in分支</strong></h4><pre><code>#define __initcall(fn) device_initcall(fn)
#define device_initcall(fn)     __define_initcall(&quot;6&quot;,fn,6)
#define __define_initcall(level,fn,id) \                                                                                            
    static initcall_t __initcall_##fn##id __used \
    __attribute__((__section__(&quot;.initcall&quot; level &quot;.init&quot;))) = fn</code></pre><p>因此使用module_init修饰的hello_module_init最终展开为：</p>
<pre><code>static initcall_t  __initcall_hello_module_init6 __used __attribute__((__section__(&quot;.initcall6.init&quot;))) = hello_module_init;</code></pre><p>就是声明一类型为<strong>initcall_t（typedef int (*initcall_t)(void)）</strong>函数指针类型的变量<br><strong>__initcall_hello_module_init6</strong>并将<strong>hello_module_init</strong>赋值与它。</p>
<p>其中<strong><strong>attribute</strong>((<strong>section</strong>(“.initcall6.init”)))</strong>表明变量<strong>__initcall_hello_module_init6</strong>放入section .initcall6.init中。</p>
<p>在文件<strong>vmlinux.lds</strong>中有以下定义：</p>
<pre><code>.initcall.init : AT(ADDR(.initcall.init) - 0) {                                                                                    
 __initcall_start = .;
 *(.initcallearly.init) __early_initcall_end = .; *(.initcall0.init) *(.initcall0s.init) *(.initcall1.init) 
                                                *(.initcall1s.init) *(.initcall2.init) *(.initcall2s.init) 
                                                *(.initcall3.init) *(.initcall3s.init) *(.initcall4.init) 
                                                *(.initcall4s.init) *(.initcall5.init) *(.initcall5s.init)
                                                *(.initcallrootfs.init) *(.initcall6.init) *(.initcall6s.init) 
                                                *(.initcall7.init) *(.initcall7s.init)
 __initcall_end = .;
}</code></pre><p><strong>启动顺序</strong></p>
<pre><code>init/main.c
start_kernel()-&gt;rest_init()-&gt;kernel_init()-&gt;do_basic_setup()-&gt;do_initcalls()

static void __init do_initcalls(void)
{ 
    initcall_t *call;

    for (call = __early_initcall_end; call &lt; __initcall_end; call++)
        do_one_initcall(*call);                                                                                                     

    /* Make sure there is no pending stuff from the initcall sequence */
    flush_scheduled_work();
} </code></pre><p>do_initcalls()将按顺序从由<strong>early_initcall_end开始，<br>到</strong>initcall_end结束的section中<strong>以函数指针的形式取出这些编译到内核的驱动模块中初始化函数起始地址</strong>，<br>来依次完成相应的初始化。</p>
<p>内核初始化函数do_basic_setup(): do_initcalls() 将从.initcall.init 中，<br>也就是这几个section中依次取出所有的函数指针，并调用这些函数指针所指向的函数，来完成内核的一些相关的初始化。</p>
<p><strong>内核的加载的时候，会搜索”.initcall”中的所有条目，并按优先级加载它们，普通驱动程序的优先级是6。<br>其它模块优先级列出如下：值越小，越先加载。</strong></p>
<h4 id="Module分支"><a href="#Module分支" class="headerlink" title="Module分支"></a><strong>Module分支</strong></h4><pre><code>/* Each module must use one module_init(). */
#define module_init(initfn)                     \
    static inline initcall_t __inittest(void)   \
    { return initfn;  }                         \                                                                                           
    int init_module(void) __attribute__((alias(#initfn)));

typedef int (*initcall_t)(void)</code></pre><p>其中</p>
<pre><code>typedef int (*initcall_t)(void)
#define module_init(initfn)                     \
    static inline initcall_t __inittest(void)   \
    { return initfn;  }                         \                                                                                           </code></pre><p>用于对传入的initfn进行类型检测，类型必须为 int (*initcall_t)(void) 的函数指针，然后通过alias将initfn变名为init_module：</p>
<pre><code>/* type newname __attribute__((alias(&quot;oldname&quot;))); */
int init_module(void) __attribute__((alias(#initfn)));</code></pre><p>当调用insmod和rmmod时，只与init_module和cleanup_module有关，insmod和rmmod中调用这两个函数。</p>
<pre><code>busybox/modutils/insmod.c:insmod_main()
rc = bb_init_module(filename, parse_cmdline_module_options(argv, /*quote_spaces:*/ 0));
.
busybox/modutils/modutils.c:bb_init_module()
init_module(image, image_size, options);
.
# define init_module(mod, len, opts) syscall(__NR_init_module, mod, len, opts)</code></pre><p>insmod最终会调用到 syscall <strong>__NR_init_module</strong>。</p>
<p>在Kernel中，各个arch下的文件unistd.h有如下定义：</p>
<pre><code>#define __NR_init_module        128
#define __NR_delete_module      129
#define __NR_get_kernel_syms    130
#define __NR_quotactl           131
#define __NR_getpgid            132</code></pre><p>然后，文件entry.S下有定义：</p>
<pre><code>.data
ALIGN
sys_call_table:
    .
    .
    .long sys_mprotect      /* 125 */
    .long sys_sigprocmask
    .long sys_ni_syscall    /* old &quot;create_module&quot; */
    .long sys_init_module
    .long sys_delete_module
    .long sys_ni_syscall    /* 130 - old &quot;get_kernel_syms&quot; */
    .long sys_quotactl
    .
    .</code></pre><p><strong>当insmod调用到系统调用号128时，sys_call_table中取出128地址的函数指针进行执行，及sys_init_module。</strong></p>
<p>现在来看系统调用<strong>sys_init_module</strong>：</p>
<pre><code>kernel/module.c
SYSCALL_DEFINE3(init_module, void __user *, umod, unsigned long, len, const char __user *, uargs)
.
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
#define SYSCALL_DEFINEx(x, name, ...)                   \                                                                           
    asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__))</code></pre><p>宏定义<strong>__SC_DECL##x</strong>作用是将参数之间的‘，’去掉，定义如下：</p>
<pre><code>#define __SC_DECL1(t1, a1)  t1 a1
#define __SC_DECL2(t2, a2, ...) t2 a2, __SC_DECL1(__VA_ARGS__)
#define __SC_DECL3(t3, a3, ...) t3 a3, __SC_DECL2(__VA_ARGS__)                                                                      
#define __SC_DECL4(t4, a4, ...) t4 a4, __SC_DECL3(__VA_ARGS__)
#define __SC_DECL5(t5, a5, ...) t5 a5, __SC_DECL4(__VA_ARGS__)
#define __SC_DECL6(t6, a6, ...) t6 a6, __SC_DECL5(__VA_ARGS__)</code></pre><p>宏定义中的‘##’为<strong>（token-pasting）符号连接操作符</strong>，全部展开之后为：</p>
<pre><code>asmlinkage long sys_init_module(void __user * umod, unsigned long len, const char __user * uargs)</code></pre><p>在文件<strong>include/linux/syscalls.h</strong>中可以看到所有的展开的系统调用，例如：</p>
<pre><code>asmlinkage long sys_init_module(void __user *umod, unsigned long len,                                                               
                const char __user *uargs);
asmlinkage long sys_delete_module(const char __user *name_user,
                unsigned int flags);

asmlinkage long sys_rt_sigprocmask(int how, sigset_t __user *set,
                sigset_t __user *oset, size_t sigsetsize);
asmlinkage long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);
asmlinkage long sys_rt_sigtimedwait(const sigset_t __user *uthese,
                siginfo_t __user *uinfo,
                const struct timespec __user *uts,
                size_t sigsetsize);</code></pre><p>在系统调用<strong>sys_init_module</strong>中：</p>
<pre><code>.
mod = load_module(umod, len, uargs);  //主要过程都在这儿
.
.
/* Start the module */
if (mod-&gt;init != NULL)
    ret = do_one_initcall(mod-&gt;init);</code></pre><p>load_module做了绝大部分的工作，将驱动拷贝到内核，重定位等等，do_one_initcall调用module注册的init函数。</p>
<h3 id="卸载函数宏定义module-exit"><a href="#卸载函数宏定义module-exit" class="headerlink" title="卸载函数宏定义module_exit()"></a>卸载函数宏定义<strong>module_exit()</strong></h3><pre><code>#ifndef MODULE
/**
 * module_exit() - driver exit entry point
 * @x: function to be run when driver is removed
 * 
 * module_exit() will wrap the driver clean-up code
 * with cleanup_module() when used with rmmod when
 * the driver is a module.  If the driver is statically
 * compiled into the kernel, module_exit() has no effect.
 * There can only be one per module.
 */
#define module_exit(x)  __exitcall(x);
#else /* MODULE */
/* This is only required if you want to be unloadable. */
#define module_exit(exitfn)                 \
    static inline exitcall_t __exittest(void)       \
    { return exitfn;  }                  \
    void cleanup_module(void) __attribute__((alias(#exitfn)));
#endif</code></pre><h4 id="build-in"><a href="#build-in" class="headerlink" title="build-in"></a>build-in</h4><p>无效，没有意义</p>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>busybox:</p>
<pre><code># define delete_module(mod, flags) syscall(__NR_delete_module, mod, flags)</code></pre><p>kernel:</p>
<pre><code>.long sys_delete_module
#define __NR_delete_module      129

SYSCALL_DEFINE2(delete_module, const char __user *, name_user, unsigned int, flags)
{
    .
    if (mod-&gt;exit != NULL)
        mod-&gt;exit();
    .
}

asmlinkage long sys_delete_module(const char __user *name_user, unsigned int flags);</code></pre><h3 id="模块传参宏定义module-param"><a href="#模块传参宏定义module-param" class="headerlink" title="模块传参宏定义module_param()"></a>模块传参宏定义<strong>module_param()</strong></h3><pre><code>include/linux/moduleparam.h
#define module_param(name, type, perm)              \                                                                               
    module_param_named(name, name, type, perm)</code></pre><p>用于向模块传递参数，其允许驱动程序声明参数，并且用户在系统启动或模块装载时为参数指定相应值，<br>在驱动程序里，参数的用法如同全局变量。</p>
<ul>
<li>name既是用户看到的参数名，又是模块内接受参数的变量;</li>
<li>type表示参数的数据类型，是下列之一：byte, short, ushort, int, uint, long, ulong, charp, bool, invbool;</li>
<li>perm指定了在sysfs中相应文件的访问权限。<br>访问权限与linux文件爱你访问权限相同的方式管理，如0644，或使用stat.h中的宏如S_IRUGO表示。0表示完全关闭在sysfs中相对应的项。</li>
</ul>
<p>这些宏不会声明变量，因此在使用宏之前，必须声明变量，典型地用法如下：</p>
<pre><code>static unsigned int int_var = 0;
module_param(int_var, uint, S_IRUGO);</code></pre><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>mod-&gt;exit()怎么调用到 <strong>alias 为 cleanup_module</strong>的函数</li>
<li>mod-&gt;init()怎么调用到 <strong>alias 为 init_module</strong>的函数</li>
</ul>
<p>接下来分析module具体组成</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>gdb反汇编调试</title>
    <url>/2015/11/25/gdb-disassemble-debug/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>重点命令</strong>：<strong>display /i $pc</strong></p>
<h2 id="gdb-命令"><a href="#gdb-命令" class="headerlink" title="gdb 命令"></a><strong>gdb 命令</strong></h2><ul>
<li>file &lt;文件名&gt;加载被调试的可执行程序文件。</li>
<li>r Run的简写，运行被调试的程序。</li>
<li>c Continue的简写，继续执行被调试程序， 直至下一个断点或程序结束。</li>
<li>b &lt;行号&gt;</li>
<li>b &lt;函数名称&gt;</li>
<li>b *&lt;函数名称&gt;</li>
<li>b *&lt;代码地址&gt;</li>
<li>b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。<br>其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。</li>
<li>d [编号] Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。</li>
<li>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；<br>s 相当于其它调试器中的“Step Into (单步跟踪进入)”；</li>
<li>n: 执行一行源程序代码，此行代码中的函数调用也一并执行。<br>n 相当于其它调试器中的“Step Over (单步跟踪)”。</li>
<li>si命令类似于s命令，ni命令类似于n命令。 所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</li>
<li>p &lt;变量名称&gt;Print的简写，显示指定变量（临时变量或全 局变量）的值。</li>
<li>display，设置程序中断后欲显示的数据及 其格式。<br>例如，<strong>如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令<br>“display /i $pc”<br>其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。</strong></li>
<li>undispaly，取消先前的display设 置，编号从1开始递增。</li>
<li>i Info的简写，用于显示各类信息，详情请查阅 “help i”。</li>
<li>q Quit的简写，退出GDB调试环境。</li>
<li>help [命令名称]GDB帮助命令，提供对GDB名种命令的解释说明。<br>如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。</li>
</ul>
<h2 id="反汇编调试"><a href="#反汇编调试" class="headerlink" title="反汇编调试"></a><strong>反汇编调试</strong></h2><p>　</p>
<h3 id="显示汇编命令-display-i-pc"><a href="#显示汇编命令-display-i-pc" class="headerlink" title="显示汇编命令 display /i $pc"></a><strong>显示汇编命令 display /i $pc</strong></h3><pre><code>(gdb) display /i $pc
(gdb) si
20 n++;
1: x/i $pc 0x8048363 &lt;main+23&gt;: lea 0xfffffffc(%ebp),%eax
(gdb) si
0x08048366 20 n++;
1: x/i $pc 0x8048366 &lt;main+26&gt;: incl (%eax)
(gdb) si
21 n--;
1: x/i $pc 0x8048368 &lt;main+28&gt;: lea 0xfffffffc(%ebp),%eax
(gdb) si
0x0804836b 21 n--;
1: x/i $pc 0x804836b &lt;main+31&gt;: decl (%eax)
(gdb) si
23 nGlobalVar += 100;
1: x/i $pc 0x804836d &lt;main+33&gt;: addl $0x64,0x80494fc</code></pre><p>　</p>
<h3 id="汇编断点设置"><a href="#汇编断点设置" class="headerlink" title="汇编断点设置"></a><strong>汇编断点设置</strong></h3><p>使用命令“b *main”在 main 函数的 prolog 代码处设置断点<br>（<strong>prolog、epilog，分别表示编译器在每个函数的开头和结尾自行插入的代码</strong>）：</p>
<pre><code>(gdb) b *main
Breakpoint 4 at 0x804834c: file gdb-sample.c, line 17.
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample

Breakpoint 4, main () at gdb-sample.c:17
17 {
1: x/i $pc 0x804834c &lt;main&gt;: push %ebp
(gdb) si
0x0804834d 17 {
1: x/i $pc 0x804834d &lt;main+1&gt;: mov %esp,%ebp
(gdb) si
0x0804834f in main () at gdb-sample.c:17
17 {
1: x/i $pc 0x804834f &lt;main+3&gt;: sub $0x8,%esp
(gdb) si
0x08048352 17 {
1: x/i $pc 0x8048352 &lt;main+6&gt;: and $0xfffffff0,%esp
(gdb) si
0x08048355 17 {
1: x/i $pc 0x8048355 &lt;main+9&gt;: mov $0x0,%eax
(gdb) si
0x0804835a 17 {
1: x/i $pc 0x804835a &lt;main+14&gt;: sub %eax,%esp
(gdb) si
19 n = 1;
1: x/i $pc 0x804835c &lt;main+16&gt;: movl $0x1,0xfffffffc(%ebp)</code></pre><p>此时可以使用“i r”命令显示寄存器中的当前值———“i r”即“Infomation Register”：</p>
<pre><code>(gdb) i r
eax 0xbffff6a4 -1073744220
ecx 0x42015554 1107383636
edx 0x40016bc8 1073834952
ebx 0x42130a14 1108544020
esp 0xbffff6a0 0xbffff6a0
ebp 0xbffff6a8 0xbffff6a8
esi 0x40015360 1073828704
edi 0x80483f0 134513648
eip 0x8048366 0x8048366
eflags 0x386 902
cs 0x23 35
ss 0x2b 43
ds 0x2b 43
es 0x2b 43
fs 0x0 0
gs 0x33 51
当然也可以显示任意一个指定的寄存器值：
(gdb) i r eax
eax 0xbffff6a4 -1073744220</code></pre><p>　<br>1.<a href="http://blog.csdn.net/winterttr/article/details/5537638" target="_blank" rel="noopener">gdb中汇编调试</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>disassemble</tag>
      </tags>
  </entry>
  <entry>
    <title>逐行处理内存文本及正则表达式元字符列表</title>
    <url>/2015/11/18/deal-with-file-by-line/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="文本内容"><a href="#文本内容" class="headerlink" title="文本内容"></a>文本内容</h2><pre><code>P:013.0:E:11054:H:27500:5DDC29D54BE4D7:F3381AD050DE3A
P:091.5:E:03960:H:29700:DAE69F8B6E0106:E0DE2F8903AE55
P:105.5:E:03960:H:27500:CEF7CE422FF89E:E42DB81767E02E
P:166.0:E:03760:V:27690:7199819B0CF04F:7EE0F00CFFBF66
P:138.0:E:03703:V:04444:AD5CDBA991505A:1E1376FD07FB13
P:166.0:E:03830:H:14000:956D98AD9E6E84:842F2801182286</code></pre><p>或者：</p>
<pre><code>B:042.0:E:11919:V:24444:00012:1000000000000000:TRT3
B:042.0:E:11954:A:08800:00001:1111110011111800:EINTERCOM
B:042.0:E:11953:A:02980:00001:1212123312121233:
B:042.0:E:11996:V:27500:00300:A33130046167824A:Sci-Tech TV
B:042.0:E:12015:H:27500:00009:1000001010000010:Teledunya 3D
B:042.0:E:12130:V:27500:00024:1000000000000000:Radio Migros
B:042.0:E:12130:V:27500:00025:1000000000000000:Radio Tansas</code></pre><h2 id="逐行读取文本strsep"><a href="#逐行读取文本strsep" class="headerlink" title="逐行读取文本strsep"></a>逐行读取文本strsep</h2><pre><code>char *tok = NULL;
for (tok = strsep(&amp;p, &quot;\n&quot;); tok != NULL; tok = strsep(&amp;p, &quot;\n&quot;))
{
    printf(&quot;\033[33m%s\n\033[0m&quot;, tok);
    //TODO
}</code></pre><h2 id="处理单行格式化文本sscanf"><a href="#处理单行格式化文本sscanf" class="headerlink" title="处理单行格式化文本sscanf"></a>处理单行格式化文本sscanf</h2><p>sscanf() - 从一个字符串中读进与指定格式相符的数据.　函数原型:</p>
<pre><code>int sscanf( string str, string fmt, mixed var1, mixed var2 ...  );
int scanf( const char \*format [,argument]...  );</code></pre><p>说明：</p>
<p>sscanf与scanf类似，都是用于输入的，只是后者以屏幕(stdin)为输入源，前者以固定字符串为输入源。<br>其中的format可以是一个或多个 %[*] [width] [{h | l | I64 | L}]type | ‘ ‘ | ‘\t’ | ‘\n’ | 非%符号：</p>
<ol>
<li>* 亦可用于格式中, (即 %*d 和 %*s) 加了星号 (*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)</li>
<li>{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。</li>
<li>width表示读取宽度。</li>
<li>{h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节size,L表示4字节size(double例外),l64表示8字节size。</li>
<li>type :这就很多了，就是%s,%d,%c之类。</li>
<li>特别的：%*[width] [{h | l | I64 | L}]type 表示满足该条件的被过滤掉，不会向目标参数中写入值</li>
</ol>
<p>支持集合操作：</p>
<ol>
<li>%[a-z] 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)</li>
<li>%[A-Z] 表示匹配A到Z中任意字符，贪婪性(尽可能多的匹配)</li>
<li>%[aB’] 匹配a、B、’中一员，贪婪性</li>
<li>%[^a] 匹配非a的任意字符，贪婪性</li>
</ol>
<p>注意：在读入的字符串是空字符串时，sscanf函数并不改变待读入到的字符串的值。</p>
<p><strong>针对格式化文本的处理：</strong></p>
<pre><code>char longitude[6] = {0};
char direction = 0;
char frequency[6] = {0};
char polar = 0;
char symbol[6] = {0};
char sid[6] = {0};
char data0[EMU_KEY_STR_LEN] = {0};
char data1[EMU_KEY_STR_LEN] = {0};

if (type == 0)
{
    //B:004.0:W:11389:A:27500:00011:1A2B3C81C3B2A116:RTR                  
    sscanf(tok, &quot;%*1c:%5c:%1c:%5c:%1c:%5c:%5c:%16c:%16c&quot;,
            longitude, &amp;direction, frequency, &amp;polar, symbol, sid, data0, data1);
}
else
{ 
    //P:105.5:E:03960:H:27500:CEF7CE422FF89E:E42DB81767E02E
    sscanf(tok, &quot;%*1c:%5c:%1c:%5c:%1c:%5c:%14c:%14c&quot;,
            longitude, &amp;direction, frequency, &amp;polar, symbol, data0, data1);
}
pMinifs-&gt;symbol_rate = atoi(symbol);
.
.
.</code></pre><p>注意：<strong>%s与%c的区别，注意buf的长度包含字符串结束符‘\0’，长度如果不对，后续处理可能出现问题。</strong></p>
<h2 id="强制内存转换处理格式化文本"><a href="#强制内存转换处理格式化文本" class="headerlink" title="强制内存转换处理格式化文本"></a>强制内存转换处理格式化文本</h2><p>针对格式化文本还有一种内存强制转换的处理方式：</p>
<pre><code>struct DevData{
    char tag[2];
    char longitude[6];
    char direction[2];
    char frequency[6];
    char polar[2];
    char symbol_rate[6];
    char service_id[6];
    char key[KEY_STR_LEN+1];
    char prog_name[PROG_NAME_LENTH];
    char line_feed[2];//tail(0x0d0a or 0x0a)
} __attribute__((packed));

//获取文件数据
fd = fopen(path, &quot;r&quot;);
p = (char *)mallocz(size);
fseek(fd, 0, SEEK_SET);
fread(fd, p, 1, size);

//强制转换
struct DevData *pRootData=NULL;
for(i=0;i&lt;total_num;i++)
{
    pRootData = (struct DevData*)p1;
    .
    .
    //处理当前结构体pRootData，并获得偏移量用来取下一个结构体数据
    memset(atoi_buf,0,sizeof(atoi_buf));
    memcpy(atoi_buf,pRootData-&gt;symbol_rate,sizeof(pRootData-&gt;symbol_rate)-1);
    pMinifs-&gt;symbol_rate = atoi(atoi_buf);
    .
    p1 += offset;
}</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a><strong>特殊字符</strong></h3><h4 id=""><a href="#" class="headerlink" title="\"></a>\</h4><p>转义字符，将下一字符标记为特殊字符、文本、反向引用或八进制转义符</p>
<pre><code>&#39;\n&#39;匹配换行，
&#39;\\&#39;匹配&#39;\&#39;</code></pre><h4 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h4><p>匹配搜索字符串开始的位置。如果标志中包括 m（多行搜索）字符，^ 还将匹配 \n 或 \r 后面的位置。<br>如果将 ^ 用作括号表达式中的第一个字符，则会对字符集求反。</p>
<pre><code>^\d{3} 与搜索字符串开始处的 3 个数字匹配。
[^abc] 与除 a、b 和 c 以外的任何字符匹配。</code></pre><h4 id="-2"><a href="#-2" class="headerlink" title="$"></a>$</h4><p>匹配搜索字符串结尾的位置。 如果标志中包括 m（多行搜索）字符，^ 还将匹配 \n 或 \r 前面的位置。</p>
<pre><code>\d{3}$ 与搜索字符串结尾处的 3 个数字匹配。</code></pre><h4 id="-3"><a href="#-3" class="headerlink" title="*"></a>*</h4><p>零次或多次匹配前面的字符或子表达式。等效于 {0,}。</p>
<pre><code>zo\* 与“z”和“zoo”匹配。</code></pre><h4 id="-4"><a href="#-4" class="headerlink" title="+"></a>+</h4><p>一次或多次匹配前面的字符或子表达式。 等效于 {1,}。</p>
<pre><code>zo+ 与“zo”和“zoo”匹配，但与“z”不匹配。</code></pre><h4 id="-5"><a href="#-5" class="headerlink" title="?"></a>?</h4><p>零次或一次匹配前面的字符或子表达式。 等效于 {0,1}。<br>当 ? 紧随任何其他限定符（*、+、?、{n}、{n,} 或 {n,m}）之后时，匹配模式是非贪婪的。<br>非贪婪模式匹配搜索到的、尽可能少的字符串， 而默认的贪婪模式匹配搜索到的、尽可能多的字符串。</p>
<pre><code>zo? 与“z”和“zo”匹配，但与“zoo”不匹配。
o+? 只与“oooo”中的单个“o”匹配，而 o+ 与所有“o”匹配。
do(es)? 与“do”或“does”中的“do”匹配。</code></pre><h4 id="-6"><a href="#-6" class="headerlink" title="."></a>.</h4><p>匹配除换行符 \n 之外的任何单个字符。 若要匹配包括 \n 在内的任意字符，请使用诸如 [\s\S] 之类的模式。</p>
<pre><code>a.c 与“abc”、“a1c”和“a-c”匹配</code></pre><h4 id="-7"><a href="#-7" class="headerlink" title="[]"></a>[]</h4><p>标记括号表达式的开始和结尾。</p>
<pre><code>[1-4] 与“1”、“2”、“3”或“4”匹配。 [^aAeEiIoOuU] 与任何非元音字符匹配</code></pre><h4 id="-8"><a href="#-8" class="headerlink" title="{}"></a>{}</h4><p>标记限定符表达式的开始和结尾。</p>
<pre><code>a{2,3} 与“aa”和“aaa”匹配</code></pre><h4 id="-9"><a href="#-9" class="headerlink" title="()"></a>()</h4><p>标记子表达式的开始和结尾。 可以保存子表达式以备将来之用。</p>
<pre><code>A(\d) 与“A0”至“A9”匹配。 保存该数字以备将来之用</code></pre><h4 id="-10"><a href="#-10" class="headerlink" title="|"></a>|</h4><p>指示在两个或多个项之间进行选择。</p>
<pre><code>z|food 与“z”或“food”匹配。 (z|f)ood 与“zood”或“food”匹配</code></pre><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h4 id="b"><a href="#b" class="headerlink" title="\b"></a>\b</h4><p>与一个字边界匹配；即字与空格间的位置。</p>
<pre><code>er\b 与“never”中的“er”匹配，但与“verb”中的“er”不匹配</code></pre><h4 id="B"><a href="#B" class="headerlink" title="\B"></a>\B</h4><p>非边界字匹配。</p>
<pre><code>er\B 与“verb”中的“er”匹配，但与“never”中的“er”不匹配</code></pre><h4 id="d"><a href="#d" class="headerlink" title="\d"></a>\d</h4><p>数字字符匹配。 等效于 [0-9]。</p>
<pre><code>在搜索字符串“12 345”中，\d{2} 与“12”和“34”匹配。 \d 与“1”、“2”、“3”、“4”和“5”匹配。</code></pre><h4 id="D"><a href="#D" class="headerlink" title="\D"></a>\D</h4><p>非数字字符匹配。 等效于 [^0-9]。</p>
<pre><code>\D+ 与“abc123 def”中的“abc”和“def”匹配。</code></pre><h4 id="w"><a href="#w" class="headerlink" title="\w"></a>\w</h4><p>与以下任意字符匹配：A-Z、a-z、0-9 和下划线。 等效于 [A-Za-z0-9_]。</p>
<pre><code>在搜索字符串“The quick brown fox…”中，\w+ 与“The”、“quick”、“brown”和“fox”匹配。</code></pre><h4 id="W"><a href="#W" class="headerlink" title="\W"></a>\W</h4><p>与除 A-Z、a-z、0-9 和下划线以外的任意字符匹配。 等效于 [^A-Za-z0-9_]。</p>
<pre><code>在搜索字符串“The quick brown fox…”中，\W+ 与“…”和所有空格匹配。</code></pre><h4 id="xyz"><a href="#xyz" class="headerlink" title="[xyz]"></a>[xyz]</h4><p>字符集。 与任何一个指定字符匹配。</p>
<pre><code>[abc] 与“plain”中的“a”匹配。</code></pre><h4 id="xyz-1"><a href="#xyz-1" class="headerlink" title="[^xyz]"></a>[^xyz]</h4><p>反向字符集。 与未指定的任何字符匹配。</p>
<pre><code>[^abc] 与“plain”中的“p”、“l”、“i”和“n”匹配。</code></pre><h4 id="a-z"><a href="#a-z" class="headerlink" title="[a-z]"></a>[a-z]</h4><p>字符范围。 匹配指定范围内的任何字符。</p>
<pre><code>[a-z] 与“a”到“z”范围内的任何小写字母字符匹配。</code></pre><h4 id="a-z-1"><a href="#a-z-1" class="headerlink" title="[^a-z]"></a>[^a-z]</h4><p>反向字符范围。 与不在指定范围内的任何字符匹配。</p>
<pre><code>[^a-z] 与不在范围“a”到“z”内的任何字符匹配。</code></pre><h4 id="n"><a href="#n" class="headerlink" title="{n}"></a>{n}</h4><p>正好匹配 n 次。 n 是非负整数。</p>
<pre><code>o{2} 与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。</code></pre><h4 id="n-1"><a href="#n-1" class="headerlink" title="{n,}"></a>{n,}</h4><p>至少匹配 n 次。 n 是非负整数。</p>
<pre><code>* 与 {0,} 相等。
+ 与 {1,} 相等。
o{2,} 与“Bob”中的“o”不匹配，但与“foooood”中的所有“o”匹配。</code></pre><h4 id="n-m"><a href="#n-m" class="headerlink" title="{n,m}"></a>{n,m}</h4><p>匹配至少 n 次，至多 m 次。 n 和 m 是非负整数，其中 n &lt;= m。 逗号和数字之间不能有空格。</p>
<pre><code>? 与 {0,1} 相等。
在搜索字符串“1234567”中，\d{1,3} 与“123”、“456”和“7”匹配。</code></pre><h4 id="pattern"><a href="#pattern" class="headerlink" title="(pattern)"></a>(pattern)</h4><p>与pattern 匹配并保存匹配项。 若要匹配括号字符 (  )，请使用“(”或者“)”。</p>
<pre><code>(Chapter|Section) [1-9] 与“Chapter 5”匹配，保存“Chapter”以备将来之用。</code></pre><h4 id="pattern-1"><a href="#pattern-1" class="headerlink" title="(?:pattern)"></a>(?:pattern)</h4><p>与pattern 匹配，但不保存匹配项；即不会存储匹配项以备将来之用。 这对于用“or”字符 (|) 组合模式部件的情况很有用。</p>
<pre><code>industr(?:y|ies) 与 industry|industries 相等。</code></pre><h4 id="pattern-2"><a href="#pattern-2" class="headerlink" title="(?=pattern)"></a>(?=pattern)</h4><p>正预测先行。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用。</p>
<pre><code>^(?=.\*\d).{4,8}$ 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。</code></pre><p>在该模式中，.*\d 查找后跟有数字的任意多个字符。 对于搜索字符串“abc3qr”，这与“abc3”匹配。<br>从该匹配项之前（而不是之后）开始，.{4,8} 与包含 4-8 个字符的字符串匹配。 这与“abc3qr”匹配。<br>^ 和 $ 指定搜索字符串的开始和结束位置。 这将在搜索字符串包含匹配字符之外的任何字符时阻止匹配。</p>
<h4 id="pattern-3"><a href="#pattern-3" class="headerlink" title="(?!pattern)"></a>(?!pattern)</h4><p>负预测先行。 匹配与模式 不匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用。</p>
<pre><code>\b(?!th)\w+\b 与不以“th”开头的单词匹配。</code></pre><p>在该模式中，\b 与一个字边界匹配。 对于搜索字符串“ quick ”，这与第一个空格匹配。 (?!th) 与非“th”字符串匹配。 这与“qu”匹配。<br>从该匹配项开始，\w+ 与一个字匹配。 这与“quick”匹配。</p>
<h4 id="cx"><a href="#cx" class="headerlink" title="\cx"></a>\cx</h4><p>匹配 x 指示的控制字符。 x 的值必须在 A-Z 或 a-z 范围内。 如果不是这样，则假定 c 就是文本“c”字符本身。</p>
<pre><code>\cM 与 Ctrl+M 或一个回车符匹配。</code></pre><h4 id="xn"><a href="#xn" class="headerlink" title="\xn"></a>\xn</h4><p>匹配 n，此处的 n 是一个十六进制转义码。<br>十六进制转义码必须正好是两位数长。 允许在正则表达式中使用 ASCII 代码。</p>
<pre><code>\x41 与“A”匹配。 \x041 等效于后跟有“1”的“\x04”（因为 n 必须正好是两位数）。</code></pre><h4 id="num"><a href="#num" class="headerlink" title="\num"></a>\num</h4><p>匹配 num，此处的 num 是一个正整数。 这是对已保存的匹配项的引用。</p>
<pre><code>(.)\1 与两个连续的相同字符匹配。</code></pre><h4 id="n-2"><a href="#n-2" class="headerlink" title="\n"></a>\n</h4><p>标识一个八进制转义码或反向引用。 如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。<br>否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</p>
<pre><code>(\d)\1 与两个连续的相同数字匹配。</code></pre><h4 id="nm"><a href="#nm" class="headerlink" title="\nm"></a>\nm</h4><p>标识一个八进制转义码或反向引用。 如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。<br>如果 \nm 前面至少有 n 个捕获子表达式，则 n 是反向引用，后面跟有文本 m。<br>如果上述情况都不存在，当 n 和 m 是八进制数字 (0-7) 时，\nm 匹配八进制转义码 nm。</p>
<pre><code>\11 与制表符匹配。</code></pre><h4 id="nml"><a href="#nml" class="headerlink" title="\nml"></a>\nml</h4><p>当 n 是八进制数字 (0-3)，m 和 l 是八进制数字 (0-7) 时，匹配八进制转义码 nml。</p>
<pre><code>\011 与制表符匹配。</code></pre><h4 id="un"><a href="#un" class="headerlink" title="\un"></a>\un</h4><p>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。</p>
<pre><code>\u00A9 与版权符号 (©) 匹配。</code></pre><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><ul>
<li>\f 换页符。 \x0c 和 \cL</li>
<li>\n 换行符。 \x0a 和 \cJ</li>
<li>\r 回车符。 \x0d 和 \cM</li>
<li>\s 任何空白字符。 其中包括空格、制表符和换页符。 [ \f\n\r\t\v ]</li>
<li>\S 任何非空白字符。 [^ \f\n\r\t\v]</li>
<li>\t Tab 字符。 \x09 和 \cI</li>
<li>\v 垂直制表符。 \x0b 和 \cK</li>
</ul>
<ol>
<li><a href="http://blog.chinaunix.net/uid-26284412-id-3189214.html" target="_blank" rel="noopener">sscanf的高级用法</a></li>
<li><a href="http://www.cnblogs.com/lyq105/archive/2009/11/28/1612677.html" target="_blank" rel="noopener">C语言函数sscanf()的用法</a></li>
<li><a href="http://www.kryptosx.info/archives/60.html" target="_blank" rel="noopener">scanf的正则表达式总结</a></li>
<li><a href="http://blog.csdn.net/tujiaw/article/details/6139896" target="_blank" rel="noopener">scanf、sscanf中的正则表达式</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>regexp</tag>
        <tag>doline</tag>
        <tag>sscanf</tag>
      </tags>
  </entry>
  <entry>
    <title>vim中使用grep、sed删除匹配行</title>
    <url>/2015/11/17/vim-tips-1/</url>
    <content><![CDATA[<p>在调试过程中经常需要分析打印、数据等等，在大量文本中仅仅需要提取需要关心的部分，使用用例如下：</p>
<p><strong>删除匹配行：</strong></p>
<pre><code>%!grep -v &quot;cscope&quot;
%!sed &#39;/cscope/&#39;d</code></pre><p><strong>只保留匹配行：</strong></p>
<pre><code>%!grep &quot;cscope&quot;</code></pre><p>grep、sed可以使用正则表达式来完成复杂匹配。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>grep</tag>
        <tag>vim</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb dump内存数据</title>
    <url>/2015/11/16/gdb-dump-memory/</url>
    <content><![CDATA[<p><strong>gdb调试过程中从内存中dump出相关数据用于分析</strong></p>
<h2 id="help-dump"><a href="#help-dump" class="headerlink" title="help dump"></a><strong>help dump</strong></h2><p>在gdb中输入：</p>
<pre><code>(gdb) help dump
Dump target code/data to a local file.

List of dump subcommands:

dump binary -- Write target code/data to a raw binary file
dump ihex -- Write target code/data to an intel hex file
dump memory -- Write contents of memory to a raw binary file
dump srec -- Write target code/data to an srec file
dump tekhex -- Write target code/data to a tekhex file
dump value -- Write the value of an expression to a raw binary file

Type &quot;help dump&quot; followed by dump subcommand name for full documentation.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.
Command name abbreviations are allowed if unambiguous.

dump [格式] memory 文件名 起始地址 结构地址 #   把指定内存段写到文件
dump [格式] value 文件名 表达式             #   把指定值写到文件</code></pre><p>格式包括:</p>
<ul>
<li>binary      原始二进制格式</li>
<li>ihex        intel 16进制格式</li>
<li>srec        S-recored格式</li>
<li>tekhex      tektronix 16进制格式</li>
</ul>
<p>命令具体参数格式：</p>
<pre><code>dump binary memory filename start_addr end_addr
    Dump contents of memory from start_addr to end_addr into raw binary format file filename.
dump binary value filename expression
    Dump value of expression into raw binary format file filename.
dump ihex memory filename start_addr end_addr
    Dump contents of memory from start_addr to end_addr into intel hex format file filename.
dump ihex value filename expression
    Dump value of expression into intel hex format file filename.
dump srec memory filename start_addr end_addr
    Dump contents of memory from start_addr to end_addr into srec format file filename.
dump srec value filename expression
    Dump value of expression into srec format file filename.
dump tekhex memory filename start_addr end_addr
    Dump contents of memory from start_addr to end_addr into tekhex format file filename.
dump tekhex value filename expression
    Dump value of expression into tekhex format file filename.</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h2><pre><code>(gdb) dump binary memory file $1 $2         //$1 $2为地址
(gdb) dump binary memory ./dump s1 s1+5     //s1为数组
(gdb) dump memory file 0x9000xxxx 0x9001xxxx     //s1为数组</code></pre><p>通过以上command来完成内存对比。</p>
<ol>
<li><a href="http://www.delorie.com/gnu/docs/gdb/gdb_69.html" target="_blank" rel="noopener">Copy between memory and a file</a></li>
<li><a href="http://blog.csdn.net/zhangmiaoping23/article/details/40892261" target="_blank" rel="noopener">gdb 内存复制到/从文件</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>AStyle代码排版整理</title>
    <url>/2015/11/10/vim-astyle/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>两种安装方式：</p>
<ol>
<li><a href="http://sourceforge.net/projects/astyle/files/" target="_blank" rel="noopener">官网</a>下载源码编译安装</li>
<li>sudo apt-get install astyle</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>两种配置方式：</p>
<ol>
<li>配置文件~/.astylerc</li>
<li>执行命令携带参数</li>
</ol>
<p>配置文件例子如下：</p>
<pre><code>--style=linux                  # -A8
--indent=force-tab             # -T,  强制 TAB 缩进
--break-blocks                 # -f,  Pad empty lines around header blocks (e.g. &#39;if&#39;, &#39;for&#39;, &#39;while&#39;...)
--attach-namespaces            # -xn, Attach brackets to a namespace statement
--attach-classes               # -xc, Attach brackets to a class statement
--delete-empty-lines           # -xe, 删除函数内多余的空行
--align-pointer=name           # -k3, *号靠近变量名
--remove-brackets              # -xj, if,while,for 等代码是单行行时，去掉 {}
--close-templates              # -xy, 模板中无空格, 如：Stack&lt;int,List&lt;int&gt;&gt; stack1;
--pad-oper                     # -p,  运算符两边加空格
--indent-preproc-define        # -w,  宏定义缩进
--indent-col1-comments         # -y,  注释缩进
--unpad-paren                  # -U,  Remove extra space padding around parenthesis on the inside and outside
--pad-header                   # -H,  关键字后加空格
--break-after-logical          # -xL
--lineend=linux                # -z2
--indent=tab                   # -t</code></pre><p>执行参数例子如下：</p>
<pre><code>-A8xnxcxek3xyfTpEwyUHxLz3t</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>自动排版命令：</p>
<pre><code>indent -npsl
astyle -A8xnxcxek3xyfTpEwyUHxLz3t
find -name &quot;*.[ch]*&quot; | xargs indent -npsl | xargs astyle -A8xnxcxek3xyfTpEwyUHxLz3t</code></pre><h2 id="与vim结合"><a href="#与vim结合" class="headerlink" title="与vim结合"></a>与vim结合</h2><p>最终成品如下：</p>
<pre><code>function! CodeFormat()
    ks
    &quot;let curfile = expand(&quot;%&quot;)
    &quot;let curfile = expand(&quot;%:t&quot;)
    &quot;echo curfile
    silent! %s/^M//g
    silent! exec &#39;%!astyle -A3LYfpjk3NSEUHwyW3xC100 --style=break&#39;
    silent! %g/^\s*$\n\s*$/d
    silent! %s/\s\+$//g
    &#39;s
endfunction

autocmd BufNewFile,BufRead *.c call CodeFormat()
autocmd BufNewFile,BufRead *.h call CodeFormat()
nmap &lt;leader&gt;&lt;leader&gt;q :call CodeFormat()&lt;CR&gt;</code></pre><p>解析如下：</p>
<ul>
<li>ks ‘s 保存当前行位置</li>
<li>expand(“%”) 取file变量</li>
<li>expand(“%:t”) 取文件名</li>
<li>silent! 静默执行命令</li>
<li>%s/^M//g 将<br>删除，相当于dos2unix</li>
<li>exec 执行命令</li>
<li>%!astyle -A3LYfpjk3NSEUHwyW3xC100 –style=break 携带参数执行外部命令</li>
<li>%g/^\s<em>$\n\s</em>$/d 删除多行空行为一行</li>
<li>%s/\s+$//g 删除行尾空格</li>
<li>autocmd BufNewFile,BufRead *.c 打开c文件时，自动调用函数CodeFormat()</li>
<li>nmap 映射快捷键</li>
</ul>
<p>astyle参数解析：</p>
<ul>
<li>-A3: Kernighan &amp; Ritchie style uses linux brackets</li>
<li>-L: 标签缩进</li>
<li>-Y: 注释缩进</li>
<li>-f: 空行分隔没有关系的块,类,标签(不包括函数块)</li>
<li>-p: 操作符两端插入一个空格 </li>
<li>-j: if,while,for 等代码是单行行时，加 {}</li>
<li>-k3: *号靠近变量名</li>
<li>-N: 缩进命名空间定义行</li>
<li>-S: switch 与case不同列,case缩进</li>
<li>-E: 块间空行的换行符前插入一个空格</li>
<li>-U: 移除括号两端多余空格</li>
<li>-H: 关键字后加空格</li>
<li>-w: 宏定义缩进</li>
<li>-y: else catch左边的大括号与else catch分隔</li>
<li>-W3: &amp;号靠近变量名</li>
<li>-xC100: 代码最大长度100,超过之后进行换行</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://tonybai.com/2010/07/29/use-astyle-to-beautify-your-code/" target="_blank" rel="noopener">使用astyle美化代码</a></li>
<li><a href="http://blog.163.com/jiangmc@yeah/blog/static/126590885201031611844360/" target="_blank" rel="noopener">Vim整合AStyle进行代码美化</a></li>
<li><a href="http://blog.chinaunix.net/uid-20662363-id-1904145.html" target="_blank" rel="noopener"> Astyle编程语言格式化工具的中文说明 </a></li>
<li><a href="http://blog.csdn.net/memory_xj/article/details/2983093" target="_blank" rel="noopener">Astyle：代码格式化工具简明指南</a></li>
<li><a href="http://astyle.sourceforge.net/astyle.html" target="_blank" rel="noopener">Artistic Style 3.1</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>code style</tag>
        <tag>astyle</tag>
      </tags>
  </entry>
  <entry>
    <title>网络性能调优（TCP/UDP）</title>
    <url>/2015/11/09/udp-packet-loss/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="检查协议栈buffer"><a href="#检查协议栈buffer" class="headerlink" title="检查协议栈buffer"></a><strong>检查协议栈buffer</strong></h2><p>检查buffer大小，修改之后重启网络服务：</p>
<pre><code>sysctl -a |grep net.core
net.core.rmem_default = 212992
net.core.rmem_max = 212992</code></pre><p>检查网卡收包情况：</p>
<pre><code>2015 git:(master)✗ &gt; netstat -su
IcmpMsg:
    InType3: 366
    OutType3: 325
Udp:
    88110 packets received
    325 packets to unknown port received.
    0 packet receive errors
    6219 packets sent
    IgnoredMulti: 2208
UdpLite:
IpExt:
    InMcastPkts: 1945
    OutMcastPkts: 35
    InBcastPkts: 42730
    OutBcastPkts: 261
    InOctets: 192296247659
    OutOctets: 192200794856
    InMcastOctets: 220327
    OutMcastOctets: 5370
    InBcastOctets: 4953400
    OutBcastOctets: 30722
    InNoECTPkts: 6131438
    InECT0Pkts: 127</code></pre><h2 id="检查socket收发缓冲区"><a href="#检查socket收发缓冲区" class="headerlink" title="检查socket收发缓冲区"></a><strong>检查socket收发缓冲区</strong></h2><p>TCP 的性能取决于几个方面的因素。两个最重要的因素是：</p>
<ol>
<li>链接带宽（link bandwidth）（报文在网络上传输的速率）</li>
<li>往返时间（round-trip time） 或 RTT（发送报文与接收到另一端的响应之间的延时）</li>
</ol>
<p><strong>这两个值确定了称为 Bandwidth Delay Product（BDP）的内容</strong>。<br>给定链接带宽和 RTT 之后，您就可以计算出 BDP 的值了，<br><strong>BDP 给出了一种简单的方法来计算理论上最优的 TCP socket 缓冲区大小</strong>（其中保存了排队等待传输和等待应用程序接收的数据）。</p>
<p>如果缓冲区太小，那么 TCP 窗口就不能完全打开，这会对性能造成限制。<br>如果缓冲区太大，那么宝贵的内存资源就会造成浪费。<br>如果您设置的缓冲区大小正好合适，那么就可以完全利用可用的带宽。下面我们来看一个例子：</p>
<p>如果应用程序是通过一个 100Mbps 的局域网进行通信，其 RRT 为 50 ms，那么 BDP 就是：</p>
<pre><code>BDP = link_bandwidth * RTT
100MBps * 0.050 sec / 8 = 0.625MB = 625KB</code></pre><p>注意：此处除以 8 是将位转换成通信使用的字节。</p>
<p>因此，我们可以将 TCP 窗口设置为 BDP 或 1.25MB。<br>但是在 <strong>Linux 2.6 上默认的 TCP 窗口大小是 110KB</strong>，这会将连接的带宽限制为 2.2MBps，计算方法如下：</p>
<pre><code>throughput = window_size / RTT
110KB / 0.050 = 2.2MBps</code></pre><p>如果使用上面计算的窗口大小，我们得到的带宽就是 12.5MBps，计算方法如下：</p>
<pre><code>625KB / 0.050 = 12.5MBps</code></pre><p>差别的确很大，并且可以为 socket 提供更大的吞吐量。<br>Sockets API 提供了几个 socket 选项，其中两个可以用于修改 socket 的发送和接收缓冲区的大小。<br><strong>使用 SO_SNDBUF 和 SO_RCVBUF 选项来调整发送和接收缓冲区的大小</strong>。<br>注意：尽管 socket 缓冲区的大小确定了通告 TCP 窗口的大小，但是 TCP 还在通告窗口内维护了一个拥塞窗口。<br>因此，由于这个拥塞窗口的存在，给定的 socket 可能永远都不会利用最大的通告窗口。</p>
<p>修改默认socket收发缓冲区大小：</p>
<pre><code>int ret, sock, sock_buf_size;
sock = socket( AF_INET, SOCK_STREAM, 0  );
sock_buf_size = 64*1024;
ret = setsockopt( sock, SOL_SOCKET, SO_SNDBUF,
        (char *)&amp;sock_buf_size, sizeof(sock_buf_size) );
ret = setsockopt( sock, SOL_SOCKET, SO_RCVBUF,
        (char *)&amp;sock_buf_size, sizeof(sock_buf_size) );</code></pre><h2 id="禁用-Nagle-算法"><a href="#禁用-Nagle-算法" class="headerlink" title="禁用 Nagle 算法"></a>禁用 Nagle 算法</h2><p>在通过 TCP socket 进行通信时，数据都拆分成了数据块，<br>这样它们就可以封装到给定连接的 TCP payload（指 TCP 数据包中的有效负荷）中了。<br>TCP payload 的大小取决于几个因素（例如最大报文长度和路径），<br>但是这些因素在连接发起时都是已知的。<br>为了达到最好的性能，我们的目标是使用尽可能多的可用数据来填充每个报文。<br><strong>当没有足够的数据来填充 payload 时（也称为最大报文段长度（maximum segment size） 或 MSS），<br>TCP 就会采用 Nagle 算法自动将一些小的缓冲区连接到一个报文段中。</strong><br>这样可以通过最小化所发送的报文的数量来提高应用程序的效率，并减轻整体的网络拥塞问题。</p>
<p>尽管 John Nagle 的算法可以通过将这些数据连接成更大的报文来最小化所发送的报文的数量，<br>但是有时您可能希望只发送一些较小的报文。<br>一个简单的例子是 telnet 程序，它让用户可以与远程系统进行交互，这通常都是通过一个 shell 来进行的。<br>如果用户被要求用发送报文之前输入的字符来填充某个报文段，那么这种方法就绝对不能满足我们的需要。<br>另外一个例子是 HTTP 协议。通常，客户机浏览器会产生一个小请求（一条 HTTP 请求消息），<br>然后 Web 服务器就会返回一个更大的响应（Web 页面）。</p>
<p>您应该考虑的第一件事情是 Nagle 算法满足一种需求。<br><strong>由于这种算法对数据进行合并，试图构成一个完整的 TCP 报文段，因此它会引入一些延时。</strong><br>但是这种算法可以最小化在线路上发送的报文的数量，因此可以最小化网络拥塞的问题。<br>但是在需要最小化传输延时的情况中，Sockets API 可以提供一种解决方案。<br>要<strong>禁用 Nagle 算法，您可以设置 TCP_NODELAY socket 选项。</strong></p>
<p>为TCP socket 禁用 Nagle 算法</p>
<pre><code>int sock, flag, ret;
/* Create new stream socket */
sock = socket( AF_INET, SOCK_STREAM, 0  );
/* Disable the Nagle (TCP No Delay) algorithm */
flag = 1;
ret = setsockopt( sock, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;flag, sizeof(flag)  );
if (ret == -1) {
printf(&quot;Couldn&#39;t setsockopt(TCP_NODELAY)\n&quot;);
    exit(-1);
}</code></pre><p>使用 Samba 的实验表明，在从 Microsoft® Windows® 服务器上的 Samba 驱动器上读取数据时，禁用 Nagle 算法几乎可以加倍提高读性能。</p>
<h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>我们知道TCP链接是有很多开销的，<strong>一个是会占用文件描述符，另一个是会开缓存</strong>，<br>一般来说一个系统可以支持的TCP链接数是有限的，我们需要清楚地认识到<strong>TCP链接对系统的开销是很大的</strong>。<br>正是因为TCP是耗资源的，所以，很多攻击都是让你系统上出现大量的TCP链接，把你的系统资源耗尽。比如著名的SYNC Flood攻击。</p>
<p>所以，我们要<strong>注意配置KeepAlive参数</strong>，这个参数的意思是定义一个时间，<br>如果链接上没有数据传输，系统会在这个时间发一个包，如果没有收到回应，<br>那么TCP就认为链接断了，然后就会把链接关闭，这样可以回收系统资源开销。<br>（注：HTTP层上也有KeepAlive参数）对于像HTTP这样的短链接，设置一个1-2分钟的keepalive非常重要。<br>这可以在一定程度上防止DoS攻击。有下面几个参数（下面这些参数的值仅供参考）：</p>
<pre><code>net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_intvl = 20
net.ipv4.tcp_fin_timeout = 30</code></pre><p>对于TCP的TIME_WAIT这个状态，主动关闭的一方进入TIME_WAIT状态，<br>TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)，默认为4分钟，TIME_WAIT状态下的资源不能回收。<br>有大量的TIME_WAIT链接的情况一般是在HTTP服务器上。对此，有两个参数需要注意，</p>
<pre><code>net.ipv4.tcp_tw_reuse=1
net.ipv4.tcp_tw_recycle=1</code></pre><p>前者表示重用TIME_WAIT，后者表示回收TIME_WAIT的资源。</p>
<p><strong>TCP还有一个重要的概念叫RWIN（TCP Receive Window Size），<br>这个东西的意思是，我一个TCP链接在没有向Sender发出ack时可以接收到的最大的数据包。<br>为什么这个很重要？因为如果Sender没有收到Receiver发过来ack，<br>Sender就会停止发送数据并会等一段时间，如果超时，那么就会重传。<br>这就是为什么TCP链接是可靠链接的原因。<br>重传还不是最严重的，如果有丢包发生的话，TCP的带宽使用率会马上受到影响（会盲目减半），<br>再丢包，再减半，然后如果不丢包了，就逐步恢复。</strong>相关参数如下：</p>
<pre><code>net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216</code></pre><p>一般来说，<strong>理论上的RWIN应该设置成：吞吐量 * 回路时间</strong>。<br><strong>Sender端的buffer应该和RWIN有一样的大小</strong>，<br>因为Sender端发送完数据后要等Receiver端确认，如果网络延时很大，<br>buffer过小了，确认的次数就会多，于是性能就不高，对网络的利用率也就不高了。<br>也就是说，<strong>对于延迟大的网络，我们需要大的buffer，这样可以少一点ack，多一些数据，对于响应快一点的网络，可以少一些buffer</strong>。<br>因为，如果有丢包（没有收到ack），buffer过大可能会有问题，因为这会让TCP重传所有的数据，反而影响网络性能。<br>（当然，网络差的情况下，就别玩什么高性能了） 所以，<br>高性能的网络重要的是要让网络丢包率非常非常地小（基本上是用在LAN里），<br>如果网络基本是可信的，这样用大一点的buffer会有更好的网络传输性能（来来回回太多太影响性能了）。</p>
<h2 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h2><p>说到UDP的调优，有一些事我想重点说一样，那就是<strong>MTU——最大传输单元（其实这对TCP也一样，因为这是链路层上的东西）</strong>。<br>对于一个UDP的包，我们要尽量地让他大到MTU的最大尺寸再往网络上传，这样可以最大化带宽利用率。<br>对于这个MTU，以太网是1500字节，光纤是4352字节，802.11无线网是7981。<br>但是，当我们用TCP/UDP发包的时候，<br>我们的有效负载Payload要低于这个值，因为<strong>IP协议会加上20个字节，UDP会加上8个字节（TCP加的更多）</strong>，<br>所以，一般来说，你的一个UDP包的最大应该是1500-8-20=1472，这是你的数据的大小。<br>当然，如果你用光纤的话， 这个值就可以更大一些。</p>
<p>再多说一下，使用Socket编程的时候，你可以<strong>使用setsockopt() 设置 SO_SNDBUF/SO_RCVBUF 的大小，TTL和KeepAlive这些关键的设置</strong></p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>关于多路复用技术，也就是用一个线程来管理所有的TCP链接，有三个系统调用要重点注意：</p>
<ol>
<li>一个是select，这个系统调用只支持上限1024个链接</li>
<li>第二个是poll，其可以突破1024的限制，但是select和poll本质上是使用的轮询机制，<br>轮询机制在链接多的时候性能很差，因主是O(n)的算法</li>
<li>所以，epoll出现了，epoll是操作系统内核支持的，仅当在链接活跃时，操作系统才会callback，<br>这是由操作系统通知触发的，但其只有Linux Kernel 2.6以后才支持（准确说是2.5.44中引入的），<br>当然，如果所有的链接都是活跃的，过多的使用epoll_ctl可能会比轮询的方式还影响性能，不过影响的不大。</li>
</ol>
<p>另外，<strong>关于一些和DNS Lookup的系统调用要小心，比如：gethostbyaddr/gethostbyname，<br>这个函数可能会相当的费时，因为其要到网络上去找域名，因为DNS的递归查询，会导致严重超时，<br>而又不能通过设置什么参数来设置time out</strong>，<br>对此你可以通过配置hosts文件来加快速度，或是自己在内存中管理对应表，在程序启动时查好，<br>而不要在运行时每次都查。</p>
<p>另外，<strong>在多线程下面，gethostbyname会一个更严重的问题，<br>就是如果有一个线程的gethostbyname发生阻塞，<br>其它线程都会在gethostbyname处发生阻塞</strong>，这个比较变态，要小心。<br>（你可以试试GNU的gethostbyname_r()，这个的性能要好一些） 这种到网上找信息的东西很多，<br>比如，如果你的Linux使用了NIS，或是NFS，某些用户或文件相关的系统调用就很慢，所以要小心。</p>
<h2 id="检查防火墙"><a href="#检查防火墙" class="headerlink" title="检查防火墙"></a>检查防火墙</h2><pre><code>iptables -L</code></pre><p>如果iptables工作，需要关闭：</p>
<pre><code>service iptables stop</code></pre><h2 id="Linux内核参数优化"><a href="#Linux内核参数优化" class="headerlink" title="Linux内核参数优化"></a>Linux内核参数优化</h2><ol>
<li>/proc/sys/net/core/rmem_max — 最大的TCP数据接收缓冲。</li>
<li>/proc/sys/net/core/wmem_max — 最大的TCP数据发送缓冲。</li>
<li>/proc/sys/net/ipv4/tcp_timestamps — 时间戳在(请参考RFC 1323)TCP的包头增加12个字节。</li>
<li>/proc/sys/net/ipv4/tcp_sack — 有选择的应答。</li>
<li>/proc/sys/net/ipv4/tcp_window_scaling — 支持更大的TCP窗口. 如果TCP窗口最大超过65535(64KB), 必须设置该数值为1。</li>
<li>rmem_default — 默认的接收窗口大小。</li>
<li>rmem_max — 接收窗口的最大大小。</li>
<li>wmem_default — 默认的发送窗口大小。</li>
<li>wmem_max — 发送窗口的最大大小。</li>
</ol>
<p>/proc目录下的所有内容都是临时性的, 所以重启动系统后任何修改都会丢失。<br>建议在系统启动时自动修改TCP/IP参数，两种方式：</p>
<ol>
<li>修改/etc/rc.local</li>
<li>修改/etc/sysctl.conf </li>
</ol>
<h2 id="GUN-Linux网络工具"><a href="#GUN-Linux网络工具" class="headerlink" title="GUN/Linux网络工具"></a>GUN/Linux网络工具</h2><p>GNU/Linux 提供了几个工具 —— 有些是 GNU/Linux 自己提供的，<br>有些是开放源码软件 —— 用于调试网络应用程序，测量带宽/吞吐量，以及检查链接的使用情况。</p>
<p><strong>任何 GNU/Linux 发行版中都可以找到的工具：</strong></p>
<ol>
<li><strong>ping</strong>这是用于检查主机的可用性的最常用的工具，但是也可以用于识别带宽延时产品计算的 RTT。</li>
<li><strong>traceroute</strong>打印某个连接到网络主机所经过的包括一系列路由器和网关的路径（路由），从而确定每个 hop 之间的延时。</li>
<li><strong>netstat</strong>确定有关网络子系统、协议和连接的各种统计信息。</li>
<li><strong>tcpdump</strong>显示一个或多个连接的协议级的报文跟踪信息；其中还包括时间信息，您可以使用这些信息来研究不同协议服务的报文时间。</li>
</ol>
<p><strong>GNU/Linux 发行版中没有提供的有用性能工具：</strong></p>
<ol>
<li><strong>netlog</strong>为应用程序提供一些有关网络性能方面的信息。</li>
<li><strong>nettimer</strong>为瓶颈链接带宽生成一个度量标准；可以用于协议的自动优化。</li>
<li><strong>Ethereal</strong>以一个易于使用的图形化界面提供了 tcpump（报文跟踪）的特性。</li>
<li><strong>iperf</strong>测量 TCP 和 UDP 的网络性能；测量最大带宽，并汇报延时和数据报的丢失情况。</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-hisock.html" target="_blank" rel="noopener">提高 Linux 上 socket 性能</a></li>
<li><a href="http://my.oschina.net/sharelinux/blog/146282" target="_blank" rel="noopener">浅谈linux性能调优之十四:调节socket缓冲区</a></li>
<li><a href="http://coolshell.cn/articles/7490.html" target="_blank" rel="noopener">性能调优攻略</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>Tools</category>
        <category>TCP</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>network</tag>
        <tag>tcp</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp udp send流程分析</title>
    <url>/2015/11/08/tcp-udp-send-sendto/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a><strong>tips</strong></h2><p>net/ipv4/af_inet.c 查看：inet_stream_ops 和 inet_dgram_ops</p>
<h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a><strong>TCP和UDP</strong></h2><p>TCP（传输控制协议）和UDP（用户数据报协议）是网络体系结构TCP/IP模型中传输层一层中的两个不同的通信协议。</p>
<ol>
<li>TCP：传输控制协议，一种面向连接的协议，给用户进程提供可靠的全双工的字节流，TCP套接口是字节流套接口(stream socket)的一种。</li>
<li>UDP：用户数据报协议。UDP是一种无连接协议。UDP套接口是数据报套接口(datagram socket)的一种。</li>
</ol>
<h3 id="TCP-Client-Server框架"><a href="#TCP-Client-Server框架" class="headerlink" title="TCP Client-Server框架"></a><strong>TCP Client-Server框架</strong></h3><p><img src="/images/socket/tcp-socket.jpg" alt="TCP" title="TCP"></p>
<p>服务器程序流程：</p>
<ol>
<li>程序初始化</li>
<li>填写本机地址信息</li>
<li>绑定并监听一个固定的端口</li>
<li>收到Client的连接后建立一个socket连接</li>
<li>产生一个新的进程与Client进行通信和信息处理</li>
<li>子通信结束后中断与Client的连接</li>
</ol>
<p>客户端程序流程：</p>
<ol>
<li>程序初始化</li>
<li>填写服务器地址信息</li>
<li>连接服务器</li>
<li>与服务器通信和信息处理</li>
<li>通信结束后断开连接</li>
</ol>
<h3 id="UDP-Client-Server框架"><a href="#UDP-Client-Server框架" class="headerlink" title="UDP Client-Server框架"></a><strong>UDP Client-Server框架</strong></h3><p><img src="/images/socket/udp-socket.jpg" alt="UDP" title="UDP"></p>
<p>服务器程序流程：</p>
<ol>
<li><p>程序初始化</p>
</li>
<li><p>填写本机地址信息</p>
</li>
<li><p>绑定一个固定的端口</p>
</li>
<li><p>收到Client的数据报后进行处理与通信</p>
</li>
<li><p>通信结束后断开连接</p>
<p>客户端程序流程：</p>
</li>
<li><p>程序初始化</p>
</li>
<li><p>填写服务器地址信息</p>
</li>
<li><p>与服务器通信和信息处理</p>
</li>
<li><p>通信结束后断开连接</p>
</li>
</ol>
<h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a><strong>Socket编程</strong></h3><p>Socket接口是TCP/IP网络的API，<br>网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。<br>常用的Socket类型有两种：<strong>流式Socket（SOCK_STREAM）</strong>和<strong>数据报式Socket（SOCK_DGRAM）</strong>。</p>
<ol>
<li>流式是一种面向连接的Socket，针对于面向连接的TCP服务应用</li>
<li>数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用</li>
</ol>
<p><strong>创建套接字</strong></p>
<pre><code>int socket(int domain, int type, int protocol);</code></pre><p><strong>建立地址和套接字的联系</strong></p>
<pre><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p><strong>服务器端侦听客户端的请求</strong></p>
<pre><code>int listen(int sockfd, int backlog);</code></pre><p><strong>建立服务器/客户端的连接 (面向连接TCP）</strong></p>
<pre><code>//客户端请求连接 
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

//服务器端从编号为Sockid的Socket上接收客户连接请求 
newsockid=accept(Sockid，Clientaddr, paddrlen)</code></pre><p><strong>发送/接收数据</strong></p>
<pre><code>//面向连接：
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

//面向无连接：
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code></pre><p><strong>释放套接字</strong></p>
<pre><code>int close(int fd);</code></pre><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3><ol>
<li>socket()的参数不同</li>
<li>UDP Server不需要调用listen和accept</li>
<li>UDP收发数据用sendto/recvfrom函数</li>
<li>TCP：地址信息在connect/accept时确定</li>
<li>UDP：在sendto/recvfrom函数中每次均需指定地址信息(客户端调用connect之后，不需要每次指定)</li>
<li>UDP：shutdown函数无效</li>
</ol>
<h3 id="socket插入内核hash表"><a href="#socket插入内核hash表" class="headerlink" title="socket插入内核hash表"></a><strong>socket插入内核hash表</strong></h3><p>根据服务器和客户端的行为不同，bind()和sendto()都会调用到get_port()，<br>也就是说，在bind()或sendto()调用时，socket才被插入到内核表中。</p>
<p><strong>bind() 绑定地址</strong></p>
<pre><code>sys_bind -&gt; sock-&gt;ops-&gt;bind -&gt; inet_bind -&gt; sk-&gt;sk_prot-&gt;get_port</code></pre><p>sk-&gt;sk_prot是udp_prot，这里实际调用udp_v4_get_port()函数。</p>
<p><strong>sendto() 发送到指定地址</strong></p>
<pre><code>sys_sendto -&gt; sock_sendmsg -&gt; __sock_sendmsg -&gt; sock-&gt;ops-&gt;sendmsg</code></pre><p>由于<strong>创建的是udp socket，因此sock-&gt;ops指向inet_dgram_ops</strong>，sendmsg()实际调用inet_sendmsg()函数。该函数中的有如下语句：</p>
<pre><code>if (!inet_sk(sk)-&gt;inet_num &amp;&amp; inet_autobind(sk))  
    return -EAGAIN;  </code></pre><p>客户端在执行sendto()前仅仅执行了socket()操作，<br>此时inet_num=0，因此执行了inet_autobind()，<br>该函数会调用sk-&gt;sk_prot-&gt;get_port()。<br>从而回到了udp_v4_get_port()函数，它会将sk插入到内核表udp_table中。</p>
<h2 id="UDP调用connect"><a href="#UDP调用connect" class="headerlink" title="UDP调用connect"></a><strong>UDP调用connect</strong></h2><p>标准的udp客户端开了套接口后，一般使用sendto和recvfrom函数来发数据，<br>udp发送数据有两种方法供大家选用的：</p>
<ol>
<li>socket–&gt;sendto()或recvfrom() </li>
<li>socket–&gt;connect()–&gt;send()或recv()</li>
</ol>
<p>sendto和recvfrom在收发时指定地址，而send和recv则没有，地址是在connect指定的.</p>
<pre><code>int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);</code></pre><p>在udp编程中，如果你只往一个地址发送，那么你可以使用send和recv，<br>在使用它们之前用connect指定目的地址。connect函数在udp中就是这个作用，用它来检测udp端口的是否开放是没有用的。</p>
<p>udp中也有connect，只是它的connect不会进行三步握手，udp中调用connect时什么包也不发送。<br>调用connect是可选的，调用connect后就可以使用send、recv来进行UDP的收发包，而不必每次都要指定地址，<br>然后使用sendto、recvfrom进行操作，当然也可以调用sendto recvfrom。<br>没有调用connect那只能调用sendto、recvfrom，不可以调用send、recv。<br>调用sendto的时候第五个参数必须是NULL,第六个参数是0.<br>调用recvfrom,recv,read系统调用只能获取到先前connect的ip&amp;port发送的报文. </p>
<p>UDP中使用connect可以提高效率.原因如下:</p>
<ol>
<li>普通的UDP发送两个报文内核做了如下:#1:建立连结#2:发送报文#3:断开连结#4:建立连结#5:发送报文#6:断开连结</li>
<li>采用connect方式的UDP发送两个报文内核如下处理:#1:建立连结#2:发送报文#3:发送报文另外一点, 每次发送报文内核都由可能要做路由查询.</li>
</ol>
<p><strong>TCP中调用connect会引起三次握手,client与server建立连结.UDP中调用connect内核仅仅把对端ip&amp;port记录下来</strong>.<br><strong>UDP中可以多次调用connect,TCP只能调用一次connect</strong>.  UDP多次调用connect有两种用途:</p>
<ol>
<li><strong>指定一个新的ip&amp;port连结</strong>. 指定新连结,直接设置connect第二个参数即可.</li>
<li><strong>断开和之前的ip&amp;port的连结</strong>. 断开连结,需要将connect第二个参数中的sin_family设置成AF_UNSPEC即可. </li>
</ol>
<p>UDP中使用connect的好处:</p>
<ol>
<li>会提升效率</li>
<li>高并发服务中会增加系统稳定性</li>
</ol>
<p><strong>内核</strong>：发送时有两种调用方式：sys_send()和sys_sendto()，<br>两者的区别在于sys_sendto()需要给入目的地址的参数；<br>而sys_send()调用前需要调用sys_connect()来绑定目的地址信息；<br>两者的后续调用是相同的。如果调用sys_sendto()发送，<br>地址信息在sys_sendto()中从用户空间拷贝到内核空间，<br>而报文内容在udp_sendmsg()中从用户空间拷贝到内核空间。</p>
<h2 id="TCP使用sendto"><a href="#TCP使用sendto" class="headerlink" title="TCP使用sendto"></a><strong>TCP使用sendto</strong></h2><p>tcp_v4_connect函数代码片段：</p>
<pre><code>/* 记录目的端口和目的IP */
inet-&gt;dport = usin-&gt;sin_port;
inet-&gt;daddr = daddr;</code></pre><p><strong>将目标地址及端口记录在inet中</strong>！</p>
<p>同样的，TCP也可以调用sendto、recvfrom来完成数据的读写。<strong>Linux内核中send系统调用</strong>：</p>
<pre><code>SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,
    unsigned int, flags)
{
    return sys_sendto(fd, buff, len, flags, NULL, 0);
}</code></pre><p>可以看到，send直接调用sendto，后面两个参数直接填NULL，0，<br>因此对于TCP调用来将，使用sendto，并将后两个参数置0，一样可以工作。</p>
<h2 id="TCP-UDP-Send流程代码分析"><a href="#TCP-UDP-Send流程代码分析" class="headerlink" title="TCP/UDP Send流程代码分析"></a><strong>TCP/UDP Send流程代码分析</strong></h2><p>TCP调用sendto时没有给定地址，如何来完成TCP传输？sendto函数原型：</p>
<pre><code>SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
    unsigned, flags, struct sockaddr __user *, addr,
    int, addr_len)
{
    struct socket *sock;
    struct sockaddr_storage address;
    int err;
    struct msghdr msg;
    struct iovec iov;
    int fput_needed;

    if (len &gt; INT_MAX)
        len = INT_MAX;
    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
    if (!sock)
        goto out;

    iov.iov_base = buff;
    iov.iov_len = len;
    msg.msg_name = NULL;
    msg.msg_iov = &amp;iov;
    msg.msg_iovlen = 1;
    msg.msg_control = NULL;
    msg.msg_controllen = 0;
    msg.msg_namelen = 0;

    if (addr) {
        err = move_addr_to_kernel(addr, addr_len, (struct sockaddr *)&amp;address);
        if (err &lt; 0)
            goto out_put;
        msg.msg_name = (struct sockaddr *)&amp;address;
        msg.msg_namelen = addr_len;
    }

    if (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)
        flags |= MSG_DONTWAIT;
    msg.msg_flags = flags;
    err = sock_sendmsg(sock, &amp;msg, len);

    out_put:
        fput_light(sock-&gt;file, fput_needed);
    out:
        return err;
}                          </code></pre><p><strong>tips</strong>: 使用sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK 来检查是否是nonblock的传送。</p>
<p>sendto中首先调用函数move_addr_to_kernel，将地址copy进内核空间：</p>
<pre><code>int move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr *kaddr)                                                      
{
    if (ulen &lt; 0 || ulen &gt; sizeof(struct sockaddr_storage))
        return -EINVAL;
    if (ulen == 0)
        return 0;
    if (copy_from_user(kaddr, uaddr, ulen))
        return -EFAULT;
    return audit_sockaddr(ulen, kaddr);
}</code></pre><p>对于TCP来说，传入参数分别为NULL，0，这部分不会执行到。</p>
<pre><code>msg.msg_name = (struct sockaddr *)&amp;address;
msg.msg_namelen = addr_len;</code></pre><p><strong>地址存入msg中，用于UDP连接</strong>。</p>
<p>然后调用sock_sendmsg来完成数据发送，调用顺序：</p>
<pre><code>sys_send -&gt; sys_sendto -&gt; sock_sendmsg -&gt; __sock_sendmsg -&gt; sock-&gt;ops-&gt;sendmsg -&gt; inet_sendmsg -&gt; sk-&gt;sk_prot-&gt;sendmsg

static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,                                                          
        struct msghdr *msg, size_t size)
{
    struct sock_iocb *si = kiocb_to_siocb(iocb);
    int err;

    si-&gt;sock = sock;
    si-&gt;scm = NULL;
    si-&gt;msg = msg;
    si-&gt;size = size;

    err = security_socket_sendmsg(sock, msg, size);
    if (err)
        return err;

    return sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size);
}</code></pre><p><strong>根据socket不同具体对应于tcp_sendmsg、udp_sendmsg</strong></p>
<h3 id="udp-sendmsg"><a href="#udp-sendmsg" class="headerlink" title="udp sendmsg"></a><strong>udp sendmsg</strong></h3><p>udp_sendmsg代码分析：</p>
<pre><code>int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len);

struct inet_sock *inet = inet_sk(sk);
if (msg-&gt;msg_name) {
    struct sockaddr_in * usin = (struct sockaddr_in*)msg-&gt;msg_name;
    if (msg-&gt;msg_namelen &lt; sizeof(*usin))
        return -EINVAL;
    if (usin-&gt;sin_family != AF_INET) {
        if (usin-&gt;sin_family != AF_UNSPEC)
            return -EAFNOSUPPORT;
    }

    daddr = usin-&gt;sin_addr.s_addr;
    dport = usin-&gt;sin_port;
    if (dport == 0)
        return -EINVAL;
} else {
    if (sk-&gt;sk_state != TCP_ESTABLISHED)
        return -EDESTADDRREQ;
    daddr = inet-&gt;daddr;
    dport = inet-&gt;dport;
    /* Open fast path for connected socket.
       Route will not be used, if at least one option is set.
     */
    connected = 1;
}
ipc.addr = inet-&gt;saddr;</code></pre><p>这段代码<strong>获取要发送数据的目的地址和端口号</strong>。<br>一种情况是<strong>调用sendto()发送数据</strong>，此时目的的信息以参数传入，存储在msg-&gt;msg_name中，因此从中取出daddr和dport；<br>另一种情况是<strong>调用connect(), send()发送数据</strong>，在<strong>connect()调用时绑定了目的的信息，存储在inet中</strong>，<br>并且由于是调用了connect()，sk-&gt;sk_state会设置为TCP_ESTABLISHED。<br>以后调用send()发送数据时，无需要再给入目的信息参数，因此从inet中取出dadr和dport。而connected表示了该socket是否已绑定目的。</p>
<h3 id="tcp-sendmsg"><a href="#tcp-sendmsg" class="headerlink" title="tcp sendmsg"></a><strong>tcp sendmsg</strong></h3><p>tcp_sendmsg代码分析，调用流程：</p>
<pre><code>tcp_sendmsg -&gt; tcp_push -&gt; __tcp_push_pending_frames -&gt; tcp_write_xmit -&gt; tcp_transmit_skb

static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
        gfp_t gfp_mask)
{
    struct inet_sock *inet;
    .
    .
    inet = inet_sk(sk);
    /* Build TCP header and checksum it. */
    th = tcp_hdr(skb);
    th-&gt;source      = inet-&gt;sport;
    th-&gt;dest        = inet-&gt;dport;
    th-&gt;seq         = htonl(tcb-&gt;seq);
    th-&gt;ack_seq     = htonl(tp-&gt;rcv_nxt);
    *(((__be16 *)th) + 6)   = htons(((tcp_header_size &gt;&gt; 2) &lt;&lt; 12) |
            tcb-&gt;flags);
    .
    .
}</code></pre><p><strong>tcp_sendmsg目标地址在函数tcp_transmit_skb中获取，获取的值是调用connect时存储在inet中！</strong></p>
<ol>
<li><a href="http://www.cnblogs.com/hubavyn/p/4322819.html" target="_blank" rel="noopener">udp调用connect有什么作用</a></li>
<li><a href="http://blog.csdn.net/vonkingdom/article/details/7057832" target="_blank" rel="noopener">UDP 的Connect函数的例子</a></li>
<li><a href="http://blog.csdn.net/qy532846454/article/details/6993695" target="_blank" rel="noopener">Linux内核分析 - 网络：UDP模块 - 收发</a></li>
<li><a href="http://blog.csdn.net/qy532846454/article/details/6942667" target="_blank" rel="noopener">Linux内核分析 - 网络：UDP模块 - socket</a></li>
<li><a href="http://blog.csdn.net/cz_hyf/article/details/602802" target="_blank" rel="noopener">linux-Tcp IP协议栈源码阅读笔记</a></li>
<li><a href="http://blog.chinaunix.net/uid-13746440-id-4825005.html" target="_blank" rel="noopener">Linux TCP/IP源码分析 Connect</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_5063e4c80101fvj3.html" target="_blank" rel="noopener">Linux TCP/IP 协议栈源码分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>network</tag>
        <tag>tcp</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>printf格式化输出</title>
    <url>/2015/11/02/printf-formats/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="格式输出控制符"><a href="#格式输出控制符" class="headerlink" title="格式输出控制符"></a><strong>格式输出控制符</strong></h2><p>printf的格式控制的完整格式：<strong>%</strong>  <strong>-</strong>  <strong>0</strong>  <strong>m.n</strong>  <strong>l</strong>或<strong>h</strong>:</p>
<ol>
<li>%：格式说明的起始符号，不可缺少。</li>
<li>-： 有-表示左对齐输出，如省略表示右对齐输出。</li>
<li>0：有0表示指定空位填0,如省略表示指定空位不填。</li>
<li>m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度，用于说明输出的实型数的小数位数。未指定n时，隐含的精度为n=6位。<br>针对字符输出，%m.ns：输出占m列，但只取字符串中左端n个字符。</li>
<li>l：l对整型指long型，对实型指double型。</li>
<li>h：用于将整型的格式字符修正为short型。</li>
</ol>
<h2 id="格式输出数据类型控制"><a href="#格式输出数据类型控制" class="headerlink" title="格式输出数据类型控制"></a><strong>格式输出数据类型控制</strong></h2><ol>
<li>d格式：用来输出十进制整数。%ld：输出长整型数据。%md：m为指定的输出字段的宽度。</li>
<li>o格式：以无符号八进制形式输出整数。对长整型可以用”%lo”格式输出。同样也可以指定字段宽度用“%mo”格式输出。</li>
<li>x格式：以无符号十六进制形式输出整数。对长整型可以用”%lx”格式输出。同样也可以指定字段宽度用”%mx”格式输出。</li>
<li>u格式：以无符号十进制形式输出整数。对长整型可以用”%lu”格式输出。同样也可以指定字段宽度用“%mu”格式输出。</li>
<li>c格式：输出一个字符。</li>
<li>s格式：用来输出一个字符串</li>
<li>f格式：用来输出实数（包括单、双精度），以小数形式输出。</li>
<li>e格式：以指数形式输出实数。</li>
<li>g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零。</li>
</ol>
<h2 id="m-n格式另一种表述"><a href="#m-n格式另一种表述" class="headerlink" title="m.n格式另一种表述"></a><strong>m.n格式另一种表述</strong></h2><p>对于m.n的格式还可以用如下方法表示：</p>
<pre><code>printf(“%*.*s\n”,m,n,ch);</code></pre><p>前边的*定义的是总的宽度，后边的定义的是输出的个数。<br>分别对应外面的参数m和n 。<br>这种方法的好处是可以在语句之外对参数m和n赋值，从而控制输出格式。</p>
<p>例如：函数接口传给你一个没有“\0”结尾的字符串str和他的长度str_len，调试的时候你需要将其打印出来。</p>
<pre><code>printf(&quot;%.*s\n&quot;, str_len, str);</code></pre><h2 id="printf输出字符串长度"><a href="#printf输出字符串长度" class="headerlink" title="printf输出字符串长度"></a><strong>printf输出字符串长度</strong></h2><p>输出格式 <strong>%n</strong> 可以将所输出字符串的长度值赋绐一个变量:</p>
<pre><code>int slen;
printf(“hello world%n”, &amp;slen);</code></pre><p>执行后变量slen被赋值为11。</p>
<h2 id="输出颜色"><a href="#输出颜色" class="headerlink" title="输出颜色"></a><strong>输出颜色</strong></h2><pre><code>printf(&quot;\033[31m test print color \033[0m\n&quot;);</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><pre><code>printf(&quot;%3s, \n%7.2s, \n%.4s, \n%-5.3s\n&quot;, &quot;PRINTF&quot;, &quot;PRINTF&quot;, &quot;PRINTF&quot;, &quot;PRINTF&quot;);
gcc main.c
./a.out
PRINTF, 
     PR, 
PRIN, 
PRI  </code></pre><p>解析如下：</p>
<ol>
<li><strong>%s</strong>原样输出字符串: %s</li>
<li><strong>%ns</strong>输出指定长度n的字符串, 超长时不截断, 不足时右对齐: %3s</li>
<li><strong>%m.ns</strong>输出指定长度的字符串, 超长时截断, 不足时<strong>右对齐</strong>，m为最终的字符串输出长度，n为从参数字符串中取出的子串长度: %7.2s</li>
<li><strong>%.ns</strong>输出指定长度的字符串, 超长时截断，不足时右对齐: %.4s; 如果使用 %.8s 与%s %3s效果一样</li>
<li><strong>%-m.ns</strong>输出指定长度的字符串, 超长时截断, 不足时<strong>左对齐</strong>: %-5.3s</li>
</ol>
<p>通过上述用例，所谓超长时截断用到的n并不是只在超长时才起作用，而是不管你有没有超长，都必须截取这么长。<br>上述m,n是可以动态指定的，方法是用*代替m或者n，然后在参数列表里加上一个数字参数</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pyinstaller打包python程序</title>
    <url>/2015/10/31/python-pyinstaller/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>常用的Python打包为exe工具有：</p>
<ol>
<li>py2exe</li>
<li>pyinstaller</li>
<li>cxfreeze</li>
</ol>
<p>选择使用方便的pyinstaller作为打包工具。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有两种方式：</p>
<ol>
<li>官网下载后解压缩到需要的文件夹就可以执行，不需要安装。</li>
<li>pip 方式安装升级： <strong>pip install pyinstaller</strong> 和 <strong>pip install –upgrade pyinstaller</strong></li>
</ol>
<p>使用第二种方式安装pyinstaller，安装过程中遇到一些环境问题，主要是pip，google解决之。</p>
<pre><code>python2.7 -m pip install -U setuptools
python3.4 -m pip install -U setuptools
python2.7 -m pip install pyinstaller
python3.4 -m pip install pyinstaller</code></pre><p>执行pyinstaller可能遇到如下问题：</p>
<pre><code>FileNotFoundError: Path or glob &quot;/usr/include/python3.4m/pyconfig.h&quot; not found or matches no files.</code></pre><p><a href="http://stackoverflow.com/questions/31767469/pyinstaller-path-or-glob-usr-include-python3-4m-pyconfig-h-not-found-or-matc" target="_blank" rel="noopener">文章</a><br>解决：</p>
<pre><code>sudo apt-get install libpython3.4-dev</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>测试代码：</p>
<pre><code>#!/usr/bin/env python3.4
# -*- coding: utf-8 -*-

from tkinter import *

root = Tk()
root.title(&#39;测试界面&#39;)
root.config(height=480,pady=10)

title = Label(root,text=&#39;测试控件&#39;,font=&#39;微软雅黑 -23 bold&#39;,fg=&#39;#fa8723&#39;)
title.pack()

root.mainloop()                         </code></pre><p>执行打包命令：</p>
<pre><code>✘ /data/OpenSourceCode/python/tkinter/test  &gt; pyinstaller -F tk-1030.py
28 INFO: PyInstaller: 3.0
28 INFO: Python: 3.4.3
28 INFO: Platform: Linux-3.19.0-32-generic-x86_64-with-Ubuntu-15.04-vivid
28 INFO: wrote /data/OpenSourceCode/python/tkinter/test/tk-1030.spec
29 INFO: UPX is not available.
30 INFO: Extending PYTHONPATH with /data/OpenSourceCode/python/tkinter/test
31 INFO: checking Analysis
31 INFO: Building Analysis because out00-Analysis.toc is non existent
31 INFO: Initializing module dependency graph...
96 INFO: Initializing module graph hooks...
110 INFO: Analyzing base_library.zip ...
1864 INFO: Processing pre-find module path hook   distutils
3560 INFO: running Analysis out00-Analysis.toc
3647 INFO: Analyzing /data/OpenSourceCode/python/tkinter/test/tk-1030.py
3834 INFO: Looking for import hooks ...
3839 INFO: Processing hook   hook-sysconfig.py
3859 INFO: Processing hook   hook-pydoc.py
3860 INFO: Processing hook   hook-_tkinter.py
3934 INFO: checking Tree
3934 INFO: Building Tree because out00-Tree.toc is non existent
3934 INFO: Building Tree out00-Tree.toc
3954 INFO: checking Tree
3954 INFO: Building Tree because out01-Tree.toc is non existent
3954 INFO: Building Tree out01-Tree.toc
3963 INFO: Processing hook   hook-encodings.py
3983 INFO: Processing hook   hook-distutils.py
3984 INFO: Processing hook   hook-xml.py
4272 INFO: Processing hook   hook-xml.sax.py
4281 INFO: Looking for ctypes DLLs
4628 INFO: Analyzing run-time hooks ...
4631 INFO: Including run-time hook &#39;pyi_rth__tkinter.py&#39;
4643 INFO: Looking for dynamic libraries
5008 INFO: Looking for eggs
5008 INFO: Python library not in binary depedencies. Doing additional searching...
5197 INFO: Using Python library /usr/lib/x86_64-linux-gnu/libpython3.4m.so.1.0
5204 INFO: Warnings written to /data/OpenSourceCode/python/tkinter/test/build/tk-1030/warntk-1030.txt
5218 INFO: checking PYZ
5218 INFO: Building PYZ because out00-PYZ.toc is non existent
5218 INFO: Building PYZ (ZlibArchive) /data/OpenSourceCode/python/tkinter/test/build/tk-1030/out00-PYZ.pyz
5430 INFO: checking PKG
5430 INFO: Building PKG because out00-PKG.toc is non existent
5430 INFO: Building PKG (CArchive) out00-PKG.pkg
10161 INFO: Bootloader /usr/local/lib/python3.4/dist-packages/PyInstaller/bootloader/Linux-64bit/run
10161 INFO: checking EXE
10161 INFO: Building EXE because out00-EXE.toc is non existent
10161 INFO: Building EXE from out00-EXE.toc
10167 INFO: Appending archive to EXE /data/OpenSourceCode/python/tkinter/test/dist/tk-1030</code></pre><p>exe文件生成在dist文件夹中，执行命令验证正常：</p>
<pre><code>✔ /data/OpenSourceCode/python/tkinter/test  &gt; ./dist/tk-1030</code></pre><ol>
<li><a href="http://www.cnblogs.com/chjbbs/p/3533187.html" target="_blank" rel="noopener">关于python打包成exe的一点经验之谈</a></li>
<li><a href="http://www.biubiu.net/blog/pyinstaller-install-use/" target="_blank" rel="noopener">PYINSTALLER 安装和使用</a></li>
<li><a href="http://www.py2exe.org/index.cgi/Tutorial" target="_blank" rel="noopener">py2exe Tutorial</a></li>
<li><a href="http://pythonhosted.org/PyInstaller/" target="_blank" rel="noopener">PyInstaller Manual</a></li>
<li><a href="https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages" target="_blank" rel="noopener">PYInstaller Supported Packages</a></li>
<li><a href="http://cx-freeze.readthedocs.org/en/latest/index.html" target="_blank" rel="noopener">cx_Freeze’s documentation</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>python Tkinter编程</title>
    <url>/2015/10/31/python-Tkinter/</url>
    <content><![CDATA[<p>python提供了多个图形开发界面的库，几个常用Python GUI库如下：</p>
<ul>
<li>Tkinter： Tkinter模块(“Tk 接口”)是Python的标准Tk GUI工具包的接口.<br>Tk和Tkinter可以在大多数的Unix平台下使用,同样可以应用在Windows和Macintosh系统里.<br>Tk8.0的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。</li>
<li>wxPython：wxPython 是一款开源软件，是 Python 语言的一套优秀的 GUI 图形库，<br>允许 Python 程序员很方便的创建完整的、功能键全的 GUI 用户界面。</li>
<li>Jython：Jython程序可以和Java无缝集成。除了一些标准模块，Jython使用Java的模块。<br>Jython几乎拥有标准的Python中不依赖于C语言的全部模块。<br>比如，Jython的用户界面将使用Swing，AWT或者SWT。Jython可以被动态或静态地编译成Java字节码。</li>
</ul>
<a id="more"></a>

<h2 id="Tkinter-编程"><a href="#Tkinter-编程" class="headerlink" title="Tkinter 编程"></a>Tkinter 编程</h2><p>Tkinter 是Python的标准GUI库。Python使用Tkinter可以快速的创建GUI应用程序。<br>由于Tkinter是内置到python的安装包中、只要安装好Python之后就能import Tkinter库、<br>而且IDLE也是用Tkinter编写而成、对于简单的图形界面Tkinter还是能应付自如。</p>
<p>创建一个GUI程序：</p>
<ol>
<li>导入Tkinter模块</li>
<li>创建控件</li>
<li>指定这个控件的master， 即这个控件属于哪一个</li>
<li>告诉GM(geometry manager)有一个控件产生了。</li>
</ol>
<p>实例:</p>
<pre><code>#!/usr/bin/env python3.4
# -*- coding: UTF-8 -*-

from tkinter import *

root = Tk()
root.title(&#39;测试界面&#39;)
root.config(height=480,pady=10)

title = Label(root,text=&#39;测试控件&#39;,font=&#39;微软雅黑 -23 bold&#39;,fg=&#39;#fa8723&#39;)
title.pack()

top.mainloop() # 进入消息循环</code></pre><p>实例2：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-

from Tkinter import *           # 导入 Tkinter 库
root = Tk()                     # 创建窗口对象的背景色
# 创建两个列表
li     = [&#39;C&#39;,&#39;python&#39;,&#39;php&#39;,&#39;html&#39;,&#39;SQL&#39;,&#39;java&#39;]
movie  = [&#39;CSS&#39;,&#39;jQuery&#39;,&#39;Bootstrap&#39;]
listb  = Listbox(root)          #  创建两个列表组件
listb2 = Listbox(root)
for item in li:                 # 第一个小部件插入数据
    listb.insert(0,item)

for item in movie:              # 第二个小部件插入数据
    listb2.insert(0,item)

listb.pack()                    # 将小部件放置到主窗口中
listb2.pack()
root.mainloop()                 # 进入消息循环</code></pre><h2 id="Tkinter-组件"><a href="#Tkinter-组件" class="headerlink" title="Tkinter 组件"></a>Tkinter 组件</h2><p><strong>目前有15种Tkinter的部件</strong></p>
<ul>
<li>Button按钮控件；在程序中显示按钮。</li>
<li>Canvas画布控件；显示图形元素如线条或文本</li>
<li>Checkbutton多选框控件；用于在程序中提供多项选择框</li>
<li>Entry输入控件；用于显示简单的文本内容</li>
<li>Frame框架控件；在屏幕上显示一个矩形区域，多用来作为容器</li>
<li>Label标签控件；可以显示文本和位图</li>
<li>Listbox列表框控件；在Listbox窗口小部件是用来显示一个字符串列表给用户</li>
<li>Menubutton菜单按钮控件，由于显示菜单项。</li>
<li>Menu菜单控件；显示菜单栏,下拉菜单和弹出菜单</li>
<li>Message消息控件；用来显示多行文本，与label比较类似</li>
<li>Radiobutton单选按钮控件；显示一个单选的按钮状态</li>
<li>Scale范围控件；显示一个数值刻度，为输出限定范围的数字区间</li>
<li>Scrollbar滚动条控件，当内容超过可视化区域时使用，如列表框。.</li>
<li>Text文本控件；用于显示多行文本</li>
<li>Toplevel容器控件；用来提供一个单独的对话框，和Frame比较类似</li>
<li>Spinbox输入控件；与Entry类似，但是可以指定输入范围值</li>
<li>PanedWindowPanedWindow是一个窗口布局管理的插件，可以包含一个或者多个子控件。</li>
<li>LabelFramelabelframe 是一个简单的容器控件。常用与复杂的窗口布局。</li>
<li>tkMessageBox用于显示你应用程序的消息框。</li>
</ul>
<p><strong>标准属性</strong></p>
<p>标准属性也就是所有控件的共同属性，如大小，字体和颜色等等。</p>
<ul>
<li>Dimension控件大小；</li>
<li>Color控件颜色；</li>
<li>Font控件字体；</li>
<li>Anchor锚点；</li>
<li>Relief控件样式；</li>
<li>Bitmap位图；</li>
<li>Cursor光标；</li>
</ul>
<p><strong>几何管理</strong></p>
<p>Tkinter控件有特定的几何状态管理方法，管理整个控件区域组织，一下是Tkinter公开的几何管理类：包、网格、位置</p>
<ul>
<li>pack()包装；</li>
<li>grid()网格；</li>
<li>place()位置；</li>
</ul>
<ol>
<li><a href="http://effbot.org/tkinterbook/tkinter-index.htm" target="_blank" rel="noopener">An Introduction To Tkinter</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>python pip执行错误</title>
    <url>/2015/10/29/python-pip/</url>
    <content><![CDATA[<h2 id="ImportError-cannot-import-name-IncompleteRead"><a href="#ImportError-cannot-import-name-IncompleteRead" class="headerlink" title="ImportError: cannot import name IncompleteRead"></a>ImportError: cannot import name IncompleteRead</h2><pre><code>pip -h
ImportError: cannot import name IncompleteRead</code></pre><p>pip出现问题，执行修复：</p>
<pre><code>sudo apt-get remove python-pip
sudo apt-get install python-pip</code></pre><p>没有解决问题，尝试另一种：</p>
<pre><code>sudo easy_install pip</code></pre><p>解决此问题</p>
<h2 id="ImportError-No-module-named-‘pip’"><a href="#ImportError-No-module-named-‘pip’" class="headerlink" title="ImportError: No module named ‘pip’"></a>ImportError: No module named ‘pip’</h2><p>Pip则是一种更为高级的安装工具，它依赖于Setuptools</p>
<pre><code>pip list
Traceback (most recent call last):
File &quot;/usr/local/bin/pip&quot;, line 9, in &lt;module&gt;
load_entry_point(&#39;pip==1.4.1&#39;, &#39;console_scripts&#39;, &#39;pip&#39;)()
File &quot;/usr/local/lib/python3.4/dist-packages/setuptools-1.1.5-py3.4.egg /pkg_resources.py&quot;, line 357, in load_entry_point
def get_entry_info(dist, group, name):
File &quot;/usr/local/lib/python3.4/dist-packages/setuptools-1.1.5-py3.4.egg/pkg_resources.py&quot;, line 2394, in load_entry_point
break
File &quot;/usr/local/lib/python3.4/dist-packages/setuptools-1.1.5-py3.4.egg/pkg_resources.py&quot;, line 2108, in load
name = some.module:some.attr [extra1,extra2]
ImportError: No module named &#39;pip&#39;

$ which pip
/usr/local/bin/pip

$ python2.7 -m pip //here can be just python, btw
Usage:   
/usr/bin/python2.7 -m pip &lt;command&gt; [options]
//and so on...

$ python3.4 -m pip
/usr/bin/python3.4: No module named pip</code></pre><p>需要安装python3.4下的pip</p>
<pre><code>$ curl https://bootstrap.pypa.io/get-pip.py | python3.4
$ python{2.7,3.4} -m pip install -U setuptools</code></pre><p>然后执行</p>
<pre><code>pip list
pip install pyinstaller</code></pre><p>均正确，解决此问题</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>python ImageTk加载错误</title>
    <url>/2015/10/29/python-ImageTK/</url>
    <content><![CDATA[<p>python中使用PIL ImageTK出现以下问题：</p>
<pre><code>Traceback (most recent call last):
    File &quot;./ExportXiamiList.py&quot;, line 4, in &lt;module&gt;
        from tkinter import *
ImportError: No module named tkinter</code></pre><p>Ubuntu下环境：</p>
<pre><code>ExportXiamiList-master &gt; python
python            python2.7         python2-config    python3.3         python3.4         python3m                          
python2           python2.7-config  python3           python3.3m        python3.4m        python-config            </code></pre><p>安装如下包，不起作用：</p>
<pre><code>sudo apt-get install python-pil python-pil.imagetk --reinstall</code></pre><p>继续安装如下包解决问题：</p>
<pre><code>sudo apt-get install python3-pil python3-pil.imagetk</code></pre><p>python中ImageTK用法如下：</p>
<pre><code>from PIL import Image
from PIL import ImageTk</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>imagetk</tag>
      </tags>
  </entry>
  <entry>
    <title>shell提取文件扩展名或文件名</title>
    <url>/2015/10/27/shell-name-suffix/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>在shell中用于提取文件名或后缀，需要用到以下几个操作符： <strong>%、%%、#、##</strong></p>
<h2 id="和-操作符"><a href="#和-操作符" class="headerlink" title="% 和 %% 操作符"></a><strong>% 和 %% 操作符</strong></h2><p>用法：</p>
<pre><code>${VAR%.*}
${VAR%%.*}</code></pre><p><strong>${VAR%.*}</strong>含义：从<strong>$VAR</strong>中<strong>删除</strong>位于 <strong>%</strong> 右侧的通配符左右匹配的字符串，<strong>通配符从右向左进行匹配</strong>。</p>
<ul>
<li><strong>% 属于非贪婪操作符</strong>，从右向左匹配最短结果</li>
<li><strong>%% 属于贪婪操作符</strong>，从右向左匹配符合条件的最长字符串</li>
</ul>
<p>示例如下：</p>
<pre><code>file=&quot;abc.c&quot;
name=${file%.*}
echo file name is: $name

输出结果：
file name is: abc</code></pre><p>变量 name 赋值abc.c，那么通配符从右向左就会匹配到 .c，所有从 $VAR 中删除匹配结果。</p>
<pre><code>file=&quot;text.gif.bak.2012&quot;
name=${file%.*}
name2=${file%%.*}
echo file name is: $name
echo file name is: $name2

输出结果：
file name is: text.gif.bak    //使用 %
file name is: text            //使用 %%</code></pre><p>操作符 %% 使用 .* 从右向左贪婪匹配到 .gif.bak.2012</p>
<h2 id="和-操作符-1"><a href="#和-操作符-1" class="headerlink" title="# 和 ## 操作符"></a><strong># 和 ## 操作符</strong></h2><p>用法：</p>
<pre><code>${VAR#*.}
${VAR##*.}</code></pre><p><strong>${VAR#*.}</strong> 含义：从 <strong>$VAR</strong> 中<strong>删除</strong>位于 <strong>#</strong> 右侧的通配符所匹配的字符串，<strong>通配符是左向右进行匹配</strong>。</p>
<ul>
<li><strong># 属于非贪婪操作符</strong>，从左向右匹配最短结果</li>
<li><strong>## 属于贪婪操作符</strong>，从左向右匹配符合条件的最长字符串</li>
</ul>
<p>符示例：</p>
<pre><code>file=&quot;text.gif&quot;
suffix=${file#*.}
echo suffix is: $suffix

输出结果：
suffix is: gif


file=&quot;text.gif.bak.2012.txt&quot;
suffix=${file#*.}
suffix2=${file##*.}
echo suffix is: $suffix
echo suffix is: $suffix2

输出结果：
suffix is: text.gif.bak.2012     //使用 #
suffix2 is: txt                  //使用 ##</code></pre><p>操作符 ## 使用 *. 从左向右贪婪匹配到 text.gif.bak.2012</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>url=&quot;www.baidu.com&quot;

echo ${url%.*}      #移除 .* 所匹配的最右边的内容。
www.baidu

echo ${url%%.*}     #将从右边开始一直匹配到最左边的 *. 移除，贪婪操作符。
www

echo ${url#*.}      #移除 *. 所有匹配的最左边的内容。
baidu.com

echo ${url##*.}     #将从左边开始一直匹配到最右边的 *. 移除，贪婪操作符。
com</code></pre>]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本的命令行选项解析</title>
    <url>/2015/10/27/shell-getopts/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>标准UNIX命一般都提供大量的选项和参数，例如：</p>
<pre><code>ps --help
Usage:
ps [options]

Try &#39;ps --help &lt;simple|list|output|threads|misc|all&gt;&#39;
or &#39;ps --help &lt;s|l|o|t|m|a&gt;&#39;
for additional help text.</code></pre><p>在这些工具的命令行处理中使用了C函数<strong>getopt</strong>；<br>shell脚本可以通过使用<strong>getopts</strong>来保持与UNIX一致的风格。</p>
<h2 id="常用shell参数变量"><a href="#常用shell参数变量" class="headerlink" title="常用shell参数变量"></a>常用shell参数变量</h2><ul>
<li>$0 ：即命令本身，相当于C/C++中的argv[0]</li>
<li>$1 ：第一个参数.</li>
<li>$2, $3, $4 … ：第2、3、4个参数，依次类推。</li>
<li>$#  参数的个数，不包括命令本身</li>
<li>$@ ：参数本身的列表，也不包括命令本身</li>
<li>$* ：和$@相同，但”$*“ 和 “$@”(加引号)并不同，”$*“将所有的参数解释成一个字符串，而”$@”是一个参数数组。</li>
</ul>
<h2 id="getopts"><a href="#getopts" class="headerlink" title="getopts"></a>getopts</h2><p>getopts有两个参数，<br>第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，<br>如果字符后面带有“：”，表示这个字符有自己的参数。<br>如果字符串最前面带有“：”，表示开启静默模式，屏蔽系统提示错误。<br>getopts从命令中获取这些参数，并且删去了“-”，<br>并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在“OPTARG”中。</p>
<p>在使用getopts命令的时候，shell会自动产生两个变量OPTIND和OPTARG。<br>OPTIND初始值为1，其含义是下一个待处理的参数的索引。<br>只要存在，getopts命令返回true，所以一般getopts命令使用while循环；<br>OPTARG是当getopts获取到其期望的参数后存入的位置。</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre><code>[ $# -eq 0   ] &amp;&amp; usage

# option_string以冒号开头表示屏蔽脚本的系统提示错误，自己处理错误提示。
# 后面接合法的单字母选项，选项后若有冒号，则表示该选项必须接具体的参数

while getopts :s:t:i:oh OPTION
do
    case $OPTION in
        s)
            STRING=$OPTARG
            ;;

        t)
            STRING=`cat $OPTARG`
            ;;

        i)
            IN=$OPTARG        #$OPTARG为特殊变量，表示选项的具体参数
            ;;

        o)
            OUT=$OPTARG        #$OPTARG为特殊变量，表示选项的具体参数
            ;;

        h)
            echo &quot;\033[31mHelp Info:\033[0m&quot;
            java -jar sfntly-builds/java-openjdk-8/sfnttool/sfnttool.jar -h
            exit 1
        ;;

        \?)                       #如果出现错误，则解析为?
            usage
            ;;
    esac
done

#$OPTIND表示第几个选项，初始值为1
#shift $(($OPTIND - 1))
#if [ $# -eq 0  ]; then
#    usage
#fi</code></pre><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p>使用shift $(($OPTIND-1))的作用是:<br>通过shift $(($OPTIND - 1))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理，例如：</p>
<pre><code>./xx -i in -o out para1 para2 ...</code></pre><p>经过处理之后，$*为 <strong>para1 para2</strong>，方便后续脚本处理</p>
<pre><code>while getopts s:h OPTION
do
    case $OPTION in
        s)
            STRING=$OPTARG
            ;;

        h)
            echo &quot;\033[31mHelp Info:\033[0m&quot;
            exit 1
        ;;

        \?)                       #如果出现错误，则解析为?
            usage
            ;;
    esac
done

echo &quot;OPTIND:&quot;$OPTIND
shift $(($OPTIND - 1))      #除了选项之外，该脚本必须接至少一个参数

echo $0
echo $*
echo $@

if [ $# -eq 0  ]; then
    usage
fi

for file in $@          #依次处理剩余的参数
do
    echo $file
done</code></pre><p>执行结果如下：</p>
<pre><code>➜  /data/OpenSourceCode/subset-ttf  &gt; ./test.sh -s &quot;123&quot; test1 test2 test3
OPTIND:3
./test.sh               $0
test1 test2 test3       $*
test1 test2 test3       $@
test1                   file
test2
test3</code></pre>]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile中嵌入一段shell脚本及函数列表</title>
    <url>/2015/10/25/makefile-and-shell/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>


<p>Makefile中需要在编译前进行一些处理，shell可以方便完成。以下为在Makefile中使用shell需要注意的一些事项：</p>
<h2 id="makefile和shell区别"><a href="#makefile和shell区别" class="headerlink" title="makefile和shell区别"></a>makefile和shell区别</h2><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>shell中所有引用<strong>以$打头的变量其后要加{}</strong>,而在Makefile中的变量是<strong>以$打头的后加()</strong>。如下：</p>
<pre><code>Makefile
PATH=&quot;/data/&quot;
SUBPATH=$(PATH)

Shell
PATH=&quot;/data/&quot;
SUBPATH=${PATH}</code></pre><h3 id="引用shell变量"><a href="#引用shell变量" class="headerlink" title="引用shell变量"></a>引用shell变量</h3><p>Makefile中所有以$打头的单词都会被解释成Makefile中的变量。<br>如果<strong>需要调用shell中的变量（或者正则表达式中锚定句位$），都需要加两个$符号（$$）</strong>。如下：</p>
<pre><code>PATH=&quot;/data/&quot;
all:
    echo $(PATH)
    echo $$PATH</code></pre><p>第一个$(PATH)引用的是Makefile中的变量，而不是shell中的PATH环境变量，后者引用的是Shell中的PATH环境变量。</p>
<h3 id="通配符区别"><a href="#通配符区别" class="headerlink" title="通配符区别"></a>通配符区别</h3><p>shell 中通配符*表示所有的字符；Makefile 中通配符%表示所有的字符</p>
<h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><p>在Makefile中只能在target中调用Shell脚本，其他地方是不能输出的。比如如下代码就是没有任何输出：</p>
<pre><code>VAR=&quot;Hello&quot;
echo &quot;$VAR&quot;
all:</code></pre><p>以上代码任何时候都不会输出，没有在target内，如果上述代码改为如下：</p>
<pre><code>VAR=&quot;Hello&quot;
all:
    echo &quot;$VAR&quot;</code></pre><p>以上代码，在make all的时候将会执行echo命令。</p>
<h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><p>Makefile中的shell，每一行是一个进程，不同行之间变量值不能传递。所以，Makefile中的shell不管多长也要写在一行<br>在Makefile中执行shell命令，一行创建一个进程来执行。<br>不同行之间变量值不能传递。<br>这也是为什么很多Makefile中有很多行的末尾都是“;\”，<br>以此来保证代码是一行而不是多行，这样Makefile可以在一个进程中执行，例如：</p>
<pre><code>SUBDIR=src example
all:
    @for subdir in $(SUBDIR); \     #shell代码开始
    do\
        echo &quot;building &quot;; \
    done</code></pre><p>上述可以看出for循环中每行都是以”; \”结尾的。</p>
<h3 id="shell代码范围"><a href="#shell代码范围" class="headerlink" title="shell代码范围"></a>shell代码范围</h3><p>在Makefile文件的目标项冒号后的另起一行的代码才是shell代码。</p>
<pre><code>xx = xx1       #这里时makefile代码
yy：xx = xx2   #这是是makefile代码，makefile允许变量赋值时，&#39;=&#39;号两边留空格
yy：
    xx=xx3     #只有这里是shell代码 ，shell不允许‘=’号两边有空格哦。

有一个例外：
xx=$(shell 这里的代码也是shell代码)</code></pre><h3 id="makefile总的反引号"><a href="#makefile总的反引号" class="headerlink" title="makefile总的反引号`"></a>makefile总的反引号<strong>`</strong></h3><p>反引号括起来的字符串被shell解释为命令行，<br>在执行时，shell首先执行该命令行，并以它的标准输出结果取代整个反引号（包括两个反引号）部分</p>
<pre><code>PATH=`pwd`
TODAY=`date`

#等同于
PATH=$(shell pwd)
TODAY=$(shell date)</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>获取当前目录</strong></p>
<pre><code>TOPDIR:=$(shell pwd)</code></pre><p><strong>获取日期</strong></p>
<pre><code>DATE:=$(shell date +%Y%m%d)</code></pre><p><strong>获取源文件列表</strong></p>
<pre><code>SRC += $(shell find . -iname &quot;*.c&quot;  | grep -v &quot;./opensource/*&quot;)
SRC += $(shell find . -iname &quot;*.cpp&quot;)

PRE_SRC=$(shell find -name &quot;*.c&quot; | xargs grep &quot;HANDLER&quot; | awk -F &#39;:&#39; &#39;{print $$1}&#39; | sort -u) #注意awk中使用的是 $$1</code></pre><p><strong>Makefile打印输出</strong></p>
<pre><code>print_version:
    @echo $(BR2_VERSION_FULL)</code></pre><p><strong>Makefile嵌入脚本</strong></p>
<pre><code>env:                                                                                                                                
    sh $(SRC_PATH)/scripts/connect.sh
    find $(SRC_PATH) -name &quot;sysinfo.o&quot; | xargs rm -f

signalpre:                                                                                                                          
    sed -i &#39;s/HANDLER/HANDLER HANDLERX/g&#39; $(LIB_PATH)/include/core.h
    @mkdir -p $(SRC_PATH)/output/signalpres
    @echo &quot;\033[031msignale handler processor...\033[0m&quot;
    @for f in $(PRE_SRC); do \
        OBJ=$(SRC_PATH)/output/signalpres/`basename $$f|sed -e &#39;s/\.c/\.i/&#39;`; \
        $(CC) $(CFLAGS) -E $$f -o $$OBJ;\
        echo -n &quot;.&quot;;\
    done
    sed -i &#39;s/HANDLER HANDLERX/HANDLER/g&#39; $(LIB_PATH)/include/core.h
    echo &quot;\n&quot;

prepare_config:
    @chmod +x scripts/proj.sh
    @scripts/proj.sh
    @chmod +x scripts/theme.sh
    @scripts/theme.sh</code></pre><p><strong>Makefile中的exec执行脚本</strong></p>
<pre><code>format:
    @echo &quot;Makeing format...&quot;;
    @find -name &quot;*.c&quot; -exec dos2unix -qU 2&gt;d2utmp1 {} \;
    @find -name &quot;*.h&quot; -exec dos2unix -qU 2&gt;d2utmp1 {} \; 
#   @find -name &quot;*.c&quot; -exec indent -npro -kr -i8 -sob -l120 -ss -ncs  {} \;
    @find -name &quot;*~&quot; -exec rm {} \;
    @find -name &quot;d2utmp*&quot; -exec rm {} \;
    @find -name &quot;deps*&quot; -exec rm {} \;</code></pre><p><strong>循环处理文件行</strong></p>
<pre><code>cat config_tmp | while read line
do
    echo &quot;${line}&quot;

    MACRO=$(echo ${line} | awk -F &#39; &#39; &#39;{print $2}&#39;)
    VALUE=$(echo ${line} | awk -F &#39; &#39; &#39;{print $3}&#39;)
    echo &quot;Macro: $MACRO Value: $VALUE\n&quot;

    #cat &quot;$SIGNALE_HANDLER_FILE&quot; | sed -e &quot;s/$MACRO/$VALUE/g&quot; &gt; signal_tmp
    sed -i &quot;s/$MACRO/$VALUE/g&quot; ${SIGNALE_HANDLER_FILE}
done</code></pre><p><strong>grep反选</strong></p>
<pre><code>cat $CONFIG_FILE | sed -s &#39;/^$/d&#39; | grep -v -e &quot;LangName&quot; -e &quot;__CONFIG_H__&quot; -e &quot;#endif&quot; -e &quot;//&quot; &gt; config_tmp</code></pre><p><strong>Makefile依赖规则</strong></p>
<pre><code>OBJS=$(addprefix $(SRC_PATH)/objects/, $(addsuffix .o, $(basename $(notdir $(SRC)))))

deps: $(SRC)
    @-rm -f deps;
    @for f in $(SRC); do \
        OBJ=$(SRC_PATH)/objects/`basename $$f|sed -e &#39;s/\.c/\.o/&#39;`; \
        echo $$OBJ: $$f&gt;&gt; deps; \
        echo &#39;  @echo -e &quot;compiling \033[032m[$(CC)]\033[0m&quot;: &#39; $$f &gt;&gt; deps; \
        echo &#39;  $(CC) $$(CFLAGS) -c -o $$@ $$^&#39;&gt;&gt; deps; \
    done</code></pre><p><strong>Makefile模式规则</strong></p>
<pre><code>%.d: %.c
    @set -e; rm -f $@; \
    $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \
    sed &#39;s,\($*\)\.o[ : ]*,\1.o $@ : ,g&#39; &lt; $@.$$$$ &gt; $@; \
    rm -f $@.$$$$</code></pre><p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，<br>第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，<br>如果有一个C文件是name.c，那么“%”就是 “name”，“$$$$”意为一个随机编号，<br>第二行生成的文件有可能是“name.d.12345”，<br>第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。<br>第四行就是删除临时文件。</p>
<p><strong>变量值的替换</strong></p>
<pre><code>foo := a.o b.o c.o
bar := $(foo:.o=.c)

foo := a.o b.o c.o
bar := $(foo:%.o=%.c)</code></pre><p>变量<em>.o替换为</em>.c</p>
<h2 id="makefile函数列表"><a href="#makefile函数列表" class="headerlink" title="makefile函数列表"></a>makefile函数列表</h2><p>函数调用，很像变量的使用，也是以“$”来标识的，其語法如下：</p>
<pre><code>$(&lt;function&gt; &lt;arguments&gt;)</code></pre><p>或是</p>
<pre><code>${&lt;function&gt; &lt;arguments&gt;}</code></pre><p>这里，&lt;function&gt;就是函数名，make支持的函数不多。<br>&lt;arguments&gt;为函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。<br>函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。<br>感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，<br>如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b, ${x})”的形式。<br>因为统一会更清楚，也会减少一些不必要的麻烦。</p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul>
<li>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;), 字符串替换函数</li>
<li>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;), 模式字符串替换函数</li>
<li>$(strip &lt;string&gt;), 去空格函数,字串中开头和结尾的空字符</li>
<li>$(findstring &lt;find&gt;,&lt;in&gt;), 查找字符串函数</li>
<li>$(filter &lt;pattern…&gt;,&lt;text&gt;), 以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，保留符合模式&lt;pattern&gt;的单词。可以有多个模式</li>
<li>$(filter-out &lt;pattern…&gt;,&lt;text&gt;), 以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可以有多个模式</li>
<li>$(sort &lt;list&gt;), 给字符串&lt;list&gt;中的单词排序（升序）。</li>
<li>$(word &lt;n&gt;,&lt;text&gt;), 取字符串&lt;text&gt;中第&lt;n&gt;个单词。（从一开始）</li>
<li>$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;), 从字符串&lt;text&gt;中取从&lt;ss&gt;开始到&lt;e&gt;的单词串。&lt;ss&gt;和&lt;e&gt;是一个数字</li>
<li>$(words &lt;text&gt;), 统计&lt;text&gt;中字符串中的单词个数</li>
<li>$(firstword &lt;text&gt;), 取字符串&lt;text&gt;中的第一个单词</li>
</ul>
<p>搭配使用：</p>
<pre><code>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))</code></pre><p>如果我们的“$(VPATH)”值是“src:../headers”，<br>那么“$(patsubst %,-I%,$(subst :, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数</p>
<h3 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h3><ul>
<li><p>$(dir &lt;names…&gt;), 从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”</p>
</li>
<li><p>$(notdir &lt;names…&gt;), 从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最後一个反斜杠（“/”）之后的部分</p>
</li>
<li><p>$(suffix &lt;names…&gt;) , 从文件名序列&lt;names&gt;中取出各个文件名的后缀</p>
</li>
<li><p>$(basename &lt;names…&gt;), 从文件名序列&lt;names&gt;中取出各个文件名的前缀部分</p>
</li>
<li><p>$(addsuffix &lt;suffix&gt;,&lt;names…&gt;), 把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面</p>
</li>
<li><p>$(addprefix &lt;prefix&gt;,&lt;names…&gt;), 把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面</p>
</li>
<li><p>$(join &lt;list1&gt;,&lt;list2&gt;), 把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。<br>如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。<br>如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list1&gt;中</p>
<p>  $(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”</p>
</li>
</ul>
<h3 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h3><p>foreach函数和别的函数非常的不一样。<br>因为这个函数是用来做循环用的，<br>Makefile中的foreach函数几乎是仿照于Unix标准 Shell（/bin/sh）中的for语句，<br>或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<pre><code>$(foreach   &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></pre><p>这个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，<br>然后再执行&lt; text&gt;所包含的表达式。<br>每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，<br>最后当整个循环结束时，<br>&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>所以，&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;这个参数来依次枚举&lt;list&gt;中的单词。举个例子：</p>
<pre><code>names := a b c d
files := $(foreach n,$(names),$(n).o)</code></pre><p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，<br>这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。</p>
<p>注意，foreach中的&lt;var&gt;参数是一个临时的局部变量，foreach函数执行完后，参数&lt;var&gt;的变量将不在作用，其作用域只在foreach函数当中。</p>
<h3 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h3><p>if函数很像GNU的make所支持的条件语句——ifeq，if函数的语法是：</p>
<pre><code>$(if &lt;condition&gt;,&lt;then-part&gt;) </code></pre><p>或是</p>
<pre><code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></pre><h3 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h3><p>call函数是唯一一个可以用来创建新的参数化的函数。<br>你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<pre><code>$(call &lt;expression&gt;;,&lt;parm1&gt;;,&lt;parm2&gt;;,&lt;parm3&gt;;...)</code></pre><p>当make执行这个函数时，&lt;expression&gt;;参数中的变量，<br>如$(1)，$(2)，$(3)等，会被参数&lt; parm1&gt;;，&lt;parm2&gt;;，&lt;parm3&gt;;依次取代。<br>而&lt;expression&gt;;的返回值就是 call函数的返回值。例如：</p>
<pre><code>reverse =  $(1) $(2)
foo = $(call reverse,a,b)</code></pre><p>那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>
<pre><code>reverse =  $(2) $(1)
foo = $(call reverse,a,b)</code></pre><p>此时的foo的值就是“b a”。</p>
<h3 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h3><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>
<pre><code>$(origin &lt;variable&gt;;)</code></pre><p>注意，&lt;variable&gt;;是变量的名字，不应该是引用。<br>所以你最好不要在&lt;variable&gt;;中使用“$”字符。<br>Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p>
<ul>
<li>“undefined” 如果&lt;variable&gt;;从来没有定义过，origin函数返回这个值“undefined”。</li>
<li>“default” 如果&lt;variable&gt;;是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</li>
<li>“environment” 如果&lt;variable&gt;;是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</li>
<li>“file” 如果&lt;variable&gt;;这个变量被定义在Makefile中。</li>
<li>“command line” 如果&lt;variable&gt;;这个变量是被命令行定义的。</li>
<li>“override” 如果&lt;variable&gt;;是被override指示符重新定义的。</li>
<li>“automatic” 如果&lt;variable&gt;;是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</li>
</ul>
<p>这些信息对于我们编写Makefile是非常有用的，<br>例如，假设我们有一个Makefile其包了一个定义文件Make.def，<br>在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，<br>此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，<br>如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<pre><code>ifdef bletch
    ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;
        bletch = barf, gag, etc.
    endif
endif</code></pre><h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>它的参数应该就是操作系统Shell的命令。它和反引号<strong>`</strong>是相同的功能。<br>这就是说，shell函数把执行操作系统命令后的输出作为函数返回。<br>于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<pre><code>contents := $(shell cat foo)
files := $(shell echo *.c)</code></pre><p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，<br>如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。<br>特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><ul>
<li><p>$@ 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</p>
</li>
<li><p>$% 仅当目标是函数库文件中，表示规则中的目标成员名。<br>例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是 “bar.o”，”$@”就是”foo.a”。<br>如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p>
</li>
<li><p>$&lt; 依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。<br>注意，其是一个一个取出来的。</p>
</li>
<li><p>$? 所有比目标新的依赖目标的集合。以空格分隔。</p>
</li>
<li><p>$^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>
</li>
<li><p>$+ 这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>
</li>
<li><p>$* 这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，<br>那么，”$*“的值就是”dir/a.foo”。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，<br>那么”$*“也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么”$*“就是除了后缀的那一部分。<br>例如：如果目标是”foo.c”，因为”.c”是make所能识别的后缀名，<br>所以，” $*“的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，<br>所以，你应该尽量避免使用”$*“，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么”$*“就是空值。<br>当你希望只对更新过的依赖文件进行操作时，”$?”在显式规则中很有用，<br>例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<p>  lib : foo.o bar.o lose.o win.o</p>
<pre><code>  ar r lib $?</code></pre></li>
</ul>
<p>在上述所列出来的自动量变量中。四个变量（$@、$&lt;、$%、$*）在扩展时只会有一个文件，<br>而另三个的值是一个文件列表。</p>
<p>对于”$&lt;”，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，”$(&lt;)”就要比”$&lt;”要好一些。</p>
<ol>
<li><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0#shell.E5.87.BD.E6.95.B0" target="_blank" rel="noopener">makefile:使用函数</a></li>
<li><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile" target="_blank" rel="noopener">跟我一起写Makefile</a></li>
<li><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99#.E4.BD.BF.E7.94.A8.E9.9A.90.E5.90.AB.E8.A7.84.E5.88.99" target="_blank" rel="noopener">makefile:隐含规则</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Shell</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>解决C编译警告</title>
    <url>/2015/10/21/compile-warning/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="implicit-declaration-of-function"><a href="#implicit-declaration-of-function" class="headerlink" title="implicit declaration of function"></a>implicit declaration of function</h2><pre><code>warning: implicit declaration of function &#39;app_create_dialog&#39;</code></pre><p>包含函数’app_create_dialog’定义的头文件解决警告。<br>如果没有声明头文件，可以将函数extern声明一下。</p>
<h2 id="unused-variable"><a href="#unused-variable" class="headerlink" title="unused variable"></a>unused variable</h2><pre><code>warning: unused variable &#39;buf&#39;</code></pre><p>删除不使用的变量</p>
<h2 id="initialization-discards-qualifiers-from-pointer-target-type"><a href="#initialization-discards-qualifiers-from-pointer-target-type" class="headerlink" title="initialization discards qualifiers from pointer target type"></a>initialization discards qualifiers from pointer target type</h2><pre><code>xx.c: In function &#39;cmm_cascam_create_dialog1&#39;:
xx.c:95:26: warning: initialization discards qualifiers from pointer target type</code></pre><p>添加类型强制转换</p>
<h2 id="pointer-targets-in-return-differ-in-signedness"><a href="#pointer-targets-in-return-differ-in-signedness" class="headerlink" title="pointer targets in return differ in signedness"></a>pointer targets in return differ in signedness</h2><pre><code>xx.c: In function &#39;cmm_ca_get_notice_str&#39;:
xx.c:58:5: warning: pointer targets in return differ in signedness</code></pre><p>数据类型不匹配，强制转换</p>
<h2 id="assignment-discards-qualifiers-from-pointer-target-type"><a href="#assignment-discards-qualifiers-from-pointer-target-type" class="headerlink" title="assignment discards qualifiers from pointer target type"></a>assignment discards qualifiers from pointer target type</h2><pre><code>ca/common_menu/cmm_cascam_dialog3.c: In function &#39;_create_dialog_check&#39;:
ca/common_menu/cmm_cascam_dialog3.c:150:17: warning: assignment discards qualifiers from pointer target type</code></pre><p>强制转换解决</p>
<h2 id="defined-but-not-used"><a href="#defined-but-not-used" class="headerlink" title="defined but not used"></a>defined but not used</h2><pre><code>x.c:59:12: warning: &#39;_mutex_delete&#39; defined but not used</code></pre><p>删除无用代码</p>
<h2 id="control-reaches-end-of-non-void-function"><a href="#control-reaches-end-of-non-void-function" class="headerlink" title="control reaches end of non-void function"></a>control reaches end of non-void function</h2><pre><code>module/cascam/cas/thinew/adapter/tnt_demux.c: In function &#39;_nit_set_equal_filter&#39;:
module/cascam/cas/thinew/adapter/tnt_demux.c:600:1: warning: control reaches end of non-void function</code></pre><p>添加</p>
<pre><code>return ret;</code></pre><h2 id="pointer-targets-in-passing-argument-1-of-‘cascam-strlen’-differ-in-signedness"><a href="#pointer-targets-in-passing-argument-1-of-‘cascam-strlen’-differ-in-signedness" class="headerlink" title="pointer targets in passing argument 1 of ‘cascam_strlen’ differ in signedness"></a>pointer targets in passing argument 1 of ‘cascam_strlen’ differ in signedness</h2><pre><code>module/cascam/cas/thinew/adapter/tnt_baseinfo.c: In function &#39;_get_basic_information&#39;:
module/cascam/cas/thinew/adapter/tnt_baseinfo.c:45:9: warning: pointer targets in passing argument 1 of &#39;cascam_strlen&#39; differ in signedness
module/cascam/cas/thinew/adapter/../../../include/cascam_os.h:61:14: note: expected &#39;char *&#39; but argument is of type &#39;unsigned char *&#39;</code></pre><p>形参与实参类型不匹配，强制转换</p>
<h2 id="warning-missing-braces-around-initializer"><a href="#warning-missing-braces-around-initializer" class="headerlink" title="warning: missing braces around initializer"></a>warning: missing braces around initializer</h2><pre><code>module/cascam/adapter/cascam_osd_adapter.c: In function &#39;cascam_osd_pop_dialog5&#39;:
module/cascam/adapter/cascam_osd_adapter.c:295:5: warning: missing braces around initializer
module/cascam/adapter/cascam_osd_adapter.c:295:5: warning: (near initialization for &#39;para.title&#39;)</code></pre><p>初始化大括号不明确，内部加上一个大括号，二维数组初始化。</p>
<h2 id="may-be-used-uninitialized-in-this-function"><a href="#may-be-used-uninitialized-in-this-function" class="headerlink" title="may be used uninitialized in this function"></a>may be used uninitialized in this function</h2><p>初始化变量</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>compile warning</tag>
      </tags>
  </entry>
  <entry>
    <title>使用反汇编定位未开源库问题</title>
    <url>/2015/10/20/gdb-disassemble-debug/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>整合版本时，遇到一个必现死机问题，每次出现问题都是调用库中的一个函数。<br>经过排查，初步怀疑是库存在一些问题，或者与外部使用配合出现问题。</p>
<h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><pre><code>(gdb) set $pc=$epc
(gdb) i r r10
r10            0x970038656
(gdb) info registers 
r0             0x90972c100x90972c10
r1             0x90486564-1874303644
r2             0x970038656
r3             0xff255
r4             0x904895de-1874291234
r5             0xae174
r6             0x00
r7             0x00
r8             0x904d03a0-1874000992
r9             0x11110009286326793
r10            0x970038656
r11            0x6096
r12            0x11
r13            0x904d03a0-1874000992
r14            0x904d02a0-1874001248
r15            0x90142750-1877727408
pc             0x9000060a0x9000060a &lt;__default_14&gt;
epc            0x902abd300x902abd30 &lt;inflate_fast+708&gt;
psr            0x8f0e0010-1894907888
epsr           0x800e0150-2146565808
(gdb) pc
#0  0x9014279cin xxx_xxm()at xx.c:574
#1  0x90142750in xxx_xxm()at xx.c:568
#2  0x9014144ein xxx_xx()at xx.c:2659
#3  0x90141446in xxx_xx()at xx.c:2658
#4  0x9014143ein xxx_xx()at xx.c:2657
#5  0x901413f2in xxx_xx()at xx.c:2657
#6  0x901413dein xxx_xx()at xx.c:2652
#7  0x901413d2in xxx_xx()at xx.c:2652
(gdb) disassemble $pc-10,$pc+10
Dump of assembler code from 0x90000600 to 0x90000614:
0x90000600 &lt;__hardware_accelerator+2&gt;:br0x90000600
0x90000602 &lt;__trap0+0&gt;:bkpt
0x90000604 &lt;__trap0+2&gt;:br0x90000604
0x90000606 &lt;__default_13+0&gt;:bkpt
0x90000608 &lt;__default_13+2&gt;:br0x90000608
=&gt; 0x9000060a &lt;__default_14+0&gt;:bkpt
0x9000060c &lt;__default_14+2&gt;:br0x9000060c
0x9000060e &lt;__default_15+0&gt;:bkpt
0x90000610 &lt;__default_15+2&gt;:br0x90000610
0x90000612 &lt;__default_17+0&gt;:bkpt
End of assembler dump.
(gdb) bt
#0  0x9000060a in __default_14 ()
#1  0x90142750 in xxx_xxm () at xx.c:568
#2  0x9013cfb8 in func () at c1.c:167
#3  0x9013f394 in main_entry (args=&lt;value optimized out&gt;) at init.c:14
#4  0x9008724c in default_thread_function (arg=0x907f32b8) at os/ecos/osapi.c:371
#5  0x901232f2 in pthread_entry(unsigned int) ()
#6  0x90127030 in Cyg_HardwareThread::thread_entry(Cyg_Thread*) ()
#7  0x9012701c in Cyg_Thread::exit() ()
#8  0xb0b6ccd0 in ?? ()</code></pre><p>可以判断出r10中值出现问题，并且问题出现在文件xx.c的函数xxx_xxm()中，重启跟踪代码：</p>
<pre><code>(gdb) b xxx_xxm 
Breakpoint 3 at 0x901425f4: file xx.c, line 524.
(gdb) c
Continuing.

Breakpoint 3, xxx_xxm () at xx.c:524
524xx.c: 没有那个文件或目录.
in xx.c
(gdb) display /i $r10
1: x/i $r10
0x1111000a:ldm r3-r15, (r0)
(gdb) display /i $pc
2: x/i $pc
=&gt; 0x901425f4 &lt;xxx_xxm+20&gt;:lrw r7, 0x903BA9CC
(gdb) n
526in xx.c
(gdb) 
574in xx.c
2: x/i $pc
=&gt; 0x9014279c &lt;xxx_xxm+444&gt;:mov r7, r2
1: x/i $r10
0x1111000a:movi r4, 86
(gdb) 
575in xx.c
2: x/i $pc
=&gt; 0x901427a6 &lt;xxx_xxm+454&gt;:mov r2, r10
1: x/i $r10
0x9700:movi r4, 86</code></pre><p><strong>问题很可能出现在源文件xx.c的574行</strong>，执行过这一行之后，r10的值修改为0x9700，最后请客户检查代码，确认为野指针。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>gdb</tag>
        <tag>disassemble</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM键值映射规则</title>
    <url>/2015/10/18/vim-map-nmap/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="map模式"><a href="#map模式" class="headerlink" title="map模式"></a>map模式</h2><p>有五种映射存在： </p>
<ol>
<li>Normal mode: 普通模式, 输入命令时</li>
<li>Visual mode: 可视模式: 可视区域高亮并输入命令时</li>
<li>Select mode: 选择模式: 与可视模式区别是会替换选择文本</li>
<li>Operator-pending mode: 操作符等待模式: 操作符等待中 (“d”，”y”，”c” 等等之后)。 见下: |omap-info|。 </li>
<li>Insert mode: 插入模式: 也用于替换模式。 </li>
<li>Command-line mode: 命令行模式: 输入 “:” 或 “/“ 命令时。 </li>
</ol>
<h2 id="快捷键映射"><a href="#快捷键映射" class="headerlink" title="快捷键映射"></a>快捷键映射</h2><p>快捷键映射分两种: map 和 noremap</p>
<h3 id="递归映射-map"><a href="#递归映射-map" class="headerlink" title="递归映射 (map)"></a>递归映射 (map)</h3><p>如果键 b 映射为键 a，然后键 c 映射为键 b，那么当按键 c 时会产生按键 a 的效果。</p>
<pre><code>:map b a
:map c b</code></pre><p>相当于</p>
<pre><code>:map c a</code></pre><h3 id="非递归映射-noremap"><a href="#非递归映射-noremap" class="headerlink" title="非递归映射 (noremap)"></a>非递归映射 (noremap)</h3><pre><code>:noremap b a
:noremap c b</code></pre><p>非递归映射则不会产生递归映射一样的效果。</p>
<h2 id="不同模式下的快捷键映射"><a href="#不同模式下的快捷键映射" class="headerlink" title="不同模式下的快捷键映射"></a>不同模式下的快捷键映射</h2><h3 id="映射模式"><a href="#映射模式" class="headerlink" title="映射模式"></a>映射模式</h3><p>在 map 与 noremap 前分别可以加 ‘n’, ‘v’, ‘x’, ‘s’, ‘o’, ‘i’, ‘l’, ‘c’ 以及 ‘map!’ 和 ‘noremap!’：</p>
<ul>
<li><Space>    Normal, Visual, Select and Operator-pending</li>
<li>n    Normal</li>
<li>v    Visual and Select</li>
<li>s    Select (在可视模式下Ctrl+G进入)</li>
<li>x    Visual</li>
<li>o    Operator-pending</li>
<li>!    Insert and Command-line</li>
<li>i    Insert</li>
<li>l    “:lmap” mappings for Insert, Command-line and Lang-Arg</li>
<li>c    Command-line</li>
</ul>
<p>常用参数：</p>
<ul>
<li>{lhs} 表示左手边 *{lhs}*</li>
<li>{rhs} 表示右手边 *{rhs}*</li>
</ul>
<h3 id="普通模式的映射命令"><a href="#普通模式的映射命令" class="headerlink" title="普通模式的映射命令"></a>普通模式的映射命令</h3><p>可以随时<strong><em>:help map</em></strong>一下，查看相关命令具体信息。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre><code>:map {lhs} {rhs} 
:map {lhs} {rhs} |mapmode-nvo| *:map* </code></pre><p>作用模式： n、v、o （普通、可视和选择、操作符等待）。<br>在:map作用的模式中把键系列 {lhs} 映射为 {rhs}，{rhs}可进行映射扫描，也就是可递归映射。 </p>
<p>举例： </p>
<pre><code>:map td :tabnew .&lt;cr&gt; </code></pre><p>在其作用模式（普通、可视、操作符）下，输入td等价于输入 :tabnew . <cr>。<br>而普通模式下输入:tabnew . <cr>就是打开当前目录，<br>如果再定义绑定：</p>
<pre><code>:map ts td</code></pre><p>就是指在其作用模式下输入ts等价于td，也就是打开当前目录。不过如果没有特殊需要，一般不建议递归映射。 </p>
<h4 id="noremap"><a href="#noremap" class="headerlink" title="noremap"></a>noremap</h4><p>:moremap和:map命令相对，作用模式和命令格式都相同，<br>只不过不允许再对{rhs}进行映射扫描，也就是{lhs}定义后的映射就是{rhs}的键序列，不会再对{rhs}键序列重新解释扫描。<br>它一般用于重定义一个命令，当然如果:map不需要递归映射的话，建议使用:noremap，比如： </p>
<pre><code>:noremap ts td </code></pre><p>它的意思是在其作用模式下，输入ts就是输入td，但是和:map不同的是，此时td再不会做进一步扫描解释。<br>虽然之前已经定义了td，但是不会对td再做扫描 </p>
<h4 id="unmap"><a href="#unmap" class="headerlink" title="unmap"></a>unmap</h4><p>:unmap是对应取消:map绑定的{lhs}，作用模式相同，命令格式</p>
<pre><code>:unmap {lhs}</code></pre><p>例如： </p>
<pre><code>:unmap td </code></pre><p>就是取消在其作用模式中td的绑定，比如之前td被绑定为:tabnew .<cr>，此时此绑定消失。 </p>
<h4 id="mapclear"><a href="#mapclear" class="headerlink" title="mapclear"></a>mapclear</h4><p>:mapclear时对应取消所有:map绑定的，慎用！ </p>
<h4 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h4><p>:nmap是:map的普通模式板，也就是说其绑定的键只作用于普通模式。例如： </p>
<pre><code>:nmap td :tabnew .&lt;cr&gt; </code></pre><p>在普通模式下等效 </p>
<pre><code>:map td :tabnew .&lt;cr&gt; </code></pre><h4 id="nnoremap"><a href="#nnoremap" class="headerlink" title="nnoremap"></a>nnoremap</h4><p>:nnorempa和:nmap的关系和:noremap和:map的关系一样，只是:nmap的非递归版 </p>
<h4 id="nunmap"><a href="#nunmap" class="headerlink" title="nunmap"></a>nunmap</h4><p>:nunmap和:nmap的关系和:unmap和:map的关系一样，取消:nmap的绑定。 </p>
<h4 id="nmapclear"><a href="#nmapclear" class="headerlink" title="nmapclear"></a>nmapclear</h4><p>:nmapclear是对应取消所有:map绑定的，慎用！ </p>
<p><strong>可以发现一个规律，前4个是一组，后4个时一组，后一组比前一组多一个n就是指只作用于普通模式。<br>其中每组内*nore*是其对应的非递归版、*un*是取消绑定某个&lt;lhs&gt;绑定、clear后缀是取消所有绑定。<br>发现了这个规律，再翻到前面的模式代号表，<br>大体可以猜到vmap、xmap、smap、omap是什么意思，以及相对应的nore版本、un版本、clear版本。</strong></p>
<p>另外，{rhs} 之前可能显示一个特殊字符: </p>
<ul>
<li>* 表示它不可重映射 </li>
<li>&amp; 表示仅脚本的局部映射可以被重映射 </li>
<li>@ 表示缓冲区的局部映射 </li>
</ul>
<h3 id="键表-key-notation"><a href="#键表-key-notation" class="headerlink" title="键表|key-notation|"></a>键表|key-notation|</h3><ul>
<li>&lt;k0&gt; - &lt;k9&gt; 小键盘 0 到 9 *keypad-0* *keypad-9* </li>
<li>&lt;S-…&gt; Shift＋键 *shift* *&lt;S-* </li>
<li>&lt;C-…&gt; Control＋键 *control* *ctrl* *&lt;C-* </li>
<li>&lt;M-…&gt; Alt＋键 或 meta＋键 *meta* *alt* *&lt;M-* </li>
<li>&lt;A-…&gt; 同 &lt;m-…&gt; *&lt;A-* </li>
<li>&lt;t_xx&gt; termcap 里的 “xx” 入口键 </li>
</ul>
<h3 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h3><ul>
<li>&lt;buffer&gt; </li>
<li>&lt;nowait&gt; </li>
<li>&lt;silent&gt; </li>
<li>&lt;special&gt; </li>
<li>&lt;script&gt; </li>
<li>&lt;expr&gt; </li>
<li>&lt;unique&gt; </li>
</ul>
<p>可以按任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。</p>
<h4 id="lt-buffer-gt"><a href="#lt-buffer-gt" class="headerlink" title="&lt;buffer&gt;"></a>&lt;buffer&gt;</h4><p>如果这些映射命令的第一个参数是&lt;buffer&gt;，映射将只局限于当前缓冲区（也就是你此时正编辑的文件）内。比如： </p>
<pre><code>:map &lt;buffer&gt; ,w /a&lt;CR&gt; </code></pre><p>它的意思时在当前缓冲区里定义键绑定，“,w”将在当前缓冲区里查找字符a。同样你可以在其他缓冲区里定义： </p>
<pre><code>:map &lt;buffer&gt; ,w /b&lt;CR&gt; </code></pre><p>其作用域也只在各自的标签里。同样要清除这些缓冲区的键绑定也要加上&lt;buffer&gt;参数，比如： </p>
<pre><code>:unmap &lt;buffer&gt; ,w 
:mapclear &lt;buffer&gt; </code></pre><h4 id="lt-nowait-gt"><a href="#lt-nowait-gt" class="headerlink" title="&lt;nowait&gt;"></a>&lt;nowait&gt;</h4><p>定义局部于缓冲区的映射 “,” 时，可能有另一个全局映射也以 “,” 开始。<br>这时你需要键入另一个字符，Vim 才能知道是用 “,” 映射还是更长的那个。<br>要避免这个问题，加入 <nowait> 参数。<br>这样映射一旦匹配就会被使用，Vim 不会等待更多字符的输入。但如果那些字符已经输入了，还是会使用的。</p>
<h4 id="lt-silent-gt"><a href="#lt-silent-gt" class="headerlink" title="&lt;silent&gt;"></a>&lt;silent&gt;</h4><p>执行键绑定时不在命令行上回显，比如： </p>
<pre><code>:map &lt;silent&gt; ,w /abcd&lt;CR&gt; </code></pre><p>输入,w查找abcd时，命令行上不会显示/abcd，如果没有&lt;silent&gt;参数就会显示出来 </p>
<h4 id="lt-special-gt"><a href="#lt-special-gt" class="headerlink" title="&lt;special&gt;"></a>&lt;special&gt;</h4><p>一般用于定义特殊键怕有副作用的场合。比如： </p>
<pre><code>:map &lt;special&gt; &lt;F12&gt; /Header&lt;CR&gt; </code></pre><h4 id="lt-unique-gt"><a href="#lt-unique-gt" class="headerlink" title="&lt;unique&gt;"></a>&lt;unique&gt;</h4><p>一般用于定义新的键映射或者缩写命令的同时检查是否该键已经被映射，如果该映射或者缩写已经存在，则该命令会失败 </p>
<pre><code>:map &lt;unique&gt; ,w  /[#&amp;!]&lt;CR&gt;</code></pre><p>这个例子将失败:</p>
<pre><code>:map ,w  /[#&amp;!]&lt;CR&gt;
:map &lt;buffer&gt; &lt;unique&gt; ,w  /[.,;]&lt;CR&gt;</code></pre><h4 id="lt-expr-gt"><a href="#lt-expr-gt" class="headerlink" title="&lt;expr&gt;"></a>&lt;expr&gt;</h4><p>如果定义新映射的第一个参数是&lt;expr&gt;，那么参数会作为表达式来进行计算，结果使用实际使用的&lt;rhs&gt;，例如： </p>
<pre><code>:inoremap &lt;expr\&gt; . InsertDot() </code></pre><p>这可以用来检查光标之前的文本并在一定条件下启动全能 (omni) 补全。 </p>
<p>这里是插入递增的列表编号的例子:</p>
<pre><code>let counter = 0 
inoremap &lt;expr&gt; &lt;C-L&gt; ListItem() 
inoremap &lt;expr&gt; &lt;C-R&gt; ListReset() 

func ListItem() 
    let g:counter += 1 
    return g:counter . &#39;. &#39; 
endfunc 

func ListReset() 
    let g:counter = 0 
    return &#39;&#39; 
endfunc </code></pre><p>CTRL-L 插入下一个数值，CTRL-R 复位计数且返回空字符串，这样就不会插入任何内容。</p>
<h3 id="lt-Leader-gt-mapleader"><a href="#lt-Leader-gt-mapleader" class="headerlink" title="&lt;Leader&gt;mapleader"></a>&lt;Leader&gt;mapleader</h3><p>要定义一个使用 “mapleader” 变量的映射，可以使用特殊字串 “<Leader>“。<br>它会被 “mapleader” 的字串值所替换。如果 “mapleader” 未设置或为空，则用反斜杠代替，例如:</p>
<pre><code>:map &lt;Leader&gt;A  oanother line&lt;Esc&gt;</code></pre><p>和下面一样:</p>
<pre><code>:map \A  oanother line&lt;Esc&gt;</code></pre><p>但是当:</p>
<pre><code>:let mapleader = &quot;,&quot;</code></pre><p>又相当于:</p>
<pre><code>:map ,A  oanother line&lt;Esc&gt;</code></pre><p>注意 “mapleader” 的值仅当定义映射时被使用。后来改变的 “mapleader” 不会影响已定义的映射。</p>
<ol>
<li><a href="http://vimcdoc.sourceforge.net/doc/map.html#:map-commands" target="_blank" rel="noopener">VIM 参考手册-MAP</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vimscript</tag>
      </tags>
  </entry>
  <entry>
    <title>vim配置golang开发环境</title>
    <url>/2015/10/15/go-with-vim/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><p>Vim-go是当前使用最为广泛的用于搭建Golang开发环境的vim插件：</p>
<pre><code>Bundle &#39;fatih/vim-go&#39;
:BundleInstall</code></pre><p>Tagbar配合gotags配置：</p>
<pre><code>let g:tagbar_type_go = {
    \ &#39;ctagstype&#39; : &#39;go&#39;,
    \ &#39;kinds&#39;     : [
        \ &#39;p:package&#39;,
    \ &#39;i:imports:1&#39;,
    \ &#39;c:constants&#39;,
    \ &#39;v:variables&#39;,
    \ &#39;t:types&#39;,
    \ &#39;n:interfaces&#39;,
    \ &#39;w:fields&#39;,
    \ &#39;e:embedded&#39;,
    \ &#39;m:methods&#39;,
    \ &#39;r:constructor&#39;,
    \ &#39;f:functions&#39;
        \ 
    ],
    \ &#39;sro&#39; : &#39;.&#39;,
    \ &#39;kind2scope&#39; : {
        \ &#39;t&#39; : &#39;ctype&#39;,
        \ &#39;n&#39; : &#39;ntype&#39;
            \ 
    },
    \ &#39;scope2kind&#39; : {
        \ &#39;ctype&#39; : &#39;t&#39;,
        \ &#39;ntype&#39; : &#39;n&#39;
            \ 
    },
    \ &#39;ctagsbin&#39;  : &#39;gotags&#39;,
    \ &#39;ctagsargs&#39; : &#39;-sort -silent&#39;
    \ }</code></pre><h2 id="安装Binaries"><a href="#安装Binaries" class="headerlink" title="安装Binaries"></a>安装Binaries</h2><p>还需要安装其他tools，vim-go安装说明中提到所有必要的binary需要先安装好，比如gocode、godef、goimports等。通过：</p>
<pre><code>:GoInstallBinaries</code></pre><p>查看文件.vim/bundle/vim-go/plugin/go.vim：</p>
<pre><code>let s:packages = [
    \ &quot;github.com/nsf/gocode&quot;,
    \ &quot;golang.org/x/tools/cmd/goimports&quot;,
    \ &quot;github.com/rogpeppe/godef&quot;,
    \ &quot;golang.org/x/tools/cmd/oracle&quot;,
    \ &quot;golang.org/x/tools/cmd/gorename&quot;,
    \ &quot;github.com/golang/lint/golint&quot;,
    \ &quot;github.com/kisielk/errcheck&quot;,
    \ &quot;github.com/jstemmer/gotags&quot;,
    \ ]</code></pre><p>这些vim-go依赖的二进制工具将会自动被下载，并被安装到$GOBIN下，但是自动安装很可能部分tools安装不成功，此时需要手动安装：</p>
<pre><code>go get -u github.com/nsf/gocode

//或者
git clone https://go.googlesource.com/tools $GOPATH/src/golang.org/x/tools
go build golang.org/x/tools/cmd/goimports</code></pre><p>安装golint：</p>
<pre><code>./3rdpkg/src/github.com/golang
git clone git@github.com:golang/lint.git
cd ../../../../go/bin
pwd
./go/bin
go build -x github.com/golang/lint/golint
cp $WORK/github.com/golang/lint/golint/_obj/exe/a.out golint</code></pre><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>安装完毕$GOBIN目录如下：</p>
<pre><code>.
├── errcheck
├── go
├── gocode
├── godef
├── godoc
├── gofmt
├── goimports
├── gorename
├── gotags
└── oracle</code></pre><ul>
<li><a href="https://github.com/jstemmer/gotags" target="_blank" rel="noopener">gotags</a> 这个用来配合vim的tagbar，查看方便的生成和查看文件中的各种方法，并进行跳转</li>
<li><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimport</a> 根据你所使用的方法，自动调整import中引用的内容，比较方便。<br>可以随时用vim命令 :Fmt 来格式化你的代码，也可以每次保存代码的时候，让vim自动为你格式化代码</li>
<li><a href="https://github.com/dgryski/vim-godef" target="_blank" rel="noopener">godef</a> 实现在代码中的跳转，从函数调用的地方，直接跳转到函数的定义。默认的命令是：gd</li>
<li><a href="https://github.com/nsf/gocode" target="_blank" rel="noopener">gocode</a>实现Golang的代码自动补全</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>新起一行输入fmt.，然后ctrl+x, ctrl+o，Vim 会弹出补齐提示下拉框，不过并非实时跟随的那种补齐，这个补齐是由gocode提供的。</li>
<li>输入一行代码：time.Sleep(time.Second)，执行:GoImports，Vim会自动导入time包。</li>
<li>将光标移到Sleep函数上，执行:GoDef或命令模式下敲入gd，Vim会打开$GOROOT/src/time/sleep.go中 的Sleep函数的定义。执行:b 1返回到hellogolang.go。</li>
<li>执行:GoLint，运行golint在当前Go源文件上。</li>
<li>执行:GoDoc，打开当前光标对应符号的Go文档。</li>
<li>执行:GoVet，在当前目录下运行go vet在当前Go源文件上。</li>
<li>执行:GoRun，编译运行当前main package。</li>
<li>执行:GoBuild，编译当前包，这取决于你的源文件，GoBuild不产生结果文件。</li>
<li>执行:GoInstall，安装当前包。</li>
<li>执行:GoTest，测试你当前路径下地_test.go文件。</li>
<li>执行:GoCoverage，创建一个测试覆盖结果文件，并打开浏览器展示当前包的情况。</li>
<li>执行:GoErrCheck，检查当前包种可能的未捕获的errors。</li>
<li>执行:GoFiles，显示当前包对应的源文件列表。</li>
<li>执行:GoDeps，显示当前包的依赖包列表。</li>
<li>执行:GoImplements，显示当前类型实现的interface列表。</li>
<li>执行:GoRename [to]，将当前光标下的符号替换为[to]。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://studygolang.com/articles/1785" target="_blank" rel="noopener">Golang开发环境搭建</a></li>
<li><a href="https://github.com/nsf/gocode" target="_blank" rel="noopener">gocode</a></li>
<li><a href="https://github.com/golang" target="_blank" rel="noopener">Go</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>go</tag>
        <tag>sdk</tag>
      </tags>
  </entry>
  <entry>
    <title>GBK、GB2312和GB18030</title>
    <url>/2015/10/13/GB-set/</url>
    <content><![CDATA[<h2 id="GB2312-80"><a href="#GB2312-80" class="headerlink" title="GB2312-80"></a>GB2312-80</h2><p><strong>GB 2312或GB 2312-80 是中国国家标准简体中文字符集</strong>，<br>全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。<br>GB2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p>
<p><strong>GB 2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；</strong><br>同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p>
<ul>
<li>GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。</li>
<li>对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</li>
</ul>
<p><strong>GB2312对任意一个图形字符都采用两个字节表示</strong>，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，<br>分别对应第一字节和第二字节。这种表示方式也称为区位码。</p>
<ul>
<li>01-09区为特殊符号。</li>
<li>16-55区为一级汉字，按拼音排序。</li>
<li>56-87区为二级汉字，按部首／笔画排序。</li>
<li>10-15区及88-94区则未有编码。</li>
</ul>
<p><strong>GB2312的编码范围为2121H-777EH，与ASCII有重叠，通行方法是将GB码两个字节的最高位置1以示区别。</strong></p>
<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p><strong>GBK即汉字内码扩展规范</strong>，K为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。</p>
<p><strong>GBK共收入21886个汉字和图形符号</strong>，包括：</p>
<ul>
<li>GB2312中的全部汉字、非汉字符号。</li>
<li>BIG5中的全部汉字。</li>
<li>与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。</li>
<li>其它汉字、部首、符号，共计984个。</li>
</ul>
<p>GBK向下与GB2312 完全兼容，向上支持ISO 10646国际标准，在前者向后者过渡过程中起到的承上启下的作用。</p>
<p><strong>GBK 采用双字节表示，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间，剔除XX7F一条线。</strong>GBK编码区分三部分：</p>
<ul>
<li>汉字区：<ul>
<li>GBK/2：OXBOA1-F7FE, 收录GB2312汉字6763个，按原序排列；</li>
<li>GBK/3：OX8140-AOFE，收录CJK汉字6080个；</li>
<li>GBK/4：OXAA40-FEAO，收录CJK汉字和增补的汉字8160个。</li>
</ul>
</li>
<li>图形符号区：<ul>
<li>GBK/1：OXA1A1-A9FE，除GB2312的符号外，还增补了其它符号</li>
<li>GBK/5：OXA840-A9AO，扩除非汉字区。</li>
</ul>
</li>
<li>用户自定义区<ul>
<li>GBK区域中的空白区，用户可以自己定义字符。</li>
</ul>
</li>
</ul>
<h2 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h2><p><strong>GB 18030，全称：国家标准GB 18030-2005《信息技术中文编码字符集》</strong>，<br>是中华人民共和国现时最新的内码字集，是GB 18030-2000《信息技术信息交换用汉字编码字符集基本集的扩充》的修订版。<br><strong>GB 18030与GB 2312-1980完全兼容，与GBK基本兼容，支持GB 13000及Unicode的全部统一汉字，共收录汉字70244个。</strong></p>
<ul>
<li>与 UTF-8 相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。</li>
<li>编码空间庞大，最多可定义161万个字符。</li>
<li>支持中国国内少数民族的文字，不需要动用造字区。</li>
<li>汉字收录范围包含繁体汉字以及日韩汉字</li>
</ul>
<p>GB18030 编码是一二四字节变长编码。</p>
<ul>
<li>单字节，其值从0到0x7F，与 ASCII 编码兼容。</li>
<li>双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F），与 GBK标准基本兼容。</li>
<li>四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。</li>
</ul>
<h2 id="CP936"><a href="#CP936" class="headerlink" title="CP936"></a>CP936</h2><p><strong>代码页936（Codepage 936）是 Microsoft 的简体中文字元集标准</strong>，<br>是东亚语文的四种双字节字元集（DBCS）之一。其最初版本和 GB 2312 一模一样，<br>但在推出 Windows 95 时扩展成包含绝大部分的 GBK 字元（代码页936 比 GBK 少95个字元，皆为当时尚未收入 Unicode 的字元）；<br>虽然该等字元现在已全部收入 Unicode，但代码页936 至今都没有修订。</p>
<h2 id="libiconv"><a href="#libiconv" class="headerlink" title="libiconv"></a><a href="https://www.gnu.org/software/libiconv/" target="_blank" rel="noopener">libiconv</a></h2><p>几个函数入口及相关转换表：</p>
<pre><code>static int ces_gbk_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, int n);
static int gbk_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, int n);</code></pre><p>重要头文件：</p>
<pre><code>lib/encodings.def
lib/ces_gbk.h
lib/gbk.h
lib/gb2312.h
lib/cp936ext.h</code></pre><ol>
<li><a href="https://zh.wikipedia.org/wiki/GB_2312" target="_blank" rel="noopener">GB 2312</a></li>
<li><a href="http://www.knowsky.com/resource/gb2312tbl.htm" target="_blank" rel="noopener">GB2312简体中文编码表</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">汉字内码扩展规范</a></li>
<li><a href="https://zh.wikipedia.org/wiki/GB_18030" target="_blank" rel="noopener">GB 18030</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E4%BB%A3%E7%A2%BC%E9%A0%81936" target="_blank" rel="noopener">代码页936</a></li>
<li><a href="http://r12a.github.io/apps/conversion/" target="_blank" rel="noopener">Unicode code converter</a></li>
<li><a href="http://code.web.idv.hk/" target="_blank" rel="noopener">中文編碼網頁GB18030</a></li>
<li><a href="http://icu-project.org/repos/icu/data/trunk/charset/source/gb18030/" target="_blank" rel="noopener">International Components for Unicode ː Repository Browser</a></li>
<li><a href="ftp://ftp.oreilly.com/examples/cjkvinfo/unicode/gb2312-80.txt">GB2312-80 to Unicode table</a></li>
<li><a href="ftp://ftp.software.ibm.com/software/globalization/gb18030.pdf">GB18030 Conversion Documentation</a></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Font</category>
      </categories>
      <tags>
        <tag>character set</tag>
        <tag>gb2312</tag>
        <tag>gbk</tag>
        <tag>gb18030</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言不定参数的使用</title>
    <url>/2015/10/11/va-list/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>在c语言中使用变长参数最常见的就是下面两个函数了：</p>
<pre><code>int printf(const char *format, ...);
int scanf(const char *format, ...);</code></pre><p>在使用变长参数的函数（这里假设是func）实现部分其实用到了stdarg.h里面的多个宏来访问那些不确定的参数，它们分别是：</p>
<pre><code>void va_start(va_list ap, last);
type va_arg(va_list ap, type);
void va_end(va_list ap);</code></pre><p>假设lastarg是func的最后一个具名参数，即在func函数定义中…之前的那个参数（在printf中lastarg是format），<br>在func中首先定义一个变量：</p>
<pre><code>va_list ap</code></pre><p>这个变量以后会依次指向各个可变参数。ap在使用之前必须用宏va_start初始化一次，如下所示：</p>
<pre><code>va_start(ap, lastarg);</code></pre><p>其中lastarg是func中的最后一个具名参数。然后就可以用va_arg来获得下一个不定参数（前提是知道这个不定参数的类型type）：</p>
<pre><code>type next = va_arg(ap, type)</code></pre><p>最后就是用宏va_end来清理现场。例子：</p>
<pre><code>void _printf(char *format, ...)                                                                                               
{
    #define BUFFER_LEN  256
    char Buf[BUFFER_LEN];
    va_list args;
    memset(Buf,0, BUFFER_LEN);

    va_start(args, format);
    vsnprintf(Buf, BUFFER_LEN, format, args);
    va_end(args);

    printf(&quot;%s&quot;, Buf);
}</code></pre><p>另一个例子：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void func(char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);

    while (*fmt)
    {
        switch(*fmt)
        {
            case &#39;d&#39;:
                fprintf(stdout, &quot;%d\n&quot;, (int)va_arg(ap, int));
                break;
            case &#39;c&#39;:
                fprintf(stdout, &quot;%c\n&quot;, (char)va_arg(ap, int));
                break;
            case &#39;s&#39;:
                fprintf(stdout, &quot;%s\n&quot;, (char *)va_arg(ap, char *));
                break;
            default:
                fprintf(stderr, &quot;error fmt\n&quot;);

        }
        fmt ++;
    }
    va_end(ap);
}

int main ( int argc, char *argv[]  )
{
    func(&quot;dcs&quot;, 10, &#39;s&#39;, &quot;hello&quot;);
        return 0;

}               /* ----------  end of function main  ---------- */</code></pre><h2 id="函数参数的传递原理"><a href="#函数参数的传递原理" class="headerlink" title="函数参数的传递原理"></a>函数参数的传递原理</h2><p>函数参数是以数据结构:栈的形式存取,从右至左入栈。</p>
<p>首先是参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数的时候，从最后一个开始入栈。<br>因此栈底高地址，栈顶低地址，举个例子如下：</p>
<pre><code>void func(int x, float y, char z);</code></pre><p>那么，调用函数的时候，实参 char z 先进栈，然后是 float y，最后是 int x，<br>因此在内存中变量的存放次序是 x-&gt;y-&gt;z，<br>因此，从理论上说，我们只要探测到任意一个变量的地址，<br>并且知道其他变量的类型，通过指针移位运算，则总可以顺藤摸瓜找到其他的输入变量。<br>va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。</p>
<ol>
<li>在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</li>
<li>然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，<br>这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数；</li>
<li>然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，<br>然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；</li>
<li>获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，<br>他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。<br>通常va_start和va_end是成对出现。</li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>va_list</tag>
      </tags>
  </entry>
  <entry>
    <title>不链接未使用代码</title>
    <url>/2015/09/27/unused-sourcecode-ld/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="默认编译"><a href="#默认编译" class="headerlink" title="默认编译"></a>默认编译</h2><p>默认编译环境下.c文件会编译为.o文件，当链接时会链接.o文件，整个.o文件为一个section，当此section存在无用函数时会造成控件浪费。</p>
<pre><code>gcc -o main main.c x.o</code></pre><p>可以使用命令来查看二进制可执行文件中的符号表，所有函数都链接进去：</p>
<pre><code>nm -S main
readelf -S x.o</code></pre><p>GCC链接时，按照section来链接，不论section中符号是否都使用到！</p>
<h2 id="拆分默认section"><a href="#拆分默认section" class="headerlink" title="拆分默认section"></a>拆分默认section</h2><pre><code>-ffunction-sections （为每个function函数分配独立的section）
-fdata-sections （为每个data item数据项分配独立的section）

gcc -c -ffunction-sections -fdata-sections x.c x.o</code></pre><p>x.o大小会明显变大，因为section大量增加。</p>
<h2 id="排除不链接section-Wl-–gc-sections"><a href="#排除不链接section-Wl-–gc-sections" class="headerlink" title="排除不链接section -Wl,–gc-sections"></a>排除不链接section -Wl,–gc-sections</h2><pre><code>-Wl,的意思是将后面的内容传递给链接器
--gc-sections是链接器参数，不链接未使用的section

gcc -Wl,--gc-sections -o main main.c x.o</code></pre><p>可以保证代码量最优。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>ld</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>\#pragma pack(n)和\_\_attribute\_\_((aligned(m)))的区别</title>
    <url>/2015/09/10/attribute-aligned/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="pragma-pack-n-和-attribute-aligned-m-的区别："><a href="#pragma-pack-n-和-attribute-aligned-m-的区别：" class="headerlink" title="#pragma pack(n)和__attribute__((aligned(m)))的区别："></a>#pragma pack(n)和__attribute__((aligned(m)))的区别：</h2><p>前者告诉编译器结构体或类内部的成员变量相对于第一个变量的地址的偏移量的对齐方式，<br>缺省情况下，编译器按照自然边界对齐，当变量所需的自然对齐边界比n大时，按照n对齐，<br>否则按照自然边界对齐；<br>后者告诉编译器一个结构体或者类或者联合或者一个类型的变量(对象)分配地址空间时的地址对齐方式。<br>也就是说，如果将__attribute__((aligned(m)))作用于一个类型，那么该类型的变量在分配地址空间时，<br>其存放的地址一定按照m字节对齐(m必须是2的幂次方)。<br>并且其占用的空间，即大小,也是m的整数倍，以保证在申请连续存储空间的时候，<br>每一个元素的地址也是按照m字节对齐。 __attribute__((aligned(m)))也可以作用于一个单独的变量。举例说明：</p>
<pre><code>#include&lt;stdio.h&gt;
#pragma pack(4)

typedef struct{
    uint32_t f1;
    uint8_t f2;
    uint8_t f3;
    uint32_t f4;
    uint64_t f5;
}__attribute__((aligned(1024))) ts;

int main()
{
    printf(&quot;Struct size is: %d, aligned on 1024\n&quot;,sizeof(ts));
    printf(&quot;Allocate f1 on address: 0x%x\n&quot;,&amp;(((ts*)0)-&gt;f1));
    printf(&quot;Allocate f2 on address: 0x%x\n&quot;,&amp;(((ts*)0)-&gt;f2));
    printf(&quot;Allocate f3 on address: 0x%x\n&quot;,&amp;(((ts*)0)-&gt;f3));
    printf(&quot;Allocate f4 on address: 0x%x\n&quot;,&amp;(((ts*)0)-&gt;f4));
    printf(&quot;Allocate f5 on address: 0x%x\n&quot;,&amp;(((ts*)0)-&gt;f5));
    return 0;
}</code></pre><p>输出：</p>
<font color="#00FF00">
    Struct size is: 1024, aligned on 1024
<br/>
</font>
    Allocate f1 on address: 0x0
<br/>
<font color="#FF0000">
    Allocate f2 on address: 0x4
<br/>
    Allocate f3 on address: 0x5
<br/>
</font>
    Allocate f4 on address: 0x8
<br/>
<font color="#FF00FF">
    Allocate f5 on address: 0xc
<br/>
</font>

<p>注意:</p>
<p>绿色部分表明了__attribute__((aligned(1024))) 的作用<br/><br>红色部分说明#pragma pack(4)只对大小大于4的成员变量的地址偏移起作用<br/><br>紫色部分说明对于大小大于4的成员变量，其地址偏移按照4字节对齐</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>gcc attribute</tag>
      </tags>
  </entry>
  <entry>
    <title>几个有用的gcc attribute</title>
    <url>/2015/09/10/gcc-attributes/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h2 id="align属性"><a href="#align属性" class="headerlink" title="align属性"></a>align属性</h2><p>align属性不仅可以修饰变量，类型， 还可以修饰函数， 举个例子：</p>
<h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><pre><code>int a = 0;

int main(void)
{
    printf(&quot;a = %d\n&quot;, a);
}</code></pre><p>用gdb看下变量a的地址：</p>
<pre><code>(gdb) p/x &amp;a
$1 = 0x60087c</code></pre><p>变量a地址是编译器随意生成的， 这个例子碰巧分配到了8字节对齐的位置上。<br>用align属性修饰下：</p>
<pre><code>int a __attribute__((aligned(8))) = 0;

(gdb) p/x &amp;a
$1 = 0x600880</code></pre><p>编译器会把变量a生成在8字节对齐的内存地址上。</p>
<h3 id="修饰类型"><a href="#修饰类型" class="headerlink" title="修饰类型"></a>修饰类型</h3><pre><code>int a __attribute__((aligned(8))) = 0;

struct test {
    int a;
} __attribute__((aligned(8)));

struct test aa;

int main(void)
{
    printf(&quot;a = %d\n&quot;, a);
}</code></pre><p>经过align修饰后，struct test数据结构定义的所有变量都会出现在8字节对齐的内存上。</p>
<pre><code>(gdb) p/x &amp;aa
$1 = 0x600888</code></pre><h3 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h3><pre><code>void test1(void) __attribute__((aligned(2)));

void  test1(void)
{
    printf(&quot;hello, world.\n&quot;);
}

int main(void)
{
    test1();
}</code></pre><p>经过align修饰后，函数出现在8字节对齐的内存上。</p>
<pre><code>(gdb) p test1 
$1 = {&lt;text variable, no debug info&gt;} 0x400538 &lt;test1&gt;</code></pre><h2 id="always-inline属性"><a href="#always-inline属性" class="headerlink" title="always_inline属性"></a>always_inline属性</h2><p>gcc有个inline关键字，可以将一个函数定义为内嵌形式：</p>
<pre><code>static inline void test2(void);

void test1(void)
{
    printf(&quot;hehe.\n&quot;);
}

void test2(void)
{
    asm(&quot;nop&quot;);
}

void test(void)
{
    test1();
    test2();
}

int main(void)
{
    test();
}</code></pre><p>按照inline的定义， test在调用test2函数的时候， 会直接将test2函数的代码展开在test函数内部，<br>这样就减少了一次函数调用过程， 加快了代码的执行速度， 用gdb反汇编看下：</p>
<pre><code>(gdb) disass test
Dump of assembler code for function test:
0x00000000004004a8 :    push   %rbp
0x00000000004004a9 :    mov    %rsp,%rbp
0x00000000004004ac :    callq  0x400498 
0x00000000004004b1 :    callq  0x4004b8 
0x00000000004004b6 :   leaveq
0x00000000004004b7 :   retq
End of assembler dump.</code></pre><p>你可以看到，gcc并没有把test2函数展开，明明已经使用inline修饰了。<br>因为虽然用inline做了修饰，但是gcc会根据代码的逻辑来优化到底有没有必要使用inline代码。<br>像这种简单的代码，用inline代码效果不大，因此gcc并没有按照inline要求来生成代码。</p>
<pre><code>static inline void test2(void) __attribute__((always_inline));
加入always_inline属性后呢？
(gdb) disass test
Dump of assembler code for function test:
0x00000000004004a8 :    push   %rbp
0x00000000004004a9 :    mov    %rsp,%rbp
0x00000000004004ac :    callq  0x400498 
0x00000000004004b1 :    nop
0x00000000004004b2 :   leaveq
0x00000000004004b3 :   retq
End of assembler dump.</code></pre><p>这次你会看到在调用完test1后， 直接把test2的代码， 也是nop语句加入在了test函数内。</p>
<h2 id="constructor-amp-destructor"><a href="#constructor-amp-destructor" class="headerlink" title="constructor &amp; destructor"></a>constructor &amp; destructor</h2><p>很犀利的2个属性，用于修饰某个函数，经过constructor属性修饰过的函数，<br>可以在main函数运行前就可以先运行完毕，同理destructor在进程exit之前执行。</p>
<pre><code>#include&lt;stdio.h&gt;

void test1(void) __attribute__((aligned(8)));

void  test1(void)
{
    printf(&quot;hello, world.\n&quot;);
}

void __attribute__((constructor)) test2(void)
{
    printf(&quot;hehe.\n&quot;);
}

void __attribute__((destructor)) test3(void)
{
    printf(&quot;haha.\n&quot;);
}

int main(void)
{
    test1();
}</code></pre><p>执行输出如下：</p>
<pre><code>➜  /data/test/1  &gt; ./main 
hehe.
hello, world.
haha.</code></pre><h2 id="fastcall-amp-regparm属性"><a href="#fastcall-amp-regparm属性" class="headerlink" title="fastcall &amp; regparm属性"></a>fastcall &amp; regparm属性</h2><p>在c语言中，通过函数传递参数通常使用堆栈的方式，如：<br>    test(a, b, c);<br>参数从右到左依次压入堆栈c, b, a。<br>函数执行完后，还要把这3个参数从堆栈中弹出来，如果一个函数每秒钟有上万次调用，<br>这将非常耗时，为了加快代码运行速度，gcc扩展了fastcall和regparm2个属性，<br>对于fastcall属性，一个函数的前2个参数分别通过ecx和edx来传递，剩下的则是使用堆栈来传递。<br>对于regparm，它的用法如下regparm(n), 函数的1到n个参数，分别通过eax, edx, ecx来传递，最多就使用3个寄存器，<br>其余参数通过堆栈来传递。注意这2个属性只在x86平台有效。很对编译平台fastcall默认开启。</p>
<pre><code>int __attribute__((fastcall)) test1(int a, int b)
{
    return a + b;
}

int __attribute__((regparm(2))) test2(int a, int b)
{
    return a + b;
}

int test3(int a, int b)
{
    return a + b;
}

int main(void)
{
    test1(1, 2);
    test2(1, 2);
    test3(1, 2);
}

(gdb) disass test1
Dump of assembler code for function test1:
0x08048354 :   push   %ebp
0x08048355 :   mov    %esp,%ebp
0x08048357 :   sub    $0x8,%esp 在堆栈里先分配了8个字节的空间
0x0804835a :   mov    %ecx,-0x4(%ebp) 将ecx的值放入第一个变量里
0x0804835d :   mov    %edx,-0x8(%ebp) 将edx的值放入第二个变量里
0x08048360 :  mov    -0x8(%ebp),%eax
0x08048363 :  add    -0x4(%ebp),%eax
0x08048366 :  leave
0x08048367 :  ret
End of assembler dump.

(gdb) disass test2
Dump of assembler code for function test2:
0x08048368 :   push   %ebp
0x08048369 :   mov    %esp,%ebp
0x0804836b :   sub    $0x8,%esp
0x0804836e :   mov    %eax,-0x4(%ebp)
0x08048371 :   mov    %edx,-0x8(%ebp)
0x08048374 :  mov    -0x8(%ebp),%eax
0x08048377 :  add    -0x4(%ebp),%eax
0x0804837a :  leave
0x0804837b :  ret
End of assembler dump.

(gdb) disass test3
Dump of assembler code for function test3:
0x0804837c :   push   %ebp
0x0804837d :   mov    %esp,%ebp
0x0804837f :   mov    0xc(%ebp),%eax 堆栈形式来传递参数，0×c(%ebp)保存第二个参数
0x08048382 :   add    0x8(%ebp),%eax 堆栈形式来传递参数，0×8(%ebp)保存第一个参数
0x08048385 :   pop    %ebp
0x08048386 :  ret
End of assembler dump.</code></pre><h2 id="packed属性"><a href="#packed属性" class="headerlink" title="packed属性"></a>packed属性</h2><p>用于修饰struct, union, enum数据结构，看如下的例子：</p>
<pre><code>struct test {
    char a;
    int b;
};

struct test1 {
    char a;
    int b;
}__attribute__((packed));

int main(void)
{
    printf(&quot;%d, %d\n&quot;, sizeof(struct test), sizeof(struct test1));
}</code></pre><p>struct test结构，理论来说一共有1+4=5字节的大小，但是gcc默认编译出来的大小是8，也就是说char是按照4字节来分配空间的。<br>加上packed修饰后，就会按照实际的类型大小来计算。</p>
<pre><code>➜  /data/test/1  &gt; ./main 
8, 5</code></pre><h2 id="section属性"><a href="#section属性" class="headerlink" title="section属性"></a>section属性</h2><p>gcc编译后的二进制文件为elf格式，代码中的函数部分会默认的链接到elf文件的text section中，<br>变量则会链接到bss和data section中。如果想把代码或变量放到特定的section中，就可以使用section属性来修饰。</p>
<pre><code>int __attribute__((section(&quot;TEST&quot;))) test1(int a, int b)
{
    return a + b;
}

int test2(int a, int b)
{
    return a + b;
}

int main(void)
{
    test1(1, 2);
    test2(1, 2);
}</code></pre><p>使用readelf来观察下test二进制格式。</p>
<pre><code>➜  /data/test/1  &gt; readelf -S main
[13] .text             PROGBITS         0000000000400400  00000400
00000000000001a2  0000000000000000  AX       0     0     16
[14] TEST              PROGBITS         00000000004005a2  000005a2
0000000000000014  0000000000000000  AX       0     0     1</code></pre><p>文件多出了一个TEST section，它的起始地址为0x4005a2, 大小为0x14， 它的地址范围在 0x4005a2 – 0x4005b6。<br>text section的起始地址为0x400400, 大小为0x1a2， 它的地址范围在0x400400 – 0x4005a2。</p>
<p>在来看下test1, test2符号表的地址：</p>
<pre><code>➜  /data/test/1  &gt; readelf -s main
57: 00000000004005a2    20 FUNC    GLOBAL DEFAULT   14 test1
68: 00000000004004f6    20 FUNC    GLOBAL DEFAULT   13 test2</code></pre><p>可以看到test2确实被链接在text section中， 而test1链接在TEST section中。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>更多关于gcc attribute的介绍请看<a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.2//gcc/Variable-Attributes.html#Variable-Attributes" target="_blank" rel="noopener">gcc手册</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>gcc attribute</tag>
      </tags>
  </entry>
  <entry>
    <title>代码分析工具</title>
    <url>/2015/08/19/analysis-tools/</url>
    <content><![CDATA[<ul>
<li>toc<br>{:toc}</li>
</ul>
<h2 id="Cppcheck"><a href="#Cppcheck" class="headerlink" title="Cppcheck"></a>Cppcheck</h2><p><strong>Cppcheck</strong> is a static analysis tool for C/C++ code.<br>Unlike C/C++ compilers and many other analysis tools it does not detect syntax errors in the code.<br>Cppcheck primarily detects the types of bugs that the compilers normally do not detect.<br>The goal is to detect only real errors in the code (i.e. have zero false positives).</p>
<ol>
<li><a href="http://cppcheck.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://cppcheck.sourceforge.net/#documentation" target="_blank" rel="noopener">documentation</a></li>
</ol>
<p>安装：</p>
<pre><code class="bash">sudo apt-get install cppcheck cppcheck-gui</code></pre>
<p>用法：</p>
<pre><code class="bash">cppcheck-gui

cppcheck -h

# Recursively check the current folder. Print the progress on the screen and
# write errors to a file:
cppcheck . 2&gt; err.txt

# Recursively check ../myproject/ and don&#39;t print progress:
cppcheck --quiet ../myproject/

# Check test.cpp, enable all checks:
cppcheck --enable=all --inconclusive --std=posix test.cpp

# Check f.cpp and search include files from inc1/ and inc2/:
cppcheck -I inc1/ -I inc2/ f.cpp</code></pre>
<h2 id="Understand"><a href="#Understand" class="headerlink" title="Understand"></a>Understand</h2><p>Understand® is an IDE built from the ground up to help you fully comprehend your source code. Analyze it, measure it, visualize it, maintain it - Understand it.</p>
<ol>
<li><a href="https://scitools.com/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://scitools.com/support/" target="_blank" rel="noopener">support</a> </li>
<li><a href="https://scitools.com/support/running-understand-headless-linux-server/" target="_blank" rel="noopener">Running Understand on a headless linux server</a></li>
</ol>
<p>Understand软件的功能主要<strong>定位于代码的阅读理解</strong>。</p>
<p>具备如下特性：</p>
<ol>
<li>支持多语言：Ada, C, C++, C#, Java, FORTRAN, Delphi, Jovial, and PL/M ，混合语言的project也支持</li>
<li>多平台： Windows/Linux/Solaris/HP-UX/IRIX/MAC OS X</li>
<li>代码语法高亮、代码折叠、交叉跳转、书签等基本阅读功能。</li>
<li>可以对整个project的architecture、metrics进行分析并输出报表。</li>
<li>可以对代码生成多种图（butterfly graph、call graph、called by graph、control flow graph、UML class graph等），<br>在图上点击节点可以跳转到对应的源代码位置。</li>
<li>提供Perl API便于扩展。作图全部是用Perl插件实现的，直接读取分析好的数据库作图。</li>
<li>内置的目录和文件比较器。</li>
<li>支持project的snapshot，并能和自家的TrackBack集成便于监视project的变化。</li>
</ol>
<h2 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h2><ol>
<li><a href="http://valgrind.org/" target="_blank" rel="noopener">valgrind</a></li>
<li><a href="http://alleyoop.sourceforge.net/" target="_blank" rel="noopener">Alleyoop</a></li>
<li><a href="http://valgrind.org/downloads/guis.html" target="_blank" rel="noopener">Valkyrie</a></li>
<li><a href="http://valgrind.org/docs/manual/manual.html" target="_blank" rel="noopener">Valgrind User Manual</a></li>
<li><a href="http://valgrind.org/info/tools.html" target="_blank" rel="noopener">Valgrind’s Tool Suite</a></li>
<li><a href="http://cstriker1407.info/blog/c-language-code-detection-use-valgrind/" target="_blank" rel="noopener">C语言代码检测：valgrind的使用</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/" target="_blank" rel="noopener">应用 Valgrind 发现 Linux 程序的内存问题</a></li>
<li><a href="http://www.oschina.net/translate/valgrind-memcheck" target="_blank" rel="noopener">如何使用Valgrind memcheck工具进行C/C++的内存泄漏检测</a></li>
</ol>
<p>Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。<br>Valgrind由内核（core）以及基于内核的其他调试工具组成。<br>内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；<br>而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。</p>
<p>它支持 C/C++，支持各类 Unix 系统。 </p>
<p>安装：</p>
<pre><code class="bash">sudo apt-get install valgrind</code></pre>
<p>工具集：</p>
<ul>
<li>Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，<br>能够发现开发中绝大多数内存错误使用情况，<br>比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li>
<li>Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</li>
<li>Cachegrind。它主要用来检查程序中缓存使用出现的问题。它与Cachegrind的功能有重叠，但也收集Cachegrind不收集的一些信息。</li>
<li>Helgrind。它主要用来检查多线程程序中出现的竞争问题。</li>
<li>Massif。它主要用来检查程序中堆栈使用中出现的问题。它有助于使你的程序使用更少的内存。</li>
<li>DRD也是一个线程错误检测器。它和Helgrind相似，但使用不同的分析技术，所以可能找到不同的问题。</li>
</ul>
<p>编译选项使用<code>-g -O0</code>, <strong>交叉编译</strong>之后在目标机上执行内存检测：</p>
<pre><code class="bash">valgrind --tool=memcheck --leak-check=full ./a.out
==2888== Memcheck, a memory error detector
==2888== Copyright (C) 2002-2009, and GNU GPL&#39;d, by Julian Seward et al.
==2888== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==2888== Command: ./val
==2888==

[a]
==2888==
==2888== HEAP SUMMARY:
==2888==     in use at exit: 1 bytes in 1 blocks
==2888==   total heap usage: 1 allocs, 0 frees, 1 bytes allocated
==2888==
==2888== 1 bytes in 1 blocks are definitely lost in loss record 1 of 1
==2888==    at 0x4C274A8: malloc (vg_replace_malloc.c:236)
==2888==    by 0x400575: main (valgrind.c:6)
==2888==
==2888== LEAK SUMMARY:
==2888==    definitely lost: 1 bytes in 1 blocks
==2888==    indirectly lost: 0 bytes in 0 blocks
==2888==      possibly lost: 0 bytes in 0 blocks
==2888==    still reachable: 0 bytes in 0 blocks
==2888==         suppressed: 0 bytes in 0 blocks
==2888==
==2888== For counts of detected and suppressed errors, rerun with: -v
==2888== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)</code></pre>
<p>memcheck可以检测下列与内存相关的问题 :</p>
<ul>
<li>未释放内存的使用</li>
<li>对释放后内存的读/写</li>
<li>对已分配内存块尾部的读/写</li>
<li>内存泄露</li>
<li>不匹配的使用malloc/new/new[] 和 free/delete/delete[]</li>
<li>重复释放内存</li>
</ul>
<h2 id="KCachegrind"><a href="#KCachegrind" class="headerlink" title="KCachegrind"></a><strong>KCachegrind</strong></h2><ol>
<li><a href="https://kcachegrind.github.io/html/Home.html" target="_blank" rel="noopener">Callgrind and KCachegrind</a></li>
<li><a href="https://kcachegrind.github.io/html/Screenshots.html" target="_blank" rel="noopener">Screenshots</a></li>
<li><a href="https://kcachegrind.github.io/html/Documentation.html" target="_blank" rel="noopener">Documentation</a></li>
</ol>
<p>安装：</p>
<pre><code class="bash">sudo apt-get install kcachegrind</code></pre>
<p><code>valgrind</code>安装之后有工具<code>callgrind</code>，使用此工具生成<code>性能日志</code>，使用<code>kcachegrind</code>进行分析：</p>
<pre><code class="bash">/data/test  &gt; gcc -g -O0 main.c -o perf
/data/test  &gt; valgrind --tool=callgrind ./perf 
==27075== Callgrind, a call-graph generating cache profiler
==27075== Copyright (C) 2002-2015, and GNU GPL&#39;d, by Josef Weidendorfer et al.
==27075== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==27075== Command: ./perf
==27075== 
==27075== For interactive control, run &#39;callgrind_control -h&#39;.
hello world!
hello world!
hello world!
test 
hello world!
test 
hello world!
test 
==27075== 
==27075== Events    : Ir
==27075== Collected : 155985
==27075== 
==27075== I   refs:      155,985
/data/test  &gt; ls
1  a.out  callgrind.out.27075  main.c  output  perf  photorec.ses  recup_dir.1  rgb  testdisk.log
/data/test  &gt; kcachegrind callgrind.out.27075 </code></pre>
<img src="https://kcachegrind.github.io/images/KcgShot3Large.gif" height="600" width="800" />

<p>在<code>Call Graph</code>中，你能看到每一个函数的开销百分比包括Inclusive,即涵带子函数的总开销和Self，函数自己的开销，<br>另外每一个函数的调用次数也列写在上面。<br>也可以分析出函数的调用关系和流程，这是一个非常好的辅助工具，帮助你快速理解系统的工作流Work Flow。</p>
<h2 id="gprof"><a href="#gprof" class="headerlink" title="gprof"></a>gprof</h2><ol>
<li><a href="https://sourceware.org/binutils/docs/gprof/" target="_blank" rel="noopener">gprof</a></li>
<li><a href="http://www.thegeekstuff.com/2012/08/gprof-tutorial/" target="_blank" rel="noopener">GPROF Tutorial – How to use Linux GNU GCC Profiling Tool</a></li>
<li><a href="https://sourceware.org/binutils/docs-2.17/gprof/index.html" target="_blank" rel="noopener">GNU gprof</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-gnuprof.html" target="_blank" rel="noopener">使用 GNU profiler 来提高代码运行速度</a></li>
<li><a href="http://www.cnblogs.com/onlyforcloud/p/4395917.html" target="_blank" rel="noopener">GNU–gprof使用总结</a></li>
</ol>
<p>Gprof 是GNU gnu binutils工具之一，默认情况下linux系统当中都带有这个工具：</p>
<ol>
<li>可以显示“flat profile”，包括每个函数的调用次数，每个函数消耗的处理器时间，</li>
<li>可以显示“Call graph”，包括函数的调用关系，每个函数调用花费了多少时间。</li>
<li>可以显示“注释的源代码”－－是程序源代码的一个复本，标记有程序中每行代码的执行次数。</li>
</ol>
<p>Gprof基本用法：</p>
<ol>
<li>使用 <code>-pg</code> 编译和链接你的应用程序。</li>
<li>执行你的应用程序使之生成供gprof 分析的数据。</li>
<li>使用gprof 程序分析你的应用程序生成的数据。</li>
</ol>
<pre><code class="bash">gcc gprof.c -pg -o example1 -O0 -g
./example1
✔ /data/test  &gt; ls gmon.out
gmon.out

# flat profile
gprof example1 gmon.out -p
Flat profile:

Each sample counts as 0.01 seconds.
%   cumulative   self              self     total           
time   seconds   seconds    calls  ms/call  ms/call  name    
50.43      0.01     0.01        3     3.36     3.36  count_sum
50.43      0.02     0.01        1    10.09    13.45  my_print2
0.00      0.02     0.00        2     0.00     3.36  my_print

# call graph
gprof example1 gmon.out -q

# gprof - display call graph profile data
man gprof</code></pre>
<p><strong>带注解的源代码</strong></p>
<p>如果希望获得一个 “带注解的源代码” 清单，它会将源代码输出到应用程序中，并加上每个函数被调用了多少次的注释。<br>要使用这种功能，请使用启用调试功能的标志来编译源代码，这样源代码就会被加入可执行程序中：</p>
<pre><code class="bash">gcc example1.c -g -pg -o example1 -O2 -lc</code></pre>
<p>像以前一样重新运行这个应用程序：</p>
<pre><code class="bash">./example1 50000</code></pre>
<p>gprof 命令现在应该是：</p>
<pre><code class="bash">gprof example1 gmon.out -A</code></pre>
<p><strong>常用参数</strong></p>
<ul>
<li>-b 不再输出统计图表中每个字段的详细描述。</li>
<li>-p 只输出函数的调用图（Call graph的那部分信息）。</li>
<li>-q 只输出函数的时间消耗列表。</li>
<li>-e Name 不再输出函数Name 及其子函数的调用图（除非它们有未被限制的其它父函数）。可以给定多个 -e 标志。一个 -e 标志只能指定一个函数。</li>
<li>-E Name 不再输出函数Name 及其子函数的调用图，此标志类似于 -e 标志，但它在总时间和百分比时间的计算中排除了由函数Name 及其子函数所用的时间。</li>
<li>-f Name 输出函数Name 及其子函数的调用图。可以指定多个 -f 标志。一个 -f 标志只能指定一个函数。</li>
<li>-F Name 输出函数Name 及其子函数的调用图，它类似于 -f 标志，但它在总时间和百分比时间计算中仅使用所打印的例程的时间。可以指定多个 -F 标志。一个 -F 标志只能指定一个函数。-F 标志覆盖 -E 标志。</li>
<li>-z 显示使用次数为零的例程（按照调用计数和累积时间计算）。</li>
</ul>
<p><strong>用户时间与内核时间</strong></p>
<p>gprof 的最大缺陷：它只能分析应用程序在运行过程中所消耗掉的用户时间，无法得到程序内核空间的运行时间。通常来说，应用程序在运行时既要花费一些时间来运行用户代码，也要花费一些时间来运行 “系统代码”，例如内核系统调用sleep()。</p>
<p>有一个方法可以查看应用程序的运行时间组成，在 time 命令下面执行程序。这个命令会显示一个应用程序的实际运行时间、用户空间运行时间、内核空间运行时间。</p>
<pre><code class="bash">✔ /data/test  &gt; time ./example1 
./example1  0.02s user 0.00s system 93% cpu 0.026 total</code></pre>
<p><strong>注意事项</strong></p>
<ol>
<li>g++在编译和链接两个过程，都要使用-pg选项。</li>
<li>只能使用静态连接libc库，否则在初始化<code>*.so</code>之前就调用profile代码会引起“segmentation fault”，<br>解决办法是编译时加上-static-libgcc或-static。</li>
<li>如果不用g++而使用ld直接链接程序，要加上链接文件/lib/gcrt0.o，如ld -o myprog /lib/gcrt0.o myprog.o utils.o -lc_p。<br>也可能是gcrt1.o</li>
<li>要监控到第三方库函数的执行时间，第三方库也必须是添加 –pg 选项编译的。</li>
<li>gprof只能分析应用程序所消耗掉的用户时间.</li>
<li>程序不能以demon方式运行。否则采集不到时间。（可采集到调用次数）</li>
<li>首先使用 time 来运行程序从而判断 gprof 是否能产生有用信息是个好方法。</li>
<li>如果 gprof 不适合您的剖析需要，那么还有其他一些工具可以克服 gprof 部分缺陷，包括 OProfile 和 Sysprof。</li>
<li>gprof对于代码大部分是用户空间的CPU密集型的程序用处明显。<br>对于大部分时间运行在内核空间或者由于外部因素（例如操作系统的 I/O 子系统过载）而运行得非常慢的程序难以进行优化。</li>
<li>gprof 不支持多线程应用，多线程下只能采集主线程性能数据。原因是gprof采用ITIMER_PROF信号，在多线程内只有主线程才能响应该信号。<br>但是有一个<a href="http://sam.zoy.org/writings/programming/gprof.html" target="_blank" rel="noopener">简单的方法</a>可以解决这一问题</li>
<li>gprof只能在程序正常结束退出之后才能生成报告（gmon.out）。<ul>
<li>gprof通过在atexit()里注册了一个函数来产生结果信息，任何非正常退出都不会执行atexit()的动作，所以不会产生gmon.out文件。</li>
<li>程序可从main函数中正常退出，或者通过系统调用exit()函数退出。</li>
</ul>
</li>
</ol>
<h2 id="KProf"><a href="#KProf" class="headerlink" title="KProf"></a>KProf</h2><blockquote>
<p>KProf - Profiling made easy</p>
</blockquote>
<ol>
<li><a href="http://kprof.sourceforge.net/" target="_blank" rel="noopener">KProf</a></li>
<li><a href="https://sourceforge.net/projects/kprof/files/" target="_blank" rel="noopener">download</a></li>
</ol>
<p>将gprof ， GUI化了，更加友好，它也利用graphviz绘制运行时流程图，但是对于大的程序，似乎效果不太好，流程图感觉完全乱掉了</p>
<img src="http://kprof.sourceforge.net/kprof_flat.png"/>

<img src="http://kprof.sourceforge.net/kprof_object.png"/>


<h2 id="gprof2dot"><a href="#gprof2dot" class="headerlink" title="gprof2dot"></a><strong>gprof2dot</strong></h2><ol>
<li><a href="https://github.com/jrfonseca/gprof2dot" target="_blank" rel="noopener">gprof2dot</a></li>
<li><a href="https://github.com/jrfonseca/xdot.py" target="_blank" rel="noopener">xdot.py</a></li>
</ol>
<pre><code class="bash">sudo apt-get install python graphviz
git clone https://github.com/jrfonseca/gprof2dot.git
python setup.py build
sudo python steup.py install</code></pre>
<p>用法：</p>
<pre><code class="bash">gcc -pg linpack.c -o linpack_gprof
gprof ./linpack_gprof | python2.7 gprof2dot.py -n0 -e0 |dot - Tpng -o output.png</code></pre>
<img src="http://img.blog.csdn.net/20160412124253219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"/>

<p>还可通过以下命令得到函数调用图:</p>
<pre><code class="bash">gprof linpack_gprof &gt; prof.log  
./gprof2dot.py prof.log | dot -Tpng -o output.png  </code></pre>
<img src="http://img.blog.csdn.net/20160424203320165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"/>

<p><strong>通过对比以上两种方法，可以发现第二种方法无法得到调用时间过短的函数调用关系</strong></p>
<p>gprof2dot默认是部分函数调用图，对性能影响不大的函数调用都不显示，例如上图中没有出现类的构造，析构函数，<br>如果想要显示全部的函数调用，可以 gprof2dot -n0 -e0 ，默认是n0.5即影响小于5%的函数就不显示了。<br>当然这样图片会很乱，因为显示内容很多，可以 gprof2dot -n0 -e0 -s #-s表示不显示诸如模板，函数入口参数等等，使得<br>函数名称显示更加精简。</p>
<p><code>dot</code>用于生成图片，使用<code>xdot.py</code>不需要生成图片，直接交互</p>
<pre><code class="bash">gprof ./linpack_gprof | python2.7 gprof2dot.py -n0 -e0 | ./xdot.py</code></pre>
<p><em>python环境变量设置有问题，xdot单独可以工作，使用管道不能正常工作</em></p>
<pre><code class="bash">function showCall()
{
    gprof $1 | python3 /data/Installer/gprof2dot/gprof2dot.py &gt; /tmp/__call_tmp
    xdot /tmp/__call_tmp
    rm /tmp/__call_tmp
}</code></pre>
<h2 id="gperftools"><a href="#gperftools" class="headerlink" title="gperftools"></a><strong>gperftools</strong></h2><ol>
<li><a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">gperftools</a></li>
<li><a href="http://airekans.github.io/cpp/2014/07/04/gperftools-profile" target="_blank" rel="noopener">用gperftools对C/C++程序进行profile</a></li>
<li><a href="http://www.cnblogs.com/persistentsnail/p/3294843.html" target="_blank" rel="noopener">Google performance Tools (gperftools) 使用心得</a></li>
<li><a href="http://qiaoyong.lofter.com/post/2b36f_1140c82" target="_blank" rel="noopener">gperftools使用详解</a></li>
</ol>
<p>在Linux的C/C++编程的世界里，性能调优一直是个让人头疼的事。<br>最出名的<code>gprof</code>虽然大家都知道， 其用法比较单一(只支持程序从启动到结束的profile)，<br>而且对程序的运行时间会有比较大的影响， 所以其profile不一定准确。</p>
<p>而<code>valgrind</code>功能十分强大，但profile也一般针对整个程序的运行，很难只对程序运行中的某段时间进行profile。<br>而且也多少会影响程序的运行，且使用的难度也较大。</p>
<p><strong>如何profile</strong></p>
<p>在gperftools的文档中，就简单的说了下面的方式来进行profile：</p>
<pre><code class="bash">gcc [...] -o myprogram -lprofiler
CPUPROFILE=/tmp/profile ./myprogram</code></pre>
<p>是的，在编译和安装了gperftools之后，只需要上面的步骤就可以进行profile了，非常简单。<br>而profile的结果就保存在/tmp/profile。查看结果只需要用gperftools自带的一个pprof脚本来看就可以：</p>
<pre><code class="bash">$ pprof --text ./myprogram /tmp/profile
14   2.1%  17.2%       58   8.7% std::_Rb_tree::find</code></pre>
<p>pprof的输出也很直观，不过也还不够好，从这个输出中还不好看出调用关系，包括caller和callee。<br>而pprof也可以输出图示，还可以输出<code>callgrind</code>兼容的格式，这样就可以用<code>kcachegrind</code>来看profile结果了。</p>
<pre><code class="bash">$ pprof --callgrind ./myprogram /tmp/profile &gt; callgrind.res</code></pre>
<p>然后利用kcachegrind打开这个callgrind.res文件</p>
<p><strong>动态profile</strong></p>
<p>上面说到的方式是通过环境变量来触发profile，而跨度也是整个程序的生命周期。<br>那如果是想要在程序运行的某段时间进行profile呢？如果我想在程序不结束的情况下就拿到profile的结果呢？</p>
<p>这种情况下就需要用到动态profile的方式了。要实现这种方式，就需要改动程序的代码了，不过也比较简单：</p>
<pre><code class="bash">#include &lt;gperftools/profiler.h&gt;

int main()
{
    ProfilerStart(&quot;/tmp/profile&quot;);
    some_func_to_profile();
    ProfilerStop();

    return 0;
}</code></pre>
<p>没错，你只需要在你想要profile的函数的开头和结尾加上<code>ProfilerStart</code>和<code>ProfilerStop</code>调用就可以了。<br>在ProfilerStop结束之后，profile的结果就会保存在/tmp/profile里面了。<br>利用这种方式就可以在指定的时间点对程序进行profile了。</p>
<p>最后需要说的一点是，gperftools的profile过程采用的是采样的方式，而且对profile中的程序性能影响极小，<br>这对于在线或者离线profile都是一个极其重要的特点。</p>
<h2 id="include-what-you-use"><a href="#include-what-you-use" class="headerlink" title="include-what-you-use"></a>include-what-you-use</h2><ol>
<li><a href="https://github.com/include-what-you-use/include-what-you-use" target="_blank" rel="noopener">include-what-you-use</a></li>
<li><a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&action=printable&tid=4145378" target="_blank" rel="noopener">找出C文件中不必要的头文件</a></li>
<li><a href="http://xinsuiyuer.github.io/blog/2013/10/30/include-what-you-use/" target="_blank" rel="noopener">使用I.W.Y.U整理头文件引用</a></li>
</ol>
<p>首先安装CLang开发包，然后编译IWYU：</p>
<pre><code class="bash">sudo apt-get install llvm llvm-devel llvm-clang llvm-clang-devel
git clone https://github.com/include-what-you-use/include-what-you-use.git
mkdir build &amp;&amp; cd build
cmake -G &quot;Unix Makefiles&quot; -DIWYU_LLVM_ROOT_PATH=/usr/lib/llvm-3.8 ../../include-what-you-use
make</code></pre>
<p>使用：</p>
<pre><code class="shell">make -k CC=/data/OpenSourceCode/include-what-you-use/build/include-what-you-use -I/usr/lib/llvm-3.8/lib/clang/3.8.0/include

-e compiling [/data/OpenSourceCode/include-what-you-use/build/include-what-you-use]: ./ca/thinew/app_tnt_baseinfo.c
In file included from ca/thinew/app_tnt_baseinfo.c:19:
In file included from ./include/app_module.h:22:
In file included from ./include/module/app_play_control.h:22:
In file included from /home/workspace/Solution-for-debug/dishcas/solution/../library/goxceed/csky-ecos/include/gxcore.h:4:
In file included from /home/workspace/Solution-for-debug/dishcas/solution/../library/goxceed/csky-ecos/include/common/gxcore_common.h:4:
In file included from /home/workspace/Solution-for-debug/dishcas/solution/../library/goxceed/csky-ecos/include/stdlib.h:70:
/home/workspace/Solution-for-debug/dishcas/solution/../library/goxceed/csky-ecos/include/stddef.h:63:15: fatal error: 
    &#39;stddef.h&#39; file not found
#include_next &lt;stddef.h&gt;
^

ca/thinew/app_tnt_baseinfo.c should add these lines:

ca/thinew/app_tnt_baseinfo.c should remove these lines:
- #include &quot;app_module.h&quot;  // lines 19-19

The full include-list for ca/thinew/app_tnt_baseinfo.c:
#include &quot;app_config.h&quot;  // for TNTCAS_SUPPORT
---
deps:17: recipe for target &#39;/home/workspace/Solution-for-debug/dishcas/solution/output/objects/app_tnt_baseinfo.o&#39; failed
make[1]: *** [/home/workspace/Solution-for-debug/dishcas/solution/output/objects/app_tnt_baseinfo.o] Error 3</code></pre>
<blockquote>
<p><strong>fatal error: ‘stddef.h’ file not found</strong>待排除，可能与CLang环境设置有关，或与<code>include_next</code>有关<br><a href="https://github.com/include-what-you-use/include-what-you-use" target="_blank" rel="noopener">How to Install</a></p>
</blockquote>
<p>可以将 IWYU 保存到文件中，之后使用其附带的 fix_includes.py 自动对代码进行修复。 <strong>但应该慎重….</strong></p>
<pre><code class="bash">$ make -B -k CXX=include-what-you-use &gt; iwyu.out
$ fix_includes.py &lt; iwyu.out</code></pre>
<h2 id="OCLint"><a href="#OCLint" class="headerlink" title="OCLint"></a>OCLint</h2><ol>
<li><a href="http://oclint.org/" target="_blank" rel="noopener">OCLint</a></li>
<li><a href="https://github.com/oclint/oclint" target="_blank" rel="noopener">The OCLint Static Code Analysis Tool</a></li>
<li><a href="https://segmentfault.com/a/1190000005150573" target="_blank" rel="noopener">OCLint 安装与使用</a></li>
<li><a href="http://ceyang.me/dai-ma-du-liang-bang-zhu-xie-chu-gao-zhi-liang-dai-ma-de-gong-ju/" target="_blank" rel="noopener">代码度量：帮助写出高质量代码的工具</a></li>
<li><a href="http://lrdcq.com/me/read.php/48.htm" target="_blank" rel="noopener">oc代码静态检查方案</a></li>
<li><a href="http://docs.oclint.org/en/stable/intro/build.html" target="_blank" rel="noopener">Building OCLint</a></li>
<li><a href="http://docs.oclint.org/en/stable/intro/installation.html" target="_blank" rel="noopener">Installation</a></li>
<li><a href="https://github.com/oclint/oclint/releases" target="_blank" rel="noopener">downloading pre-compiled binaries</a></li>
</ol>
<p>下载<code>预编译</code>版本，然后将<code>PATH</code>添加到<code>.zshrc</code>中，测试如下：</p>
<pre><code class="bash">oclint
oclint: Not enough positional command line arguments specified!
Must specify at least 1 positional arguments: See: oclint -help</code></pre>
<p>如果使用<code>make</code>来构建系统，使用方式如下：</p>
<pre><code class="bash">sudo apt-get install bear

#compile_commands.json
bear make 

#oclint-json-compilation-database for code analysis
oclint-json-compilation-database

oclint -p &lt;build path&gt; &lt;source0&gt; [... &lt;sourceN&gt;]</code></pre>
<p><strong>OCLint配置规则</strong></p>
<h2 id="Clang-Static-Analyzer"><a href="#Clang-Static-Analyzer" class="headerlink" title="Clang Static Analyzer"></a><strong>Clang Static Analyzer</strong></h2><ol>
<li><a href="http://clang-analyzer.llvm.org/index.html" target="_blank" rel="noopener">Clang Static Analyzer</a></li>
<li><a href="http://clang-analyzer.llvm.org/installation#OtherPlatforms" target="_blank" rel="noopener">Building the Analyzer from Source</a></li>
<li><a href="http://blog.csdn.net/sealjin/article/details/45221209" target="_blank" rel="noopener">How to use Clang Static Analyzer</a></li>
<li><a href="http://xinsuiyuer.github.io/blog/2014/01/12/clang-static-analyzer/" target="_blank" rel="noopener">静态代码分析工具</a></li>
</ol>
<p>在编译安装 <code>llvm/clang</code> 或者 <code>sudo apt-get install clang</code> 之后，<code>scan-build</code> 和 <code>scan-view</code> 分别在</p>
<pre><code class="bash">$(SRC)/llvm/tools/clang/tools/scan-build
$(SRC)/llvm/tools/clang/tools/scan-view</code></pre>
<p>使用：</p>
<pre><code class="bash">scan-build make
.
scan-build: 3 bugs found.
scan-build: Run &#39;scan-view /tmp/scan-build-2016-06-23-124956-25166-1&#39; to examine bug reports.
scan-view /tmp/scan-build-2016-06-23-124956-25166-1</code></pre>
<p><strong>checker – 检查规则</strong></p>
<p>内置的 checker 存放在 <code>$(SRC)/llvm/tools/clang/lib/StaticAnalyzer/Checkers</code> 目录下。<br>这些 <code>checker</code> 默认情况下并没有全部开启，所以需要根据情况启用合适的 checker。<br>可以使用 <code>-enable-checker</code> 和 <code>-disable-checker</code> 开启和禁用具体的 checker 或者 某种类别的 checker。</p>
<pre><code class="bash">$ scan-build -enable-checker alpha.security.ArrayBoundV2 make # 启用数组边界检查</code></pre>
<p>所有支持的 checkers 可以使用如下命令查看：</p>
<pre><code class="bash">$ clang -cc1 -analyzer-checker-help
alpha.core.BoolAssignment       Warn about assigning non-{0,1} values to Boolean variables
alpha.core.CastSize             Check when casting a malloced type T, whether the size is a multiple of the size of T
alpha.core.CastToStruct         Check for cast from non-struct pointer to struct pointer
alpha.core.FixedAddr            Check for assignment of a fixed address to a pointer
alpha.core.IdenticalExpr        Warn about unintended use of identical expressions in operators
alpha.core.PointerArithm        Check for pointer arithmetic on locations other than array elements
alpha.core.PointerSub           Check for pointer subtractions on two pointers pointing to different memory chunks
alpha.core.SizeofPtr            Warn about unintended use of sizeof() on pointer expressions
alpha.cplusplus.NewDeleteLeaks  Check for memory leaks. Traces memory managed by new/delete.
alpha.cplusplus.VirtualCall     Check virtual function calls during construction or destruction
...
alpha.security.ArrayBound       Warn about buffer overflows (older checker)
alpha.security.ArrayBoundV2     Warn about buffer overflows (newer checker)
alpha.security.MallocOverflow   Check for overflows in the arguments to malloc()
alpha.security.ReturnPtrRange   Check for an out-of-bound pointer being returned to callers
...
core.CallAndMessage             Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers)
core.DivideZero                 Check for division by zero
core.DynamicTypePropagation     Generate dynamic type information
core.NonNullParamChecker        Check for null pointers passed as arguments to a function whose arguments are references or marked with the &#39;nonnull&#39; attribute
core.NullDereference            Check for dereferences of null pointers
core.StackAddressEscape         Check that addresses to stack memory do not escape the function
...
unix.API                        Check calls to various UNIX/Posix functions
unix.Malloc                     Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free().
unix.MallocSizeof               Check for dubious malloc arguments involving sizeof
unix.MismatchedDeallocator      Check for mismatched deallocators.
unix.cstring.BadSizeArg         Check the size argument passed into C string functions for common erroneous patterns
unix.cstring.NullArg            Check for null pointers being passed as arguments to C string functions</code></pre>
<p>在使用 <code>-enable-checker</code> 或者 <code>-disable-checker</code> 时，不需要完整的指定某个 checker 的名称， 也可以是某一类的，如：</p>
<pre><code class="bash">$ scan-build -enable-checker alpha ...
$ scan-build -enable-checker alpha.security ...</code></pre>
<p>例如：</p>
<pre><code class="bash">$ scan-build -enable-checker alpha.security make
-e compiling [/usr/share/clang/scan-build-3.8/bin/../libexec/ccc-analyzer]: ./channel_edit.c
channel_edit.c:202:15: warning: Value stored to &#39;data&#39; during its initialization is never read
    list_data data = {0};
            ^~~~   ~~~
1 warning generated.
scan-build: 150 bugs found.
scan-build: Run &#39;scan-view /tmp/scan-build-2016-06-23-125458-27549-1&#39; to examine bug reports.

# scan-view-3.8 ImportError: No module named ScanView
$ scan-view-3.4 /tmp/scan-build-2016-06-23-125458-27549-1</code></pre>
<p><strong>相比 cppcheck，它提供了更多的检查规则。</strong></p>
<h2 id="Purify"><a href="#Purify" class="headerlink" title="Purify"></a>Purify</h2><ol>
<li><a href="http://brantc.blog.51cto.com/410705/116674/" target="_blank" rel="noopener">Purify使用体验</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/rational/r-cail/" target="_blank" rel="noopener">Rational Purify 使用及分析实例</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/rational/07/0306_chitale/" target="_blank" rel="noopener">使用 IBM Rational PurifyPlus</a></li>
</ol>
<h2 id="Infer"><a href="#Infer" class="headerlink" title="Infer"></a>Infer</h2><p>Facebook 的 Infer 是一个静态分析工具。Infer 可以分析 Objective-C， Java 或者 C 代码，报告潜在的问题。</p>
<ol>
<li><a href="http://infer.liaohuqiu.net/" target="_blank" rel="noopener">Infer</a></li>
<li><a href="http://infer.liaohuqiu.net/docs/getting-started.html" target="_blank" rel="noopener">documentation</a></li>
</ol>
<h2 id="coverity"><a href="#coverity" class="headerlink" title="coverity"></a>coverity</h2><ol>
<li><a href="http://www.coverity.com/html_cn/products/index.html" target="_blank" rel="noopener">coverity</a></li>
<li><a href="http://blog.csdn.net/yasi_xi/article/details/8349985" target="_blank" rel="noopener">Coverity 代码静态安全检测</a></li>
</ol>
<h2 id="PVS-Studio"><a href="#PVS-Studio" class="headerlink" title="PVS-Studio"></a>PVS-Studio</h2><p><a href="http://www.hkaco.com/software/viva64/home.html" target="_blank" rel="noopener">C/C++/C++11 静态代码分析工具</a></p>
<h2 id="PC-lint"><a href="#PC-lint" class="headerlink" title="PC-lint"></a>PC-lint</h2><p><a href="http://www.gimpel.com/html/pcl.htm" target="_blank" rel="noopener">PC-lint</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><!--
1. [C++ static code analysis tool on Windows](http://stackoverflow.com/questions/97454/c-static-code-analysis-tool-on-windows)
2. [静态代码分析工具汇总](http://blog.csdn.net/dongwuming/article/details/49423909)
3. [C/C++ 编程有哪些值得推荐的工具](https://www.zhihu.com/question/23357089)
4. [linux环境下 C++性能测试工具 gprof + kprof + gprof2dot](http://www.cnblogs.com/rocketfan/archive/2009/11/15/1603465.html)
5. [源码分析：动态分析 C 程序函数调用关系](http://blog.csdn.net/tinylab/article/details/45051097)
6. [Tutorial: Using GNU Profiling (gprof) with ARM Cortex-M](https://mcuoneclipse.com/2015/08/23/tutorial-using-gnu-profiling-gprof-with-arm-cortex-m/)
7. [如何使用gprof对软件做profiling](https://forums.xilinx.com/t5/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7%E4%B8%8EIP/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gprof%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%81%9Aprofiling/td-p/397451)
-->
<ol start="5">
<li><a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2C_C.2B.2B" target="_blank" rel="noopener">List of tools for static code analysis</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>tools</tag>
        <tag>static analysis tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下malloc函数和OOM Killer</title>
    <url>/2015/07/06/Linux-OOM-Killer/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h3 id="Malloc函数和OOM-Killer"><a href="#Malloc函数和OOM-Killer" class="headerlink" title="Malloc函数和OOM Killer"></a><strong>Malloc函数和OOM Killer</strong></h3><p>Linux下malloc函数主要用来在用户空间从heap申请内存，申请成功返回指向所分配内存的指针，申请失败返回NULL。<br><strong>默认情况下，Linux内核使用“乐观的”分配内存策略</strong>，首先粗略估计系统可使用的内存数，然后分配内存，<br>但是在使用的时候才真正把这块分配的内存给你。<br>这样一来，即使用malloc申请内存没有返回NULL，你也不一定能完全使用这块内存，<br>特别是在一次或连续多次申请很多内存的时候。</p>
<p>如果一直连续用malloc申请内存，而不真正使用，所申请的内存总数可以超过真正可以使用的内存数。<br>但是当真正使用这块内存，比如用memset或bzero函数一次性把所申请到的大块内存“使用掉”，<br>Linux系统就会Out Of Memory，这个时候OOM Killer就会kill掉用户空间的其他进程来腾出更多可使用内存。</p>
<p>OOM Killer根据OOM score来决定kill哪个进程，OOM score可以看/proc/<PID>/oom_score，<br>score由badness函数计算得出，根据进程运行时间长短，进程优先级，进程所使用的内存数等等。<br>可以通过/proc/<PID>/oom_adj来干预计算socre，这个值的取值范围是-17～15，<br>如果是-17该进程就永远不会被kill（这个可能也和内核版本有关，不见得所有内核版本都支持，得实际试试）。</p>
<p>“默认情况”Linux是这种做的，“默认情况”是指/proc/sys/vm/overcommit_memory为0的时候。<br>这个参数也可以调整，如果为1表示“来着不拒”，只要你malloc过来申请，我啥都不做，立马给你分配内存，<br>这样的话性能就会有大幅度的提高；<br>如果为2表示Linux会精确计算所有可使用的内存和所申请的内存，如果所申请的超过的可使用的内存数就返回NULL。<br>可使用的内存值计算方法，虚拟内存（swap）+ /proc/sys/vm/overcommit_memory（百分比） × 物理内存。<br>/proc/sys/vm/overcommit_memory默认值为50,计算起来就是50%的物理内存数。</p>
<p>Linux自身内核会占一部分内存，还有buffer/cache所占用的内存，<br>所以实际上能被malloc申请后使用的内存并非物理内存大小，<br>demsg的输出里面包含了相关信息（如果看不到，可能是被别的信息冲掉了，重启系统，在系统起来后马上看）：</p>
<pre><code>Memory: 2071220k/2097152k available (2122k kernel code, 24584k reserved, 884k data, 228k init, 1179584k highmem)</code></pre><h3 id="关于OOM-Killer的proc文件系统"><a href="#关于OOM-Killer的proc文件系统" class="headerlink" title="关于OOM Killer的proc文件系统"></a><strong>关于OOM Killer的proc文件系统</strong></h3><p>下面开始介绍与OOM Killer相关的proc文件系统。</p>
<h4 id="proc-PID-oom-adj"><a href="#proc-PID-oom-adj" class="headerlink" title="/proc/PID/oom_adj"></a><strong>/proc/PID/oom_adj</strong></h4><p>为/proc/PID/oom_adj设置值就可以调整得分。<br>调整值的范围为–16~15。正的值容易被OOM Killer选定。负值可能性较低。<br>例如，当指定3时，得分就变为23倍；当指定–5时，得分就变为1/25。</p>
<p>“–17”是一个特殊的值。如果设置为–17，就会禁止OOM Killer发出的信号（从Linux 2.6.12开始支持设置–17）。</p>
<p>在OOM Killer运行的情况下，为了实现远程登录而想要将sshd排除在对象外时，可以执行下列命令。</p>
<pre><code># cat /proc/&#39;cat /var/run/sshd.pid&#39;/oom_score
15
# echo -17 &gt;  /proc/&#39;cat /var/run/sshd.pid&#39;/oom_adj
# tail /proc/&#39;cat /var/run/sshd.pid&#39;/oom_*
==&gt; /proc/2278/oom_adj &lt;==
-17
==&gt; /proc/2278/oom_score &lt;==
0                               /*得分变成0*/</code></pre><p>从Linux 2.6.18开始可以使用/proc/PID/oom_adj。内容记载在Documentation /filesystems/proc.txt中。</p>
<h4 id="proc-sys-vm-panic-on-oom"><a href="#proc-sys-vm-panic-on-oom" class="headerlink" title="/proc/sys/vm/panic_on_oom"></a><strong>/proc/sys/vm/panic_on_oom</strong></h4><p>将/proc/sys/vm/panic_on_oom设置为1时，在OOM Killer运行时可以不发送进程信号，而是使内核产生重大故障。</p>
<pre><code># echo 1 &gt; /proc/sys/vm/panic_on_oom</code></pre><h4 id="proc-sys-vm-oom-kill-allocating-task"><a href="#proc-sys-vm-oom-kill-allocating-task" class="headerlink" title="/proc/sys/vm/oom_kill_allocating_task"></a><strong>/proc/sys/vm/oom_kill_allocating_task</strong></h4><p>从Linux 2.6.24开始proc文件系统就有oom_kill_allocating_task。<br>如果对此设置除0以外的值，则促使OOM Killer运行的进程自身将接收信号。此处省略对所有进程的得分计算过程。</p>
<pre><code># echo 1 &gt; /proc/sys/vm/oom_kill_allocating_task</code></pre><p>这样就不需要参照所有进程，但是也不会考虑进程的优先级和root权限等，只发送信号。</p>
<h4 id="proc-sys-vm-oom-dump-tasks"><a href="#proc-sys-vm-oom-dump-tasks" class="headerlink" title="/proc/sys/vm/oom_dump_tasks"></a><strong>/proc/sys/vm/oom_dump_tasks</strong></h4><p>从Linux 2.6.25开始，将oom_dump_tasks设置为除0以外的值时，在OOM Killer运行时的输出中会增加进程的列表信息。</p>
<pre><code># echo 1 &gt; /proc/sys/vm/oom_dump_tasks</code></pre><p>列表信息显示如下，可以使用dmesg或syslog来确认。</p>
<pre><code>[ pid ]   uid  tgid total_vm      rss cpu oom_adj name
[    1]     0     1     2580        1   0       0 init
[  500]     0   500     3231        0   1     -17 udevd
[ 2736]     0  2736     1470        1   0       0 syslogd
[ 2741]     0  2741      944        0   0       0 klogd
[ 2765]    81  2765     5307        0   0       0 dbus-daemon
[ 2861]     0  2861      944        0   0       0 acpid
...
[ 3320]     0  3320   525842   241215   1       0 stress</code></pre><h4 id="proc-PID-oom-score-adj"><a href="#proc-PID-oom-score-adj" class="headerlink" title="/proc/PID/oom_score_adj"></a><strong>/proc/PID/oom_score_adj</strong></h4><p>从Linux 2.6.36开始都安装了/proc/<PID>/oom_score_adj，<br>此后将替换为/proc/PID/oom_adj。<br>即使当前是对/proc/PID/oom_adj进行的设置，在内核内部进行变换后的值也是针对/proc/PID/oom_score_adj设置的。</p>
<p>可以设置–1000~1000之间的值。设置为–1000时，该进程就被排除在OOM Killer强制终止的对象外。</p>
<p>在内核2.6.36以后的版本中写入oom_adj，只会输出一次如下的信息。</p>
<pre><code># dmesg
.....
udevd (60): /proc/60/oom_adj is deprecated, please use /proc/60/oom_score_adj instead.</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>malloc</tag>
        <tag>OOM Killer</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内存分配原理（brk和mmap）（转载）</title>
    <url>/2015/07/06/Linux-malloc/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<h3 id="如何查看进程发生缺页中断的次数？"><a href="#如何查看进程发生缺页中断的次数？" class="headerlink" title="如何查看进程发生缺页中断的次数？"></a><strong>如何查看进程发生缺页中断的次数？</strong></h3><pre><code>ps -o majflt,minflt -C program</code></pre><p>majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。<br>这两个数值表示一个进程自启动以来所发生的缺页中断的次数。</p>
<h3 id="发成缺页中断后，执行了那些操作？"><a href="#发成缺页中断后，执行了那些操作？" class="headerlink" title="发成缺页中断后，执行了那些操作？"></a><strong>发成缺页中断后，执行了那些操作？</strong></h3><p>当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作： </p>
<ol>
<li>检查要访问的虚拟地址是否合法 </li>
<li>查找/分配一个物理页 </li>
<li>填充物理页内容（读取磁盘，或者直接置0，或者啥也不干） </li>
<li>建立映射关系（虚拟地址到物理地址） </li>
<li>重新执行发生缺页中断的那条指令 </li>
</ol>
<p>如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。 </p>
<h3 id="内存分配的原理"><a href="#内存分配的原理" class="headerlink" title="内存分配的原理"></a><strong>内存分配的原理</strong></h3><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<ol>
<li>brk是将数据段(.data)的最高地址指针_edata往高地址推；</li>
<li>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</li>
</ol>
<p><strong>这两种方式分配的都是虚拟内存，没有分配物理内存。<br>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</strong><br>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p>
<h3 id="以例子来说明内存分配的原理"><a href="#以例子来说明内存分配的原理" class="headerlink" title="以例子来说明内存分配的原理"></a><strong>以例子来说明内存分配的原理</strong></h3><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a><strong>情况一</strong></h4><p>malloc小于128k的内存，使用brk分配内存，<br>将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，<br>第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</p>
<p><img src="/images/malloc/1.jpg" alt="brk" title="wizard"></p>
<ul>
<li><p>进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。<br>其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。<br>_edata指针（glibc里面定义）指向数据段的最高地址。 </p>
</li>
<li><p>进程调用A=malloc(30K)以后，内存空间如图2：<br>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。<br>你可能会问：只要把_edata+30K就完成内存分配了？<br>事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，<br>等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。<br>也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。 </p>
</li>
<li><p>进程调用B=malloc(40K)以后，内存空间如图3。</p>
</li>
</ul>
<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a><strong>情况二</strong></h4><p>malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：</p>
<p><img src="/images/malloc/2.jpg" alt="mmap" title="build"></p>
<ul>
<li><p>进程调用C=malloc(200K)以后，内存空间如图4：<br>默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），<br>那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。<br>  <strong>这样子做主要是因为:<br>  brk分配的内存需要等到高地址内存释放以后才能释放<br>  （例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），<br>  而mmap分配的内存可以单独释放。</strong><br>  当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。 </p>
</li>
<li><p>进程调用D=malloc(100K)以后，内存空间如图5；</p>
</li>
<li><p>进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。</p>
</li>
</ul>
<p><img src="/images/malloc/3.jpg" alt="free" title="dot"></p>
<ul>
<li><p>进程调用free(B)以后，如图7所示：<br>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？<br>当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。 </p>
</li>
<li><p>进程调用free(D)以后，如图8所示：<br>B和D连接起来，变成一块140K的空闲内存。</p>
</li>
<li><p>默认情况下：<br>当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。<br>在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title>Grep搜索特定文件</title>
    <url>/2015/07/01/grep-special/</url>
    <content><![CDATA[<h3 id="Script"><a href="#Script" class="headerlink" title="Script"></a><strong>Script</strong></h3><pre><code>grep XXYYZZ * -Rn --include=&#39;*.c&#39;
grep XXYYZZ * -Rn --include=&#39;*.h&#39;
grep XXYYZZ * -Rn --include=&#39;*.[ch]&#39;</code></pre>]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下使用Doxygen和graphviz来产生源代码函数调用图</title>
    <url>/2015/07/01/doxygen-graphviz/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><pre><code>sudo apt-get install doxygen doxygen-doc doxygen-gui graphviz
doxywizard
doxygen -g</code></pre><h3 id="生成函数调用图"><a href="#生成函数调用图" class="headerlink" title="生成函数调用图"></a><strong>生成函数调用图</strong></h3><h4 id="DoxyWizard"><a href="#DoxyWizard" class="headerlink" title="DoxyWizard"></a><strong>DoxyWizard</strong></h4><p>打开DoxyWizard，弹出Doxygen配置界面。如下图，标出了主要需要设置的选项:</p>
<p><img src="/images/doxygen/1.png" alt="wizard" title="wizard"></p>
<ol>
<li>Step1：设置doxygen的工作目录，这里主要是生成doxygen运行的目录</li>
<li>Step2：选项设置，wizard和expert选项可以同时设置。</li>
</ol>
<p>wizard选项卡中，选择Project Name作为工程名称，将来会显示在文档的标题中；<br>选择Source code directory，设置源代码所在目录，Destination directory设置文档的生成目录；<br>选择Scan recursively则递归分析源代码目录中的子目录内的源代码。</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a><strong>build</strong></h4><p>需要从没有任何标记的源代码中分析出函数调用关系，所以还需要设置expert选项卡:</p>
<p><img src="/images/doxygen/2.png" alt="build" title="build"></p>
<p>勾选Build选项中的与函数有关的选项，EXTRACT_ALL必须勾选；<br>sourcebrowser: 需要查看代码，勾选Inline sources和souce Browser。</p>
<h4 id="dot"><a href="#dot" class="headerlink" title="dot"></a><strong>dot</strong></h4><p>由于使用到了Graphviz，所以要设置Dot选项，勾选HAVE_DOT，并设置DOT_PATH为Graphviz的bin目录。</p>
<p><img src="/images/doxygen/3.png" alt="dot1" title="dot"></p>
<p>Dot: 这里可以勾选CLASS_DIAGRAMS/HAVE_DOT/CALL_GRAPH/CALLER_GRAPH/DOT_PATH</p>
<p><img src="/images/doxygen/4.png" alt="dot2" title="dot2"></p>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a><strong>run</strong></h4><p>然后就可以点RUN标签，运行后，会生成HTML，查看INDEX.HTML既可以看到结果</p>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_7a1c18a80102vd2p.html" target="_blank" rel="noopener">Ubuntu 下使用 Doxygen</a></li>
<li><a href="http://www.07net01.com/program/229677.html" target="_blank" rel="noopener">使用Doxygen+graphviz+Sublime2来看代码，查看函数调用关系</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Doxygen</category>
      </categories>
      <tags>
        <tag>Doxygen</tag>
        <tag>Graphviz</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM多文件查找与替换</title>
    <url>/2015/07/01/vim-multifile/</url>
    <content><![CDATA[<h3 id="Script"><a href="#Script" class="headerlink" title="Script"></a><strong>Script</strong></h3><pre><code>find . -name &quot;*.c&quot; | xargs sed -i &quot;s/$1/$2/g&quot;</code></pre><h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a><strong>VIM</strong></h3><h4 id="多文件查找"><a href="#多文件查找" class="headerlink" title="多文件查找"></a><strong>多文件查找</strong></h4><h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a><strong>grep</strong></h5><p>直接在vim中输入</p>
<pre><code>:grep abc * </code></pre><p>这是直接调用unix下的grep命令 </p>
<h5 id="vimgrep"><a href="#vimgrep" class="headerlink" title="vimgrep"></a><strong>vimgrep</strong></h5><p>基本用法就是</p>
<pre><code>:vimgrep /匹配模式/[g][j] 要搜索的文件/范围 
:vim[grep][!] /{pattern}/[g][j] {file} ...</code></pre><p>g 和 j 是两个可选的标志位，g表示是否把每一行的多个匹配结果都加入。j表示是否搜索完后定位到第一个匹配位置。<br>要搜索的文件可以是具体的文件路径，也可以是带通配符的路径比如 <em>.as **/</em>.as ，**表示递归所有子目录。<br>要搜索的文件和或搜索范围都可以写多个，用空格分开。 例子：</p>
<pre><code>:vimgrep /\/ **/*.as 搜索当前目录以及所有子目录内as文件中的 &quot;flash&quot;
:vimgrep /an error/ *.c 就是在所有的.c文件中搜索an error。
:vimgrep/an error/* 意思是查找当前目录下的文件中的an error，不包括子目录</code></pre><h5 id="定位"><a href="#定位" class="headerlink" title="定位"></a><strong>定位</strong></h5><p>输入上述的命令后，可以像输入:make命令，那样定位匹配到的文件位置 </p>
<pre><code>:cnext (:cn)           下一个匹配位置
:cprevious (:cp)     上一个匹配位置
:cwindow (:cw)     quickfix窗口，可以选择匹配的文件位置
:cl(:clist)                查看所有匹配的位置</code></pre><h4 id="多文件替换-arg"><a href="#多文件替换-arg" class="headerlink" title="多文件替换(arg)"></a><strong>多文件替换(arg)</strong></h4><ol>
<li>加入要处理的文件  :args *.txt</li>
<li>输入对上述文件的动作  :argdo %s/hate/love/gc | update  （这里将hate替换成love，update表示要写入到文件中，否则只作替换而不写入）</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Editor</category>
      </categories>
      <tags>
        <tag>grep</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu64位系统32位兼容包</title>
    <url>/2015/05/07/lib32-for-ubuntu64/</url>
    <content><![CDATA[<p>ubuntu 14.04 64位无法安装ia32-libs，此包已被移除</p>
<pre><code>sudo apt-get install ia32-libs</code></pre><p>替换为</p>
<pre><code>sudo apt-get install libc6:i386
sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0</code></pre><p>上面这些包基本上都是基本必备库，另外编译中需要到的各个库可以搜索相应的版本，进行安装，例如：</p>
<pre><code>➜  /home/yanwzh  &gt; sudo apt-cache search libelf

libelf-dev - libelf1 development libraries and header files
libelf1 - library to read and write ELF files
libelfg0 - an ELF object file access library
libelfg0-dev - an ELF object file access library: development files
libelf-freebsd-1 - library to read and write ELF files
libelf-freebsd-dev - Development files for libelf (FreeBSD version)

➜  /home/yanwzh  &gt; sudo apt-get install libelf-dev:i386</code></pre><p>使用sudo apt-get install somepkg:i386 来强制安装32位版本</p>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>lib32</tag>
      </tags>
  </entry>
  <entry>
    <title>nm symbols 类型及程序组成</title>
    <url>/2015/04/05/nm-symbols/</url>
    <content><![CDATA[<p><code>nm symbols</code> 类型列表</p>
<a id="more"></a>

<h2 id="man-nm"><a href="#man-nm" class="headerlink" title="man nm"></a><strong>man nm</strong></h2><ul>
<li><strong>A</strong> 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</li>
<li><strong>B/b</strong> 该符号的值出现在非初始化数据段 (bss) 中。例如，在一个文件中定义全局 static int test。则该符号 test 的类型为 b，位于 bss section 中。其值表示该符号在 bss 段中的偏移。一般而言，bss 段分配于 RAM 中</li>
<li><strong>C</strong> 该符号为 common。common symbol 是未初始化数据段。该符号没有包含于一个普通 section 中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个 c 文件中，定义 int test，并且该符号在别的地方会被引用，则该符号类型即为 C。否则其类型为 B。</li>
<li><strong>D/d</strong> 该符号位于初始话数据段中。一般来说，分配到 data section 中。例如定义全局 int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。</li>
<li><strong>G/g</strong> 该符号也位于初始化数据段中。主要用于 small object 提高访问 small data object 的一种方式。</li>
<li><strong>I</strong> 该符号是对另一个符号的间接引用。</li>
<li><strong>N</strong> 该符号是一个 debugging 符号。</li>
<li><strong>R/r</strong> 该符号位于只读数据区。例如定义全局 const int test[] = {123, 123}; 则 test 就是一个只读数据区的符号。注意在 cygwin 下如果使用 gcc 直接编译成 MZ 格式时，源文件中的 test 对应 <code>_test</code>，并且其符号类型为 D，即初始化数据段中。但是如果使用 m6812-elf-gcc 这样的交叉编译工具，源文件中的 test 对应目标文件的 test, 即没有添加下划线，并且其符号类型为 R。一般而言，位于 rodata section。值得注意的是，如果在一个函数中定义 const char *test = “abc”, const char test_int = 3。使用 nm 都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test 在 rodata section 中，大小为 4。</li>
<li><strong>S/s</strong> 符号位于非初始化数据区，用于 small object。</li>
<li><strong>T/t</strong> 该符号位于代码区 text section。</li>
<li><strong>U</strong> 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是 T。但是对于全局变量来说，在定义它的文件中，其符号类型为 C，在使用它的文件中，其类型为 U。</li>
<li><strong>V/v</strong> 该符号是一个 weak object。</li>
<li><strong>W/w</strong> The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</li>
<li><strong>-</strong> 该符号是 a.out 格式文件中的 stabs symbol。</li>
<li><strong>?</strong> 该符号类型没有定义</li>
</ul>
<h2 id="程序分段"><a href="#程序分段" class="headerlink" title="程序分段"></a>程序分段</h2><ol>
<li>text 段， 就是代码段，直观上看就是你码上去的东西，代码编译之后就交给 OS 运行，不能在 OS 上运行中修改它，因此这个段是只读的</li>
<li>data 段，就是数据段，顾名思义它里面存的是数据，这个数据是初始化的全局变量，初始化的用 static 修饰的变量也放在这里，会占用程序文本空间，编译出来的可执行文件大小为 4.1M</li>
</ol>
<pre><code class="c">int a[1024*1024] = {1};
void main (void)
{
    printf(&quot;hello world\n&quot;);
}</code></pre>
<ol start="3">
<li>bss 段，bss: block started by symbol，直译过来就是从符号开始的块，它里面存储的是未初始化的全局变量，<strong>包括初始化为 0 的全局变量</strong>，但不会占用程序文本空间，编译出来的可执行文件大小为 6.0K，去掉那个全局变量 a 编译出来的大小也是 6.0K</li>
</ol>
<pre><code class="c">int a[1024*1024];
void main (void)
{
    printf(&quot;hello world\n&quot;);
}</code></pre>
<ol start="4">
<li><p>heap 堆，用 malloc 分配的内存就是它了，这个是在程序运行过程中动态分配的，所以不会占用程序文本空间；堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用 malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
</li>
<li><p>stack 栈，这里面存放的是临时变量，也就是你在函数中 int a; a 就放在栈里，另外函数的形参也放在这里；是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括 static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存 / 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
</li>
<li><p>rodata 段，存放 C 中的字符串和#define 定义的常量</p>
</li>
</ol>
<p>一般情况下，一个程序本质上都是由 bss 段、data 段、text 段三个组成的——本概念是当前的计算机程序设计中是很重要的一个基本概念。而且在嵌入式系统的设计中也非常重要，牵涉到嵌入式系统运行时的内存大小分配，存储单元占用空间大小的问题。在采用段式内存管理的架构中（比如 intel 的 80x86 系统），bss 段（Block Started by Symbol segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时 bss 段部分将会清零（bss 段属于静态内存分配，即程序一开始就将其清零了）。比如，在 C 语言程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。text 和 data 段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而 bss 段不在可执行文件中，由系统初始化。未初始化的全局变量和静态变量放在 BSS 段，初始化的全局变量和静态变量放在数据段</p>
<h2 id="常用分析命令"><a href="#常用分析命令" class="headerlink" title="常用分析命令"></a><strong>常用分析命令</strong></h2><pre><code class="shell">$ nm -S --size-sort -l output/out.elf
$ csky-elf-objdump -h -t output/out.elf</code></pre>
]]></content>
      <categories>
        <category>C</category>
        <category>Linker</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>debug</tag>
        <tag>nm</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Ecos Mem Info[转]</title>
    <url>/2015/04/04/ecos-mem-info/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>嵌入式系统的内存资源是非常有限的，<br>如果配置不当可导致eCos应用程序因为存储空间不足而链接失败。<br>解决这个问题的办法可以是增加更多的内存或者是减少软件对内存资源的使用，通常是后一种办法。<br>既然要减少内存使用量，那么首先要找出都是哪些变量吃光了内存，<br>就是说要对映像符号进行分析，找出最占内存的变量，<br>看看能否避免使用该变量或减少该变量的占用容量。<br>GNU工具链中的nm就是做这个事情用的，按照用户手册的说法，<br>nm是用来解析映像符号的，包括符号使用容量和所在的文件。</p>
<h2 id="查找最占内存变量"><a href="#查找最占内存变量" class="headerlink" title="查找最占内存变量"></a><strong>查找最占内存变量</strong></h2><pre><code>$ nm --print-size --line-numbers --size-sort app.elf | grep &quot; [dDbB] &quot;  
......  
10004154 00000800 b var_data    /cygdrive/f/ecos/hg/packages/net/lwip_tcpip/current/src/ecos/sys_arch.c:84  
10002fb0 00000b00 b timer_table  
10001f98 00001000 b main_stack  
10004994 00001800 b stack_data  /cygdrive/f/ecos/hg/packages/net/lwip_tcpip/current/src/ecos/sys_arch.c:95  
2007c000 000018b8 b emac_ahb_ram        /cygdrive/f/ecos/hg/packages/devs/eth/arm/lpc2xxx/current/src/if_lpc2xxx.c:357  
20080388 0000283b b memp_memory /cygdrive/f/ecos/hg/packages/net/lwip_tcpip/current/src/core/memp.c:146  </code></pre><ul>
<li>–print-size：打印符号符号占用内存量</li>
<li>–line-numbers：打印符号所在的源文件名及行号</li>
<li>–size-sort：以符号占用内存量来排序</li>
<li>app.elf：eCos应用映像文件名</li>
<li>输出内容按列分别为：符号地址、符号占用内存量、符号类型、所在文件及行号</li>
<li>grep的作用是过滤不需要的符号，我们这里仅需要存储在RAM中的变量，将常量和函数等过滤掉，<br>注意grep参数的引号和方括号之间有空格。<br>输出结果按照变量内容占用量排序输出，最后输出的是占用量最大的变量。<br>从上面的输出可以看出memp_memory占用的内存最多，通过文件名可以判断这是lwIP内存池，<br>修改lwIP配置减少连接数和缓存数目等可以减少该变量的内存占用量。</li>
</ul>
<h2 id="链接失败时的办法"><a href="#链接失败时的办法" class="headerlink" title="链接失败时的办法"></a><strong>链接失败时的办法</strong></h2><p>如果容量超限，压根就不能编译完成，也就谈不上映像文件了，<br>这时候可以修改target.ld文件，修改内存容量，内存容量可以修改成比目标机实际容量更大的值，<br>修改target.ld的目的是可以正确地生成映像文件然后使用nm来分析内存使用情况并进行调整，<br>而不是下载到目标机运行，如果target.ld设定的内存容量比目标机实际内存容量大，<br>即使下载到目标机也不能正常运行。根据nm输出结果及应用需求调整内存使用量，<br>当映像使用的内存容量小于目标机实际内存容量后，恢复target.ld的内存容量设置。</p>
<h2 id="使用size查看总内存量"><a href="#使用size查看总内存量" class="headerlink" title="使用size查看总内存量"></a><strong>使用size查看总内存量</strong></h2><p>nm打印出每个符号占用的内存量，而size打印映像的总内存量，<br>可以使用size输出快速判断容量是否超限的问题，size还可以显示srec和ihex格式的映像容量。</p>
<pre><code>$ size app.elf  
text    data     bss     dec     hex filename  
158712    1852   43503  204067   31d23 app.elf  </code></pre><h2 id="使用哪个nm？"><a href="#使用哪个nm？" class="headerlink" title="使用哪个nm？"></a><strong>使用哪个nm？</strong></h2><p>nm和size只是对ELF格式的映像文件符号和加载段进行分析，<br>因此跟硬件架构没多大关系，<br>使用nm或arm-eabi-nm的效果是一样的，如果不放心，那就用arm-eabi-nm吧，size同理。</p>
<h2 id="nm常用参数"><a href="#nm常用参数" class="headerlink" title="nm常用参数"></a><strong>nm常用参数</strong></h2><h3 id="C-–demangle"><a href="#C-–demangle" class="headerlink" title="-C, –demangle"></a><strong>-C, –demangle</strong></h3><p>逆向解析C++符号转换，编译C++源代码时，<br>会将C++符号转换成符号汇编器要求的符号，<br>如果不对C++符号进行逆向解析，那么看到的是汇编符号而不是C++源文件中的符号名。</p>
<p>使用该参数前，输出汇编符号，晦涩难懂</p>
<pre><code>$ arm-eabi-nm app.elf  
......  
00006adc T _ZN10Cyg_Thread5delayEy  
......  </code></pre><p>使用该参数后，输出C++符号，与源文件符号一致</p>
<pre><code>$ arm-eabi-nm -C app.elf  
    ......  
00006adc T Cyg_Thread::delay(unsigned long long)  
    ......  </code></pre><h3 id="l-–line-numbers"><a href="#l-–line-numbers" class="headerlink" title="-l, –line-numbers"></a><strong>-l, –line-numbers</strong></h3><p>输出符号所在的文件名和行号。使用该参数前</p>
<pre><code>$ arm-eabi-nm app.elf  
......  
0001a0c4 T write  </code></pre><p>使用该参数后，行尾追加文件名和行号</p>
<pre><code>$ arm-eabi-nm -l app.elf  
......  
0001a0c4 T write        /cygdrive/f/ecos/hg/packages/io/fileio/current/src/io.cxx:169  </code></pre><h3 id="S-–print-size"><a href="#S-–print-size" class="headerlink" title="-S, –print-size"></a><strong>-S, –print-size</strong></h3><p>输出符号占用内存量。使用该参数前</p>
<pre><code>$ arm-eabi-nm app.elf  
......  
0001a0c4 T write  </code></pre><p>使用该参数后，第2列数字为符号占用内存量</p>
<pre><code>$ arm-eabi-nm -S app.elf  
......  
0001a0c4 00000034 T write  </code></pre><h3 id="n-–numeric-sort"><a href="#n-–numeric-sort" class="headerlink" title="-n, –numeric-sort"></a><strong>-n, –numeric-sort</strong></h3><p>输出结果按照符号地址排序。使用该参数前</p>
<pre><code>$ arm-eabi-nm app.elf  
......  
000202c8 T udp_sendto_if  
00018ec0 t update_arp_entry  
10004154 b var_data  
1000497c b var_handle  
10004954 b var_mempool  
00009a60 T vfnprintf  
0001a0c4 T write  </code></pre><p>使用该参数后，根据第1列数值排序</p>
<pre><code>$ arm-eabi-nm -n app.elf  
......  
100070b0 A __heap1  
10007fe0 A hal_startup_stack  
2007c000 A __ahb_sram0_start  
2007c000 b emac_ahb_ram  
2007d8b8 A __ahb_sram0_end  
20080000 A __ahb_sram1_start  
20080000 b ram_heap  
20080388 b memp_memory  
20082bc3 A __ahb_sram1_end  </code></pre><h3 id="–size-sort"><a href="#–size-sort" class="headerlink" title="–size-sort"></a><strong>–size-sort</strong></h3><p>按照内存使用量排序。使用该参数前</p>
<pre><code>$ arm-eabi-nm -S app.elf  
......  
10004154 00000800 b var_data  
1000497c 00000004 b var_handle  
10004954 00000028 b var_mempool  
00009a60 000015f4 T vfnprintf  
0001a0c4 00000034 T write  </code></pre><p>使用该参数后，根据第2列数值进行排序</p>
<pre><code>$ arm-eabi-nm -S --size-sort app.elf  
......  
10001f98 00001000 b _ZL10main_stack  
0001cf38 000011dc t tcp_receive  
00009a60 000015f4 T vfnprintf  
10004994 00001800 b stack_data  
2007c000 000018b8 b emac_ahb_ram  
20080388 0000283b b memp_memory </code></pre>]]></content>
      <categories>
        <category>Ecos</category>
      </categories>
      <tags>
        <tag>ecos</tag>
        <tag>nm</tag>
        <tag>mem info</tag>
      </tags>
  </entry>
  <entry>
    <title>Ecos Cpu Load[转]</title>
    <url>/2015/04/04/ecos-cpu-load/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>cpuload组件包提供了一种估算CPU负载的方式。它可以估算最近0.1秒、1秒和10秒内的CPU负载百分比。</p>
<h3 id="负载测量API"><a href="#负载测量API" class="headerlink" title="负载测量API"></a><strong>负载测量API</strong></h3><p>首先，必须在被测目标机上对测量算法进行校准，一旦校准完成后就可以开始测量。<br>测量是一个连续过程，因此总是提供最近的测量数据，测量过程可以根据需要随时停止。<br>一旦开始测量过程，就可以获取测量结果。</p>
<p>需要注意的是：如果目标机或CPU执行任何节能措施，例如降低时钟频率或者挂起CPU等，<br>这些节能措施将干扰CPU负载测量，在这种情况下，测量结果是未定义的。<br>Synthetic Target就是这样的情况之一。阅读本文后续实现细节章节可以了解更多。</p>
<p>『译注』Cortex-M架构的默认实现会在执行空闲任务时挂起CPU，<br>因此默认情况下，测量结果并非是实际的CPU负载，<br>需要重定义HAL_IDLE_THREAD_ACTION宏取消空闲时挂起，<br>HAL_IDLE_THREAD_ACTION宏的默认实现位于hal/cortexm/arch/<version>/include/hal_arch.h:336。</p>
<p>负载测量不支持SMP系统，仅支持单CPU系统。</p>
<p>负载测量API可以在cyg/cpuload/cpuload.h中找到。</p>
<p>『译注』源代码位于services/cpuload</p>
<h4 id="cyg-cpuload-calibrate"><a href="#cyg-cpuload-calibrate" class="headerlink" title="cyg_cpuload_calibrate"></a><strong>cyg_cpuload_calibrate</strong></h4><p>这个函数用来校准CPU负载测量算法。它执行一次特别的测量过程确定空闲时的CPU性能。</p>
<pre><code>void cyg_cpuload_calibrate(cyg_uint32* calibration);  </code></pre><p>该函数通过calibration指针返回校准值。<br>这个函数是非常特别的，为了获得正确的校准结果需要满足若干条件。<br>该函数使用了2个最高线程优先级，当该函数被使用时，其它线程不能使用这两个优先级。<br>调用该函数时，内核调度器必须已经启动而且调度器未加锁。<br>该函数将花费0.1秒的时间完成校准操作，在这0.1秒校准期间不能有任何其它线程执行。</p>
<p>『译注』这个函数使用了线程优先级1和2，为了获得正确的测量结果，<br>其它线程不能使用优先级1和2。eCos的最高线程优先级是0，如果有优先级为0的线程，<br>必须保证在校准过程该线程处于挂起状态，<br>否则校准过程可能被优先级为0的线程抢占而导致错误的校准结果。</p>
<p>『译注』该函数将会创建一个线程，线程堆栈大小为CYGNUM_HAL_STACK_SIZE_MINIMUM，<br>在Cortex-M架构下约1.5KB，该线程仅在校准过程执行一次，<br>随后被删除永远都不会再执行，如果目标机内存非常有限，<br>应当知晓CPU负载测量校准时使用了1.5KB的堆栈空间。</p>
<h4 id="cyg-cpuload-create"><a href="#cyg-cpuload-create" class="headerlink" title="cyg_cpuload_create"></a><strong>cyg_cpuload_create</strong></h4><p>这个函数启动CPU负载测量。</p>
<pre><code>void cyg_cpuload_create(cyg_cpuload_t* cpuload,  
        cyg_uint32 calibrate,  
        cyg_handle_t* handle);  </code></pre><p>调用该函数启动测量过程，handle返回操作句柄，通过该句柄可以读取测量结果以及停止测量过程。</p>
<h4 id="cyg-cpuload-delete"><a href="#cyg-cpuload-delete" class="headerlink" title="cyg_cpuload_delete"></a><strong>cyg_cpuload_delete</strong></h4><p>这个函数停止CPU负载测量。</p>
<pre><code>void cyg_cpuload_delete(cyg_handle_t handle);  </code></pre><p>handle必须是cyg_cpuload_create函数返回的操作句柄。</p>
<h4 id="cyg-cpuload-get"><a href="#cyg-cpuload-get" class="headerlink" title="cyg_cpuload_get"></a><strong>cyg_cpuload_get</strong></h4><p>这个函数返回最近的测量结果。</p>
<pre><code>void cyg_cpuload_get(cyg_handle_t handle,  
        cyg_uint32* average_point1s,  
        cyg_uint32* average_1s,  
        cyg_uint32* average_10s);  </code></pre><p>handle必须是cyg_cpuload_create函数返回的操作句柄。<br>最近0.1秒、1秒和10秒的负载测量结果通过average_point1s、average_1s和average_10s返回。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><strong>实现细节</strong></h3><p>这一节给出一些测量过程的实现细节，这些细节可以帮助我们理解测量结果的意义。<br>当没有其它线程可以执行时，eCos将执行空闲线程，空闲线程总是可执行的而且使用最低线程优先级。<br>空闲线程只做一点点事情，它有一个永远都不会退出的循环，每次循环将idle_thread_loops变量加1，<br>然后调用HAL_IDLE_THREAD_ACTION宏。<br>CPU负载测量算法就是使用了idle_thread_loops变量，<br>测量算法周期性地检查idle_thread_loops变量，并记录前后两次检查的差值，<br>系统越空这个差值就越大，通过这个简单的手段就可以确定系统的负载。</p>
<p>cyg_cpuload_calibrate函数执行空闲任务0.1秒，<br>从而确定系统空闲0.1秒的时间内idle_thread_loops会被累加多少次。<br>cyg_cpuload_create函数启动一个闹钟，这个闹钟每隔0.1秒调用回调函数，<br>回调函数计算idle_thread_loops从上次检查到本次检查的差值，然后根据这个差值以及校准值计算出CPU负载。<br>回调函数用新的计算结果更新cyg_cpuload结构，<br>0.1秒负载只是简单地复制最近的测量结果，然后通过一个简单的滤波计算1秒和10秒负载。<br>由于舍入误差的存在，即使系统满负载，1秒和10秒测量值也永远都不会达到100%，通常看到的是99%。</p>
<p>如前所述，电源管理代码将干扰上述测量结果。<br>CPU负载测量的基本假设是：空闲线程可以无障碍地运行，而且运行条件与校准时的运行条件保持一致。<br>如果降低CPU时钟频率，那么空闲线程的计数器累加速率将变慢，<br>因此CPU负载测量结果值将偏高，如果CPU被完全挂起，那么CPU负载测量结果将是100%。</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a><strong>Ref</strong></h3><ol>
<li><a href="http://ecos.sourceware.org/docs-3.0/ref/cpuload-functions.html" target="_blank" rel="noopener">Chapter 68. CPU Load Measurements</a></li>
<li><a href="http://ecos.sourceware.org/docs-3.0/ref/ecos-ref.html" target="_blank" rel="noopener">eCos Reference Manual</a></li>
</ol>
]]></content>
      <categories>
        <category>Ecos</category>
      </categories>
      <tags>
        <tag>ecos</tag>
        <tag>cpu load</tag>
      </tags>
  </entry>
  <entry>
    <title>Ecos Stack Info[转]</title>
    <url>/2015/04/04/ecos-stack-info/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>如何获得eCos系统的线程堆栈和中断堆栈使用情况。<br>eCos是开源免版税的抢占式实时操作系统。其最大亮点是可配置，<br>与其配套的图形化配置工具提供组件管理、选项配置、自动化单元测试等。<br>eCos官网<a href="http://ecos.sourceware.org。" target="_blank" rel="noopener">http://ecos.sourceware.org。</a></p>
<p>在嵌入式系统中，堆栈是静态分配的，<br>不会依据堆栈的使用情况自动增加堆栈深度，存在堆栈溢出的风险。<br>一旦发生堆栈溢出，后果很严重，可能会立即导致死机，也可能埋了一颗定时炸弹，<br>在随后的开发过程随时导致死机。<br>事实上，堆栈溢出导致死机还算是不错的状况，<br>更糟糕的情况是，有时候正常，有时候功能错误，捉摸不定，<br>如果又是在修改了与这个堆栈压根就没什么关系的代码的情况下出现，<br>那真的要吐血，因为第一感觉会告诉你，刚刚修改的代码存在错误。<br>好在可以预防这种情况，稍微专业点的RTOS就会提供堆栈检查API，<br>eCos当然也不例外，在有堆栈检查API的RTOS中，<br>即使已经发生了堆栈溢出，也可以快速诊断哪个堆栈产生溢出。</p>
<h3 id="堆栈检查选项"><a href="#堆栈检查选项" class="headerlink" title="堆栈检查选项"></a><strong>堆栈检查选项</strong></h3><p>堆栈检查通常是发生在开发和测试阶段，<br>因此在eCos中堆栈检查功能是一个可选项，<br>要使用eCos堆栈检查功能，首先要打开对应的选项。</p>
<pre><code>&gt; eCos kernel  
    &gt; Thread-related options  
        &gt; Measure stack usage  </code></pre><h3 id="堆栈检查API"><a href="#堆栈检查API" class="headerlink" title="堆栈检查API"></a><strong>堆栈检查API</strong></h3><p>使能Measure stack usage选项后，cyg_thread_measure_stack_usage函数可用，函数原型如下：</p>
<pre><code>cyg_uint32 cyg_thread_measure_stack_usage(cyg_handle_t thread)  </code></pre><p>这个函数以线程句柄为入参，返回该线程已使用的堆栈深度，以字节为单位。</p>
<p>仅有已使用堆栈深度是不够的，<br>使用cyg_thread_get_stack_size获取线程堆栈大小，<br>使用cyg_thread_get_stack_base获取线程堆栈基址。<br>通过这三个函数可以确定线程堆栈存储位置，分配空间大小，已使用堆栈大小，<br>通过已使用堆栈大小与分配空间大小相比可以评估线程堆栈是否存在堆栈溢出的风险。<br>此外，可以使用cyg_thread_get_info函数一次性获取上述三个参数。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><p>使用cyg_thread_get_info可以一次性地获取上述三个参数，<br>而且还可以获取其他线程信息，使用cyg_thread_get_next可以枚举当前运行环境下的所有线程。<br>下面的代码使用cyg_thread_get_next函数枚举所有线程，<br>然后调用cyg_thread_get_info获取线程信息，<br>并打印线程名称和堆栈使用情况。<br>如果堆栈检查选项未使能，那么thread_info.stack_used为0。</p>
<pre><code>cyg_handle_t thread = 0;  
cyg_uint16 id;  
cyg_thread_info thread_info;  

while(cyg_thread_get_next(&amp;thread, &amp;id))  
{  
    if(cyg_thread_get_info(thread, id, &amp;thread_info))  
    {  
        diag_printf(&quot;name: %s, handle: 0x%08x, id: 0x%04x, &quot;  
                &quot;stack_base: 0x%08x, stack_size: %d, stack_used: %d\n&quot;,  
                thread_info.name, thread_info.handle, thread_info.id,  
                thread_info.stack_base, thread_info.stack_size, thread_info.stack_used);  
    }  
    else  
    {  
        diag_printf(&quot;ERROR: get thread info failed, handle: 0x%08x, id: 0x%04x\n&quot;,  
                thread, id);  
    }  
}  </code></pre><h3 id="影响堆栈深度的因素"><a href="#影响堆栈深度的因素" class="headerlink" title="影响堆栈深度的因素"></a><strong>影响堆栈深度的因素</strong></h3><ol>
<li><p>函数调用深度，每调用1次函数至少需要8字节堆栈空间用来保存LR寄存器以及堆栈对齐，<br>因此嵌入式系统应当尽量避免递归调用，递归调用将大大增加对堆栈需求并且引入不确定性，最终可能导致堆栈溢出。</p>
</li>
<li><p>函数复杂度，函数越复杂使用的临时变量越多，<br>临时变量可以保存在寄存器或堆栈中，如果要保存在寄存器中，<br>那么首先要将原寄存器内容压栈保存，因此临时变量无论是保存在寄存器或堆栈都会增加堆栈深度。</p>
</li>
<li><p>编译选项，不同的编译参数会影响堆栈深度，<br>例如使用-O0编译出的代码要比-O2编译出的代码使用更多的堆栈。<br>因为使用-O0时，会将所有变量压栈，而不仅是保存在寄存器，这有利于调试，但会增加堆栈深度。</p>
</li>
<li><p>中断，产生中断时，中断服务函数将被中断线程的上下文保存到被中断线程的堆栈，<br>因此中断也会加深线程堆栈深度，中断嵌套将会加深中断堆栈。</p>
</li>
</ol>
<h3 id="堆栈检查原理"><a href="#堆栈检查原理" class="headerlink" title="堆栈检查原理"></a><strong>堆栈检查原理</strong></h3><p>在线程初始化时，将线程堆栈所有空间填入预设值，eCos预设值为0xDEADBEEF，<br>在调用cyg_thread_measure_stack_usage或者cyg_thread_get_info时从堆栈底部开始检查堆栈存储的内容是否为预设值，<br>如果是预设值说明该地址可能未被使用，如果不是那么说明该地址已经被使用。<br>预设值不是0而是0xDEADBEEF的原因是：变量值为0的可能性非常大，<br>而为0xDEADBEEF的可能性非常小，减少因为变量值与预设值相同而导致计算偏差的可能性。</p>
<pre><code>// kernel/&lt;version&gt;/include/thread.inl:222  
inline void Cyg_HardwareThread::attach_stack(CYG_ADDRESS s_base, cyg_uint32 s_size)  
{  
    ......  
#ifdef CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT  
    {  
        CYG_WORD *base = (CYG_WORD *)s_base;  
        cyg_uint32 size = s_size/sizeof(CYG_WORD);  
        cyg_ucount32 i;  

        for (i=0; i&lt;size; i++) {  
            base[i] = 0xDEADBEEF;  
        }  
    }  
#endif  
    ......  
}  
&lt;/version&gt;  

// kernel/&lt;version&gt;/include/thread.inl:157  
inline cyg_uint32 Cyg_HardwareThread::measure_stack_usage(void)  
{  
    CYG_WORD *base = (CYG_WORD *)stack_base;  
    cyg_uint32 size = stack_size/sizeof(CYG_WORD);  
    cyg_ucount32 i;  

    for (i=0; i&lt;size; i++) {  
        if (base[i] != 0xDEADBEEF)  
            break;  
    }  
    return (size - i)*sizeof(CYG_WORD);  
}  
&lt;/version&gt;  </code></pre><h3 id="中断堆栈"><a href="#中断堆栈" class="headerlink" title="中断堆栈"></a><strong>中断堆栈</strong></h3><p>eCos提供了线程堆栈检查，但没有发现中断堆栈检查，<br>中断堆栈同样会有溢出的风险，因此编写了stkinfo组件对中断堆栈进行检查，<br>此外该组件还可以对不包含内核情况下的应用程序主堆栈进行检查。</p>
<h3 id="stkinfo组件"><a href="#stkinfo组件" class="headerlink" title="stkinfo组件"></a><strong>stkinfo组件</strong></h3><p>目前该组件仅支持Cortex-M架构，可能支持其他架构，但未经验证。</p>
<p>stkinfo扩展组件包提供的接口如下：</p>
<pre><code>typedef struct _cyg_stack_info  
{  
CYG_ADDRWORD    base;  
cyg_uint32      size;  
cyg_uint32      used;  
}cyg_stack_info;  

// initialize interrupt stack with known value.  
void cyg_interrupt_stack_measure_init(void);  

// Measure the stack usage of the interrupt.  
void cyg_get_interrupt_stack_info(cyg_stack_info* info);  

// initialize main stack with known value.  
void cyg_main_stack_measure_init(void);  

// Measure the stack usage of the user program.  
void cyg_get_main_stack_info(cyg_stack_info* info);  </code></pre><ol>
<li><p>堆栈信息数据结构，包括堆栈基址，堆栈大小，已使用堆栈大小。</p>
</li>
<li><p>中断堆栈检查初始化，这个函数将中断堆栈写入预设值，<br>但是仅写到堆栈的下半段，因为eCos使用中断堆栈作为初始化过程的堆栈，<br>因此中断的上半段已经在使用中，不能写入预设值，<br>从这里可以看出，只有在中断堆栈使用量超过堆栈大小一半时检查结果才比较精确，<br>但是用来判断堆栈溢出已经足够啦。</p>
</li>
<li><p>获取中断堆栈信息，包括堆栈已使用大小，<br>如果堆栈已使用量小于堆栈的一半，<br>那么总是返回堆栈的一半大小值，例如堆栈分配1024字节，实际仅使用378字节，<br>该函数返回的使用量是512字节，如果堆栈已使用量超过堆栈的一半，那么返回堆栈的实际使用量。</p>
</li>
<li><p>应用程序主堆栈初始化，与中断堆栈一样仅初始化下半段，如果当前配置包含内核，那么该函数什么都不做。</p>
</li>
<li><p>获取应用程序主堆栈信息，包括堆栈已使用大小，如果当前配置包含内核，那么info数据结构的所有值为0。</p>
</li>
</ol>
<h3 id="安装stkinfo组件"><a href="#安装stkinfo组件" class="headerlink" title="安装stkinfo组件"></a><strong>安装stkinfo组件</strong></h3><p>使用ecosadmin.tcl脚本安装stkinnfo组件，该脚本在eCos源代码的packages子目录下。</p>
<pre><code>cd &lt;ecos-prefix&gt;/packages  
tclsh ecosadmin.tcl add &lt;download-prefix&gt;/stkinfo-&lt;version&gt;.epk  
&lt;/version&gt;&lt;/download-prefix&gt;&lt;/ecos-prefix&gt;  </code></pre><p>也可以手动安装该组件。</p>
<pre><code>tar -xf &lt;download-prefix&gt;/stkinfo-&lt;version&gt;.epk  
cat &lt;download-prefix&gt;/pkgadd.db &gt;&gt; &lt;ecos-prefix&gt;/packages/ecos.db  
cp -R &lt;donwload-prefix&gt;/services &lt;ecos-prefix&gt;/packages/  
&lt;/ecos-prefix&gt;&lt;/donwload-prefix&gt;&lt;/ecos-prefix&gt;&lt;/download-prefix&gt;&lt;/version&gt;&lt;/download-prefix&gt;  </code></pre><h3 id="使用stkinfo组件"><a href="#使用stkinfo组件" class="headerlink" title="使用stkinfo组件"></a><strong>使用stkinfo组件</strong></h3><p>在对堆栈进行检查之前，首先要对堆栈进行预设值填充，<br>为了保证预设值不会覆盖当前正在使用的堆栈空间，<br>要在初始化的早期对堆栈进行预设值填充，<br>因此在hal_system_init函数中调用cyg_interrupt_stack_measure_init进行堆栈预设值填充。<br>hal_system_init是平台HAL的一部分，<br>在系统初始化早期被架构HAL调用。这里以Olimex LPC-1766-STK目标机为例。</p>
<pre><code>// hal/cortexm/lpc17xx/lpc1766stk/&lt;version&gt;/src/lpc1766stk_misc.c:78  
......  
#ifdef CYGPKG_STKINFO  
# include &lt;cyg/stkinfo/stkinfo.h&gt;  
#endif  
......  
    __externC void  
hal_system_init(void)  
{  
#ifdef CYGPKG_STKINFO  
    cyg_interrupt_stack_measure_init();  
    cyg_main_stack_measure_init();  
#endif  
    ......  
}  
......  </code></pre><p>初始化过后，可以在任意时刻调用cyg_get_interrupt_stack_info获取堆栈信息，<br>并打印堆栈的使用情况，<br>将上面打印堆栈使用情况的代码示例添加上中断堆栈后的示例如下，<br>这个示例的完整代码见stkinfo组件的测试用例。</p>
<pre><code>cyg_handle_t thread = 0;  
cyg_uint16 id;  
cyg_thread_info thread_info;  
cyg_stack_info  stack_info;  

cyg_get_interrupt_stack_info(&amp;stack_info);  
diag_printf(&quot;name: %s, &quot;  
        &quot;stack_base: 0x%08x, stack_size: %d, stack_used: &lt;=%d\n&quot;,  
        &quot;ISR/DSR&quot;,  
        stack_info.base, stack_info.size, stack_info.used);  

while(cyg_thread_get_next(&amp;thread, &amp;id))  
{  
    if(cyg_thread_get_info(thread, id, &amp;thread_info))  
    {  
        diag_printf(&quot;name: %s, handle: 0x%08x, id: 0x%04x, &quot;  
                &quot;stack_base: 0x%08x, stack_size: %d, stack_used: %d\n&quot;,  
                thread_info.name, thread_info.handle, thread_info.id,  
                thread_info.stack_base, thread_info.stack_size, thread_info.stack_used);  
    }  
    else  
    {  
        diag_printf(&quot;ERROR: get thread info failed, handle: 0x%08x, id: 0x%04x\n&quot;,  
                thread, id);  
    }  
}  </code></pre><p>Line4声明中断堆栈信息变量。</p>
<p>Line6调用cyg_get_interrupt_stack_info获取堆栈信息。</p>
<p>Line7打印中断堆栈基址、大小、已使用大小。</p>
<h3 id="Statue"><a href="#Statue" class="headerlink" title="Statue"></a><strong>Statue</strong></h3><pre><code>static const unsigned char * const thread_state_str[] = {
    &quot;RUN&quot;,      /* 0 - Running */
    &quot;SLEEP&quot;,    /* 1 - Sleeping */
    &quot;CNTSLP&quot;,   /* 2 - Counted sleep */
    &quot;SLPSET&quot;,   /* 3 - Sleep set */     
    &quot;SUSP&quot;,     /* 4 - Suspended */
    NULL,       /* 5 - INVALID */
    NULL,       /* 6 - INVALID */
    NULL,       /* 7 - INVALID */
    &quot;CREAT&quot;,    /* 8 - Creating */
    NULL,       /* 9 - INVALID */
    NULL,       /* 10 - INVALID */
    NULL,       /* 11 - INVALID */
    NULL,       /* 12 - INVALID */
    NULL,       /* 13 - INVALID */
    NULL,       /* 14 - INVALID */
    NULL,       /* 15 - INVALID */
    &quot;EXIT&quot;      /* 16 - Exiting */
};</code></pre><p>参考代码<strong>&lt;ecos3.0/packages/net/httpd/v3_0/src/monitor.c&gt;</strong></p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a><strong>Ref</strong></h3><ol>
<li><a href="http://blog.csdn.net/zoomdy/article/details/16970395" target="_blank" rel="noopener">获取eCos堆栈使用情况</a></li>
<li><a href="http://ecos.sourceware.org/docs-3.0/ref/ecos-ref.html" target="_blank" rel="noopener">eCos Reference Manual</a></li>
</ol>
]]></content>
      <categories>
        <category>Ecos</category>
      </categories>
      <tags>
        <tag>ecos</tag>
        <tag>stack info</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux lua及依赖库安装</title>
    <url>/2015/03/10/lua-run/</url>
    <content><![CDATA[<p>lua5.2暂时不使用，使用lua5.1+luarocks</p>
<ol>
<li>看readline软件包是否安装（dpkg -l | grep -i 软件名）</li>
<li>是否安装ncurses安装包（ncurses安装包 ）</li>
<li>是否安装libncurses5-dev 或libncursesw5-dev软件包（apt-get install libncurses5-dev）</li>
</ol>
<h2 id="ncurses-5-9-tar-gz"><a href="#ncurses-5-9-tar-gz" class="headerlink" title="ncurses-5.9.tar.gz"></a>ncurses-5.9.tar.gz</h2><pre><code>$ ./configure
$ make
$ sudo make install</code></pre><h2 id="readline-6-3-tar-gz"><a href="#readline-6-3-tar-gz" class="headerlink" title="readline-6.3.tar.gz"></a>readline-6.3.tar.gz</h2><pre><code>$ ./configure
$ make
$ sudo make install
$ sudo ldconfig</code></pre><h2 id="lua-5-2-3-tar-gz"><a href="#lua-5-2-3-tar-gz" class="headerlink" title="lua-5.2.3.tar.gz"></a>lua-5.2.3.tar.gz</h2><pre><code>$ sudo apt-get install libreadline6-dev
$ sudo apt-get install libreadline6-dbg
$ make linux
$ OK</code></pre><h2 id="lua-cjson"><a href="#lua-cjson" class="headerlink" title="lua-cjson"></a>lua-cjson</h2><pre><code>$ vim Makefile
LUA_VERSION = 5.2    
$ make
$ sudo make install</code></pre><h2 id="lua-rocks"><a href="#lua-rocks" class="headerlink" title="lua rocks"></a>lua rocks</h2><p>luarocks会自动安装lua版本，现在版本为5.1，如果版本不一致，会导致找不到安装包，建议使用手动方式安装需要的包；</p>
<p>如果使用luarocks管理包，不要单独安装lua，或者必须保证版本一致为5.1</p>
<pre><code>$ sudo apt-get install luarocks
$ sudo luarocks install luasocket
$ luarocks list
$ sudo luarocks install lua-cjson
$ luarocks search **</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake使用</title>
    <url>/2015/03/04/cmake-02/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<h2 id="A-Basic-Starting-Point-Step1"><a href="#A-Basic-Starting-Point-Step1" class="headerlink" title="A Basic Starting Point (Step1)"></a>A Basic Starting Point (Step1)</h2><p>CMakeLists.txt文件：</p>
<pre><code>cmake_minimum_required (VERSION 2.6)
project (Tutorial)
add_executable(Tutorial tutorial.cxx)</code></pre><p>cmake_minimum_required：是判断需要cmake的最小版本号。所有程序都需要这个。</p>
<p>project:用于指定工程的名字。</p>
<p>add_executable命令用于指定程序从哪些源文件生成。此例中 程序 Tutorial则是tutorial.cxx 源文件生成。</p>
<p><strong>添加版本号和配置头文件：</strong></p>
<pre><code>cmake_minimum_required (VERSION 2.6)
project (Tutorial)
# The version number.
set (Tutorial_VERSION_MAJOR 1)
set (Tutorial_VERSION_MINOR 0)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file (
        &quot;${PROJECT_SOURCE_DIR}/TutorialConfig.h.in&quot;
        &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot;
        )

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
include_directories(&quot;${PROJECT_BINARY_DIR}&quot;)

# add the executable
add_executable(Tutorial tutorial.cxx)</code></pre><p>因为配置文件会被生成到二进制目录中，所以我们需要把二进制目录加入到头文件搜索路径中<br>(include），然后我们在源码目录中建立如下 ‘TutorialConfig.h.in’：</p>
<pre><code>    // the configured options and settings for Tutorial
    #define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
    #define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</code></pre><p>执行cmake时，配置文件头文件中@Tutorial_VERSION_MAJOR@ 和 @Tutorial_VERSION_MINOR@的值将会被<br>CMakeLists.txt文件中指定的值所替换。然后我们可以在源文件tutorial.cxx引用这个所定义的宏：</p>
<pre><code>fprintf(stdout,&quot;%s Version %d.%d\n&quot;,
    argv[0],
    Tutorial_VERSION_MAJOR,
    Tutorial_VERSION_MINOR);
fprintf(stdout,&quot;Usage: %s number\n&quot;,argv[0]);</code></pre><h2 id="Adding-a-Library-Step-2"><a href="#Adding-a-Library-Step-2" class="headerlink" title="Adding a Library (Step 2)"></a>Adding a Library (Step 2)</h2><p>添加一个库到工程中：</p>
<pre><code>add_library(MathFunctions mysqrt.cxx)</code></pre><p>将mysqrt.cxx源文件打包为库文件MathFunctions，<br>使用add_subdirectory命令指示这个目录需要进行编译。<br>用include_directories命令添加MathFunctions目录，<br>是为了能让编译程序找到 mysqrt.h 头文件。<br>然后用target_link_libraries命令把生成的库链接到执行文件中：</p>
<pre><code>#增加头文件搜索目录
include_directories (&quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;)
#增加子目录
add_subdirectory (MathFunctions) 
# 生成执行文件
add_executable (Tutorial tutorial.cxx)
#链接库
target_link_libraries (Tutorial MathFunctions)</code></pre><h2 id="Installing-and-Testing-Step-3"><a href="#Installing-and-Testing-Step-3" class="headerlink" title="Installing and Testing (Step 3)"></a>Installing and Testing (Step 3)</h2><p>在工程中增加一个安装规则和测试支持。我们需要把库安装到bin目录下，把头文件安装到include下：</p>
<pre><code>install (TARGETS MathFunctions DESTINATION bin)
install (FILES MathFunctions.h DESTINATION include)</code></pre><p>对于这个向导程序，需要在顶层CMakeList.txt文件中增加下面行，安装执行文件和头文件。</p>
<pre><code># 安装程序 Tutorial到安装目录的bin子目录中
install (TARGETS Tutorial DESTINATION bin)
#安装头文件到安装目录中的include目录中
install (FILES &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot; DESTINATION include)</code></pre><p>CMake用变量CMAKE_INSTALL_PREFIX决定安装的根目录。</p>
<h2 id="常用cmake命令"><a href="#常用cmake命令" class="headerlink" title="常用cmake命令"></a>常用cmake命令</h2><h3 id="检查CMake版本"><a href="#检查CMake版本" class="headerlink" title="检查CMake版本"></a>检查CMake版本</h3><p>cmake版本至少为2.8</p>
<pre><code>cmake_minimum_required(VERSION 2.8)</code></pre><h3 id="定义工程名称"><a href="#定义工程名称" class="headerlink" title="定义工程名称"></a>定义工程名称</h3><p>工程名为helloworld</p>
<pre><code>project(helloworld)</code></pre><h3 id="查找源文件"><a href="#查找源文件" class="headerlink" title="查找源文件"></a>查找源文件</h3><p>查找当前目录下所有的源文件并保存到SRC_LIST变量里</p>
<pre><code>aux_source_directory(. SRC_LIST)</code></pre><p>查找src目录下所有以cmake开头的文件并保存到CMAKE_FILES变量里</p>
<pre><code>file(GLOB CMAKE_FILES &quot;src/cmake*&quot;)</code></pre><p>file命令同时支持目录递归查找</p>
<pre><code>file(GLOB_RECURSE CMAKE_FILES &quot;src/cmake*&quot;)</code></pre><p>按照官方文档的说法，不建议使用file的GLOB指令来收集工程的源文件，原文解释如下：</p>
<p>We do not recommend using GLOB to collect a list of source files from your source tree.<br>If no CMakeLists.txt file changes when a source is added or removed<br>then the generated build system cannot know when to ask CMake to regenerate.<br>大意就是，GLOB收集的源文件增加或删除，而CMakeLists.txt没有发生修改时，CMake不能识别这些文件。<br>其实，当CMakeLists.txt使用aux_source_directory和file glob查找工程源文件时，如果添加或删除源文件，都需要重新运行CMake。</p>
<h3 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h3><p>经常配合set命令使用的CMake变量，使用set(variable value)进行设置。</p>
<ul>
<li>CMAKE_VERBOSE_MAKEFILE on 输出详细的编译和链接信息</li>
<li>CMAKE_CXX_COMPILER “g++” c++编译器</li>
<li>CMAKE_CXX_FLAGS “-Wall” c++编译器参数<ul>
<li>CMAKE_CXX_FLAGS_DEBUG debug版本对应的编译器参数</li>
<li>CMAKE_CXX_FLAGS_RELEASE release版本对应的编译器参数</li>
</ul>
</li>
<li>EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin 可执行文件的输出目录</li>
<li>LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib 链接库的输出目录</li>
</ul>
<p>set命令还可以设置自定义变量，比如</p>
<pre><code>set(MY_GREETINGS &quot;hello world&quot;)</code></pre><h3 id="包含目录和链接目录"><a href="#包含目录和链接目录" class="headerlink" title="包含目录和链接目录"></a>包含目录和链接目录</h3><p>将./include和./abc加入包含目录列表</p>
<pre><code>include_directories(
        ./include
        ./abc
        )</code></pre><p>将./lib加入编译器链接阶段的搜索目录列表</p>
<pre><code>link_directories(
        ./lib
        )</code></pre><h3 id="添加生成目标"><a href="#添加生成目标" class="headerlink" title="添加生成目标"></a>添加生成目标</h3><p>使用SRC_LIST源文件列表里的文件生成一个可执行文件hello</p>
<pre><code>add_executable(hello ${SRC_LIST})</code></pre><p>使用SRC_LIST源文件列表里的文件生成一个静态链接库libhello.a</p>
<pre><code>add_library(hello STATIC ${SRC_LIST})</code></pre><p>使用SRC_LIST源文件列表里的文件生成一个动态链接库libhello.so</p>
<pre><code>add_library(hello SHARED ${SRC_LIST})</code></pre><p>将若干库文件链接到生成的目标hello(libhello.a或libhello.so)</p>
<pre><code>target_link_libraries(hello A B.a C.so)</code></pre><p><strong>需要注意的是，target_link_libraries里库文件的顺序符合gcc链接顺序的规则，<br>即被依赖的库放在依赖它的库的后面，比如上面的命令里，<br>libA.so可能依赖于libB.a和libC.so，<br>如果顺序有错，链接时会报错。<br>还有一点，B.a会告诉CMake优先使用静态链接库libB.a，<br>C.so会告诉CMake优先使用动态链接库libC.so，也可直接使用库文件的相对路径或绝对路径。</strong></p>
<h3 id="自定义链接选项"><a href="#自定义链接选项" class="headerlink" title="自定义链接选项"></a>自定义链接选项</h3><p>有时候需要自定义链接选项，比如需要单独对B.a使用–whole-archive选项，可以</p>
<pre><code>target_link_libraryies(hello A -Wl,--whole-archive B.a -Wl,--no-whole-archive C.so)</code></pre><h3 id="自定义Makefile目标"><a href="#自定义Makefile目标" class="headerlink" title="自定义Makefile目标"></a>自定义Makefile目标</h3><p>运行下面的whatever目标make whatever，会先创建一个目录./hello，然后将当前目录的a.txt拷贝到新建的./hello目录里。</p>
<pre><code>add_custom_command(
        OUTPUT ./hello/a.txt
        COMMAND mkdir -p ./hello 
        cp a.txt ./hello
        DEPENDS a.txt
        )
add_custom_target(whatever DEPENDS ./hello/a.txt)</code></pre><p>自定义目标还可以使用add_dependencies命令加入到其他目标的依赖列表里，当执行make demo时，whatever目标会被自动调用。</p>
<pre><code>add_executable(demo ${SRC_LIST})
add_dependencies(demo whatever)</code></pre><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><p>包含其他目录的CMakeLists.txt</p>
<pre><code>include(/path/to/another/CMakeLists.txt)</code></pre><p>if命令</p>
<pre><code>if(${MY_BUILD_TYPE} MATCHES &quot;debug&quot;)
    ...
else()
    ...
endif()</code></pre><p>list命令</p>
<pre><code>list(APPEND SRC_LIST 
        a.cpp
        b.cpp
    )

list(REMOVE_ITEM SRC_LIST
        a.cpp
    )</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
PROJECT(demo)

# add include dir
INCLUDE_DIRECTORIES(.)
INCLUDE_DIRECTORIES(lua/src)

# add source dir
AUX_SOURCE_DIRECTORY(lua/src/           SRCS)
AUX_SOURCE_DIRECTORY(lua/lua-cjson-xml/ SRCS)

ADD_LIBRARY(demo ${SRCS})

SET(CMAKE_BUILD_TYPE &quot;Release&quot;)

ADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -Wno-deprecated-declarations )

SET(CMAKE_EXE_LINKER_FLAGS &quot;--static&quot;)
ADD_EXECUTABLE(test main.cpp)
TARGET_LINK_LIBRARIES(A demo jansson dl pthread curl z)

INSTALL(FILES demo.hpp http.hpp DESTINATION include)</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>引用文档：</p>
<ol>
<li><a href="http://www.cmake.org/cmake/help/v3.0/manual/cmake-language.7.html#syntax" target="_blank" rel="noopener">cmake syntax</a></li>
<li><a href="http://www.cmake.org/cmake-tutorial/" target="_blank" rel="noopener">cmake tutorial</a></li>
<li><a href="http://www.cmake.org/Wiki/CMake_Useful_Variables" target="_blank" rel="noopener">CMake常用变量列表</a></li>
<li><a href="http://www.cmake.org/documentation/" target="_blank" rel="noopener">CMake文档列表</a></li>
<li><a href="http://www.cmake.org/cmake/help/v3.0/manual/cmake-modules.7.html" target="_blank" rel="noopener">cmake modules</a></li>
<li><a href="http://blog.atime.me/note/cmake.html" target="_blank" rel="noopener">CMake 使用总结</a></li>
<li><a href="http://www.cnblogs.com/coderfenghc/archive/2013/01/20/2846621.html" target="_blank" rel="noopener">CMake 用法导览</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>github push避免输入用户名和密码</title>
    <url>/2015/03/04/git-push/</url>
    <content><![CDATA[<p>github上传代码时，每次都需要输入用户名和密码，原因是使用了https方式进行push：</p>
<pre><code>$ git clone https://github.com/breezetemple/breezetemple.github.com.git</code></pre><p>使用以下命令更换为使用ssh方式：</p>
<pre><code>$ git remote -v
origin  https://github.com/breezetemple/breezetemple.github.com.git (fetch)
origin  https://github.com/breezetemple/breezetemple.github.com.git (push)
$ git remote rm origin
$ git remote add origin git@github.com:breezetemple/breezetemple.github.com.git
$ git push origin master 
Everything up-to-date</code></pre><p>或者使用如下命令初始化：</p>
<pre><code>git clone git@github.com:breezetemple/breezetemple.github.com.git</code></pre><p>另外，需要将ssh pub key上传到github：</p>
<pre><code>$ ls ~/.ssh/id_rsa.pub                
/home/yanwzh/.ssh/id_rsa.pub
$ xclip -sel clip &lt; ~/.ssh/id_rsa.pub</code></pre>]]></content>
      <categories>
        <category>Tools</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 常用命令</title>
    <url>/2015/03/04/cmake-03/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>##Commands</p>
<p>头文件路径，相当于编译器参数 -Idir1 -Idir2</p>
<pre><code>INCLUDE_DIRECTORIES( &quot;dir1&quot; &quot;dir2&quot; ... )</code></pre><p>库文件路径。注意：<br>由于历史原因，相对路径会原样传递给链接器。<br>尽量使用FIND_LIBRARY而避免使用这个。</p>
<pre><code>LINK_DIRECTORIES(&quot;dir1&quot; &quot;dir2&quot;)</code></pre><p>收集目录中的文件名并赋值给变量</p>
<pre><code>AUX_SOURCE_DIRECTORY( “sourcedir” variable)</code></pre><p>可执行程序目标</p>
<pre><code>ADD_EXECUTABLE</code></pre><p>库目标</p>
<pre><code>ADD_LIBRARY</code></pre><p>自定义目标</p>
<pre><code>ADD_CUSTOM_TARGET</code></pre><p>目标target1依赖于t2 t3</p>
<pre><code>ADD_DEPENDENCIES( target1 t2 t3 )</code></pre><p>本意是供设置 -D… /D… 等编译预处理需要的宏定义参数，对比 REMOVE_DEFINITIONS()</p>
<pre><code>ADD_DEFINITIONS( &quot;-Wall -ansi&quot;)</code></pre><p>设置单个目标需要链接的库</p>
<pre><code>TARGET_LINK_LIBRARIES( target-name lib1 lib2 ...)</code></pre><p>设置所有目标需要链接的库</p>
<pre><code>LINK_LIBRARIES( lib1 lib2 ...)</code></pre><p>设置目标的属性 OUTPUT_NAME, VERSION, ….</p>
<pre><code>SET_TARGET_PROPERTIES( ... )</code></pre><p>打印输出信息</p>
<pre><code>MESSAGE(...)</code></pre><p>DESTINATION 相对于 ${CMAKE_INSTALL_PREFIX}</p>
<pre><code>INSTALL( FILES “f1” “f2”DESTINATION . )</code></pre><p>变量赋值</p>
<pre><code>SET( VAR value [CACHE TYPE DOCSTRING [FORCE]])</code></pre><p>列表操作</p>
<pre><code>LIST( APPEND|INSERT|LENGTH|GET| REMOVE_ITEM|REMOVE_AT|SORT ...)</code></pre><p>字符串操作</p>
<pre><code>STRING( TOUPPER|TOLOWER|LENGTH| SUBSTRING|REPLACE|REGEX ...)</code></pre><p>转换空格分隔的字符串到列表</p>
<pre><code>SEPARATE_ARGUMENTS( VAR )</code></pre><p>文件操作</p>
<pre><code>FILE( WRITE|READ|APPEND|GLOB| GLOB_RECURSE|REMOVE|MAKE_DIRECTORY ...)</code></pre><p>注意 CMAKE_INCLUDE_PATH</p>
<pre><code>FIND_FILE</code></pre><p>注意 CMAKE_INCLUDE_PATH</p>
<pre><code>FIND_PATH</code></pre><p>注意 CMAKE_LIBRARY_PATH</p>
<pre><code>FIND_LIBRARY
FIND_PROGRAM</code></pre><p>注意 CMAKE_MODULE_PATH</p>
<pre><code>FIND_PACKAGE</code></pre><p>执行外部程序</p>
<pre><code>EXEC_PROGRAM( bin [work_dir] ARGS &lt;..&gt; [OUTPUT_VARIABLE var] [RETURN_VALUE var] )</code></pre><p>设置选项</p>
<pre><code>OPTION( OPTION_VAR “description” [initial value] )</code></pre><p>##Ref</p>
<p>引用文档：</p>
<ol>
<li><a href="http://www.cmake.org/cmake/help/v3.0/manual/cmake-language.7.html#syntax" target="_blank" rel="noopener">cmake syntax</a></li>
<li><a href="http://www.cmake.org/Wiki/CMake_Useful_Variables" target="_blank" rel="noopener">CMake常用变量列表</a></li>
<li><a href="http://www.cmake.org/cmake/help/v3.0/manual/cmake-commands.7.html" target="_blank" rel="noopener">cmake command</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake语法简介</title>
    <url>/2015/03/03/cmake/</url>
    <content><![CDATA[<p>CMake意为cross-platform make，可用于管理c/c++工程。<br>CMake解析配置文件CMakeLists.txt生成Makefile，相比直接用Makefile管理工程，CMake更灵活和简单。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Cmake的输入是源码目录下的 ‘CMakeLists.txt’ 文件，或者后缀为’.cmake’。<br>这个文件可以用 ‘include’ 或者 ‘add_subdirectory’ 命令增加入其它的输入文件。组织结构有以下几部分组成：</p>
<ul>
<li><strong>Directories (CMakeLists.txt)</strong></li>
<li><strong>Scripts (&lt;script&gt;.cmake)</strong></li>
<li><strong>Modules (&lt;module&gt;.cmake)</strong></li>
</ul>
<h3 id="Directories"><a href="#Directories" class="headerlink" title="Directories"></a>Directories</h3><p>顶层目录下的 ‘CMakeLists.txt’ 文件可以使用命令 ‘add_subdirectory’ 来添加子目录，<br>此子目录下必须存在 ‘CMakeLists.txt’ 文件</p>
<pre><code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></pre><h3 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h3><p>脚本模式可以使用以下命令运行给定的CMake源文件中的命令，但是不会构建系统。</p>
<pre><code>cmake [&lt;options&gt;] (&lt;path-to-source&gt; | &lt;path-to-existing-build&gt;)
cmake [(-D&lt;var&gt;=&lt;value&gt;)...] -P &lt;cmake-script-file&gt;
cmake --build &lt;dir&gt; [&lt;options&gt;] [-- &lt;build-tool-options&gt;...]
cmake -E &lt;command&gt; [&lt;options&gt;]
cmake --find-package &lt;options&gt;...</code></pre><h3 id="Modeles"><a href="#Modeles" class="headerlink" title="Modeles"></a>Modeles</h3><p>使用命令 ‘include’ 来导入 ‘<module>.cmake’ 源文件</p>
<pre><code>include(&lt;file|module&gt; [OPTIONAL] [RESULT_VARIABLE &lt;VAR&gt;] [NO_POLICY_SCOPE])</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>使用7-bit ASCII进行编码，新行可使用 ‘\n’ 或 ‘\r\n’，将被转换为 ‘\n’ 做为输入文件读取</p>
<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p>CMakeList.txt文件是由注释、命令和空白字符组成。</p>
<h3 id="命令调用"><a href="#命令调用" class="headerlink" title="命令调用"></a>命令调用</h3><p>命令是由：命令名、（、空格分隔的参数、）组成。<br>‘CMakeLists.txt’ 文件中命令调用大小写不敏感的。 例如：</p>
<pre><code>command (args….)</code></pre><p>上面的command可以是一个命令名；或者是一个宏；也可以是一个函数名。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p>args是以空格分隔的参数例表（如果参数中包含空格，则要加双引号）</p>
<p>除了用于分隔参数的空白字符（空格、换行号、tabs）都是被忽略不计的。任何包含在双引号中的字符都做为一个参数。</p>
<p>三种参数类型：括号、引号和普通</p>
<p><strong>Bracket Argument</strong>:</p>
<pre><code>message([=[
This is the first line in a bracket argument with bracket length 1.
No \-escape sequences or ${variable} references are evaluated.
This is always one argument even though it contains a ; character.
The text does not end on a closing bracket of length 0 like ]].
It does end in a closing bracket of length 1.
]=])</code></pre><p><strong>Quoted Argument</strong>:</p>
<pre><code>message(&quot;This is a quoted argument containing multiple lines.
This is always one argument even though it contains a ; character.
Both \\-escape sequences and ${variable} references are evaluated.
The text does not end on an escaped double-quote like \&quot;.
It does end in an unescaped double quote.
&quot;)</code></pre><p>可以在行尾添加 ‘&#39; 进行行连接，例如：</p>
<pre><code>message(&quot;\
This is the first line of a quoted argument. \
In fact it is the only line but since it is long \
the source code uses line continuation.\
&quot;)</code></pre><p><strong>Unquoted Argument</strong>:</p>
<pre><code>foreach(arg
        NoSpace
        Escaped\ Space
        This;Divides;Into;Five;Arguments
        Escaped\;Semicolon
    )
    message(&quot;${arg}&quot;)
endforeach()</code></pre><p>前两种都是提供一个参数，而且不会进行转义，最后一个需要注意转义！</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>‘&#39;后跟的部分字符进行转义:</p>
<pre><code>escape_sequence  ::=  escape_identity | escape_encoded | escape_semicolon
escape_identity  ::=  &#39;\(&#39; | &#39;\)&#39; | &#39;\#&#39; | &#39;\&quot;&#39; | &#39;\ &#39; |
                    &#39;\\&#39; | &#39;\$&#39; | &#39;\@&#39; | &#39;\^&#39;
escape_encoded   ::=  &#39;\t&#39; | &#39;\r&#39; | &#39;\n&#39;
escape_semicolon ::=  &#39;\;&#39;</code></pre><p>‘(‘,’)’,’#’,’”‘,’ ‘,’&#39;,’$’,‘@’,’^’ 进行简单转义；’\t’ : tab ‘\r’ : return ‘\n’ : newline；’;‘ 用于参数中不表示隔离参数</p>
<h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>变量引用的形式为 ‘${variable_name}’，替换为变量的值，或空字符串（变量未赋值）。</p>
<p>变量引用可以嵌套，从内到外展开，例如 ‘${outer_${inner_variable}_variable}’</p>
<p>环境变量引用形式为 ‘$ENV{VAR}’</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释由一个不是 （括号中的参数、引用参数或’&#39;转义）一部分的’#’字符开始，有行注释和括号注释：</p>
<p>括号注释：</p>
<pre><code>#[[This is a bracket comment.
It runs until the close bracket.]]
message(&quot;First Argument\n&quot; #[[Bracket Comment]] &quot;Second Argument&quot;)</code></pre><p>行注释：</p>
<pre><code># This is a line comment.
message(&quot;First Argument\n&quot; # This is a line comment :)
        &quot;Second Argument&quot;) # This is a line comment.</code></pre><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="Conditional-Blocks"><a href="#Conditional-Blocks" class="headerlink" title="Conditional Blocks"></a>Conditional Blocks</h3><pre><code># some_command will be called if the variable&#39;s value is not:
# empty, 0, N, NO, OFF, FALSE, NOTFOUND, or -NOTFOUND. 
if(var)
    some_command(...)
elseif()
    some_command(...)
else()
    some_command(...)
endif() </code></pre><h3 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h3><pre><code>set(VAR a b c) 

# loop over a, b,c with the variable f 
foreach(f ${VAR}) 
    message(${f}) 
endforeach(f)

while(condition)
    command(args ...)
    command(args ...)
endwhile(condition)</code></pre><h3 id="Command-Definitions"><a href="#Command-Definitions" class="headerlink" title="Command Definitions"></a>Command Definitions</h3><p>macro()/endmacro() 和 function()/endfunction() 进行宏和函数的定义：</p>
<pre><code># define a macro hello 
macro(hello MESSAGE)
    message(${MESSAGE})
endmacro(hello) 

# call the macro with the string &quot;hello world&quot; 
hello(&quot;hello world&quot;) 

# define a function hello 
function(hello MESSAGE)
    message(${MESSAGE}) 
endfunction(hello)</code></pre><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>变量命名大小写敏感，set()/unset()对变量进行赋值操作：</p>
<pre><code>set (VAR &quot; hello world &quot;)   #赋值
unset (VAR)                 #取消赋值</code></pre><p>CMake支持简单的变量：字符串或字符串列表。用${VAR} 语法得到变量的引用。</p>
<p>可以用一个set命令把一个字符串列表设置为一个变量，然后把这个变量传递给需要传递多参数的函数。例如：</p>
<pre><code>set(Foo a b c)
command(${Foo})</code></pre><p>上面两行等效 </p>
<pre><code>command(a b c)</code></pre><p>如果你想传把一个字符串列表做为一个单独的参数传递给函数，用双引号包含它。例如：</p>
<pre><code>Command(“${Foo}”)
#等效于
command(“a b c”)</code></pre><p>环境变量：</p>
<p>用$ENV{VAR}得到环境变量的引用</p>
<p>设置环境变量：</p>
<p>Set(ENV{VAR} /home)</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>字符串(string)和字符串列表（lists）</p>
<p>CMake的基本数据类型是字符串（string）。<br>CMake也支持由字符串组成的字符串列表。字符串列表可以由；或空格分隔的组成。例如：下面设置变量var是等效的。</p>
<pre><code>set(var a;b;c)
set(var a b c)</code></pre><p>字符串列表可以用 foreach命令叠代（iterated）或list命令操作。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>一些CMake命令（如if和 string），能使用正则表达式或使用正则表达式作为参数。<br>一个简单的形式，一个正则表达式用于在一个序列的字符串中精确查找一个字符。<br>然而在大多时候，一个精确查找是不知道的或者只是匹配最前或者最后字符。<br>所以这里用正则表达式进行不同的转换。<br>Cmake标准是可被描述的。这个描述是基于开源的正则表达式类（Texas Instruments）。</p>
<ul>
<li>^ 匹配一行或一字符串开头</li>
<li>$匹配一行或一字符串结尾</li>
<li>.匹配单一字符或一个新行</li>
<li>[ ]匹配括号中的任一字符</li>
<li>[^ ] 匹配不在括号内的任一字符</li>
<li>[-] 匹配指定范围内的字符</li>
<li>* 匹配0次或多次</li>
<li>+ 匹配一次或多次</li>
<li>? 匹配0次或一次</li>
<li>()保存匹配的表达式并用随后的替换它</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="http://www.cmake.org/cmake/help/v3.0/manual/cmake-language.7.html#syntax" target="_blank" rel="noopener">cmake syntax</a></li>
<li><a href="http://www.cmake.org/cmake-tutorial/" target="_blank" rel="noopener">cmake tutorial</a></li>
<li><a href="http://www.cmake.org/Wiki/CMake_Useful_Variables" target="_blank" rel="noopener">CMake常用变量列表</a></li>
<li><a href="http://www.cmake.org/documentation/" target="_blank" rel="noopener">CMake文档列表</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux libcurl学习</title>
    <url>/2015/03/01/libcurl/</url>
    <content><![CDATA[<h3 id="http-使用curl发起https请求"><a href="#http-使用curl发起https请求" class="headerlink" title="http 使用curl发起https请求"></a><strong>http 使用curl发起https请求</strong></h3><h4 id="设定为不验证证书和host。"><a href="#设定为不验证证书和host。" class="headerlink" title="设定为不验证证书和host。"></a>设定为不验证证书和host。</h4><pre><code>curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);</code></pre><h4 id="设定一个正确的证书。"><a href="#设定一个正确的证书。" class="headerlink" title="设定一个正确的证书。"></a>设定一个正确的证书。</h4><pre><code>curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,true); ;
curl_setopt($ch,CURLOPT_CAINFO,dirname(__FILE__).&#39;/cacert.pem&#39;);</code></pre><ol>
<li><a href="http://curl.haxx.se/libcurl/c/" target="_blank" rel="noopener">libcurl-api</a></li>
<li><a href="http://curl.haxx.se/libcurl/c/libcurl-tutorial.html" target="_blank" rel="noopener">libcurl-tutorial</a></li>
<li><a href="http://blog.csdn.net/jgood/article/details/4787670" target="_blank" rel="noopener">libcurl教程</a></li>
<li><a href="http://blog.csdn.net/ljob2006/article/details/4390612" target="_blank" rel="noopener">LibCurl编程</a></li>
<li><a href="http://blog.csdn.net/ljob2006/article/details/4390707" target="_blank" rel="noopener">libcurl调试程序</a></li>
<li><a href="http://finux.iteye.com/blog/715247" target="_blank" rel="noopener">使用libcurl提交POST请求</a></li>
<li><a href="http://blog.chinaunix.net/uid-22312037-id-4209472.html" target="_blank" rel="noopener">使用libcurl C接口之Easy接口 </a></li>
<li><a href="http://www.groad.net/bbs/thread-4455-1-1.html" target="_blank" rel="noopener">curl跟随重定向页面</a></li>
<li><a href="http://unitstep.net/blog/2009/05/05/using-curl-in-php-to-access-https-ssltls-protected-sites/" target="_blank" rel="noopener">Using cURL in PHP to access HTTPS (SSL/TLS) protected sites</a></li>
<li><a href="http://www.happylivelife.com/r/?id=381" target="_blank" rel="noopener">libcurl 接口调用方式</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_502d765f0101c50p.html" target="_blank" rel="noopener">CURL并发–multi perform模式</a></li>
<li><a href="http://www.xobm.com/php/id-321-page-1.html" target="_blank" rel="noopener">curl详细解说</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux GDB 调试命令</title>
    <url>/2015/02/28/Linux-gdb-commands/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>


<h3 id="Set-Break"><a href="#Set-Break" class="headerlink" title="Set Break"></a><strong>Set Break</strong></h3><p>断点命令（break）缩写为<em>b</em>，格式如下：</p>
<ul>
<li>break function        : b main </li>
<li>break line            : b 256</li>
<li>break file:line       : b app_main.c:256</li>
<li>break file:function   : b app_main.c:main</li>
<li>break +offset         : b +3</li>
<li>break -offset         : b -3</li>
<li>break *addr           : b *0x0811efd4</li>
</ul>
<h3 id="Set-Catch"><a href="#Set-Catch" class="headerlink" title="Set Catch"></a><strong>Set Catch</strong></h3><p>catch point作用是让程序在发生某种事件的时候停止运行。设置events如下：</p>
<ul>
<li>catch assert – Catch failed Ada assertions</li>
<li>catch catch – Catch an exception</li>
<li>catch exception – Catch Ada exceptions</li>
<li>catch exec – Catch calls to exec</li>
<li>catch fork – Catch calls to fork</li>
<li>catch syscall – Catch system calls by their names and/or numbers</li>
<li>catch throw – Catch an exception</li>
<li>catch vfork – Catch calls to vfork</li>
</ul>
<h3 id="Show-Backtrace"><a href="#Show-Backtrace" class="headerlink" title="Show Backtrace"></a><strong>Show Backtrace</strong></h3><p>backtrace命令可以断点处执行显示栈帧，简写为<em>bt<em>，别名有</em>where</em> &amp; <em>info stack</em>，格式如下：</p>
<ul>
<li>bt        : show all</li>
<li>bt N      : show start N</li>
<li>bt -N     : show end N</li>
<li>bt full   : show all &amp; locals</li>
</ul>
<p>查看桢信息：</p>
<ul>
<li>frame n: 查看第n桢的信息， frame可以用f缩写</li>
<li>frame addr: 查看pc地址为addr的桢的相关信息</li>
<li>up n: 查看当前桢上面第n桢的信息</li>
<li>down n: 查看当前桢下面第n桢的信息</li>
</ul>
<p>查看更加详细的信息：</p>
<ul>
<li>info frame</li>
<li>info frame n</li>
<li>info frame addr</li>
</ul>
<p>示例如下：</p>
<pre><code>(cskygdb) info frame 1
Stack frame at 0x32aa9518:
pc = 0x4ce00 in app_ott_vod_detail_create_exec (ott/app_ott_vod_detail.c:606); saved pc 0x49fee
called by frame at 0x32aa9538, caller of frame at 0x32aa9500
source language c.
Arglist at 0x32aa9500, args: nAlbumNo=0, pName=0xa916d0 &quot;危险关系&quot;, pPic=0x96e628 &quot;/tmp/6C880089F646D38.jpg&quot;, 
        pVid=0xa916a8 &quot;706afed05f&quot;
        Locals at 0x32aa9500, Previous frame&#39;s sp is 0x32aa9518
        Saved registers:
        r8 at 0x32aa9514, r15 at 0x32aa9510, pc at 0x32aa9510</code></pre><p>上图中显示的信息有：</p>
<ul>
<li>当前桢的地址: 0x32aa9518</li>
<li>当前桢PC: pc = 0x4ce00</li>
<li>当前桢函数： app_ott_vod_detail_create_exec (ott/app_ott_vod_detail.c:606)</li>
<li>caller桢的PC: saved pc 0x49fee</li>
<li>caller桢的地址: called by frame at 0x32aa9538</li>
<li>callee桢的地址: caller of frame at 0x32aa9500</li>
<li>源代码所用的程序的语言(c/c++): source language c</li>
<li>当前桢的参数的地址及值: Arglist at at 0x32aa9500, args: nAlbumNo=0, pName=0xa916d0 “危险关系”, pPic=0x96e628 “/tmp/6C880089F646D38.jpg” …</li>
<li>当前相中局部变量的地址：Locals at 0x32aa9500, Previous frame’s sp is 0x32aa9518</li>
<li>. 当前桢中存储的寄存器： Saved registers: r8 at 0x32aa9514, r15 at 0x32aa9510, pc at 0x32aa9510</li>
</ul>
<p>info args：查看当前桢中的参数</p>
<pre><code>(cskygdb) info args
window_name = 0x5650a8 &quot;wnd_ott_vod_detail&quot;</code></pre><p>info locals：查看当前桢中的局部变量</p>
<pre><code>(cskygdb) info locals 
widget = 0x0
window = 0x0</code></pre><p>info catch：查看当前桢中的异常处理器（exception handlers）</p>
<pre><code>(cskygdb) info catch 
print_frame_label_vars disabled.</code></pre><p>示例2：</p>
<pre><code>(cskygdb) info frame 3
Stack frame at 0x32aa9550:
pc = 0x4a40c in app_ott_vod_keypress (ott/app_ott_vod.c:489); saved pc 0x11cd86
called by frame at 0x32aa9568, caller of frame at 0x32aa9538
source language c.
Arglist at 0x32aa9538, args: widgetname=0x6c44d0 &quot;wnd_ott_vod&quot;, usrdata=0x32aa963c
Locals at 0x32aa9538, Previous frame&#39;s sp is 0x32aa9550
Saved registers:
r8 at 0x32aa954c, r15 at 0x32aa9548, pc at 0x32aa9548
(cskygdb) frame 3
#3  0x0004a40c in app_ott_vod_keypress (widgetname=0x6c44d0 &quot;wnd_ott_vod&quot;, usrdata=0x32aa963c) at ott/app_ott_vod.c:489
489             app_ott_page_ok_keypress(find_virtualkey(event-&gt;key.scancode));
(cskygdb) info args 
widgetname = 0x6c44d0 &quot;wnd_ott_vod&quot;
usrdata = 0x32aa963c
(cskygdb) info locals 
event = 0x32aa963c
__FUNCTION__ = &quot;app_ott_vod_keypress&quot;
(cskygdb) info catch 
print_frame_label_vars disabled.</code></pre><h3 id="Show-Variable-amp-Registers"><a href="#Show-Variable-amp-Registers" class="headerlink" title="Show Variable &amp; Registers"></a><strong>Show Variable &amp; Registers</strong></h3><p>print命令可以显示变量，简写为<em>p</em>。</p>
<p>info registers可以显示寄存器，简写为info reg。</p>
<p>在寄存器名之前添加$，可以显示寄存器内容：</p>
<pre><code>p &amp;pc</code></pre><p>支持的格式如下：</p>
<ul>
<li>x     : 十六进制</li>
<li>d     : 十进制</li>
<li>u     : 无符号十进制</li>
<li>o     : 八进制</li>
<li>t     : 二进制</li>
<li>a     : 地址</li>
<li>c     : ASCII</li>
<li>f     : 浮点</li>
<li>s     : 字符串</li>
</ul>
<p>用<em>x</em>命令可以显示内存内容，支持以上格式之外还支持：</p>
<pre><code>i : 显示为汇编语言</code></pre><p>使用<em>x</em>命令格式为 <em>x/NFU ADDR</em>，参数意义如下：</p>
<ul>
<li>ADDR  : 希望显示的地址</li>
<li>N     : 重复次数</li>
<li>F     : 支持格式(x,d,u,o,t,a,c,f,s,i)</li>
<li>U     : 单位，下所示<ul>
<li>b : 字节</li>
<li>h : 半字（2字节） </li>
<li>w : 字（4字节，默认值）</li>
<li>g : 双字（8字节）</li>
</ul>
</li>
</ul>
<p>反汇编存在命令：<strong>disassemble</strong></p>
<p><strong>show value</strong>命令显示历史中的最后10个值</p>
<h3 id="attach到进程"><a href="#attach到进程" class="headerlink" title="attach到进程"></a><strong>attach到进程</strong></h3><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a><strong>条件断点</strong></h3><p>使用格式如下：</p>
<pre><code>break 断点 if 条件</code></pre><p>例如：</p>
<pre><code>b main if mode==1</code></pre><p>使用condition可以给已存在的断点添加或删除触发条件：</p>
<pre><code>condition Bn
condition Bn 条件</code></pre><h3 id="反复执行"><a href="#反复执行" class="headerlink" title="反复执行"></a><strong>反复执行</strong></h3><p>在指定的断点、监控点或捕获点忽略指定次数，格式如下：</p>
<pre><code>ignore Bn N</code></pre><p>类似命令如下：</p>
<ul>
<li>continue N</li>
<li>step N</li>
<li>stepi N</li>
<li>next N</li>
<li>nexti N</li>
<li>finish</li>
<li>until</li>
<li>until ADDR</li>
</ul>
<h3 id="断点命令"><a href="#断点命令" class="headerlink" title="断点命令"></a><strong>断点命令</strong></h3><p>指定程序在某个breakpoint处停下来后执行一串命令，格式：</p>
<pre><code>commands [bnum]
… command-list …
end</code></pre><p>指定程序在第bnum个breakpoint处停下来后，执行由command-list指定的命令串，<br>如果没有指定bnum，则对最后一个breakpoint生效，例子：</p>
<pre><code>break foo if x&gt;0
commands
silent
printf “x is %d\n”,x
continue
end</code></pre><p>上面的例子含义：当x&gt;0时，在foo函数处停下来，然后打印出x的值，然后继续运行程序</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>并行计算初识</title>
    <url>/2014/12/15/parallel-computing/</url>
    <content><![CDATA[<ul>
<li><strong>MPI</strong>:英文全称是Message Passing Interface，这个就很明了了，信息传递接口，是独立于语言的通信协议（标准），是一个库。<br>MPI的实现有MPICH，MPI-1，MPI-2等等</li>
<li><strong>openMPI</strong>：英文全称是open Message Passing Interface。openMPI是MPI的一种实现，一种库项目</li>
<li><strong>OpenMP</strong>：英文全称是Open Multiprocessing，一种应用程序界面（API，即Application Program Interface），<br>是一种并行的实现和方法，也可以认为是共享存储结构上的一种编程模型，<br>可用于共享内存并行系统的多线程程序设计的一套指导性注释（Compiler Directive）。</li>
</ul>
<p>在当前的并行机子中，openMP和openMPI都是需要的（从上面的各自概念可以看出），<br>openMP用于本地的并行计算（共享内存内存架构），<br>支持目前所有平台上的c,fortran等的共享内存式并行计算，<br>它相当于是给出了一个让并行编程更加容易实现的模型，<br>而openMPI则是用于机器之间的通信（分布式内存架构）。</p>
<h3 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a><strong>OpenMP</strong></h3><p>简单。不用大改源程序，直接加#pragma就行了。<br>只适用于共享式内存。比如一台电脑，4核cpu共享16G内存，可以用Openmp启动4核同时计算。</p>
<p>OpenMP:线程级（并行粒度）；共享存储；隐式（数据分配方式）；可扩展性差；</p>
<h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a><strong>MPI</strong></h3><p>稍复杂。需要重新设计程序，学习成本稍高。</p>
<p>MPI：进程级；分布式存储；显式；可扩展性好。</p>
<p><strong>OpenMP采用共享存储，意味着它只适应于SMP,DSM机器，不适合于集群。MPI虽适合于各种机器，但它的编程模型复杂</strong></p>
<p>在并行计算领域内，主要的并行编程模型有三类模型：<br>数据并行、消息传递、共享变量。<br>其中基于消息传递的 MPI 编程模型和基于共享变量的 OpenMP 编程模型是最为流行的并行编程模型。<br>openmp比较简单，修改现有的大段代码也容易。<br>基本上openmp只要在已有程序基础上根据需要加并行语句即可。<br>而mpi有时甚至需要从基本设计思路上重写整个程序，调试也困难得多，涉及到局域网通信这一不确定的因素。<br>不过，openmp虽然简单却只能用于单机多CPU/多核并行，mpi才是用于多主机超级计算机集群的强悍工具，当然复杂。</p>
<h3 id="MPI＝message-passing-interface"><a href="#MPI＝message-passing-interface" class="headerlink" title="MPI＝message passing interface"></a><strong>MPI＝message passing interface</strong></h3><p>在分布式内存（distributed-memory）之间实现信息通讯的一种 规范/标准/协议（standard）。<br>它是一个库，不是一门语言。可以被fortran，c，c++等调用。<br>MPI 允许静态任务调度，显示并行提供了良好的性能和移植性，用 MPI 编写的程序可直接在多核集群上运行。<br>在集群系统中，集群的各节点之间可以采用 MPI 编程模型进行程序设计，<br>每个节点都有自己的内存，可以对本地的指令和数据直接进行访问，<br>各节点之间通过互联网络进行消息传递，这样设计具有很好的可移植性，<br>完备的异步通信功能，较强的可扩展性等优点。<br>MPI 模型存在一些不足，包括：程序的分解、开发和调试相对困难，<br>而且通常要求对代码做大量的改动；<br>通信会造成很大的开销，为了最小化延迟，通常需要大的代码粒度；<br>细粒度的并行会引发大量的通信；动态负载平衡困难；并行化改进需要大量地修改原有的串行代码，调试难度比较大</p>
<h3 id="MPICH和OpenMPI"><a href="#MPICH和OpenMPI" class="headerlink" title="MPICH和OpenMPI"></a><strong>MPICH和OpenMPI</strong></h3><p>它们都是采用MPI标准，在并行计算中，实现节点间通信的开源软件。各自有各自的函数，指令和库。</p>
<p>Reference:</p>
<p>They are two implementations of the MPI standard.<br>In the late 90s and early 2000s, there were many different MPI implementations,<br>and the implementors started to realize they were all re-inventing the wheel;<br>there was something of a consolidation.<br>The LAM/MPI team joined with the LA/MPI, FT-MPI, and eventually PACX-MPI teams to develop OpenMPI.<br>LAM MPI stopped being developed in 2007.<br>The code base for OpenMPI was completely new,<br>but it brought in ideas and techniques from all the different teams.</p>
<p>Currently, the two major open-source MPI implementation code-bases are OpenMPI and MPICH2.</p>
<p>而MPICH2是MPICH的一个版本。</p>
<p>有的计算机厂商，也会针对旗下机型特点，自主开发基于MPICH的MPI软件，从而使机器的并行计算效率得以提高。</p>
<h3 id="OpenMP-1"><a href="#OpenMP-1" class="headerlink" title="OpenMP"></a><strong>OpenMP</strong></h3><p>在节点内（多核 SMP）执行的基于共享内存的编程模型。</p>
<p>OpenMP是针对单主机上多核/多CPU并行计算而设计的工具，<br>换句话说，OpenMP更适合单台计算机共享内存结构上的并行计算。<br>由于使用线程间共享内存的方式协调并行计算，<br>它在多核/多CPU结构上的效率很高、内存开销小、编程语句简洁直观，<br>因此编程容易、编译器实现也容易（现在最新版的C、C++、Fortran编译器基本上都内置OpenMP支持）。<br>不过OpenMP最大的缺点是只能在单台主机上工作，不能用于多台主机间的并行计算</p>
<p>MPI 负责节点之间的通信（集群系统中的单个计算机通常称为节点）<br>OpenMP负责节点中多核CPU的计算<br>CUDA负责节点中gpu上的计算</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>异步非阻塞I/O</title>
    <url>/2014/12/15/aio/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p>对I/O操作的分类主要基于时间和占有两个角度进行划分：<br>从时间角度可分为同步操作和异步操作；<br>从资源占有角度可分为阻塞操作和非阻塞操作。<br>从而UNXI可以构造出4种不同的I/O操作模型：</p>
<ul>
<li><strong>同步阻塞I/O</strong></li>
<li><strong>同步非阻塞I/O</strong></li>
<li><strong>异步阻塞I/O</strong></li>
<li><strong>异步非阻塞I/O</strong>，AIO</li>
</ul>
<p>AIO是将I/O操作与应用程序的计算操作重叠执行的一种模型，即实现I/O操作与计算操作的有效分离。<br>AIO背后的基本思想是允许进程发起很多I/O操作，而不用阻塞或等待任何操作完成。<br>异步非阻塞I/O模型是一种处理与I/O重叠进行的模型。<br>读请求会立即返回，说明read请求已经成功发起了。<br>在后台完成读操作时，应用程序然后会执行其他处理操作。<br>当read的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。</p>
<p><img src="http://www.myexception.cn/img/2013/08/08/103815107.gif" alt=""></p>
<p>在一个进程中为了执行多个I/O请求而对计算操作和I/O处理进行重叠处理的能力利用了处理速度与 I/O 速度之间的差异。<br>当一个或多个I/O请求挂起时，CPU可以执行其他任务；<br>或者更为常见的是，在发起其他I/O的同时对已经完成的I/O进行操作。</p>
<p>AIO在当前Linux下主要有两种AIO实现技术：一种是glibc库函数实现，另一种是Linux内核实现，并由libaio库进行封装</p>
<p>glibc库中的AIO实现，需要在编译时<code>-lrt</code>：</p>
<pre><code>#include &lt;aio.h&gt;

//请求异步读操作
int aio_read(struct aiocb *aiocbp);
//检查异步请求的状态
int aio_error(const struct aiocb *aiocbp);
//获得完成的异步请求的返回状态
ssize_t aio_return(struct aiocb *aiocbp);
//请求异步写操作
int aio_write(struct aiocb *aiocbp);
//挂起调用进程，直到一个或多个异步请求已经完成（或失败）
int aio_suspend(const struct aiocb * const aiocb_list[],
                int nitems, const struct timespec *timeout);
//取消异步 I/O 请求
int aio_cancel(int fd, struct aiocb *aiocbp);
//发起一系列 I/O 操作
int lio_listio(int mode, struct aiocb *const aiocb_list[],
                int nitems, struct sigevent *sevp);</code></pre><p>在异步非阻塞I/O中，我们可以同时发起多个传输操作。<br>这需要每个传输操作都有惟一的上下文，<br>这样我们才能在它们完成时区分到底是哪个传输操作完成了。<br>在 AIO 中，这是一个 aiocb（AIO I/O Control Block）结构。<br>这个结构包含了有关传输的所有信息，包括为数据准备的用户缓冲区。<br>在产生 I/O （称为完成）通知时，aiocb 结构就被用来惟一标识所完成的 I/O 操作。<br>定义如下：</p>
<pre><code>#include &lt;aiocb.h&gt;

struct aiocb {
    /* The order of these fields is implementation-dependent */

    int             aio_fildes;     /* File descriptor */
    off_t           aio_offset;     /* File offset */
    volatile void  *aio_buf;        /* Location of buffer */
    size_t          aio_nbytes;     /* Length of transfer */
    int             aio_reqprio;    /* Request priority */
    struct sigevent aio_sigevent;   /* Notification method */
    int             aio_lio_opcode; /* Operation to be performed;
                                    lio_listio() only */

    /* Various implementation-internal fields not shown */
};</code></pre><p>sigevent 结构告诉 AIO 在 I/O 操作完成时应该执行什么操作。<br>我们将在 AIO 的展示中对这个结构进行探索。<br>现在我们将展示各个 AIO 的 API 函数是如何工作的，以及我们应该如何使用它们。</p>
<p>AIO通知：通过信号实现异步通知和通过函数回调来实现</p>
<ol>
<li><a href="http://blog.csdn.net/yfkiss/article/details/7516589" target="_blank" rel="noopener">网络编程–IO模型示例</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="noopener">使用异步 I/O 大大提高应用程序的性能</a></li>
<li><a href="http://www.wzxue.com/linux-kernel-aio%E8%BF%99%E4%B8%AA%E5%A5%87%E8%91%A9/" target="_blank" rel="noopener">Linux kernel AIO这个奇葩</a></li>
<li><a href="http://nicedayyep.iteye.com/blog/89773" target="_blank" rel="noopener">Linux下的服务器开发模型 Epoll和AIO的讨论</a></li>
<li><a href="http://blog.csdn.net/sparkliang/article/details/4836536" target="_blank" rel="noopener">Epoll vs. IOCP</a></li>
<li><a href="http://bbs.chinaunix.net/thread-1942420-1-1.html" target="_blank" rel="noopener">异步,epoll和aio</a></li>
</ol>
<p>转载：</p>
<p><strong>异步IO</strong>就是把IO提交给系统，让系统替你做，做完了再用某种方式通知你(通过信号，或者其他异步方式<br>通知，这时候，操作系统已经帮你完成IO操作，具体来说就是你那个作为传入参数的的buffer的指针所指向<br>的空间已经读到了数据或者你的buffer的数据已经写出去了）；</p>
<p><strong>非阻塞IO</strong>就是你要通过某种方式不定时地向系统询问你是否可以开始做某个IO( 轮询啊 )，当可以开始<br>后，是要自己来完成IO(也就是说还要自己调用一次read来填充buffer或者write来不buffer的数据写出去)；</p>
<p><strong>epoll和aio（这里的aio是指linux 2.6内核后提供的aio api）区别：</strong></p>
<p>aio是异步非阻塞的。其实是aio是用线程池实现了异步IO。</p>
<p>epoll在这方面的定义上有点复杂，首先epoll的fd集里面每一个fd都是非阻塞的，但是epoll（还<br>select poll ）在调用时阻塞等待fd可用，然后epoll只是一个异步通知机制，只是在fd可用时通知你，并<br>没有做任何IO操作，所以不是传统的异步。</p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC静态库链接顺序</title>
    <url>/2014/12/14/Linux-ld/</url>
    <content><![CDATA[<p>工程中遇到问题，修改配置文件之后发现编译不过，部分符号未定义，检查Makefile如下：</p>
<pre><code>LDFLAGS += -lui -lenca -lxml -lgxbox -lstdc++ -ljansson -lcurl
...
LDFLAGS += -L$(GXSRC_PATH)/lib/$(THIRD_LIB)/ -lkolatv -lpcre</code></pre><p>其中<strong>kolatv库</strong>需要调用<strong>jansson库</strong>，<strong>gxbox库</strong>也需要调用<strong>jansson库</strong>。</p>
<p>在修改配置文件之前，开启了gxbox的支持，在编译中需要链接gxbox库，从而jansson库可以链接成功。</p>
<p>在修改配置文件之后，关闭了gxbox的支持，在编译中不会编译gxbox代码，gxbox库链接失败，<br>从而jansson库链接失败，在载入kolatv库时不存在jansson库的符号表。</p>
<p>GCC：</p>
<p>-l library</p>
<p>Search the library named library when linking.<br>(The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.)</p>
<p>It makes a difference where in the command you write this option;<br>the linker searches and processes libraries and object files in the order they are specified.<br>Thus, <code>foo.o -lz bar.o&#39; searches library</code>z’ after file foo.o but before bar.o.<br>If bar.o refers to functions in `z’, those functions may not be loaded.</p>
<p><strong>因此，在链接过程中，链接的库，一定要在使用该库的目标被连接之后，基本的库要放在最后。</strong></p>
<p>修改如下：</p>
<pre><code>LDFLAGS += -lui -lenca -lxml -lkolatv -lgxbox -lstdc++ -ljansson -lcurl</code></pre>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>ld</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统调用</title>
    <url>/2014/12/14/Linux-system-programming-syscall/</url>
    <content><![CDATA[<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p>计算机系统内存分为系统空间和用户空间。通常，用户是不能够直接访问系统空间、调用系统函数的，<br>但用户可以通过<strong>系统调用</strong>进入内核空间，获取内核服务。</p>
<p>用户进程对系统函数的成功调用，将进行相应的用户空间到系统空间的转换。<br>进入内核后，不同的系统调用会找到各自对应的内核函数入口地址，<strong>由内核函数提供服务</strong>。</p>
<p>以调用系统调用fork()来分析如下：</p>
<p><img src="http://images.51cto.com/files/uploadimg/20090603/163946908.jpg" alt="fork()系统调用"></p>
<p>从图中我们可以看出，调用fork()实际上是调用了中断0x80，通过事先初始化好的IDT，<br>程序转移到了_system_call，最终通过一个函数指针数组sys_call_table[]转化成了调用sys_fork()。</p>
<p>系统调用起到了连接用户进程和操作系统的桥梁作用，由于桥两端处于不同的态，因此需要使用中断来过渡。</p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
  </entry>
  <entry>
    <title>动态库的显式调用</title>
    <url>/2014/12/14/dlopen/</url>
    <content><![CDATA[<p>动态链接库在使用时，分为“隐式调用”和“显式调用”两种:</p>
<p>1.如果是隐式调用，则与静态库的使用方法差不多，注意需要包含导出函数的头文件，即mylib.h：</p>
<pre><code>#include ...
#include &quot;mylib.h&quot;

int main()
{
    Print();
}</code></pre><p>编译方法：</p>
<pre><code>gcc -o main main.c -L./ mylib.so</code></pre><p>注意要加上动态链接库的搜索路径，否则编译器只会到系统路径中去寻找。</p>
<p>2.显式调用的方式，不必包含mylib.h，但是需要增加几个系统调用：</p>
<pre><code>#include ...
#include  &lt;dlfcn.h&gt;// 显式加载需要用到的头文件

int main()
{
    void *pdlHandle = dlopen(&quot;./mylib.so&quot;, RTLD_LAZY); // RTLD_LAZY 延迟加载
    char *pszErr = dlerror();
    if( !pdlHandle || pszErr )
    {
        printf(&quot;Load mylib failed!n&quot;)
            return 1;
    }

    void (*Print)() = dlsym(pdlHandle, &quot;Print&quot;); // 定位动态链接库中的函数
    if( !Print )
    {
        pszErr = dlerror();
        printf(&quot;Find symbol failed!%sn&quot;, pszErr);
        dlclose(pdlHandle);
        return 1;
    }

    Print(); // 调用动态链接库中的函数

    dlclose(pdlHandle); // 系统动态链接库引用数减1

    return 0;
}</code></pre><p>可以看到，显式调用的代码看上去要复杂很多，但是却比隐式调用要灵活，<br>不必在编译时就确定要加载哪个动态链接库，可以在运行时再确定，甚至重新加载。</p>
<p>看一下显式调用的编译方式：</p>
<pre><code>gcc -ldl -o main main.c</code></pre><p>注意要添加-ldl选项，以使用显式调用相关的函数调用</p>
<p>手动加载动态链接库dlopen dlsym dlcolose</p>
<p><strong>打开动态链接库</strong>：</p>
<pre><code>#include &lt;dlfcn.h&gt;
void *dlopen(const char *filename, int flag);</code></pre><p>该函数返回操作句柄，如：</p>
<pre><code>void *pHandle = dlopen(strSoFilePath, RTLD_LAZY);</code></pre><p><strong>取动态对象地址</strong>：</p>
<pre><code>#include &lt;dlfcn.h&gt;
void *dlsym(void *pHandle, char *symbol);</code></pre><p>dlsym根据动态链接库操作句柄(<code>pHandle</code>)与符号(<code>symbol</code>),返回符号对应的地址。<br>使用这个函数不但可以获取函数地址，也可以获取变量地址。比如，假设在so中<br>定义了一个<code>void mytest()函数</code>，那在使用so时先声明一个函数指针：<br><code>void (*pMytest)()</code>,然后使用dlsym函数将函数指针pMytest指向mytest函数，<br><code>pMytest = (void (*)())dlsym(pHandle, &quot;mytest&quot;)</code>;</p>
<p><strong>关闭动态链接库</strong>：</p>
<pre><code>#include &lt;dlfcn.h&gt;
int dlclose(void *handle);</code></pre><p>该函数将该.so的引用计数减一，当引用计数为0时，将它从系统中卸载。</p>
<p><strong>动态库错误函数</strong>：</p>
<pre><code>#include &lt;dlfcn.h&gt;
const char *dlerror(void);</code></pre><p>当动态链接库操作函数执行失败时，dlerror可以返回出错信息，返回值为NULL时   表示没有错误信息。</p>
<p>在取到函数执行地址后，就可以在动态库的使用程序里根据动态库提供的函数接口调用动态库里的函数。<br>在编写调用动态库的程序的Makefile文件时，需要加入编译选-ldl。</p>
<p>从<code>void *dlsym(void *handle, char *symbol)</code> 的参数可以看出，<br>该函数只传两个参数：一个指向so的handle和一个函数的symbol，<br>所以so里面的函数应该不允许重载，否则根据一个symbol不能确定指向那个函数。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>网络编程Socket</title>
    <url>/2014/12/14/socket/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>网络中的进程通常由一个三元组来标识，包括<strong>协议、本地地址和端口</strong>。</p>
<p><strong>主机字节次序与网络字节次序</strong></p>
<p>对于一个4字节的整数：<code>0x11223344</code>，占用四个字节存储单元，在主机中有两种<strong>主机字节次序</strong>：</p>
<hr>
<table border="1" width="400" frame="hsides" rules="rows">
    <tr>
        <td></td>
        <td>Bytes3</td>
        <td>Bytes2</td>
        <td>Bytes1</td>
        <td>Bytes0</td>
    </tr>
    <tr>
        <td>Little Endian :</td>
        <td>11</td>
        <td>22</td>
        <td>33</td>
        <td>44</td>
    </tr>
    <tr>
        <td>Big Endian :</td>
        <td>44</td>
        <td>33</td>
        <td>22</td>
        <td>11</td>
    </tr>
</table>

<hr>
<p>x86采用小端方式，PowerPC和Sparc采用大端方式。<br>为了保证互连性，要求所有的数据按照统一字节顺序传输，于是出现了<strong>网络字节次序</strong>，规定与x86的主机字节次序相反。</p>
<p>在UNIX中提供如下API用于转换：</p>
<pre><code>#include &lt;arpa/inet.h&gt;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);</code></pre><p>进程经网络通信时，有两种方法可以选择：</p>
<ul>
<li><p><strong>面向连接方式</strong>，就是通信双方在通信时，要事先建立一条通信线路，<br>其过程有建立连接、使用连接和释放连接三个过程。<br>TCP协议就是一种面向连接服务的协议，电话系统是一个面向连接的模式。</p>
</li>
<li><p><strong>无连接方式</strong>，就是通信双方不需要事先建立一条通信线路，<br>而是把每个带有目的地址的包（报文分组）送到线路上，由系统选定路线进行传输。<br>IP、UDP协议就是一种无连接协议，邮政系统是一个无连接的模式。</p>
<p>  #include &lt;sys/types.h&gt;          /* See NOTES */<br>  #include &lt;sys/socket.h&gt;</p>
<p>  int socket(int domain, int type, int protocol);</p>
</li>
</ul>
<p>Socket类型：</p>
<ul>
<li><strong>流套接字，SOCK_STREAM，用于提供面向连接、可靠的数据传输服务</strong></li>
<li><strong>数据包套接字，SOCK_DGRAM，用于提供无连接服务，不能保证数据的可靠性</strong></li>
<li><strong>原始套接字，SOCK_RAW</strong></li>
</ul>
<p>Raw socket与标准套接字（SOCK_STREAM、SOCK_DGRAM）的区别：</p>
<p>raw socket可以读写内核没有处理的IP数据包，而流套接字只能读取TCP数据，数据包套接字只能读取UDP数据。<br>使用raw socket可以避开TCP/IP处理机制，被传送的数据包可以被直接传送给需要它的应用程序。</p>
<p>raw socket植根于操作系统网络核心（Network Core），而标准socket则“悬浮”于TCP和UDP协议的外围。</p>
<p>套接字寻址API：</p>
<pre><code>include &lt;netdb.h&gt;

//获取主机名和IP地址
struct hostent *gethostbyname(const char *name);
struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);
//获取服务与端口地址
struct servent *getservbyname(const char *name, const char *proto);
struct servent *getservbyport(int port, const char *proto);</code></pre><p>套接字选项API：</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

//获取套接字选项的设置情况
int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
//设置套接字选项
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</code></pre><p>套接字API：</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t addrlen);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
int shutdown(int sockfd, int how);</code></pre><p>bind函数使用通用地址结构<code>struct sockaddr</code>来设置套接字地址，<br>而在网络通信时必须使用<code>sockaddr_in</code>来构造一个套接字地址，<br>所以，调用bind时，需要将<code>sockaddr_in</code>结构类型强制转换为<code>struct sockaddr</code>结构类型。</p>
<p>listen函数仅被TCP服务器调用。当函数<code>socket</code>创建一个套接字时，它被假设为一个主动套接字，<br>listen将此套接字转换为被动套接字，指示内核应接受向此套接字的连接请求，<br>同时维护两个队列（未完成连接队列、已完成连接队列）排队连接请求。</p>
<p>服务器套接字进入侦听状态后，必须通过函数accept接收客户进程提交的连接请求，从而完成一个套接字的完整连接。</p>
<p>套接字的数据收发即可以使用文件库函数 read/write ，也可以使用套接字的专用收发函数 recv/send 。</p>
<p>TCP是面向连接的通信协议，采用客户机-服务器模式。套接字的全部工作流程如下所述：</p>
<ol>
<li>服务器启动进程，调用Socket创建一个基于TCP协议的流套接字描述符。</li>
<li>其次，服务进程调用bind命名套接字，将套接字描述符绑定到本地地址和本地端口上，至此Socket的半相关描述—{协议，本地地址，本地端口}—完成。</li>
<li>再次，服务器端调用listen，开始侦听客户端的Socket连接请求。</li>
<li>接下来，客户端创建套接字描述符，并且调用connect向服务端提交连接请求。服务器端接收到客户端连接请求后，调用accept接受，并创建一个新的套接字描述符与客户端建立连接，然后原套接字描述符继续侦听客户端的连接请求。</li>
<li>客户端与服务器端的新套接字进行数据传送，调用write或send向对方发送数据，调用read或recv接收数据。</li>
<li>在数据交流完毕后，双方调用close或者shutdown半闭套接字。</li>
</ol>
<p>基于TCP（面向连接）的socket编程TCP是面向连接的，可靠的传输协议</p>
<p>服务器端程序：</p>
<ol>
<li>创建套接字（socket）</li>
<li>将套接字绑定到一个本机地址和端口上（bind）</li>
<li>将套接字设为监听模式，准备接收客户请求（listen）</li>
<li>等待客户请求到来，当请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept）</li>
<li>用返回的套接字和客户端进行通信（send/recv）</li>
<li>返回，等待另一个用户的请求</li>
<li>关闭套接字</li>
</ol>
<p>客户端程序：</p>
<ol>
<li>创建套接字（socket）</li>
<li>向服务器端发送连接请求（connect）</li>
<li>和服务器进行通信（recv/send）</li>
<li>关闭套接字</li>
</ol>
<p>基于UDP（面向无连接）的socket编程UDP是无连接的，不可靠的传输协议</p>
<p>服务器端（接收端）程序：</p>
<ol>
<li>创建套接字(socket)</li>
<li>将套接字绑定到一个本地地址和端口上（bind）</li>
<li>等待接收数据（recvfrom）</li>
<li>关闭套接字</li>
</ol>
<p>客户端（发送端）程序：</p>
<ol>
<li>创建套接字（socket）</li>
<li>发送数据（sendto）</li>
<li>关闭套接字</li>
</ol>
<hr>
<ol>
<li><a href="http://www.cnblogs.com/chengmin/archive/2010/06/10/1755751.html" target="_blank" rel="noopener">socket与TCP/UDP编程</a></li>
<li><a href="http://blog.163.com/zhangmaochu@126/blog/static/373606222009118103318856/" target="_blank" rel="noopener">基于Socket的UDP和TCP编程介绍</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Socket</category>
        <category>Network</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>FAT32文件系统</title>
    <url>/2014/12/04/fat32/</url>
    <content><![CDATA[<p><strong>FAT文件系统部分资料，用于开发Ecos FAT接口，&lt;FatFs – FAT&gt; &lt;NTGS-3G – NTFS&gt;</strong></p>
<hr>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可怕的问题：FATFS  f_open() 返回可怕的 FR_NO_FILESYS</p>
<p>SDHC KINGSTON的4G卡 ，在电脑上已经格式化，里面有ABC.TXT文本文件。</p>
<p>移植好的FATFS文件系统在 万利的EK-STM32F 开发板上 对写SD卡。</p>
<pre><code>disk_sta=disk_initialize(0);//disk_status        
f_mount(0, &amp;fatfs[0]);  </code></pre><p>上面两句都运行正常！ 到 </p>
<pre><code>/* Open source file on the drive 1 */
res = f_open(&amp;fsrc, &quot;0:/ABC.TXT&quot;, FA_CREATE_NEW | FA_READ);</code></pre><p>就返回可怕的FR_NO_FILESYSTEM</p>
<p>从网上找来同样的问题的帖子：</p>
<p>SD卡sector0读出来只有最后两个字节是 55 AA，中间也有几个数据，其他的都是00，<br>check_fs函数返回 FR_NO_FILESYSTEM 无可用的文件系统。<br>网上查了一下FAT系统的资料，发现物理扇区0（MBR）并不是逻辑扇区0，<br>根据第一个sector读出的数据，我的物理扇区的地址应该是0x61而不是0。<br>后来仔细查了一下FATFS的源码，发现只支持 FDISK 和 SFD 格式的FAT系统，<br>于是我猜想如果用fdisk格式化，MBR的物理扇区和逻辑扇区地址就都是0了。<br>然后在linux下用FDISK又格式化了一把，发现情况还是一样。</p>
<p>我现在在裸机下移植fatfs，出现和你差不多的问题，麻烦楼主能看看</p>
<pre><code>fmt = check_fs(fs, bsect = 0);                // Check sector 0 if it is a VBR 
//fmt = check_fs(fs, 243);
if (fmt == 1) {                                                // Not an FAT-VBR, the disk may be partitioned 
    // Check the partition listed in top of the partition table 
    tbl = &amp;fs-&gt;win;        // Partition table 
    if (tbl) {                                                                        // Is the partition existing? 
        bsect = LD_DWORD(&amp;tbl);                                        // Partition offset in LBA 
        fmt = check_fs(fs, bsect);                                        // Check the partition 
        //fmt = check_fs(fs, 0);
    }
}</code></pre><p>第一句话fmt = check_fs(fs, bsect = 0);是去读sd卡的MBR，即第0扇区，数据正常，<br>且根据里面的数据经过bsect = LD_DWORD(&amp;tbl);这句话计算正确得到启动扇区的位置（243），<br>然后fmt = check_fs(fs, bsect);这句话就是去读这个启动扇区内的数据，这里面的数据<br>非常重要，就像我们电脑的C盘，但是返回来全部是0，导致fatfs失败。<br>然后同一张卡在另一块板子的代码上测试正常，里面的数据也正常。<br>那么可以说明一点的是，既然可以读0扇区数据正常那么说明sd的底层读函数是对的，那么为什么读不出来第243扇区的数据？<br>同事怀疑是sd卡初始化中设置成了只能读一次，那么我一开始就读第243扇区，<br>也是返回全0.这就郁闷了。在另一块板子的代码上测试，一开始读243扇区的数据是正常的。<br>最后，我将sd卡格式化，用winhex查看其扇区内容，发现0扇区和243扇区的数据没变。</p>
<p>FR_NO_FILESYSTEM  问题：</p>
<p>提示没有在你的目标存储器上建立文件系统，试试res = f_mkfs(0,0,2048);这里的2048是2048 bytes，<br>指的是你的目标存储器的扇区大小 也有可能是你没有执行注册磁盘空间的操作，试试res = f_mount(0,&amp;fs);</p>
<p>我在读写TF卡的时候也出现过这样的问题，我的解决方式是将卡用卡槽插到PC机上，然后格式化一下，我格式化选择的是FAT格式。</p>
<p>试试用F_MKFS函数格式化一下<br>未格式化为Fat格式，先在电脑里格式化或者用Fatfs自带的格式化函数格式化SD.记得要格式化为Fatfs支持的格式 </p>
<p>记得要把文件系统变量放到main函数的外面，比如工作区的变量，文件指针变量等。不这样做会出现一些错误，改了就好。我移植的时候没注意，就一直停顿这里很久，原因不明。</p>
<p>说明你没有格式化，首先需要执行f_mkfs()函数，此步骤为建立FAT相关的一些表。只需要执行一次就可以了，以后再运行程序不需执行。</p>
<p>在FATFS中经常用到chk_mount这个函数，主要是对物理驱动器检测它的可用性，即磁盘现在是否可用，避免了磁盘中途掉电的情况，在其中有这么一段程序</p>
<pre><code>fmt = check_fs(fs, bsect = 0);                // Check sector 0 if it is a VBR /可用的分区记录
if (fmt == 1) {                                                // Not an FAT-VBR, the disk may be partitioned /
    //结束符正确，确不是FAT系统，则读取下一个分区的数据，看是否是有效的结束符和FAT系统
    // Check the partition listed in top of the partition table /
    tbl = &amp;fs-&gt;win[MBR_Table + LD2PT(vol) * SZ_PTE];// Partition table /下一个分区属性的16字节存储指针
    if (tbl[4]) {                                                                        // Is the partition existing? /系统ID对于FAT32为0x01，未用是为0
        bsect = LD_DWORD(&amp;tbl[8]);                                        // Partition offset in LBA /分区偏移地址
        fmt = check_fs(fs, bsect);        //root record                                // Check the partition /这一句不懂了
    }
}        </code></pre><p>这一次它是要检测什么的？？</p>
<p>后来想了一想，对于我们的硬盘，大多是只有一个分区的，但是有的可能会有多个分区，而对于每一个分区而言，他都有一个MBR区，又称为伪MBR区，存储了这一个分区的引导程序，以及分区的信息，这样的话，如果第一个分区不是FAT系统，我们就查找是否又下一个分区，如果有的话，就开始对下一分区的判断……</p>
<p>但是为什么它只检测了两个分区呢，可能后面还有分区呢？？？</p>
<p>if (fmt == 3) return FR_DISK_ERR;<br>if (fmt) return FR_NO_FILESYSTEM; // No FAT volume is found /<br>//两次检测之后还不是FAT系统，就返回错误</p>
<p>我的理解是：<br>在一些SD1.0中，物理0扇区就是逻辑0扇区，0扇区就是DBR，没有MBR，<br>这种情况也就不存在分区，第一个fmt = check_fs(fs, bsect = 0);会返回0，<br>因为check_fs里的第三个或第四个if判断会检测到DBR里面的FAT系统标识字符串，<br>其中一个会返回0，fmt=0，fmt = check_fs(fs, bsect);就不会执行了 </p>
<pre><code>if (disk_read(fs-&gt;drive, fs-&gt;win, sect, 1) != RES_OK) // Load boot record  
    return 3; 
if (LD_WORD(&amp;fs-&gt;win[BS_55AA]) != 0xAA55) // Check record signature (always placed at offset 510 even if the sector size is &gt;512)  
    return 2; 

if ((LD_DWORD(&amp;fs-&gt;win[BS_FilSysType]) &amp; 0xFFFFFF) == 0x544146) // Check &quot;FAT&quot; string  
    return 0; 
if ((LD_DWORD(&amp;fs-&gt;win[BS_FilSysType32]) &amp; 0xFFFFFF) == 0x544146) 
    return 0; 

    return 1; </code></pre><p>而在一些有MBR的sd卡中物理0扇区是MBR，mbr里有DBR的偏移信息，<br>执行fmt = check_fs(fs, bsect = 0);的时候，第一个和第二个if会通过，<br>但是mbr里面没有fat标识字符串所以第三个和第四个if不会过，返回1，fmt=1就会执行fmt = check_fs(fs, bsect);<br>其中bsect是从mbr里读出来的逻辑0扇区偏移量，既DBR所在扇区，这次执行就同上面读DBR一样，会再第三个或第三个if返回0.</p>
<p>chaN的驱动是针对sd，ata，usb，nand的，不单单是sd。我的sd2.0是没有MBR的，0扇区就是DBR。而PC硬盘ata的MBR就在0扇区。<br>我们重装PC的时候硬盘是可以选择NTFS和FAT等格式。<br>在有MBR的前提下，就有DPT，紧接MBR引导代码是DPT和“55AA”，DBR是在偏移X扇区里，X就是代码的tbl[8]的双字（4字节），也就是DPT的OFFSET 8~11。<br>假设有4分区，那么只要第一次检查0扇区是不是DBR，如果不是就检查第二次（只需检查1次即可，无需检查多次，目的是验证是否是FAT），检查偏移X扇区。<br>执行check_fs(fs, bsect);后返回0，则说明第4分区DBR就在X扇区，验证成功，返回！0则错误。</p>
<p>用电脑上的winhex去看下你的sd卡的0扇区是怎么回事<br>看看是不是mbr，当然 也得了解下这个mbr的结构<br>fat文件系统原理总得知道个大概吧</p>
<p>可以使用WinHex来查看MBR，方法为：打开WinHex，然后在菜单栏选择“工具”、“打开磁盘”，在“物理驱动器”一栏选择自己的硬盘打开就可以了。</p>
<p><strong>对U盘的格式化就是按照文件系统的规范完成BUFF的组建，然后写入到指定的扇区中，例如FAT32的DBR、FAT表等。</strong></p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol>
<li><a href="http://velep.com/archives/714.html" target="_blank" rel="noopener">stm32移植ecos #31，ecos sd driver，SD卡驱动（1）</a></li>
<li><a href="http://velep.com/archives/725.html" target="_blank" rel="noopener">stm32移植ecos #32，ecos sd driver，SD卡驱动（2）</a></li>
<li><a href="http://velep.com/archives/729.html" target="_blank" rel="noopener">stm32移植ecos #33，ecos sd driver，SD卡驱动（3）</a></li>
<li><a href="http://velep.com/archives/732.html" target="_blank" rel="noopener">stm32移植ecos #34，ecos sd driver，SD卡驱动（4）</a></li>
<li><a href="https://www.sourceware.org/ml/ecos-discuss/2012-07/msg00006.html" target="_blank" rel="noopener">reading size and used space on compact flash (CF) card?</a></li>
<li><a href="http://velep.com/archives/688.html" target="_blank" rel="noopener">SD卡数据结构与FAT文件系统详细分析（上）</a></li>
<li><a href="http://velep.com/archives/707.html" target="_blank" rel="noopener">SD卡数据结构与FAT文件系统详细分析（下）</a></li>
<li><a href="http://elm-chan.org/fsw/ff/00index_e.html" target="_blank" rel="noopener">FatFs - Generic FAT File System Module</a></li>
<li><a href="http://dengqi.blog.51cto.com/5685776/1349327" target="_blank" rel="noopener">FAT32文件系统详解</a></li>
<li><a href="http://blog.csdn.net/l545045612/article/details/7490260" target="_blank" rel="noopener">FATFS 移植 （应用部分）</a></li>
<li><a href="http://bbs.21ic.com/icview-619554-1-1.html" target="_blank" rel="noopener">FATFS  f_open() 返回可怕的 FR_NO_FILESYS</a></li>
<li><a href="">FAT系统原理.pdf</a></li>
<li><a href="">FAT白皮书中文版.pdf</a></li>
</ol>
]]></content>
      <categories>
        <category>Ecos</category>
      </categories>
      <tags>
        <tag>ecos</tag>
        <tag>fat32</tag>
        <tag>fs</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-高级文件I/O</title>
    <url>/2014/11/23/Linux-system-Advanced-File-IO/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<h2 id="分散-聚集IO"><a href="#分散-聚集IO" class="headerlink" title="分散/聚集IO"></a><strong>分散/聚集IO</strong></h2><p>分散/聚集IO是一种在单次系统调用中对多个缓冲区输入输出的方法，<br>可以把多个缓冲区的数据写到单个数据流，<br>也可以把单个数据流读到多个缓冲区。</p>
<p>与线性IO（标准读写系统调用）相比有以下优势：</p>
<ul>
<li>编码模式更自然，尤其针对分段的数据</li>
<li>效率更高，单个向量IO操作可以取代多个线性IO操作</li>
<li>性能更好</li>
<li>支持原子操作</li>
</ul>
<p>Linux实现了POSIX 1003.1-2001中定义的一组实现分散/聚集IO机制的系统调用：</p>
<pre><code>#include &lt;sys/uio.h&gt;

struct iovec {
    void *iov_base;
    size_t iov_len;
};

ssize_t readv(int fd, const struct iovec *iov, int count);
ssize_t writev(int fd, const struct iovec *iov, int count);</code></pre><p>readv()从fd中读取count个段到参数iov所指定的缓冲区中；<br>writev()从参数iov指定的缓冲区读取count个段，并写入到fd中。<br>每个iovec结构体描述一个独立的、物理不连续的缓冲区，称之为段：</p>
<p>writev()示例：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/uio.h&gt;

int main(void)
{
    struct iovec iov[3];
    ssize_t nr;
    int fd, i;

    char *buf = {
        &quot;AAAAAAAAAAAAAAAAAA\n&quot;,
        &quot;BBBBBBBBBBBBBBBBBB\n&quot;,
        &quot;CCCCCCCCCCCCCCCCCC\n&quot;
    };

    fd = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC);
    if(-1 == fd) {
        perror(&quot;open&quot;);
        return 1;
    }

    /* fill out three iovec structures */
    for(i = 0; i &lt; 3; i++) {
        iov[i].iov_base = buf[i];
        iov[i].iov_len = strlen(buf(i)) + 1;
    }

    nr = writev(fd, iov, 3);
    if(-1 == nr) {
        perror(&quot;writev&quot;);
        return 1;
    }
    printf(&quot;wrote %d bytes\n&quot;, nr);

    if(close(fd)) {
        perror(&quot;close&quot;);
        return 1;
    }

    return 0;
}</code></pre><h2 id="Event-Poll"><a href="#Event-Poll" class="headerlink" title="Event Poll"></a><strong>Event Poll</strong></h2><p>由于poll()和select()的局限，Linux2.6内核引入了event poll机制。<br>虽然epoll的实现比poll()和select()要复杂的多，epoll解决了前两个都存在的基本性能问题，并增加了一些新的特性。</p>
<p>对于poll()和select()，每次调用时都需要被监听的文件描述符列表。<br>内核必须遍历所有被监听的文件描述符。<br>当这个文件描述符列表变得很大时，每次调用都要遍历列表就变成规模上的瓶颈。</p>
<p>epoll把监听注册从实际监听中分离出来，从而解决这个问题。<br>一个系统调用会初始化epoll上下文，<br>另一个从上下文中加入或删除监听的文件描述符，<br>第三个执行真正的时间等待（event wait）。</p>
<hr>
<hr>
<p><strong>创建新的epoll实例</strong></p>
<pre><code>#include &lt;sys/epoll.h&gt;

int epoll_create(int size);
int epoll_create1(int flags);</code></pre><p>epoll_create()创建一个epoll的实例，当创建成功后，会占用一个fd，所以记得在使用完之后调用close()，否则fd可能会被耗尽。<br>自从Linux2.6.8版本以后，size值被忽略，内核可以动态的分配大小，只需要size参数大于0即可。</p>
<p>epoll_create()是老版本的epoll_create1()实现，接受参数flags支持修改epoll行为，当前，只有EPOLL_CLOEXEC是合法flag。<br>当flag = EPOLL_CLOEXEC，创建的epfd会设置FD_CLOEXEC。</p>
<p>epoll的标准调用方式如下：</p>
<pre><code>int epfd;

epfd = epoll_create1(0);
if(epfd &lt; 0)
    perror(&quot;epoll_create1&quot;);</code></pre><hr>
<hr>
<p><strong>epoll控制函数</strong></p>
<pre><code>#include &lt;sys/epoll.h&gt;

typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;

struct epoll_event {
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></pre><p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。<br>第一个参数是epoll_create1()的返回值，<br>第二个参数表示动作，用三个宏来表示：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的fd到epfd中</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件</li>
<li>EPOLL_CTL_DEL：从epfd中删除一个fd</li>
</ul>
<p>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂起</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，默认是条件触发(Level Triggered)</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<p>event_poll中的data变量是由用户私有使用。<br>当接收到请求的事件后，data会被返回给用户。<br>通常的用法是把event.data.fd设置为fd，这样可以很容易查看那个文件描述符触发了事件。</p>
<hr>
<hr>
<p><strong>等待epoll事件</strong></p>
<pre><code>#include &lt;sys/epoll.h&gt;

int epoll_wait(int epfd, struct epoll_event *events,
        int maxevents, int timeout);</code></pre><p>当调用epoll_wait()时，等待epoll实例epfd中的文件fd上的事件，时限为timeout毫秒。<br>成功时，events指向描述每个事件的epoll_event结构体的内存，且最多可以有maxevents个事件，返回值是事件数。<br>当调用返回时，epoll_event结构体中的events变量描述了发生的事件。<br>data变量保留用户在调用epoll_ctl()前的所有内容。</p>
<hr>
<hr>
<p><strong>边缘触发（ET）和条件触发（LT）</strong></p>
<p>如果epoll_ctl()的参数event中的events设置为EPOLLET，fd上监听方式为边缘触发（ET），否则为条件触发（LT）。</p>
<p>以下面的生产者和消费者在通过UNIX管道通信时举例：</p>
<p>1.生产者向管道写入1KB数据<br>2.消费者在管道上调用epoll_wait()，等待管道上有数据并可读</p>
<p>通过LT，在步骤2中epoll_wait()调用会立即返回，表示管道可读。<br>通过ET，需要步骤1发生后，步骤2的epoll_wait()才会返回。<br>也就是说对于ET，在调用epoll_wait()时，即使管道已经可读，也只有在数据写入之后，调用才会返回。</p>
<ul>
<li>LT：效率会低于ET触发，尤其在大并发，大流量的情况下。<br>但是LT对代码编写要求比较低，不容易出现问题。<br>LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。</li>
<li>ET：效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。<br>但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。</li>
</ul>
<hr>
<hr>
<p><strong>epoll使用例子：</strong></p>
<p>epoll_wait范围之后应该是一个循环，遍利所有的事件。<br>几乎所有的epoll程序都使用下面的框架：</p>
<pre><code>for( ; ; )
{
    nfds = epoll_wait(epfd,events,20,500);
    for(i=0;i&lt;nfds;++i)
    {
        if(events[i].data.fd==listenfd) //有新的连接
        {
            connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); //accept这个连接
            ev.data.fd=connfd;
            ev.events=EPOLLIN|EPOLLET;
            epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); //将新的fd添加到epoll的监听队列中
        }
        else if( events[i].events&amp;EPOLLIN ) //接收到数据，读socket
        {
            n = read(sockfd, line, MAXLINE)；       //读
            ev.data.ptr = md;     //md为自定义类型，添加数据
            ev.events=EPOLLOUT|EPOLLET;
            epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓
        }
        else if(events[i].events&amp;EPOLLOUT) //有数据待发送，写socket
        {
            struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    //取数据
            sockfd = md-&gt;fd;
            send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 );        //发送数据
            ev.data.fd=sockfd;
            ev.events=EPOLLIN|EPOLLET;
            epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); //修改标识符，等待下一个循环时接收数据
        }
        else
        {
            //其他的处理
        }
    }
}</code></pre><h2 id="存储映射"><a href="#存储映射" class="headerlink" title="存储映射"></a><strong>存储映射</strong></h2><p>内存映射支持应用程序将文件映射到内存中，即内存地址和文件数据一一对应。<br>开发人员可以通过内存来访问文件，就像操作内存中的数据块一样，甚至可以写入内存数据区，<br>然后通过透明的映射机制将文件写入磁盘。</p>
<h3 id="mmap-和munmap"><a href="#mmap-和munmap" class="headerlink" title="mmap()和munmap()"></a><strong>mmap()和munmap()</strong></h3><pre><code>#include &lt;sys/mmap.h&gt;  

void *mmap(void *addr,size_t len,int prot, int flags,int fd,off_t offset); 
int mummap(void *addr, size_t len);</code></pre><ul>
<li>addr：建议内核将文件映射到的地址，这只是一个hint，为了可移植性，一般设置为0，调用返回mapping开始的实际地址。 </li>
<li>fd：要映像文件的描述符。 </li>
<li>prot描述了内存映像的保护权限，可以使用OR连接以下选项： <ul>
<li>PROT_READ：区域可读。 </li>
<li>PROT_WRITE:区域可写 </li>
<li>PROT_EXEC:区域可执行 </li>
<li>PROT_NONE:区域不可访问，很少有用。 </li>
<li>prot不能和打开文件的模式冲突。比如打开了一个只读文件，prot不可以指定为PROT_WRITE。 </li>
</ul>
</li>
<li>flags:描述了内存映像的方式，可以使用OR连接以下选项： <ul>
<li>MAP_FIXED: addr是必须的，并且不是一个hint，如果内核无法在该地址映像，则失败。具有不可移植性，不推荐使用。 </li>
<li>MAP_PRIVATE:映像不共享，文件被映像为copy-on-write，任何在内存中的改变，都不会反映在文件或者其他进程的mapping中。 </li>
<li>MAP_SHARED：映像和其他进程共享映射的同一个文件，写入buffer等效于写入文件，读取映像写操作同时反映在其他进程中。 </li>
<li>MAP_SHARED和MAP_PRIVATE其中之一必须被指定。 </li>
</ul>
</li>
</ul>
<p>addr和off的值需要被指定为系统虚拟页的整数倍，可以通过使用_SC_PAGESIZE或_SC_PAGE_SIZE作为sysconf参数获得页的大小。<br>如果文件的大小12字节，但系统页的大小是512字节，那么系统调用会映射512字节，其他的部分被填充为0，<br>我们可以修改另外的500个字节，但是并不反应在文件中，所有我们不能使用mmap来append文件，我们需要首先增大文件到指定的值。</p>
<p>mummap删除了从addr地址开始，是page对齐的，连续的len字节的映像，一旦被删除，<br>内存中的区域就不在有效，访问会产生SIGSEGV信号。<br>munmap通常传入由mmap返回的addr以及设置的len长度。</p>
<h3 id="内存映射实例"><a href="#内存映射实例" class="headerlink" title="内存映射实例"></a><strong>内存映射实例</strong></h3><pre><code>#include &lt;stdio.h&gt;  
#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;  
#include &lt;fcntl.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;sys/mman.h&gt;  

int main(int argc,char *argv[])
{  
    struct stat sb;  
    off_t i;  
    char *p;  
    int fd;  

    if(argc &lt; 2){  
        fprintf(stderr,&quot;usage: %s &lt;file&gt;\n&quot;,argv[0]);  
        return 1;  
    }  

    fd = open(argv[1],O_RDONLY);  
    if(fd == -1){  
        perror(&quot;open&quot;);  
        return 1;  
    }  

    if(fstat(fd,&amp;sb) == -1){  
        perror(&quot;fstat&quot;);  
        return 1;  
    }  

    if(! S_ISREG(sb.st_mode)){  
        fprintf(stderr,&quot;%s is not a regular file\n&quot;,argv[1]);  
        return 1;  
    }  

    p = mmap(0,sb.st_size, PROT_READ,MAP_SHARED,fd,0);  
    if(p == MAP_FAILED){  
        perror(&quot;mmap&quot;);  
        return 1;  
    }  

    if(close(fd) == -1){  
        perror(&quot;close&quot;);  
        return 1;  
    }  

    for(i = 0;i &lt; sb.st_size; i++){  
        putchar(p[len]);  
    }  

    if(munmap(p,sb.st_size) == -1){  
        perror(&quot;mummap&quot;);  
        return 1;  
    }  
    return 0;  
}</code></pre><h3 id="mmap-优缺点"><a href="#mmap-优缺点" class="headerlink" title="mmap()优缺点"></a><strong>mmap()优缺点</strong></h3><p>优点： </p>
<ol>
<li>从内存映像文件中读写，避免了read、write多余的拷贝。 </li>
<li>从内存映像文件中读写，避免了多余的系统调用和用户-内核模式的切换 </li>
<li>可以多个进程共享内存映像文件。 </li>
<li>seeking内存映像只需要指针操作，避免系统调用lseek。 </li>
</ol>
<p>缺点： </p>
<ol>
<li>内存映像需要时整数倍页大小，如果文件较小，会浪费内存。 </li>
<li>内存映像需要在放在进程地址空间，大的内存映像可能导致地址空间碎片，找不到足够大的空余连续区域供其它用。 </li>
<li>内核需要维护更多的和内存映像相关的数据结构。 </li>
</ol>
<h3 id="调整映射大小"><a href="#调整映射大小" class="headerlink" title="调整映射大小"></a><strong>调整映射大小</strong></h3><pre><code>#define _GNU_SOURCE  

#include &lt;unistd.h&gt;  
#include &lt;sys/mman.h&gt;  

void *mremap(void *addr, size_t old_size, size_t new_size, unsigned long flags);  </code></pre><p>mremap扩展或者缩小内存映像，从区域[addr,add+old_size]编程一个新的大小new_size。</p>
<p>flags: </p>
<ul>
<li>0:不可以移动来改变内存映像大小。 </li>
<li>MREMAP_MAYMOVE:如果需要可以移动地址改变内存映像大小。 </li>
</ul>
<p>返回值：成功返回重新设置大小之后的内存映像的大小，失败返回MAP_FAILED，并设置errno： </p>
<ul>
<li>EAGAIN：内存区域被锁定，无法改变大小。 </li>
<li>EFAULT：给定区域的一些也有不合法的页或者重新映像存在问题。 </li>
<li>EINAL：参数不合法。 </li>
<li>ENOMEM：不移动则无法扩展,如果MREMAP_MAYMOVE没有被设置。 </li>
</ul>
<p>glibc经常使用mremap来实现高效的realloc()： </p>
<pre><code>void * realloc(void *addr, size_t len)
{  
    size_t old_size = look_up_mapping_size(addr);  
    void *p;  
    p = mremp(addr,old_size, len,MREMAP_MAYMOVE);  
    if(p == MAP_FAILED)  
        return NULL;  
    return p;  
} </code></pre><h3 id="改变映射区域权限"><a href="#改变映射区域权限" class="headerlink" title="改变映射区域权限"></a><strong>改变映射区域权限</strong></h3><p>mprotect可以允许程序改变已经存在内存区域的permissions： </p>
<pre><code>#include &lt;sys/mman.h&gt;  

int mprotect(const void *addr, size_t len, int prot);  
//mprotect (memory, alloc_size, PROT_READ | PROT_WRITE);</code></pre><p>一些系统只能改变由mmap得到的内存映像的protection，Linux可以操作任何一个内存区域。<br>成功返回0，失败返回-1，并设置errno为： </p>
<ul>
<li>EACCESS：不可以被设置成prot的permissions，可能是文件打开时只读的，设置成可写 </li>
<li>EINVAL：参数不合法。 </li>
<li>ENOMEM：内核内存不足或者所给的内存区域不是进程的合法地址空间。 </li>
</ul>
<h3 id="通过映射同步文件"><a href="#通过映射同步文件" class="headerlink" title="通过映射同步文件"></a><strong>通过映射同步文件</strong></h3><p>POSIX提供了和文件操作中fsync类似的将文件和内存映像同步的操作： </p>
<pre><code>#include &lt;sys/mman.h&gt;  

int msync(void *addr, size_t len, int flags);  </code></pre><p>将内存映像flush到磁盘。没有msync，没有能够保证将mapping的脏数据写回磁盘，除非被unmapped。<br>当修改内存映像，进程直接修改在内核页cache中的文件页，<br>内核可能不会很快将内核的页cache同步到磁盘。</p>
<p>flags使用OR链接下面选项： </p>
<ul>
<li><p>MS_ASYNC:异步的执行同步操作，msync立即返回，更新操作被调度。 </p>
</li>
<li><p>MS_INVALIDATE:指定所有其他的内存映像cache副本无效。任何以后的操作都同步到磁盘中。 </p>
</li>
<li><p>MS_SYNC：同步的执行同步操作，等将内容写入磁盘在返回。 </p>
<p>  if(msync(addr,len,MS_ASYNC) == -1)  </p>
<pre><code>  perror(&quot;msync&quot;);  </code></pre></li>
</ul>
<p>成功返回0，失败返回-1，并设置errno： </p>
<ul>
<li>EINVAL：MS_SYNC和MS_ASYNC同时被设置或者addr没有页对齐。 </li>
<li>ENOMEM：所给的内存区域（或者部分）没有被映射。 </li>
</ul>
<h3 id="给出映射提示"><a href="#给出映射提示" class="headerlink" title="给出映射提示"></a><strong>给出映射提示</strong></h3><p>Linux提供了madvice来让进程建议内核或者给内核提供线索来使用mapping，这样可以优化mapping的使用。 </p>
<pre><code>#include &lt;sys/mman.h&gt;  

int madvice(void *addr, size_t len, int advice);  </code></pre><p>madvise() 函数建议内核，在从 addr 指定的地址开始，<br>长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。<br>len如果为0，内核将建议施用于从addr开始的整个映像。advice：可以是以下之一： </p>
<ul>
<li>MADV_NORMAL:没有特别的建议。建议使用中等程度的预读。 </li>
<li>MADV_RANDOM:以随机访问的方式访问指定的区域。建议较少的预读。 </li>
<li>MADV_SEQUENTIAL：顺序访问指定区域。建议大量预读 </li>
<li>MADV_WILLNEED：将来要访问指定区域。初始化预读，将指定的页读到内存。 </li>
<li>MADV_DONTNEED：将来不再访问指定区域。内核释放与指定页关联的资源。后续的读会导致从文件中再度调入。 </li>
</ul>
<p><strong>调用mmap()时内核只是建立了逻辑地址到物理地址的映射表，并没有映射任何数据到内存。<br>在你要访问数据时内核会检查数据所在分页是否在内存，如果不在，则发出一次缺页中断。<br>将madvise()和mmap()搭配起来使用，在使用数据前告诉内核这一段数据我要用，将其一次读入内存。</strong></p>
<ol>
<li><a href="http://blog.chinaunix.net/uid-24517549-id-4051156.html" target="_blank" rel="noopener">epoll详解</a></li>
<li><a href="http://www.cnblogs.com/napoleon_liu/archive/2010/07/20/1781578.html" target="_blank" rel="noopener">LT自动挡，ET手动挡(epoll)</a></li>
<li><a href="http://blog.csdn.net/wangxmin2005/article/details/7587525" target="_blank" rel="noopener">EPOLL LT和ET区别</a></li>
<li><a href="http://blog.csdn.net/ljx0305/article/details/4065058" target="_blank" rel="noopener">epoll使用详解（精髓）</a></li>
<li><a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/" target="_blank" rel="noopener">How to use epoll? A complete example in C</a></li>
<li><a href="http://blog.chinaunix.net/uid-28263175-id-3541869.html" target="_blank" rel="noopener"><strong>Linux的内存映射</strong></a></li>
</ol>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>echo/printf输出颜色显示</title>
    <url>/2014/11/18/Linux-echo-colors/</url>
    <content><![CDATA[<p>以下脚本可以查看echo输出的各种颜色效果：</p>
<pre><code>#!/bin/bash
#
#   This file echoes a bunch of color codes to the
#   terminal to demonstrate what&#39;s available.  Each
#   line is the color code of one forground color,
#   out of 17 (default + 16 escapes), followed by a
#   test use of that color on all nine background
#   colors (default + 8 escapes).
#

T=&#39;gYw&#39;   # The test text

echo -e &quot;\n                 40m     41m     42m     43m\
    44m     45m     46m     47m&quot;;

for FGs in &#39;    m&#39; &#39;   1m&#39; &#39;  30m&#39; &#39;1;30m&#39; &#39;  31m&#39; &#39;1;31m&#39; &#39;  32m&#39; \
    &#39;1;32m&#39; &#39;  33m&#39; &#39;1;33m&#39; &#39;  34m&#39; &#39;1;34m&#39; &#39;  35m&#39; &#39;1;35m&#39; \
    &#39;  36m&#39; &#39;1;36m&#39; &#39;  37m&#39; &#39;1;37m&#39;;
do FG=${FGs// /}
    echo -en &quot; $FGs \033[$FG  $T  &quot;
    for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
    do echo -en &quot;$EINS \033[$FG\033[$BG  $T  \033[0m&quot;;
    done
    echo;
done
echo</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>color</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>RGB 颜色空间显示</title>
    <url>/2014/11/18/rgb/</url>
    <content><![CDATA[<p>代码如下，实现RGB颜色空间的显示：</p>
<pre><code>for(r = 0 ; r &lt; 0xFF; r++)
{   
    for(g = 0 ; g &lt; 0xFF; g++)
    {   
        for(b = 0 ; b &lt; 0xFF; b++)                                                                                         
        {   
            count++;

            printf(&quot;\e]4;60;rgb:%d/%d/%d\e\\\e[38;5;60m 0x%02x%02x%02x██████\e[m&quot;, r, g, b, r, g, b); 

            if(count%8 == 0)
                printf(&quot;\n&quot;);
        }   
    }   
}   </code></pre><p>shell中如下进行显示：</p>
<pre><code>$ echo -en &#39;\e]4;60;rgb:ff/ff/ff\e\\\e[38;5;60m = ██ \e[m\n&#39;</code></pre><p>可以方便进行RGB颜色的查询</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>color</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>6442-YCbCr转换为565-RGB</title>
    <url>/2014/11/18/ycbcr2rgb/</url>
    <content><![CDATA[<p>如下代码实现YCbCr(6:4:4:2)到RGB(5:6:6)的转换：</p>
<pre><code>for(i = 0 ; i &lt; 0x10000; i++)
{   
    count++;

    //得到y，cb，cr颜色分量
    y = (i&amp;0xFC00)&gt;&gt;10;
    u = (i&amp;0x03C0)&gt;&gt;6;
    v = (i&amp;0x003C)&gt;&gt;2;

    //每个分量为8bits
    Y = (double) (y&lt;&lt;2);
    Cb = (double) (u&lt;&lt;4);
    Cr = (double) (v&lt;&lt;4);

    //计算r，g，b颜色分量，每个分量为8bits
    r = (int) (Y + 1.40200 * (Cr - 0x80));
    g = (int) (Y - 0.34414 * (Cb - 0x80) - 0.71414 * (Cr - 0x80));
    b = (int) (Y + 1.77200 * (Cb - 0x80));

    r = max(0, min(255, r));
    g = max(0, min(255, g));
    b = max(0, min(255, b));

    //r = (unsigned char)(1.164383*(y- 16) + 0 + 1.596027*(v - 128)); 
    //g = (unsigned char)(1.164383*(y- 16) - 0.391762*(u - 128) - 0.812969*(v - 128)); 
    //b = (unsigned char)(1.164383*(y- 16) + 2.017230*(u - 128) + 0 );

    //printf(&quot;\033[32m y : [0x%04x] %x u : %x v : %x \t RGB:[0x%02x%02x%02x] \n\033[0m&quot;, i, y, u ,v ,r, g, b);
    //printf(&quot;%x %x %x\n&quot;, (((unsigned int) r)&amp;0x00F8)&lt;&lt;8, (((unsigned int) g)&amp;0x00FC)&lt;&lt;3, (((unsigned int) b)&amp;0x00F8)&gt;&gt;3);

    //计算5:6:5 RGB
    rgb = ((((unsigned int) r)&amp;0x00F8)&lt;&lt;8) + ((((unsigned int) g)&amp;0x00FC)&lt;&lt;3) + ((((unsigned int) b)&amp;0x00F8)&gt;&gt;3);

    //printf(&quot;565RGB : %x&quot;, rgb);

    printf(&quot;0x%04x, &quot;, rgb);
    if(count%8 == 0)
        printf(&quot;\n&quot;);
}</code></pre><ol>
<li><a href="http://en.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">Yuv-Wiki</a></li>
<li><a href="http://www.cnitblog.com/Hali/archive/2010/01/11/63663.html" target="_blank" rel="noopener">RGB与YCbCr颜色空间的转换</a></li>
<li><a href="http://blog.csdn.net/alfredtofu/article/details/6303305" target="_blank" rel="noopener">RGB与YCbCr颜色空间的转换</a></li>
<li><a href="http://www.equasys.de/colorconversion.html" target="_blank" rel="noopener">Color Conversion</a></li>
<li><a href="http://stackoverflow.com/questions/4041840/function-to-convert-ycbcr-to-rgb" target="_blank" rel="noopener">Function to convert YCbCr to RGB?</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-时间</title>
    <url>/2014/11/13/Linux-system-programming-Time/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p>UNIX系统把绝对时间表示成新纪元至今所经过的秒数，<code>新纪元</code>定义成1970年1月1日早上00:00:00 UTC。<br>UTC（协调世界时，Coordinated Universal Time）相当于GMT或Zulu时间。</p>
<h2 id="时间的数据结构"><a href="#时间的数据结构" class="headerlink" title="时间的数据结构"></a><strong>时间的数据结构</strong></h2><p><strong>原始表示：</strong></p>
<pre><code>#incliude &lt;time.h&gt;
typedef long time_t;</code></pre><hr>
<p><strong>微秒级精度</strong></p>
<pre><code>#include &lt;sys/time.h&gt;

struct timeval {
    time_t      tv_sec;
    suseconds_t tv_usec;
};</code></pre><hr>
<p><strong>纳秒级精度</strong></p>
<pre><code>#include &lt;time.h&gt;

struct timespec {
    time_t  tv_sec;
    long    tv_nsec;
};</code></pre><hr>
<p><strong>时间描述</strong></p>
<pre><code>#include &lt;time.h&gt;

struct tm
{
  int tm_sec;           /* Seconds. [0-60] (1 leap second) */
  int tm_min;           /* Minutes. [0-59] */
  int tm_hour;          /* Hours.   [0-23] */
  int tm_mday;          /* Day.     [1-31] */
  int tm_mon;           /* Month.   [0-11] */
  int tm_year;          /* Year - 1900.  */
  int tm_wday;          /* Day of week. [0-6] */
  int tm_yday;          /* Days in year.[0-365] */
  int tm_isdst;         /* DST.     [-1/0/1]*/

# ifdef __USE_BSD
  long int tm_gmtoff;       /* Seconds east of UTC.  */
  const char *tm_zone;      /* Timezone abbreviation.  */
# else
  long int __tm_gmtoff;     /* Seconds east of UTC.  */
  const char *__tm_zone;    /* Timezone abbreviation.  */
# endif
};</code></pre><h2 id="时间API"><a href="#时间API" class="headerlink" title="时间API"></a><strong>时间API</strong></h2><p>在Linux上，所有使用POSIX时钟的函数都需要将目标文件与librt链接：</p>
<pre><code>$ gcc -Wall -W -O2 -lrt -g -o a a.c</code></pre><p><strong>取得、设置目前时间：</strong></p>
<pre><code>#include &lt;time.h&gt;

time_t time(time_t *t);
int stime(time_t *t);</code></pre><p>time()如果参数t非NULL，也将当前时间写入到提供的指针t中。</p>
<hr>
<p>对某些需要较高精准度的需求，Linux提供了以下接口，提供微秒级精度支持：</p>
<pre><code>#include &lt;sys/time.h&gt;

int gettimeofday(struct timeval * tv, struct timezone *tz);  
int settimeofday(const struct timeval * tv, const struct timezone *tz);</code></pre><p>当前时间tv指向timeval结构体。结构提timezone和参数tz已经废止，都不应该在Linux中使用，建议传NULL。</p>
<hr>
<p><strong>用于纳秒级的高级接口：</strong></p>
<pre><code>#include &lt;time.h&gt;

int clock_gettime(clockid_t clock_id, struct timespec *ts);
int clock_settime(clockid_t clock_id, const struct timespec *ts);</code></pre><hr>
<p><strong>文字时间格式函数：</strong></p>
<pre><code>#include &lt;time.h&gt;

//将tm转换为ASCII字符串
char * asctime(const struct tm *tm);
char * asctime_r(const struct tm *tm, char *buf);

//将time_t转换为ASCII字符串
char * ctime(const struct time_t *tm);
char * ctime_r(const struct time_t *tm, char *buf);

//将tm转换为time_t，使用本地时间
time_t mktime(struct tm *tm);

//将time_t转换为tm，使用UTC时区格式
struct tm * gmtime(const time_t *tp);
struct tm * gmtime_r(const time_t *tp, struct tm *result);

//将time_t转换为tm，使用本地时区格式
struct tm * localtime(const time_t *tp);
struct tm * localtime_r(const time_t *tp, struct tm *result);

//计算秒差
double difftime(time_t time1, time_t time2);</code></pre><p>后缀_r的函数不使用静态分配的指针，而是通过参数传递。</p>
<hr>
<p><strong>睡眠函数：</strong></p>
<pre><code>#include &lt;unistd.h&gt;

unsigned int sleep(unsigned int seconds);   //秒级
void usleep(unsigned long usec);            //微秒级</code></pre><hr>
<p><strong>纳秒级精度睡眠</strong></p>
<pre><code>#include &lt;time.h&gt;

int nanosleep(const struct timespec *req, struct timrspec *rem);</code></pre><p>这个函数功能是暂停某个线程直到你规定的时间后恢复，参数req就是你要暂停的时间。<br>由于调用nanosleep是使线程进入TASK_INTERRUPTIBLE，这种状态是会相应信号而进入TASK_RUNNING状态的，<br>这就意味着有可能会没有等到你规定的时间就因为其它信号而唤醒，<br>此时函数返回-1，且还剩余的时间会被记录在rem中（rem不为空的情况下）。</p>
<hr>
<p><strong>实现睡眠的高级方法？？</strong></p>
<pre><code>#include &lt;time.h&gt;  

int clock_nanosleep(clockid_t clock_id, int flags,  
                    const struct timespec *request,  
                    struct timespec *remain);  </code></pre><hr>
<p><strong>select()实现sleep可移植实现：</strong></p>
<pre><code>struct timeval tv = {.tv_sec = 0, .tv_usec = 750};

/* sleep for 750 us */
select(0, NULL, NULL, NULL, &amp;tv);</code></pre><p>select的精确度为10毫秒，在10毫秒以上很精确，sleep 可以在多线程中使用，只阻塞本线程，不影响所属进程中的其它线程。<br>Linux下短延时推荐使用select函数。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h2><p><strong>简单定时器接口：</strong></p>
<pre><code>#include &lt;unistd.h&gt;

unsigned int alarm(unsigned int seconds);</code></pre><p>想要成功调用该函数，需要为SIGALRM信号注册一个信号处理函数：</p>
<pre><code>signal(SIGALRM, alarm_handler);</code></pre><hr>
<p><strong>计时器</strong></p>
<pre><code>#include &lt;sys/time.h&gt;

int getitimer(int which, struct itimerval *value);
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue);</code></pre><hr>
<p><strong>高级定时器</strong></p>
<pre><code>#include &lt;signal.h&gt;
#include &lt;time.h&gt;

int timer_create(clockid_t clockid, struct sigevent *evp, timer_t *timerid);
int timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);
int timer_gettime(timer_t timerid, struct itimerspec *value);
int timer_getoverrun(timer_t timerid);
int timer_delete(timer_t timerid);</code></pre><p>*<a href="http://blog.csdn.net/zjwoody/article/details/7882240" target="_blank" rel="noopener">关于短延迟 sleep usleep nanosleep select</a></p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>Time</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-信号</title>
    <url>/2014/11/12/Linux-system-programming-signals/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>信号是一种软件中断，它提供了异步时间的处理机制。<br>信号作为一种进程间通信（IPC）的基本形式，而一个进程可以给另一个进程发送信号。</p>
<p>信号有非常明显的生命周期。首先，产生信号（信号被发出或生成）。<br>然后内核存储信号，至到可以发送该信号。<br>最后，一旦空闲，内核就会适当地处理信号。<br>根据进程的请求，内核会执行以下三种操作之一：</p>
<ul>
<li>忽略信号。SIGKILL和SIGSTOP不能忽略</li>
<li>捕获并处理信号。暂停该进程正在执行的代码，并跳转到先前注册的函数。返回后跳回捕获信号的地方继续执行</li>
<li>执行信号的默认操作。</li>
</ul>
<p>信号标识符以SIG作为前缀的正整数，在头文件&lt;signal.h&gt;中定义，可以使用以下命令查看系统提供的信号列表：</p>
<pre><code>$ kill -l</code></pre><h2 id="信号的分类及生命周期"><a href="#信号的分类及生命周期" class="headerlink" title="信号的分类及生命周期"></a><strong>信号的分类及生命周期</strong></h2><ul>
<li>非可靠信号：早期unix下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能丢失。</li>
<li>可靠信号： 信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。</li>
</ul>
<p>信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。<br>当然也可以称为实时信号或者非实时信号，非实时信号都不支持排队，都是不可靠信号；<br>实时信号都支持排队，都是可靠信号。</p>
<p>信号的生命周期：<br>从信号发送到信号处理函数的执行完毕。<br>对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个重要的阶段，<br>这三个阶段由四个重要事件来刻画：</p>
<ul>
<li>信号产生</li>
<li>信号在进程中注册完毕</li>
<li>信号在进程中的注销完毕</li>
<li>信号处理函数执行完毕。</li>
</ul>
<p>相邻两个事件的时间间隔构成信号生命周期的一个阶段。</p>
<p>当一个实时信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，<br>信号不会丢失，因此，实时信号又叫做”可靠信号”。<br>这意味着同一个实时信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构（进程每收到一个实时信号，都会为它分配一个结构来登记该信号信息，<br>并把该结构添加在未决信号链尾，即所有诞生的实时信号都会在目标进程中注册）；</p>
<p>当一个非实时信号发送给一个进程时，如果该信号已经在进程中注册，则该信号将被丢弃，造成信号丢失。<br>因此，非实时信号又叫做”不可靠信号”。这意味着同一个非实时信号在进程的未决信号信息链中，<br>至多占有一个sigqueue结构（一个非实时信号产生后，1如果发现相同的信号已经在目标结构中注册，则不再注册，<br>对于进程来说，相当于不知道本次信号发生，信号丢失；2如果进程的未决信号中没有相同信号，则在进程中注册自己）。</p>
<p>需要注意的要点是：</p>
<ul>
<li>信号注册与否，与发送信号的函数（如kill()或sigqueue()等）以及信号安装函数（signal()及sigaction()）无关，<br>只与信号值有关（信号值小于SIGRTMIN的信号最多只注册一次，信号值在SIGRTMIN及SIGRTMAX之间的信号，只要被进程接收到就被注册）。</li>
<li>在信号被注销到相应的信号处理函数执行完毕这段时间内，如果进程又收到同一信号多次，则对实时信号来说，<br>每一次都会在进程中注册；而对于非实时信号来说，无论收到多少次信号，都会视为只收到一个信号，只在进程中注册一次。</li>
</ul>
<h2 id="信号API"><a href="#信号API" class="headerlink" title="信号API"></a><strong>信号API</strong></h2><h3 id="发送信号函数"><a href="#发送信号函数" class="headerlink" title="发送信号函数"></a><strong>发送信号函数</strong></h3><pre><code>#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;

int kill(pid_t pid, int signo);</code></pre><p><strong>kill()</strong>系统调用，用于向另外一个进程发送信号。<br>参数pid的值为信号的接收进程：</p>
<ul>
<li>pid&gt;0 进程ID为pid的进程 </li>
<li>pid=0 同一个进程组的进程 </li>
<li>pid&lt;0 pid!=-1 进程组ID为 -pid的所有进程 </li>
<li>pid=-1 除发送进程自身外，所有进程ID大于1的进程 </li>
</ul>
<p>signo是信号值，当为0时（即空信号），实际不发送任何信号，但照常进行错误检查，因此，可用于检查目标进程是否存在，<br>以及当前进程是否具有向目标发送信号的权限（root权限的进程可以向任何进程发送信号，<br>非root权限的进程只能向属于同一个session或者同一个用户的进程发送信号）。</p>
<pre><code>#include &lt;signal.h&gt;

int raise(int signo);</code></pre><p><strong>raise()</strong>用于给进程本身发送信号。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;

int sigqueue(pid_t pid, int sig, const union sigval val);</code></pre><p><strong>sigqueue()</strong>是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，<br>与函数sigaction()配合使用。<br>sigqueue的第一个参数是指定接收信号的进程ID，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构union sigval，<br>指定了信号传递的参数，即通常所说的4字节值。</p>
<pre><code>typedef union sigval 
{
    int sival_int;
    void *sival_ptr;
}sigval_t;</code></pre><p>sigqueue()比kill()传递了更多的附加信息，但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。如果sig为0，<br>将会执行错误检查，但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号。<br>在调用sigqueue时，sigval_t指定的信息会拷贝到3参数信号处理函数（3参数信号处理函数指的是信号处理函数由sigaction安装，<br>并设定了sa_sigaction指针，稍后将阐述）的siginfo_t结构中，这样信号处理函数就可以处理这些信息了。由于sigqueue系统调用<br>支持发送带参数信号，所以比kill()系统调用的功能要灵活和强大得多。</p>
<p>注：sigqueue()发送非实时信号时，第三个参数包含的信息仍然能够传递给信号处理函数；<br>sigqueue()发送非实时信号时，仍然不支持排队，<br>即在信号处理函数执行过程中到来的所有相同信号，都被合并为一个信号。</p>
<pre><code>#include &lt;unistd.h&gt;

unsigned int alarm(unsigned int seconds);</code></pre><p><strong>alarm()</strong>专门为SIGALRM信号而设，在指定的时间seconds秒后，<br>将向进程本身发送SIGALRM信号，又称为闹钟时间。进程调用alarm后，<br>任何以前的alarm()调用都将无效。如果参数seconds为零，那么进程内将不再包含任何闹钟时间。<br>返回值：如果调用alarm()前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</p>
<pre><code>#include &lt;sys/time.h&gt;

int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue));</code></pre><p><strong>setitimer()</strong>比alarm功能强大，支持3种类型的定时器：</p>
<ul>
<li>ITIMER_REAL： 设定绝对时间；经过指定的时间后，内核将发送SIGALRM信号给本进程</li>
<li>ITIMER_VIRTUAL 设定程序执行时间；经过指定的时间后，内核将发送SIGVTALRM信号给本进程</li>
<li>ITIMER_PROF 设定进程执行以及内核因本进程而消耗的时间和，经过指定的时间后，内核将发送ITIMER_VIRTUAL信号给本进程</li>
</ul>
<hr>
<pre><code>#include &lt;stdlib.h&gt;

void abort(void);</code></pre><p><strong>abort()</strong>向进程发送SIGABORT信号，默认情况下进程会异常退出，当然可定义自己的信号处理函数。<br>即使SIGABORT被进程设置为阻塞信号，调用abort()后，SIGABORT仍然能被进程接收。该函数无返回值。</p>
<h3 id="信号的捕获与安装"><a href="#信号的捕获与安装" class="headerlink" title="信号的捕获与安装"></a><strong>信号的捕获与安装</strong></h3><p>如果进程要处理某一信号，那么就要在进程中安装该信号。<br>安装信号主要用来确定信号值及进程针对该信号值的动作之间的映射关系，<br>即进程将要处理哪个信号；该信号被传递给进程时，将执行何种操作。<br>linux主要有两个函数实现信号的安装：signal()、sigaction()。<br>其中signal()在可靠信号系统调用的基础上实现, 是库函数。<br>它只有两个参数，不支持信号传递信息，主要是用于前32种非实时信号的安装；<br>而sigaction()是较新的函数（由两个系统调用实现：sys_signal以及sys_rt_sigaction），<br>有三个参数，支持信号传递信息，主要用来与sigqueue()系统调用配合使用，<br>当然，sigaction()同样支持非实时信号的安装。<br>sigaction()优于signal()主要体现在支持信号带有参数。</p>
<pre><code>#include &lt;signal.h&gt;

typedef void (*sighandler_t)(int)；
sighandler_t signal(int signum, sighandler_t handler));</code></pre><p>第一个参数指定信号的值，第二个参数指定针对前面信号值的处理：</p>
<ul>
<li>SIG_IGN，忽略该信号</li>
<li>SIG_DFL，系统默认方式处理信号</li>
<li>也可以自己实现处理方式(参数指定一个函数地址)</li>
</ul>
<p>第三种用法如下：</p>
<pre><code>static void sigint_handler(int signo)
{
    printf(&quot;Caught SIGINT!\n&quot;);
    exit(EXIT_SUCCESS);
}

int main(void)
{
    if(signal(SIGIN, sigint_handler) == SIG_ERR) {
        fprintf(stderr, &quot;Cannot handle SIGINT!\n&quot;);
        exit(EXIT_FAILURE);
    }

    for(;;)
        pause();

    return 0;
}</code></pre><p>如果signal()调用成功，返回最后一次为安装信号signum而调用signal()时的handler值；失败则返回SIG_ERR。</p>
<pre><code>#include &lt;signal.h&gt;

int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</code></pre><p>sigaction函数用于改变进程接收到特定信号后的行为。<br>该函数的第一个参数为信号的值，<br>可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号<br>（为这两个信号定义自己的处理函数，将导致信号安装错误）。<br>第二个参数是指向结构sigaction的一个实例的指针，<br>在结构sigaction的实例中，指定了对特定信号的处理，<br>可以为空，进程会以缺省方式对信号处理；<br>第三个参数oldact指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。<br>如果把第二、第三个参数都设为NULL，那么该函数可用于检查信号的有效性。</p>
<p>第二个参数最为重要，其中包含了对指定信号的处理、信号所传递的信息、信号处理函数执行过程中应屏蔽掉哪些函数等等。<br>sigaction结构定义如下：</p>
<pre><code>struct sigaction {
    void (*sa_handler)(int signo)；
    void (*sa_sigaction)(int siginfo_t *info，void *act)；
    sigset_t sa_mask；
    int sa_flags；
    void (*sa_restore)(void)；
}</code></pre><p>sa_handler以及sa_sigaction指定信号关联函数，即用户指定的信号处理函数。<br>除了可以是用户自定义的处理函数外，还可以为SIG_DFL(采用缺省的处理方式)，也可以为SIG_IGN（忽略信号）。<br>sa_handler指定的处理函数只有一个参数，即信号值，所以信号不能传递除信号值之外的任何信息。</p>
<p>如果sa_flags被设置为SA_SIGINFO，那么将由sa_sigaction，而不是sa_handler来设置信号关联函数。<br>sa_sigaction信号处理函数带有三个参数，是为实时信号而设的（当然同样支持非实时信号），它指定一个3参数信号处理函数。</p>
<p>第一个参数为信号值，第三个参数没有使用（POSIX没有规范使用该参数的标准），<br>第二个参数是指向siginfo_t结构的指针，结构中包含信号携带的数据值，参数所指向的结构如下：</p>
<pre><code>siginfo_t {
    int si_signo; /* 信号值，对所有信号有意义*/
    int si_errno; /* errno值，对所有信号有意义*/
    int si_code; /* 信号产生的原因，对所有信号有意义*/
    union{ /* 联合数据结构，不同成员适应不同信号 */ 
        //确保分配足够大的存储空间
        int _pad[SI_PAD_SIZE];
    //对SIGKILL有意义的结构
    struct{
        ...
    }...

    ... ...
    ... ... 
    //对SIGILL, SIGFPE, SIGSEGV, SIGBUS有意义的结构
    struct{
        ...
    }...
    ... ...
}</code></pre><p>}</p>
<p>注：为了更便于阅读，在说明问题时常把该结构表示为如下所表示的形式。</p>
<pre><code>siginfo_t {
    int si_signo;       /* 信号值，对所有信号有意义*/
    int si_errno;       /* errno值，对所有信号有意义*/
    int si_code;        /* 信号产生的原因，对所有信号有意义*/
    pid_t si_pid;       /* 发送信号的进程ID,对kill(2),实时信号以及SIGCHLD有意义 */
    uid_t si_uid;       /* 发送信号进程的真实用户ID，对kill(2),实时信号以及SIGCHLD有意义 */
    int si_status;      /* 退出状态，对SIGCHLD有意义*/
    clock_t si_utime;   /* 用户消耗的时间，对SIGCHLD有意义 */
    clock_t si_stime;   /* 内核消耗的时间，对SIGCHLD有意义 */
    sigval_t si_value;  /* 信号值，对所有实时有意义，是一个联合数据结构，见函数sigqueue()*/
    void * si_addr;     /* 触发fault的内存地址，对SIGILL,SIGFPE,SIGSEGV,SIGBUS 信号有意义*/
    int si_band;        /* 对SIGPOLL信号有意义 */
    int si_fd;          /* 对SIGPOLL信号有意义 */
} </code></pre><p>实际上，除了前三个元素外，其他元素组织在一个联合结构中，在联合数据结构中，又根据不同的信号组织成不同的结构。<br>注释中提到的对某种信号有意义指的是，<br>在该信号的处理函数中可以访问这些域来获得与信号相关的有意义的信息，只不过特定信号只对特定信息感兴趣而已。</p>
<p>调用sigqueue发送信号时，sigqueue的第三个参数就是sigval联合数据结构，<br>当调用sigqueue时，该数据结构中的数据就将拷贝到信号处理函数的第二个参数中。<br>这样，在发送信号同时，就可以让信号传递一些附加信息。信号可以传递信息对程序开发是非常有意义的。<br>信号参数的传递过程：</p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/2.gif" alt=""></p>
<p>sa_mask指定在信号处理程序执行过程中，哪些信号应当被阻塞。<br>缺省情况下当前信号本身被阻塞，防止信号的嵌套发送，除非指定SA_NODEFER或者SA_NOMASK标志位。<br>请注意sa_mask指定的信号阻塞的前提条件：是在由sigaction()安装信号的处理函数执行过程中由sa_mask指定的信号才被阻塞。</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（上）</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（下）</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>Linux Signals</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-多线程同步条件变量</title>
    <url>/2014/11/11/Linux-system-programming-pthread_cont/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p>与互斥锁不同，<strong>条件变量是用来等待而不是用来上锁的。<br>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</strong></p>
<p>条件变量使我们可以睡眠等待某种条件出现。<br>条件变量是利用线程间共享的全局变量进行同步的一种机制，<br>主要包括两个动作：<strong>一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。</strong></p>
<p><strong>条件的检测是在互斥锁的保护下进行的。<br>如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。</strong><br>如果另一个线程改变了条件，它发信号给关联的条件变量，<br>唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。<br>如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。</p>
<p>使用条件变量之前要先进行初始化。<br>可以在单个语句中生成和初始化一个条件变量如：pthread_cond_t my_condition=PTHREAD_COND_INITIALIZER;（用于进程间线程的通信）。<br>可以利用函数pthread_cond_init动态初始化。</p>
<p><strong>条件变量分为两部分: 条件和变量。<br>条件本身是由互斥量保护的。<br>线程在改变条件状态前先要锁住互斥量。<br>它利用线程间共享的全局变量进行同步的一种机制。</strong></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h2><pre><code>int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr);     
int pthread_cond_destroy(pthread_cond_t *cond);  
int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);
int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);  //解除所有线程的阻塞</code></pre><p>条件变量采用的数据类型是pthread_cond_t, 在使用之前必须要进行初始化, 这包括两种方式:</p>
<ul>
<li>静态: 可以把常量PTHREAD_COND_INITIALIZER给静态分配的条件变量</li>
<li>动态: pthread_cond_init函数, 释放动态条件变量的内存空间之前, 要用pthread_cond_destroy对其进行清理</li>
</ul>
<p>pthread_cond_wait()函数用于等待条件被触发。<br>该函数传入两个参数，一个条件变量一个互斥量，函数将条件变量和互斥量进行关联，<br>互斥量对该条件进行保护，传入的互斥量必须是已经锁住的。<br>调用pthread_cond_wait()函数后，会原子的执行以下两个动作：</p>
<ul>
<li>将调用线程放到等待条件的线程列表上，即进入睡眠</li>
<li>对互斥量进行解锁</li>
</ul>
<p>由于这两个操作时原子操作，<br>这样就关闭了条件检查和线程进入睡眠等待条件改变这两个操作之间的时间通道，<br>这样就不会错过任何条件的变化。<br><strong>当pthread_cond_wait()返回后，互斥量会再次被锁住。</strong></p>
<p>pthread_cond_timedwait()函数和pthread_cond_wait()的工作方式相似，只是多了一个等待时间。<br>等待时间的结构为struct timespec，</p>
<pre><code>struct timespec{  
    time_t  tv_sec    //Seconds.  
    long    tv_nsec   //Nanoseconds.  
};</code></pre><p>函数要求传入的时间值是一个绝对值，不是相对值，<br>例如，想要等待3分钟，必须先获得当前时间，然后加上3分钟。<br>要想获得当前系统时间的timespec值，没有直接可调用的函数，<br>需要通过调用gettimeofday函数获取timeval结构，然后转换成timespec结构，转换公式就是：</p>
<pre><code>timeSpec.tv_sec = timeVal.tv_sec;  
timeSpec.tv_nsec = timeVal.tv_usec * 1000; </code></pre><p>所以要等待3分钟，timespec时间结构的获得应该如下所示:</p>
<pre><code>struct timeval now;  
struct timespec until;  
gettimeofday(&amp;now);//获得系统当前时间  

//把时间从timeval结构转换成timespec结构  
until.tv_sec = now.tv_sec;  
until.tv_nsec = now.tv_usec * 1000;  

//增加min  
until.tv_sec += 3 * 60;  </code></pre><p>如果时间到后，条件还没有发生，那么会返回ETIMEDOUT错误。</p>
<p><strong>从pthread_cond_wait()和pthread_cond_timewait()成功返回时，<br>线程需要重新计算条件，因为其他线程可能在运行过程中已经改变条件。</strong></p>
<p>pthread_cond_signal() 和 pthread_cond_broadcast()<br>这两个函数都是用于向等待条件的线程发送唤醒信号，<br>pthread_cond_signal()函数只会唤醒等待该条件的某个线程，<br>pthread_cond_broadcast()会广播条件状态的改变，以唤醒等待该条件的所有线程。<br>例如多个线程只读共享资源，这是可以将它们都唤醒。<br>这里要注意的是：<strong>一定要在改变条件状态后，再给线程发送信号。</strong><br>考虑条件变量信号单播发送和广播发送的一种候选方式是坚持使用广播发送。<br><strong>只有在等待者代码编写确切，只有一个等待者需要唤醒，<br>且唤醒哪个线程无所谓，那么此时为这种情况使用单播，<br>所以其他情况下都必须使用广播发送。</strong></p>
<p>在实际编程中，把共享数据和它们的同步变量集合到一个结构中，这往往是一个较好的编程技巧：</p>
<pre><code>struct{  
    pthread_mutex_t mutex;  
    pthread_cond_t cond;  
    int data;  
}Data;  </code></pre><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a><strong>Source Code</strong></h2><pre><code>#include &lt;pthread.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;/* 初始化互斥锁*/  
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;/* 初始化条件变量*/  
void *thread1(void *);  
void *thread2(void *);  
int i=1;  
int main(void)  
{  
    pthread_t t_a;  
    pthread_t t_b;  

    pthread_create(&amp;t_a,NULL,thread1,(void *)NULL);/* 创建进程t_a*/  
    sleep(1);
    pthread_create(&amp;t_b,NULL,thread2,(void *)NULL); /* 创建进程t_b*/  

    pthread_join(t_a, NULL);/* 等待进程t_a结束*/  
    pthread_join(t_b, NULL);/* 等待进程t_b结束*/  

    pthread_mutex_destroy(&amp;mutex);  
    pthread_cond_destroy(&amp;cond);  

    exit(0);  
}  
void *thread1(void *junk)  
{  
    for(i=1;i&lt;=6;i++)  
    {  
        pthread_mutex_lock(&amp;mutex);/* 锁住互斥量*/  
        printf(&quot;thread1: lock %d\t i %d\n&quot;, __LINE__, i);  

        if(i%3==0){  
            printf(&quot;thread1:signal 1  %d\n&quot;, __LINE__);  
            pthread_cond_signal(&amp;cond);/* 条件改变，发送信号，通知t_b进程*/  
            printf(&quot;thread1:signal 2  %d\n&quot;, __LINE__);  
            sleep(1);  
        }  

        pthread_mutex_unlock(&amp;mutex);/* 解锁互斥量*/  
        printf(&quot;thread1: unlock %d\t i %d\n\n&quot;, __LINE__, i);  
        sleep(1);  
    }  
}  
void *thread2(void *junk)  
{  
    while(i&lt;6)  
    {  
        pthread_mutex_lock(&amp;mutex);  
        printf(&quot;thread2: lock %d\t i %d\n&quot;, __LINE__, i);  

        if(i%3!=0){  
            printf(&quot;thread2: wait 1  %d\n&quot;, __LINE__);  
            pthread_cond_wait(&amp;cond,&amp;mutex);/* 解锁mutex，并等待cond改变*/  
            printf(&quot;thread2: wait 2  %d\n&quot;, __LINE__);  
        }  

        pthread_mutex_unlock(&amp;mutex);  
        printf(&quot;thread2: unlock %d\t i %d\n\n&quot;, __LINE__, i);  
        sleep(1);  
    }  
}</code></pre><p>编译运行结果如下：</p>
<pre><code>thread1: lock 31     i 1
thread1: unlock 41   i 1

thread2: lock 50     i 1
thread2: wait 1  53
thread1: lock 31     i 2
thread1: unlock 41   i 2

thread1: lock 31     i 3
thread1:signal 1  34
thread1:signal 2  36
thread1: unlock 41   i 3

thread2: wait 2  55
thread2: unlock 59   i 3

thread1: lock 31     i 4
thread1: unlock 41   i 4

thread2: lock 50     i 4
thread2: wait 1  53
thread1: lock 31     i 5
thread1: unlock 41   i 5

thread1: lock 31     i 6
thread1:signal 1  34
thread1:signal 2  36
thread1: unlock 41   i 6

thread2: wait 2  55
thread2: unlock 59   i 6</code></pre><p>线程1先执行，获得mutex锁，打印，然后释放mutex锁，然后阻塞自己1秒。</p>
<p>线程2执行,阻塞在pthread_mutex_lock(&amp;mutex)<br>这行语句中，直到线程1释放mutex锁。<br>然后线程2得已执行，获取metux锁，满足if条件，到pthread_cond_wait (&amp;cond,&amp;mutex)<br>这里线程2阻塞，不仅仅是等待cond变量发生改变，同时释放mutex锁。<br>mutex锁释放后，线程1终于获得了mutex锁，得已继续运行，当线程1的if（i%3==0）的条件满足后，<br>通过pthread_cond_signal发送信号，<br>告诉等待cond的变量的线程（线程2），cond条件变量已经发生了改变。</p>
<p>线程2并没有立即得到运行，因为线程2还在等待mutex锁的释放，<br>所以线程1继续往下走，直到线程1释放mutex锁，<br>线程2才能停止等待，打印语句，<br>然后往下走通过pthread_mutex_unlock(&amp;mutex)释放mutex锁，进入下一个循环。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h2><ul>
<li><a href="http://www.cnblogs.com/feisky/archive/2010/03/08/1680950.html" target="_blank" rel="noopener">Linux线程同步之条件变量</a></li>
<li><a href="http://blog.csdn.net/anonymalias/article/details/9174481" target="_blank" rel="noopener">Linux线程同步之条件变量</a></li>
<li><a href="http://my.oschina.net/solu/blog/125998" target="_blank" rel="noopener">线程同步之条件变量原理</a></li>
<li><a href="http://www.blogjava.net/fhtdy2004/archive/2009/07/05/285519.html" target="_blank" rel="noopener">线程同步：何时互斥锁不够，还需要条件变量?</a></li>
<li><a href="多线程同步条件变量">多线程同步条件变量</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-内存管理</title>
    <url>/2014/11/11/Linux-system-programming-Memory-Management/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p>内存管理包括<strong>内存分配（allocation）、内存操作（manipulation）和内存释放（release）。管理内存相关的函数如下：</strong></p>
<p><img src="http://img.ddvip.com/2009_09_10/1252583529_ddvip_8052.png" alt="linux下的管理内存相关的函数"></p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a><strong>进程地址空间</strong></h2><p>进程地址空间由进程可寻址的虚拟内存组成，对于某个虚拟内存地址，<br>它要在地址空间范围内，例如: 0421f000，这个值表示的是进程32位地址空间中的一个特定的字节。<br>尽管一个进程可以寻址4GB的虚拟内存（在32位的地址空间中），<br>但是这并不代表它有权访问所有的虚拟地址。<br>在地址空间中，我们更常用或者关心的是某个虚拟内存地址空间，比如 0848000-084c000，<br>它们可以被进程访问。我们称这些可被访问的合法地址空间称为虚拟内存区域。<br>通过内核，进程可以给自己的地址空间动态的增加或减少虚拟内存区域。</p>
<p>内核将具有某些相同特征的页组织成块（blocks），例如读写权限。<br>这些块叫做内存区域（memory regions），段（segments），或者映射（mappings）。<br>Linux进程的虚拟内存区域一般有：</p>
<ul>
<li>文本段（text segment）包含一个进程的代码、字符串、常量和一些只读数据。Linux直接从目标文件映射到内存中</li>
<li>堆栈段（stack）包含一个进程的执行栈，随着栈的深度变化会自动伸缩。执行栈中包含局部变量和函数的返回值</li>
<li>数据段（data segment），又叫堆（heap），包含一个进程的动态内存空间，通常由malloc()来分配</li>
<li>BSS段（bss segment）包含了未被初始化的全局变量</li>
</ul>
<p>每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程访问。<br>内核不用记录那些不存在的虚拟页，而这样的页也不占用存储器、磁盘或者内核本身的其他任何资源。</p>
<p>进程只能访问有效内存区域的内存地址，每个内存区域也具有相关权限，如可读、可写、可执行性质。<br>如果一个进程访问了无效范围中的内存区域或者以不正确的方式访问了有效地址，<br>那么内核就会终止该进程，并返回  “段错误”信息。</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a><strong>动态内存分配</strong></h2><p>C提供用于获取动态内存的接口：</p>
<pre><code>#include &lt;stdlib.h&gt;

void * malloc(size_t size);
void * calloc(size_t nr, size_t size);
void * realloc(void *ptr, size_t size);
void free(void *ptr);</code></pre><p>malloc()用于申请一段新的地址，参数size为需要内存空间的长度。可能返回NULL，必须检查返回值有效性。</p>
<p>calloc()与malloc()相似，参数size为申请地址的单位元素长度，nr为元素个数，常用于<strong>数组分配</strong>。<br>和malloc()不同的是，calloc()将分配的区域全部用0进行初始化。</p>
<p>realloc()是给一个已经分配了地址的指针重新分配空间，参数ptr为原有的空间地址，size是重新申请的地址长度。<br>size为0，相当于调用free()；ptr为NULL，相当于调用malloc()。</p>
<p>free()参数ptr可能是NULL，这时free()不做任何事情就返回，因此<strong>调用free()不需要检查ptr是否为NULL。</strong></p>
<p>realloc()和free()的ptr参数必须是通过调用malloc()、calloc()或者realloc()的返回值。</p>
<ul>
<li>malloc与calloc的区别为1块与n块的区别： </li>
<li>malloc调用形式为(类型*)malloc(size)：在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址。 </li>
<li>calloc调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址。 </li>
</ul>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a><strong>对齐</strong></h3><p>数据的对齐(alignment)是指数据的地址和由硬件条件决定的内存块大小之间的关系。<br>一个变量的地址是它大小的倍数的时候，这就叫做自然对齐 (naturally aligned)。<br>例如，对于一个32bit的变量，如果它的地址是4的倍数，<br>就是说，如果地址的低两位是0，那么这就是自然对齐了。<br>所以，如果一个类型的大小是2n个字节，那么它的地址中，至少低n位是0。<br>对齐的规则是由硬件引起的。<br>一些体系的计算机在数据对齐这方面有着很严格的要求。<br>在一些系统上，一个不对齐的数据的载入可能会引起进程的陷入。<br>在另外一些系统，对不对齐的数据的访问是安全的，但却会引起性能的下降。<br>在编写可移植的代码的时候，对齐的问题是必须避免的，所有的类型都该自然对齐。</p>
<p>在大多数情况下，编译器和C库透明地帮你处理对齐问题。<br>POSIX 标明了通过malloc()， calloc()， 和realloc()返回的地址对于任何的C类型来说都是对齐的。<br>在Linux中，这些函数返回的地址在32位系统是以8字节为边界对齐，<br>在64位系统是以16字节为边界对齐 的。有时候，对于更大的边界，例如页面，程序员需要动态的对齐。<br>虽然动机是多种多样的，但最常见的是直接块I/O的缓存的对齐或者其它的软件对硬件的交互，<br>因此，POSIX 1003.1d提供一个叫做posix_memalign( )的函数：</p>
<pre><code>/* one or the other -- either suffices */
#define _XOPEN_SOURCE 600
#define _GNU_SOURCE

#include &lt;stdlib.h&gt;

int posix_memalign (void **memptr,
        size_t alignment,
        size_t size);</code></pre><p>调用posix_memalign()成功时会返回size字节的动态内存，<br>并且这块内存的地址是alignment的倍数。<br>参数alignment必须是2的幂，还是void指针的大小的倍数。<br>返回的内存块的地址放在了memptr里面，函数返回值是0。</p>
<p>调用失败时，没有内存会被分配，memptr的值没有被定义，返回错误码。<br>要注意的是，对于这个函数，errno不会被设置，只能通过返回值得到。</p>
<p>由posix_memalign()获得的内存通过free()释放。用法很简单：</p>
<pre><code>char *buf;
int ret;

/* allocate 1 KB along a 256-byte boundary */
ret = posix_memalign (&amp;buf, 256, 1024);
if (ret) {
    fprintf (stderr, &quot;posix_memalign: %s\n&quot;,
            strerror (ret));
    return -1;
}
/* use &#39;buf&#39;... */
free (buf);</code></pre><p>更早的接口。在POSIX定义了posix_memalign( )之前，BSD和SunOS分别提供了如下接口：</p>
<pre><code>#include &lt;malloc.h&gt;
void * valloc (size_t size);
void * memalign (size_t boundary, size_t size);</code></pre><p>函数valloc()的功能和malloc()一模一样，但返回的地址是页面对齐的。<br>页面的大小很容易通过getpagesize()得到。</p>
<p>相似地，函数memalign()是以boundary字节对齐的，而boundary必须是2的幂。<br>在这个例子中，两个函数都返回一块足够大的内存去容纳一个ship结构，并且地址都是在一个页面的边界上：</p>
<pre><code>struct ship *pirate, *hms;
pirate = valloc (sizeof (struct ship));
if (!pirate) {
    perror (&quot;valloc&quot;);
    return -1;
}
hms = memalign (getpagesize ( ), sizeof (struct ship));
if (!hms) {
    perror (&quot;memalign&quot;);
    free (pirate);
    return -1;
}
/* use &#39;pirate&#39; and &#39;hms&#39;... */
free (hms);
free (pirate);</code></pre><p>在 Linux中，由这两个函数获得的内存都可以通过free()释放。<br>但在别的Unix系统却未必是这样，<br>一些系统并没有提供一个足够安全的机制去释放这些内存。<br>考虑移植性的程序不得不放弃使用这些接口来获得动态内存。<br><strong>Linux程序员最好只在考虑对老系统的兼容性时才使用它们；posix_memalign()更加强大。<br>只有在malloc()不能提供足够大的对齐时，这三个接口才需要使用。</strong></p>
<h2 id="数据段的管理"><a href="#数据段的管理" class="headerlink" title="数据段的管理"></a><strong>数据段的管理</strong></h2><p>Unix系统在历史上提供过直接管理数据段的接口。<br>然而，程序都没有直接地使用这些接口，因为malloc()和其它的申请方法更容易使用和更加强大。<br>在这里说一下这些接口来满足一下大家的好奇心，同时也给那些想实现他自己的基于堆栈的动态内存申请机制的人一个参考：</p>
<pre><code>#include &lt;unistd.h&gt;

int brk (void *end);
void * sbrk (intptr_t increment);</code></pre><p>这些功能的名字源于老版本的Unix系统，那时堆和栈还在同一个段中。<br>堆中动态存储器的分配由数据段的底部向上生长；栈从数据段的顶部向着堆向下生长。<br>堆和栈的分界线叫做break或break point。<br>在现代的系统里面，数据段存在于它自己的内存映射，我们继续用断点来标记映射的结束地址。</p>
<p>一个brk()的调用设置断点(数据段的末端)的地址为end。在成功的时候，返回0。失败的时候，返回-1，并设置errno为ENOMEM。</p>
<p>一个sbrk()的调用将数据段末端生长increment字节，increment可能是正数，也可能是负数。<br>sbrk()返回修改后的断点。所以，increment为0时得到的是现在断点的地址：</p>
<pre><code>printf (&quot;The current break point is %p\n&quot;, sbrk (0));</code></pre><p>尽管POSIX和C都没有定义这些函数。但几乎所有的Unix系统，都提供其中一个或全部。<br><strong>可移植的程序应该坚持使用基于标准的接口。</strong></p>
<h2 id="匿名内存映射"><a href="#匿名内存映射" class="headerlink" title="匿名内存映射"></a><strong>匿名内存映射</strong></h2><p>glibc的动态存储器使用了数据段和内存映射。<br>实现malloc()的经典方法是将数据段分为一系列的大小为2的幂的分区，<br>返回最小的符合要求的那个块来满足请求。<br>释放内存只是简单地将这块区域标记为“未使用”。<br>如果临近的分区是空闲的，他们会被合成一个更大的分区。<br>如果断点的下面是空的，系统可以用brk()来降低断点，使堆收缩，将内存返回给系统。</p>
<p>这个算法叫做<strong>伙伴内存分配算法（buddy memory allocation scheme）</strong>。<br>它的优势是高速和简单，但不好的地方是引入了两种碎片。<br>内部碎片（Internal fragmentation）发生在用更大的块来满足一个分配。<br>这样导致了内存的低使用率。<br>当有着足够的空闲内存来满足要求但这“块”内存分布在两个不相邻空间的时候，<br>外部碎片（External fragmentation）就产生了。<br>这会导致内存的低使用率（因为一块更大的不够适合的块可能被使用了），或者内存分配失败（在没有可供选择的块时）。</p>
<p>更有甚者，这个算法允许一个内存的分配“栓”住另外一个，<br>使得glibc不能向内核归还内存。<br>想象内存中的已被分配的两个块，块A和块B。<br>块A刚好在断点的下面，块B刚好在A的下面，就算释放了B，glibc也不能相应的调整断点直到A被释放。<br>在这种情况，一个长期存在的内存分配就把另外的空闲空间“栓”住了。</p>
<p>但这不需太过担忧。因为glibc并没有严格地将将释放的空闲内存返回给系统。<br>通常来说，在每次释放后堆并不收缩。<br>相反，glibc会维护释放的内存，为后续的分配保留着些自由的空间。<br>只有在堆与已分配的空间相比明显太大的时候，<br>glibc才会把堆缩小。然而，一个更大的分配，就能防止这个收缩了。</p>
<p>因此，对于较大的分配，glibc并不使用堆。<br>glibc使用一个匿名存储器映射（anonymous memory mapping）来满足请求。<br>匿名存储器映射和基于文件的映射是相似的，只是它并不基于文件-所以称为之“匿名”。<br>实际上，匿名存储器映射是一个简单的全0填充的大内存块，以供用户使用。<br>因为这种映射的存储不是基于堆的，所以并不会在数据段内产生碎片。</p>
<p>通过匿名映射来分配内存又下列好处：</p>
<ul>
<li>无需关心碎片。当程序不再需要这块内存的时候，只是撤销映射，这块内存就直接归还给系统了</li>
<li>匿名存储器映射能改变大小，有着改变大小的能力，还能像普通的映射一样接收参数</li>
<li>每个分配存在于独立的内存映射。没有必要再去管理一个全局的堆</li>
</ul>
<p>下面是两个使用匿名存储器映射而不使用堆的劣处：</p>
<ul>
<li>每个存储器映射都是页面大小的整数倍。<br>所以，如果大小不是页面整数倍的分配会浪费大量的空间。<br>这些空间更值得忧虑，因为相对于被分配的空间，被浪费掉的空间往往更多。</li>
<li>建立一个存储器映射比将堆里面的空间回收利用的代价更大，<br>因为堆几乎不涉及任何内核操作。越小的分配，这个劣处就明显。</li>
</ul>
<p><strong>权衡优缺点，glibc的malloc() 用数据段来满足小的分配，用存储器映射来满足大的分配。<br>临界点是可被设定的（看后面的高级内存分配），并且随着glibc版本的不同而变化。<br>目前，临界点一般是128KB：比128KB小的分配由堆实现，相应地，更大的由匿名存储器映射来实现。</strong></p>
<h3 id="创建匿名存储器映射"><a href="#创建匿名存储器映射" class="headerlink" title="创建匿名存储器映射"></a><strong>创建匿名存储器映射</strong></h3><p>可能你会想强制在堆上使用存储器映射来满足一个特定的内存分配，<br>也可能你会想写一个自己的存储分配系统，总之你可能会要手动创建你自己的匿名内存映射，Linux让这变得很简单。<br>回想第四章系统调用，用来创建存储器映射的mmap( )和取消映射的munmap( )：</p>
<pre><code>#include &lt;sys/mman.h&gt;

void * mmap (void *start,
        size_t length,
        int prot,
        int flags,
        int fd,
        off_t offset);

int munmap (void *start, size_t length);</code></pre><p>因为没有文件需要打开和管理，创建匿名存储器映射真的要比创建基于文件的存储器映射简单。<br>两者最关键的差别在于匿名标记是否出现，表示该映射是匿名映射。让我们来看看这个例子：</p>
<pre><code>void *p;

p = mmap (NULL,                         /* do not care where */
        512 * 1024,                     /* 512 KB */
        PROT_READ | PROT_WRITE,         /* read/write */
        MAP_ANONYMOUS | MAP_PRIVATE,    /* anonymous, private */
        -1,                             /* fd (ignored) */
        0);                             /* offset (ignored) */

if (p == MAP_FAILED)
    perror (&quot;mmap&quot;);
    else
    /* &#39;p&#39; points at 512 KB of anonymous memory... */</code></pre><p>对于大多数的匿名映射来说，mmap( )的参数都跟这个例子一样，<br>当然了，程序员决定的映射大小这个参数是个例外。别的参数一般都像这样：</p>
<ul>
<li>第一个参数是start，被设为NULL，意味着匿名映射可以在内核安排的任意地址上发生。<br>当然给定一个non-NULL值也是有可能的，必须是页对齐的，但这样会限制了可移植性。<br>实际上很少有程序真正在意映射到哪个地址上</li>
<li>prot参数经常都同时设置了PROT_READ和PROT_WRITE位，使得映射是可读可写的。<br>一块不能读写的空存储器映射是没有用的。<br>另外一方面，很少将可执行代码映射到匿名映射，因为那样做能产生潜在的安全漏洞。</li>
<li>flags参数设置MAP_ANONYMOUS位，来使得映射是匿名的，设置MAP_PRIVATE位，使得映射是私有的。</li>
<li>假如MAP_ANONYMOUS被设置了，fd和offset参数将被忽略的。<br>然而，在一些更早的系统里，需要让fd为-1，如果要考虑移植性，需要设置为-1。</li>
</ul>
<p>由匿名映射获得的内存块，看上去和由堆获得的一样。<br>使用匿名映射的一个好处是，那块内存交给你的时候，已经是全0的了。<br>这种映射还没有额外的开销，因为内核使用写时复制(copy-on-write)将内存块映射到了一个全0的页面上。<br>所以没有必要对返回的内存块使用memset()。<br>事实上，这是使用calloc()比使用malloc()后再使用memset()效率更高的原因之一。</p>
<p>系统调用munmap()释放一个匿名映射，归还已分配的内存给内核。</p>
<pre><code>int ret;

/* all done with &#39;p&#39;, so give back the 512 KB mapping */
ret = munmap (p, 512 * 1024);
if (ret)
    perror (&quot;munmap&quot;);</code></pre><h3 id="映射到-dev-zero"><a href="#映射到-dev-zero" class="headerlink" title="映射到/dev/zero"></a><strong>映射到/dev/zero</strong></h3><p>其它Unix系统，就像BSD，并没有MAP_ANONYMOUS标记。<br>作为替代，它们用一个特殊的设备文件/dev/zero实现了一个类似的解决方法。<br>这个设备文件提供了和匿名存储器语义上一致的实现。<br>一个映射包含了全0的写时复制页面；所以行为上和匿名存储器一样。</p>
<p>Linux一直支持/dev/zero设备，可以由映射这个文件来获得全0的内存块。<br>实际上，在引入之前MAP_ANONYMOUS，Linux的程序员就是这样做的。<br>为了对早期的Linux版本提供向后兼容性，或者对其他Unix系统的可移植性，<br>程序员仍然可以将映射/dev/zero作为匿名映射的替代。</p>
<pre><code>void *p;
int fd;

/* open /dev/zero for reading and writing */
fd = open (&quot;/dev/zero&quot;, O_RDWR);
if (fd &lt; 0) {
    perror (&quot;open&quot;);
    return -1;
}

/* map [0,page size) of /dev/zero */
p = mmap (NULL,                 /* do not care where */
        getpagesize ( ),        /* map one page */
        PROT_READ | PROT_WRITE, /* map read/write */
        MAP_PRIVATE,            /* private mapping */
        fd,                     /* map /dev/zero */
        0);                     /* no offset */

if (p == MAP_FAILED) {
    perror (&quot;mmap&quot;);
    if (close (fd))
        perror (&quot;close&quot;);
    return -1;
}

/* close /dev/zero, no longer needed */
if (close (fd))
    perror (&quot;close&quot;);

/* &#39;p&#39; points at one page of memory, use it... */</code></pre><p>在这种情况下映射的存储器也是用munmap()来取消映射。<br>这种实现引入了附加的打开和关闭文件的系统调用，所以会有额外的系统调用开销。<br>相比之下，匿名内存映射是一种较快的方法。</p>
<h2 id="高级内存分配"><a href="#高级内存分配" class="headerlink" title="高级内存分配"></a><strong>高级内存分配</strong></h2><p>很多内存分配操作受到glibc或内核的参数所限制和控制，可以通过调用<code>mallopt()</code>函数修改这些参数：</p>
<pre><code>#include &lt;malloc.h&gt;

int mallopt(int param, int value);</code></pre><p>控制内存分配函数的行为，param表示参数，value表示值。Linux目前支持6种param值：</p>
<ul>
<li>M_CHECK_ACTION，环境变量MALLOC_CHECK_的值</li>
<li>M_MMAP_MAX，最大内存映射数。达到限制后只能在数据段中分配，当为0时禁止使用匿名映射分配内存</li>
<li>M_MMAP_THRESHOLD，匿名映射阀值，当值为0时，所有分配启用匿名映射</li>
<li>M_MXFAST，fast bin的最大大小，fast bins是堆最特殊的内存块，永远不和临近的内存合并。当值为0时，禁止fast bin</li>
<li>M_TOP_PAD，当在堆顶的空闲空间到达设定的值时，则将这些内存还给系统。<br>这样做的目的是在堆项保留一些空闲空间，防止频繁的申请内存的系统调用</li>
<li>M_TRIM_THRESHOLD，堆的最小保持空间，只有超过这个设定值的堆内存，才有可能被sbrk回收，返还给系统</li>
</ul>
<p>程序必须在调用malloc()或其他内存分配之前，使用mallopt()，使用方法如下：</p>
<pre><code>int ret;

ret = mallopt(M_MMAP_THRESHOLD, 64*1024);
if(!ret)
    perror(&quot;mallopt&quot;);</code></pre><p>Linux提供了一组用来控制glibc内存分配系统的底层函数：</p>
<pre><code>#include &lt;malloc.h&gt;

size_t malloc_usable_size(void *ptr);   //查询一块已分配内存中有多少可用字节
int malloc_trim(size_t padding);        //强制glibc归还所有可释放的动态内存给内核，保留填充字节</code></pre><p><strong>除了调试和教学之外，其他地方几乎永远都不要使用这两个函数。</strong><br>他们是不可移植的，而且会将glibc内存分配系统的一些底层细节暴露给应用程序。</p>
<p><strong>调试内存分配</strong>，设置环境变量MALLOC_CHECK_，开启储存系统中高级的调试功能。<br>不必重新编译程序，简单执行如下命令：</p>
<pre><code>$ MALLOC_CHECK_=1 ./out.elf</code></pre><ul>
<li>0：忽略所有错误</li>
<li>1：信息输出到标准错误输出stderr</li>
<li>2：立即通过abort()终止</li>
</ul>
<p><strong>获取统计信息</strong>，通过mallinfo()函数，可以获取动态内存分配系统相关的统计信息，<br>malloc_stats()函数可以将内存相关的统计信息打印到stderr：</p>
<pre><code>#include &lt;malloc.h&gt;

struct mallinfo                                                                                                            
{
    int arena;    /* non-mmapped space allocated from system */
    int ordblks;  /* number of free chunks */
    int smblks;   /* number of fastbin blocks */
    int hblks;    /* number of mmapped regions */
    int hblkhd;   /* space in mmapped regions */
    int usmblks;  /* maximum total allocated space */
    int fsmblks;  /* space available in freed fastbin blocks */
    int uordblks; /* total allocated space */
    int fordblks; /* total free space */
    int keepcost; /* top-most, releasable (via malloc_trim) space */
};

struct mallinfo(void);
void malloc_stats(void);</code></pre><h2 id="基于栈的分配"><a href="#基于栈的分配" class="headerlink" title="基于栈的分配"></a><strong>基于栈的分配</strong></h2><p>alloca()函数，可以在堆栈上分配一块内存，当前函数退出时，由于系统堆栈指针的调整，这块内存会被自动回收。</p>
<pre><code>#include &lt;alloca.h&gt;

void * alloca(size_t size);</code></pre><p><strong>当调用alloca()的函数返回后，就不能再使用由alloca()得到的那块内存！<br>更要注意的是不要使用alloca()函数分配的内存作为一个函数的调用参数，<br>因为分配的内存块会存在于函数参数所保存的栈空间中。</strong></p>
<p>在各种编程文档中已经不太提倡使用了。因为它有许多不安全因素。<br>如果希望代码具有可移植性，应该避免使用alloca()函数。<br>但是，<strong>在Linux系统上，alloca()是一个非常好用的工具，表现很出色（使用calloca()分配内存和增加栈指针一样简单）。<br>在Linux下，对较小内存的分配，比malloc()有很大的性能提升。</strong></p>
<h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a><strong>内存操作</strong></h2><p>主要包含字节设置、字节比较、字节移动、字节查找和字节加密函数：</p>
<pre><code>#include &lt;string.h&gt;

void * memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void memmove(void *dst, const void *src, size_t n);     //支持内存区域重叠
void memcpy(void *dst, const void *src, size_t n);      //不支持内存区域重叠，但是可能效率高一些
void memccpy(void *dst, const void *src, int c, size_t n);
void memchr(const char *s, int c, size_t n);
void memrchr(const char *s, int c, size_t n);
void * memfrob(void *s, size_t n);      //加密，第二次调用解密</code></pre><h2 id="内存锁定"><a href="#内存锁定" class="headerlink" title="内存锁定"></a><strong>内存锁定</strong></h2><p>用于将一个或多个页面“锁定”在物理内存，以保证他们不会被交换到磁盘：</p>
<pre><code>#include &lt;sys/mman.h&gt;

int mlock(const void *addr, size_t n);
int mlockall(int flags);
int munlock(const void *addr, size_t n);
int munlockall(void);</code></pre><h2 id="投机性内存分配策略"><a href="#投机性内存分配策略" class="headerlink" title="投机性内存分配策略"></a><strong>投机性内存分配策略</strong></h2><p>Linux使用一种“投机性内存分配策略（opportunistic allocation strategy）”。<br>当进程想内核请求额外的内存时，内核作出了承诺，但实际上没有分配给进程任何物理存储。<br>仅当进程对新“分配到”的内存区域执行读写操作时，内核才履行承诺，分配一块物理内存。</p>
<p>出于以上策略，分配到的内存可能比实际的物理内存甚至比交换空间多得多。<br>这个特征叫做“超量使用（overcommitment）”。</p>
<p>当超量使用导致内存不足以满足一个请求时，就发生了“内存溢出（out of memory）”。<br>为了处理OOM，内核使用OOM Killer来挑选一个进程（最不重要又占用很多内存），并终止它。</p>
<p>可以通过修改<code>/proc/sys/vm/overcommit_memory</code>来控制超量使用：</p>
<ul>
<li>0：默认值，适度的超量使用策略</li>
<li>1：没有顾忌</li>
<li>2：禁止使用</li>
</ul>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-文件和目录管理</title>
    <url>/2014/11/11/Linux-system-programming-File-and-Directory-Management/</url>
    <content><![CDATA[<ul>
<li>toc<br>{:toc}</li>
</ul>
<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<h2 id="获得文件metadata的Stat家族"><a href="#获得文件metadata的Stat家族" class="headerlink" title="获得文件metadata的Stat家族"></a>获得文件metadata的Stat家族</h2><pre><code>#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;  
#include &lt;unistd.h&gt;  

struct stat{  
    dev_t st_dev; /*包含文件的设备号*/  
    ino_t st_ino; /*文件inode序列号 */  
    mode_t st_mode;/*文件的mode*/  
    nlink_t st_nlink; /*硬链接的数量*/  
    uid_t st_uid; /*文件的用户id*/  
    gid_t st_gid; /*文件的goup id*/  
    off_t st_size;/*文件大小*/  

    time_t st_atime;/*最后一次访问时间*/  
    time_t st_mtime;/*最后一次修改时间*/  
    time_t st_ctime;/*最后一次状态改变时间*/  
}  

int lstat(const char * restrict path, struct stat * restrict buf);  
int stat(const char *restrict path, struct stat * restrict buf);  
int fstat(int fd,struct stat *buf);  </code></pre><p>对于软链来说： </p>
<ul>
<li>lstat返回软链本身的状态 </li>
<li>stat返回软链所指文件的状态 </li>
</ul>
<p>例子： </p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;time.h&gt;  
#include &lt;sys/stat.h&gt;  

int isdirectory(char *path) {  
    struct stat statbuf;  

    if (stat(path, &amp;statbuf) == -1)  
        return 0;  
    else  
        return S_ISDIR(statbuf.st_mode);  
}  </code></pre><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>设置文件权限的系统调用： </p>
<pre><code>#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;  

int chmod(const char *path, mode_t mode);  
int fchmod(int fd,mode_t mode);  </code></pre><p>成功返回0，失败返回-1，并设置errno： </p>
<ul>
<li>EACCESS：没有搜索path的权限 </li>
<li>EBADF：fd不合法的文件描述符（仅fchmod) </li>
<li>EFAULT:path不合法的指针（仅chmod) </li>
<li>EIO：文件系统内部I/O错误 </li>
<li>ELOOP：由于symbolic link导致解析path死循环 </li>
<li>ENAMETOOLONG：path太长（仅chmod) </li>
<li>ENOENT：path不存在 </li>
<li>ENOME：内存不足 </li>
<li>ENOTDIR：不是一个目录（仅chmod) </li>
<li>EPERM:进程不是文件的owner或者缺少CAP_FOWNER能力。 </li>
<li>EROFS：文件在只读文件系统中。 </li>
</ul>
<h2 id="文件的所有者"><a href="#文件的所有者" class="headerlink" title="文件的所有者"></a>文件的所有者</h2><p>stat结构中st_uid和st_gid提供了文件的所有者和group，以下系统调用可以改变所有者： </p>
<pre><code>#include &lt;sys/types.h&gt;  
#include &lt;unistd.h&gt;  

int chown(const char *path, uid_t owner, gid_t group);  
int lchown(const char *path, uid_t owner, gid_t group);  
int fchown(int fd, uid_t owner, gid_t group);  </code></pre><p>chown和lchown区别：chown会follow simbolic link，改变link的目标文件，lchmod改变符号链接本身。<br>成功过返回0，失败返回-1，并设置errno。 </p>
<pre><code>struct group *gr;  
int ret;  

gr = getgrnam(&quot;officers&quot;);  
if(! gr){  
    perror(&quot;getgrnam&quot;);  
    return 1;  
}  

ret = chmod(&quot;manifest.txt&quot;,-1,gr-&gt;gr_gid);  
if(ret){  
    perror(&quot;chmod&quot;);  
    return 1;  
}  </code></pre><p>设置为root拥有者： </p>
<pre><code>int make_root_owner(int fd){  
    int ret;  

    ret = fchown(fd,0,0);  
    if(ret)  
        perror(&quot;fchown&quot;);  
    return ret;  
}  </code></pre><p>进程需要有CAP_CHOWN能力，也就是必须是root为所有。 </p>
<h2 id="文件系统Navigation"><a href="#文件系统Navigation" class="headerlink" title="文件系统Navigation"></a>文件系统Navigation</h2><h3 id="改变当前的工作目录"><a href="#改变当前的工作目录" class="headerlink" title="改变当前的工作目录"></a>改变当前的工作目录</h3><pre><code>#include &lt;unistd.h&gt;  

int chdir(const char *path);  
int fchdir(int fd);  </code></pre><p>将当前的工作目录指定为path：</p>
<pre><code>char *dir = &quot;/tmp&quot;;  
if(chdir(dir) == -1)  
    perror(&quot;Failed to change current working directory to /tmp&quot;);  </code></pre><h3 id="获得当前工作目录"><a href="#获得当前工作目录" class="headerlink" title="获得当前工作目录"></a>获得当前工作目录</h3><pre><code>#include &lt;unistd.h&gt;  

char *getcwd(char *buf, size_t size);  

例子： 

#include &lt;limits.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;unistd.h&gt;  
#ifndef PATH_MAX  
#define PATH_MAX 255  
#endif  

int main(void)
{  
    char mycwd[PATH_MAX];  
    if(getcwd(mycwd,PATH_MAX) == NULL){  
        perror(&quot;Failed to get current working directory&quot;);  
        return 1;  
    }  
    printf(&quot;Current working directory: %s\n&quot;,mycwd);  
    return 0;  
}  </code></pre><h3 id="path-conf"><a href="#path-conf" class="headerlink" title="path conf"></a>path conf</h3><pre><code>#include &lt;unistd.h&gt;  

long fpathconf(int fd, int name);  
long pathconf(const char *path,int name);  
sysconf(int name);  </code></pre><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><pre><code>#include &lt;sys/stat.h&gt;  
#include &lt;sys/types.h&gt;  

int mkdir(const char *path, mode_t mode);  </code></pre><p>成功返回0，失败返回-1，并设置好errno。没有可以递归删除与rm -r等价的系统调用。<br>如果目录非空，失败设置errno为ENOTEMPTY。 </p>
<pre><code>int ret;  

ret = rmdir(&quot;/home/fuliang/test&quot;);  
if(ret)  
    perror(&quot;rmdir&quot;);  </code></pre><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><pre><code>#include &lt;unistd.h&gt;  

int rmdir(const char *path);  

成功返回0，失败返回-1 </code></pre><h2 id="文件夹访问"><a href="#文件夹访问" class="headerlink" title="文件夹访问"></a>文件夹访问</h2><h3 id="opendir-closedir-readdir"><a href="#opendir-closedir-readdir" class="headerlink" title="opendir closedir, readdir"></a>opendir closedir, readdir</h3><pre><code>#include &lt;dirent.h&gt;  
DIR *opendir(const char *dirname);  
struct dirent *readdir(DIR *dirp);  
int closedir(DIR *dirp);  
void rewinddir(DIR *dirp);  </code></pre><p>例子：显示pathname下的文件： </p>
<pre><code>#include &lt;dirent.h&gt;  
#include &lt;errno.h&gt;  
#include &lt;stdio.h&gt;  

int main(int argc, char *argv[])
{  
    struct dirent *direntp;  
    DIR *dirp;  

    if(argc != 2){  
        fprintf(stderr,&quot;Usage %s directory_name\n&quot;, argv[0]);  
    }  

    if((dirp = opendir(argv[1])) == NULL){  
        perror(&quot;Failed to open directory&quot;);  
        return 1;  
    }  

    while((direntp = readdir(dirp)) != NULL)  
        printf(&quot;%s\n&quot;, direntp-&gt;d_name);  
    while((closedir(dirp) == -1) &amp;&amp; (errno == EINTR)) ;  
    return 0;   
}  </code></pre><p>dirent结构： </p>
<pre><code>struct dirent{  
    ino_t d_ino; /* inode number */  
    off_t d_off; /* offset to the next dirent */  
    unsigned short d_reclen; /* length of this record */  
    unsigned char d_type; /* type of file */  
    char d_name[256]; /*filename*/    
};  </code></pre><p>POSIX仅需要d_name字段，其他的都是可选的或者是linux特有的。<br>可移植性的程序应该只访问d_name字段。 </p>
<p>从Dir可以获得文件描述符： </p>
<pre><code>#define _BSD_SOURCE  
#include &lt;sys/types.h&gt;  
#include &lt;dirent.h&gt;  

int dirfd(DIR *dir);  </code></pre><p>这个是BSD的一个扩展，并不是POSIX标准。 </p>
<h3 id="访问文件的状态信息"><a href="#访问文件的状态信息" class="headerlink" title="访问文件的状态信息"></a>访问文件的状态信息</h3><p>lstat、stat </p>
<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><p>硬链接：两个path指向同一个inode.<br>软链接：单独的一个文件，里面存储了链接文件的路径。 </p>
<h3 id="创建和删除一个硬链接"><a href="#创建和删除一个硬链接" class="headerlink" title="创建和删除一个硬链接"></a>创建和删除一个硬链接</h3><pre><code>#include &lt;unistd.h&gt;  

int link(const char *path1, const char *path2);  
int unlink(const char *path);  </code></pre><p>为有path1指定的文件创建一个新的目录项。 </p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;unistd.h&gt;  

if (link(&quot;/dirA/name1&quot;,&quot;dirB/name2&quot;) == -1)  
    perror(&quot;Failed to make a new link in /dirB&quot;);  </code></pre><h3 id="创建和删除一个硬链接-1"><a href="#创建和删除一个硬链接-1" class="headerlink" title="创建和删除一个硬链接"></a>创建和删除一个硬链接</h3><pre><code>#include &lt;unistd.h&gt;  

int symlink(const char *path1, const char *path2);  </code></pre><h2 id="拷贝或者移动文件"><a href="#拷贝或者移动文件" class="headerlink" title="拷贝或者移动文件"></a>拷贝或者移动文件</h2><p>拷贝和移动文件时两个最基本的文件操作任务，可以使用shell命令cp和mv来完成。 </p>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><p>Unix没有提供此操作的系统调用或者库来完成拷贝文件和目录，但可以使用cp命令来手工执行这个任务。<br>拷贝一个文件src到目标dst，要执行的操作步骤： </p>
<ol>
<li>打开src </li>
<li>打开dst，创建如果不存在，清空如果存在。 </li>
<li>将src读取到内存 </li>
<li>将从src读取到的内容写入dst </li>
<li>继续指导所有内容从src写到dst </li>
<li>关闭dst </li>
<li>关闭src </li>
</ol>
<p>如果拷贝一个目录，递归拷贝目录本身及其子目录通过mkdir及其采用上面步骤拷贝文件。 </p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>Unix提供了移动文件的系统调用。ANSI C使用这个调用来移动文件，POSIX标准将其用于文件和目录。 </p>
<pre><code>#include &lt;stdio.h&gt;  

int rename(const char *oldpath, const char *newpath);  </code></pre><p>将路径名称从oldpath改成newpath，内容和inode没有变化。newpath需要在同一文件系统中。<br>成功返回0，失败返回-1，并设置errno。 </p>
<h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>ISO C标准定义了两个标准I/O函数来创建临时文件。 </p>
<pre><code>#include &lt;stdio.h&gt;  

char *tmpnam(char *ptr); /*返回执行路径的指针*/  
FILE *tmpfile(void); /*返回文件指针，错误则为NULL*/  </code></pre><p>tmpnam每次产生一个不同的合法的路径名字。如果ptr是NULL，生成一个存储在静态区域的名字，<br>并返回指向它的指针，所以如果连续调用两次会覆盖前一次的tmpname。<br>如果指定了ptr，则它被假设指向一个数组，并且长度不小于L_tmpnam（&lt;stdio.h&gt;中定义）。<br>例子： </p>
<pre><code>#include &lt;stdio.h&gt;  

int main(void){  
    char name[L_tmpnam],line[MAXLINE];  
    FILE *fp;  

    printf(&quot;%s\n&quot;,tmpnam(NULL));  
    tmpname(name);  
    printf(&quot;%s\n&quot;,name);  

    if((fp = tmpfile()) == NULL){  
        perror(&quot;tmpfile&quot;);  
        return 1;  
    }  

    fputs(&quot;one line of output\n&quot;,fp);  
    rewind(fp);  

    if(fgets(line,sizeof(line),fp) == NULL){  
        perror(&quot;fgets&quot;);  
        return 1;  
    }  
    fputs(line,stdout);  

    return 0;  
}  </code></pre><p>XSI扩展定义了两个另外的方法来操作临时文件： </p>
<pre><code>#include &lt;stdio.h&gt;  

char *tempnam(const char *directory, const char *prefix);  
int mkstemp(char *template);  </code></pre><p>tempnam和tmpnam一样，但是可以指定目录和前缀来生成临时文件名。 </p>
<ol>
<li>如果环境变量定义了TMPDIR，则使用它作为目录。 </li>
<li>如果directory不为NULL，则使用它。 </li>
<li>在&lt;stdio.h&gt;中的P_tmpdir作为目录。 </li>
<li>本地的目录，通常/tmp被作为临时目录。 </li>
</ol>
<p>前缀prefix如果不为NULL，至少5个字节。<br>生成的名字是通过malloc动态申请的内存，所以要使用free释放。 </p>
<pre><code>#include &lt;stdio.h&gt;  

int main(int argc, char *argv[]){  
    if(argc != 3){  
        pintf(&quot;usage: %s &lt;directory&gt; &lt;prefix&gt;&quot;,argv[0]);  
        return 1;  
    }  

    printf(&quot;%s\n&quot;,tempnam(argv[1][0] != &#39; &#39; ? argv[1] : NULL, argv[2][0] != &#39; &#39; ? argv[2] : NULL));  

    return 0;  
}  </code></pre><p>mkstemp和tmpfile类似，只是返回了文件描述符，并且mkstemp生成的临时文件不会自动清除。<br>path的后六个字符要设置为XXXXXX，通过替换它来生成不同的名字。 </p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
  </entry>
  <entry>
    <title>Linux系统编程-线程</title>
    <url>/2014/11/10/Linux-system-programming-thread/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p>线程是指在单个进程内，多路并行执行的创建和管理单元。由于线程引入了数据竞争和死锁，相关的编程错误不计其数。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程和线程</strong></h2><p>现代操作系统包括了两种对用户空间的基础的虚拟抽象：<strong>虚拟内存和虚拟处理器</strong>。<br>它们使进程认为自己独占机器资源。</p>
<p>虚拟内存为每个进程提供独立的内存地址空间，该内存地址连续映射到物理内存上。<br>虚拟处理器使得进程“感觉”只有自己正在运行，操作系统对其“隐藏”了事实：多个进程在可能多个处理器上以多任务方式同时运行。</p>
<p>虚拟内存是和进程相关的，与线程无关。<br>因此，每个进程有独立的内存空间，而进程中的所有线程共享这份空间。</p>
<p>虚拟处理器是和线程相关的，与进程无关。每个线程都是可独立调度的实体，支持单个进程每次“处理”多个操作。</p>
<p>和进程一样，线程也“感觉”自己独占一个处理器。<br>但是，和进程不一样的是，线程没有“感觉”自己独占内存–进程中的所有线程共享内存空间。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h2><p>进程是正在运行的程序的抽象。但是，为什么要分离执行单元，引入线程？多线程机制有以下优点：</p>
<ul>
<li>编程抽象：将工作分为多个模块，每个模块分配一个执行单元（线程）。<br>利用这种方法的设计模式包括“每个连接一个线程”和线程池模式</li>
<li>并发性：对多处理器提供了实现“真正并发”的高效方式。<br>每个线程有自己的虚拟处理器，作为独立的调度实体，可以在多处理器上运行多个线程，从而提高系统吞吐量</li>
<li>提高响应能力：单线程进程中，一个长时间运行的任务会影响应用对用户输入的响应，多线程中可以有一条线程响应用户输入</li>
<li>I/O阻塞：单线程中，I/O阻塞会影响整个进程</li>
<li>上下文切换：线程间切换的代价显著低于进程间的上下文切换</li>
<li>内存保存：线程提供了一种可以共享内存，并同时利用多个执行单元的高效方式</li>
</ul>
<p><strong>上下文切换</strong>：线程的一大性能优势是同一进程内的线程之间切换代价很低。<br>在任何系统上，进程内切换的代价低于进程间切换，前者通常是后者的一部分。<br>在非Linux系统上，这种差别非常明显，进程间通信（IPC）代价非常高。<br>因此，很多系统上，称线程为“轻量级进程”。在Linux中，进程间切换代价并不高，而进程内切换的成本接近于0：<br>接近进入和退出内核的代价。进程的代价不高，但是线程的代价更低。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a><strong>线程模型</strong></h2><p>在系统上实现线程模型的方式有好几种，因内核和用户空间提供的支持而有一定程度的级别差异。</p>
<p>最简单的是内核为线程提供了本地支持的情况，每个内核线程直接转换成用户空间的线程。<br>这种模型称为“1:1线程模型”，也称为“内核级线程模型”。<br>在Linux中只是简单的将线程实现成能够共享资源的进程。<br>线程库通过系统调用clone()创建一个新的线程，返回的“进程”直接作为用户空间的线程。</p>
<p>“用户级线程模型”是“N:1线程模型”，一个N个线程的进程只会映射到一个内核进程。</p>
<p>“混合式线程模型”是“N:M线程模型”，上述两中的综合，但是模型过于复杂。</p>
<p>Linux上普遍的线程模型是第一种。</p>
<h2 id="线程模式"><a href="#线程模式" class="headerlink" title="线程模式"></a><strong>线程模式</strong></h2><p>创建多线程应用最重要的一步是确定线程模式，线程模式也是应用程序的逻辑处理和I/O模式，<br>可能存在很多抽象和实现细节，但两个核心的编程模式是：</p>
<ul>
<li><strong>每个连接对应一个线程（thread-per-connection）</strong></li>
<li><strong>事件驱动（event-driven）</strong></li>
</ul>
<h2 id="并发性、并行性和竞争"><a href="#并发性、并行性和竞争" class="headerlink" title="并发性、并行性和竞争"></a><strong>并发性、并行性和竞争</strong></h2><p>并发性与并行性？？</p>
<p><strong>竞争条件</strong>是指由两个或多个线程对共享资源的非同步访问而导致错误的程序行为。<br>共享资源可以是系统硬件、内核资源或内存中的数据。后者最常见，称为数据竞争（date race）。<br>竞争发生的窗口–需要同步的代码–成为“临界区”。</p>
<h2 id="同步，互斥和死锁"><a href="#同步，互斥和死锁" class="headerlink" title="同步，互斥和死锁"></a><strong>同步，互斥和死锁</strong></h2><p>最常用来完成同步，实现临界区原子操作的技术是锁（lock），在Pthreads中称之为“互斥（mutexes）”。</p>
<p><strong>锁住数据，而不是代码</strong>，当锁和代码关联起来时，锁的语义就很难理解。<br>随着时间变化，锁和数据之间的关系就不会很清晰，程序员会为数据引入新的使用方式，而不会包含相应的锁。<br>把锁和数据关联，这个映射就会很清晰。</p>
<p>互斥的引入会带来编程BUG：死锁。</p>
<p>避免死锁需要从一开始的设计中为多线程设计好锁的机制。<br>互斥体应该和数据关联，而不是和代码关联，从而有清晰的数据层。<br>针对死锁（ABBA）问题，需要明确互斥获取的顺序。</p>
<h2 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a><strong>Pthreads</strong></h2><p>Linux内核只为线程的支持提供了底层原语，比如clone()系统调用。<br>POSIX对线程库进行了标准化，称之为POSIX线程，简称为Pthreads。<br>是UNIX系统上C／C++语言的主要线程解决方案。</p>
<h3 id="Pthread-API"><a href="#Pthread-API" class="headerlink" title="Pthread API"></a><strong>Pthread API</strong></h3><p>Pthreads是由glibc提供，存在于独立库libpthread中，使用时需要显示链接：</p>
<pre><code>gcc -Wall -Werror -pthread b.c -o b</code></pre><p>Pthread API在文件&lt;pthread.h&gt;中定义，每个函数前缀都是pthread_，可以分为两大类：<br><strong>线程管理（创建、销毁、连接和detach线程等）</strong>和<strong>同步（互斥、条件变量等）</strong>。</p>
<pre><code>#include &lt;pthread.h&gt;

int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func) (void *), void *arg);
int pthread_join (pthread_t tid, void ** status);
pthread_t pthread_self (void);
int pthread_equal(pthread_t t1, pthread_t t2);
int pthread_detach (pthread_t tid);
void pthread_exit (void *status);
int pthread_cancel(pthread_t thread);

int pthread_mutex_lock(pthread_mutex_t * mptr); 
int pthread_mutex_unlock(pthread_mutex_t * mptr); 

int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr); 
int pthread_cond_signal(pthread_cond_t *cptr); 
int pthread_cond_broadcast (pthread_cond_t * cptr);
int pthread_cond_timedwait (pthread_cond_t * cptr, pthread_mutex_t *mptr, const struct timespec *abstime);</code></pre><p>pthread_create用于创建一个线程，成功返回0，否则返回错误码（不使用errno）。</p>
<ul>
<li>pthread_t <em>tid：线程id的类型为pthread_t，通常为无符号整型，当调用pthread_create成功时，通过</em>tid指针返回。</li>
<li>const pthread_attr_t *attr：指定创建线程的属性，如线程优先级、初始栈大小、是否为守护进程等。<br>可以使用NULL来使用默认值，通常情况下我们都是使用默认值。</li>
<li>void <em>(</em>func) (void *)：函数指针func，指定当新的线程创建之后，将执行的函数。</li>
<li>void *arg：线程将执行的函数的参数。如果想传递多个参数，请将它们封装在一个结构体中。</li>
</ul>
<p>pthread_join用于等待某个线程退出，成功返回0，否则返回错误码（不使用errno）。<br>成功调用时，调用线程会被阻塞，直到由tid指定的线程终止，用于线程同步。</p>
<ul>
<li>pthread_t tid：指定要等待的线程ID</li>
<li>void ** status：如果不为NULL，那么线程的返回值存储在status指向的空间中（这就是为什么status是二级指针的原因！这种才参数也称为“值-结果”参数）。</li>
</ul>
<p>默认情况下，线程是创建成可join的。<br>pthread_detach用于是指定线程变为分离状态（不可join），就像进程脱离终端而变为后台进程类似。<br>成功返回0，否则返回错误码（不使用errno）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。<br>而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了pthread_join。</p>
<p><strong>pthread_join()或pthread_detach()都应该在进程中每个线程上调用，这样当线程终止时，也会释放资源。</strong></p>
<p>pthread_self用于返回当前线程的ID</p>
<p>pthread_equal用于比较两个线程ID是否一样，如果不同返回0</p>
<p>pthread_exit用于终止线程，可以指定返回值，以便其他线程通过pthread_join函数获取该线程的返回值。</p>
<p>pthread_cancel用于通过其他线程调用来结束线程。</p>
<p>在对临界资源进行操作之前需要pthread_mutex_lock先加锁，操作完之后pthread_mutex_unlock再解锁。<br>而且在这之前需要声明一个pthread_mutex_t类型的变量，用作前面两个函数的参数。</p>
<pre><code>int withdraw(struct account *account, int amount)
{
    pthread_mutex_lock(&amp;account-&gt;mutex);
    const int balance = account-&gt;balance;
    if(balance &lt; amount)
    {
        pthread_mutex_unlock(&amp;account-&gt;mutex);
        return -1;
    }

    account-&gt;balance = balance - amount;
    pthread_mutex_unlock(&amp;account-&gt;mutex);

    disburse_money(amount);

    return 0;
}</code></pre><p>在这个例子中，不是使用全局锁，而是在结构体中定义一把锁，这样每个account实例都有自己的锁，实现对数据的加锁。</p>
<p>条件变量是一种同步机制，允许线程挂起，直到共享数据上的某些条件得到满足。<br>条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。<br>条件变量要和互斥量相联结，以避免出现条件竞争–一个线程预备等待一个条件变量，<br>当它在真正进入等待之前，另一个线程恰好触发了该条件。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://fanqiang.chinaunix.net/a4/b8/20010811/0905001105.html" target="_blank" rel="noopener">Linux下的多线程编程</a></li>
<li><a href="http://www.cnblogs.com/skynet/archive/2010/10/30/1865267.HTML" target="_blank" rel="noopener">Linux多线程编程-吴秦</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-高级进程管理</title>
    <url>/2014/11/09/Linux-system-programming-process-02/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a><strong>进程调度</strong></h2><p><strong>进程调度器</strong>是内核子系统，用于将有限的处理器资源分配给系统中的各个进程。</p>
<p>多任务操作系统分为<strong>协同式（cooperative）</strong>和<strong>抢占式（preemptive）</strong>：</p>
<p>协同式多任务系统中，进程会一直运行到自己结束。这种自发结束的行为称为“让出（yielding）”。<br>操作系统不会强制要求让出。</p>
<p>抢占式多任务系统中，调度器决定某个进程何时停止运行，而由另一个进程运行，这种行为成为“抢占”。<br>进程在被抢占前所能够运行的时间成为该进程的“时间片（timeslice）”。</p>
<p>现代操作系统基本上都使用抢占式多任务机制。</p>
<h2 id="完全公平调度器"><a href="#完全公平调度器" class="headerlink" title="完全公平调度器"></a><strong>完全公平调度器</strong></h2><p>当前Linux进程调度器是在Linux内核版本2.6.23发布的，称为“完全公平调度器（Completely Fair Scheduler,CFS）”。<br>采用“公平入队（fair queuing）”调度算法，对竞争进程采取公平访问资源的策略。</p>
<p>和传统的UNIX进程调度器有很大区别，消除了时间片作为处理器访问分配单元，而是给每个进程分配了处理器的时间比例。</p>
<h2 id="让出处理器"><a href="#让出处理器" class="headerlink" title="让出处理器"></a><strong>让出处理器</strong></h2><pre><code>#include &lt;sched.h&gt;
int sched_yield(void);</code></pre><p>系统调用，支持进程主动让出处理器，并通知调度器选择新的进程来运行。<br>sched_yield()这个函数可以使用另一个级别等于或高于当前线程的线程先运行。<br>如果没有符合条件的线程，那么这个函数将会立刻返回然后继续执行当前线程的程序。</p>
<p>使用sched_yield()的两种情况：</p>
<ul>
<li>用户空间线程的锁定。如果一个线程试图取得另一个线程所持有的锁，<br>则新的线程应该让出处理器知道该锁变为可用。<br>用户空间锁没有内核的支持，这是一个最间单、最有效率的做法。<br>但是现在Linux线程实现引入一个使用futexes的优化解决方案。</li>
<li><strong>处理器密集型程序</strong>可用周期性调用sched_yield，<br>试图将该进程对系统的冲击减到最小。但是存在两个缺点：系统调度应该由调度器来承担，而不是用户进程。<br>而且减轻处理器密集应用带来的负担，是用户的责任，而不是某个应用。</li>
</ul>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a><strong>进程优先级</strong></h2><p>CFS中进程的nice value会决定进程会运行多长时间，或者说是占用的百分比。<br>可以通过系统调用nice来设置、获取进程的nice value。<br>该值的范围是(-20,19]，越低的值越高的优先级，实时进程应该是负数。</p>
<pre><code>#include &lt;unistd.h&gt;
int nice(int inc);</code></pre><p>nice()调用成功会在现有nice value上增加inc，并返回更新之后的值。<br>只有拥有CAP_SYS_NICE权限的进程（实际上即进程所有者为root）才可以使用负值inc，减少nice value。<br>从而提升该进程的优先级。因此，非root用户的进程只能降低优先级（增加nice value）。</p>
<p>因为nice()返回可以是-1，那么在判断是否系统调用失败的时候就要综合ret和errno。<br>调用前将errno值置为0，然后再检查errno：</p>
<pre><code>int ret;

errno = 0;
ret = nice(10); /*increase our nice by 10*/
if(ret == -1 &amp;&amp; errno != 0)
    perror(&quot;nice&quot;);
else
    printf(&quot;nice value is now %d\n&quot;, ret);</code></pre><p>还有两个系统调用可以更灵活地设置，<br>getpriority可以获得进程组、用户的任何进程中优先级最高的。<br>setpriority将所指定的所有进程优先级设置为prio:</p>
<pre><code>#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;

int getpriority(int which, int who);
int setpriority(int which, int who, int prio);</code></pre><ul>
<li>which取值为PRIO_PROCESS、PRIO_PGRP或PRIO_USER</li>
<li>who指定了进程ID、进程组ID或用户ID，当值为0时，调用分别在当前进程、当前进程组或当前用户上运行</li>
</ul>
<h2 id="处理器亲和力（Affinity）"><a href="#处理器亲和力（Affinity）" class="headerlink" title="处理器亲和力（Affinity）"></a><strong>处理器亲和力（Affinity）</strong></h2><p>Linux支持具有多个处理器的单一系统。在SMP上，系统要决定每个处理器上要运行那些程序，这里有两项挑战：</p>
<ul>
<li>调度程序必须想办法充分利用所有的处理器</li>
<li>切换程序运行的处理器是需要代价的</li>
</ul>
<p>进程会继承父进程的处理器亲和性，Linux提供两个系统调用用于获取和设定“硬亲和性”：</p>
<pre><code>int ret;
cpu_set_t set;

CPU_ZERO(&amp;set);
ret = sched_getaffinity(0, sizeof(cpu_set_t), &amp;set);
if(ret == -1)
    printf(&quot;调用失败!\n&quot;);
for(i = 0; i &lt; 10; i++){
    int cpu = CPU_ISSET(i, &amp;set);
    printf(&quot;cpu=%i is %s\n&quot;, i, cpu?&quot;set&quot;:&quot;unset&quot;);
}

CPU_ZERO(&amp;set);
CPU_SET(0, &amp;set);   /*allow CPU #0*/
CPU_CLR(1, &amp;set);   /*disallow CPU #1*/
ret = sched_setaffinity(0, sizeof(cpu_set_t), &amp;set);
if(ret == -1)
    printf(&quot;调用失败!\n&quot;);
for(i = 0; i &lt; 10; i++){
    int cpu = CPU_ISSET(i, &amp;set);
    printf(&quot;cpu=%i is %s\n&quot;, i, cpu?&quot;set&quot;:&quot;unset&quot;);
}</code></pre><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a><strong>实时系统</strong></h2><p>Linux除了正常的默认调度策略，还提供两种实时调度策略，头文件&lt;sched.h&gt;中宏定义：</p>
<ul>
<li>SCHED_FIFO，“先进先出”策略</li>
<li>SCHED_RR，“轮询”策略（round-robin）</li>
<li>SCHED_OTHER，标准调度策略，是非实时进程的默认调度策略，上述两种调度策略进程可以抢占它</li>
</ul>
<p>获得和设置调度策略的系统调用：</p>
<pre><code>#include &lt;sched.h&gt;

struct sched_param
{
    /* ... */
    int sched_priority;
    /* ... */
};

int sched_getscheduler(pid_t pid);
int sched_setscheduler(pid_t pid, int policy, const struct sched_param *sp);</code></pre><p>sched_getscheduler()用法：</p>
<pre><code>int policy;

/* Get our scheduling policy */
policy = sched_getscheduler(0);
switch(policy){
    case SCHED_OTHER:
        printf(&quot;Policy is normal.\n&quot;);
        break;
    case SCHED_RR:
        printf(&quot;Policy is round-robin.\n&quot;);
        break;
    case SCHED_FIFO:
        printf(&quot;Policy is first-in, first-out.\n&quot;);
        break;
    case -1:
        printf(&quot;sched_getscheduler failed.\n&quot;);
        break;
    default:
        printf(&quot;Unknow policy\n&quot;);</code></pre><p>sched_setscheduler()用法：</p>
<pre><code>int ret;
struct sched_param sp;

sp.sched_priority = 1;
ret = sched_setscheduler(0, SCHED_RR, &amp;sp);
if(ret == -1)
    printf(&quot;sched_setscheduler failed.\n&quot;);
if(errno == EPERM)
    printf(&quot;Process don&#39;t the ability.\n&quot;);</code></pre><p>sched_getparam和sched_setparam接口可用于取得、设定一个已经设定好的调度策略参数：</p>
<pre><code>int ret, i;
struct sched_param sp;

sp.sched_priority = 1;
ret = sched_setparam(0, &amp;sp);    
if(ret == -1)
    printf(&quot;sched_setparam error.\n&quot;);

ret = sched_getparam(0, &amp;sp);
if(ret == -1)
    printf(&quot;sched_getparam error.\n&quot;);</code></pre><p>Linux提供两个用于取得有效优先值的范围的系统调用：</p>
<pre><code>int min, max;
struct sched_param sp;

min = sched_get_priority_min(SCHED_RR);
if(min == -1)
    printf(&quot;sched_get_priority_min error.\n&quot;);

max = sched_get_priority_max(SCHED_RR);
if(max == -1)
    printf(&quot;sched_get_priority_max error.\n&quot;);

printf(&quot;SCHED_RR priority range is %d-%d\n&quot;, min, max);</code></pre><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a><strong>资源限制</strong></h2><p>Linux对进程加上了若干资源限制，这些限制是一个进程所能耗用的内核资源的上限。限制的类型如下：</p>
<ul>
<li>RLIMIT_AS:地址空间上限</li>
<li>RLIMIT_CORE:core文件大小上限</li>
<li>RLIMIT_CPU:可耗用CPU时间上限</li>
<li>RLIMIT_DATA:数据段与堆的上限</li>
<li>RLIMIT_FSIZE:所能创建文件的大小上限</li>
<li>RLIMIT_LOCKS:文件锁数目上限</li>
<li>RLIMIT_MEMLOCK:不具备CAP_SYS_IPC能力的进程最多将多少个字节锁进内存</li>
<li>RLIMIT_MSGQUEUE:可以在消息队列中分配多少字节</li>
<li>RLIMIT_NICE:最多可以将自己的友善值调多低</li>
<li>RLIMIT_NOFILE:文件描述符数目的上限</li>
<li>RLIMIT_NPROC:用户在系统上能运行进程数目上限</li>
<li>RLIMIT_RSS:内存中页面的数目的上限</li>
<li>RLIMIT_RTTIME:最多可以消耗CPU时间上限</li>
<li>RLIMIT_RTPRIO:不具备CAP_SYS_NICE能力进程所能请求的实时优先级的上限</li>
<li>RLIMIT_SIGPENDING:在队列中信号量的上限，Linux特有的限制</li>
<li>RLIMIT_STACK:堆栈大小的上限</li>
</ul>
<p>获取或设置这些限制的方法：</p>
<pre><code>int ret;
struct rlimit rlim;

rlim.rlim_cur = 32*1024*1024;
rlim.rlim_max = RLIM_INFINITY;
ret = setrlimit(RLIMIT_CORE, &amp;rlim);

ret = getrlimit(RLIMIT_CORE, &amp;rlim);
if(ret == -1)
    printf(&quot;getrlimit error.\n&quot;);
printf(&quot;RLIMIT_CORE limits: soft=%ld hard=%ld\n&quot;, rlim.rlim_cur, rlim.rlim_max);</code></pre>]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-进程管理</title>
    <url>/2014/11/03/Linux-system-programming-process/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<h2 id="程序、进程和线程"><a href="#程序、进程和线程" class="headerlink" title="程序、进程和线程"></a><strong>程序、进程和线程</strong></h2><p>程序（program）是指编译过的、可执行的二进制代码，保存在介质上，不运行。</p>
<p>进程（process）是指正在运行的程序。进程包括二进制镜像，加载到内存中，<br>还涉及到虚拟内存实例、内核资源、安全上下文，以及一个或多个线程。</p>
<p>线程（thread）是进程内的活动单元。每个线程包含自己的虚拟存储器，包括栈、进程状态如寄存器，以及指令指针。</p>
<p>在单线程的进程中，进程即线程。一个进程只有一个虚拟内存实例，一个虚拟处理器。<br>在多线程的进程中，由于虚拟内存是和进程关联的，所有线程共享相同的内存地址空间。</p>
<h2 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a><strong>进程ID</strong></h2><p>创建新进程的那个进程称为父进程，而新进程称为子进程。</p>
<p>获取进程ID和父进程ID：</p>
<pre><code>#include &lt;sys/types.h&gt;
#inlcude &lt;unistd.h&gt;

pid_t getpid(void);
pid_t getppid(void);</code></pre><h2 id="运行新进程"><a href="#运行新进程" class="headerlink" title="运行新进程"></a><strong>运行新进程</strong></h2><p>在UNIX中，将程序载入内存并执行程序映像的操作与创建新进程的操作是分离的。<br>一次系统调用会将二进制程序加载到内存中，替换地址空间原来的内容，<br>并开始执行。这个过程成为“执行（executing）”一个新的程序，是通过exec系列函数完成。</p>
<p>另一个不同的系统调用用于创建新的进程，相当于复制其父进程。<br>通常情况下，<strong>新的进程会立即执行新的程序</strong>。<br>创建新进程的操作称为派生（fork），是系统调用fork()来完成的。</p>
<p>在新进程中执行一个新的程序需要执行两个步骤：fork()和exec系列函数。</p>
<h3 id="exec系统调用"><a href="#exec系统调用" class="headerlink" title="exec系统调用"></a><strong>exec系统调用</strong></h3><p>函数原型如下：</p>
<pre><code>#include &lt;unistd.h&gt;

int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *filename, char *const argv[], char *const envp[]);</code></pre><p>exec系列函数只有execve()是真正的系统调用，其他都是基于该系统调用在C库中的封装函数。</p>
<p>这些函数如果调用成功则加载新的程序并跳转到新的程序入口点开始执行，不再返回，如果调用出错则返回-1。<br>所以，<strong>exec函数只有出错的返回值而没有成功的返回值</strong>。</p>
<p>函数名和参数解析：</p>
<ul>
<li>l和v分别表示参数以列表或数组（向量）方式提供，两种形式的最后一个参数必须为NULL。<br>由于execl、execlp、execle这三个函数都是可变参数函数，所以NULL应该转换为(char <em>)NULL或(char</em>)0</li>
<li>p表示会在用户的绝对路径path下查找可执行文件，不需要输入完整路径</li>
<li>…表示可变长度的参数列表</li>
<li>e表示会为新进程提供新的环境变量</li>
</ul>
<p>exec示例代码：</p>
<pre><code>#include &lt;unistd.h&gt;   

char *const ps_argv[] = {&quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL};   
char *const ps_envp[] = {&quot;PATH=/bin:/usr/bin&quot;, &quot;TERM=console&quot;, NULL};  

execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL);   
execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, (char*)0); 
execle(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL, ps_envp);   

execv(&quot;/bin/ps&quot;, ps_argv);    
execvp(&quot;ps&quot;, ps_argv); 
execve(&quot;/bin/ps&quot;, ps_argv, ps_envp); </code></pre><p>函数关系图如下：</p>
<p><img src="http://s12.sinaimg.cn/middle/674b5aaeg9a45c6c0bcbb&690" alt=""></p>
<h3 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork()系统调用"></a><strong>fork()系统调用</strong></h3><p>通过fork()系统调用可以创建一个和当前进程一样的新进程：</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);</code></pre><p>当fork()调用成功时，会创建一个新的进程，几乎与调用fork()的进程完全相同。<br>这两个进程都会继续运行，调用者进程从fork()返回后，还是照常运行。此处产生分叉点！</p>
<p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p>
<ul>
<li>在父进程中，fork返回新创建子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果出现错误，fork返回一个负值-1；</li>
</ul>
<p>可以通过fork返回的值来判断当前进程是子进程还是父进程,fork()系统调用用法：</p>
<pre><code>pid_t pid;

pid = fork();
if(pid &gt; 0)
    printf(&quot;I am the parent of pid=%d!\n&quot;, pid);
else if(0 == pid)
    printf(&quot;I am the child!\n&quot;);
else if(-1 == pid)
    printf(&quot;fork&quot;);</code></pre><p>一个进程调用fork()函数后，系统先给新的进程分配资源，<br>例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，<br>只有少数值与原来的进程的值不同。相当于克隆了一个自己。<br>在Linux中，采用写时复制（copy-on-write，COW）的方式，而不是对父进程空间的整体复制。</p>
<h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a><strong>终止进程</strong></h2><p>标准函数，用于终止当前进程：</p>
<pre><code>#include &lt;stdlib.h&gt;

void exit(int status);</code></pre><p>status值为0表示终止程序成功，用非0值表示异常终止。<br>标准C语言中数值0和宏EXIT_SCCESS的值表示终止成功，<br>宏EXIT_FAILURE的值表示终止不成功，其他值的含义由实现定义。<br>从函数main返回一个整数值相当于用这个值调用exit函数。</p>
<p>在终止进程之前，C库会安顺序执行一下操作步骤：</p>
<ul>
<li>所有通过atexit()或on_exit()函数（废止？）注册的函数按与注册时相反的顺序调用，注册几次就调用几次。</li>
<li>刷新打开的是输出流，关闭所有打开的数据流。</li>
<li>删除tmpfile()函数生成的临时文件。</li>
<li>完成用户空间需要做的所有工作，调用系统调用_exit()，内核可以处理终止进程的剩余工作。</li>
</ul>
<p>很多时候我们需要在程序退出的时候做一些诸如释放资源的操作，但程序退出的方式有很多种，<br>比如main()函数运行结束、在程序的某个地方用exit()结束程序、用户通过Ctrl+C或Ctrl+break操作来终止程序等等，<br>因此需要有一种与程序退出方式无关的方法来进行程序退出时的必要处理。<br>方法就是用atexit()函数来注册程序正常终止时要被调用的函数。</p>
<p>atexit()函数的参数是一个函数指针，<br>函数指针指向一个没有参数也没有返回值的函数。atexit()的函数原型是：</p>
<pre><code>int atexit (void (*function)(void));</code></pre><p>在一个程序中最多可以用atexit()注册32个处理函数，<br>这些处理函数的调用顺序与其注册的顺序相反，也即最先注册的最后调用，最后注册的最先调用。<br><strong>如果进程调用了exec函数，会清空所注册的函数列表。<br>如果进程是通过信号结束(SIGTERM和SIGKILL)，就不会调用这些注册的函数。</strong></p>
<h2 id="等待子进程结束"><a href="#等待子进程结束" class="headerlink" title="等待子进程结束"></a><strong>等待子进程结束</strong></h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);</code></pre><p><strong>僵尸进程</strong>：已经终止，但是它的父进程还没有获取到其状态的进程。<br>僵尸进程会消耗一些系统资源–仅仅是描述进程之前状态的一些概要信息。<br>主要是为父进程查询子进程状态时提供相应信息。<br>一旦父进程得到了想要的信息，内核就清除这些信息，僵尸进程终止。</p>
<h2 id="创建并等待新进程"><a href="#创建并等待新进程" class="headerlink" title="创建并等待新进程"></a><strong>创建并等待新进程</strong></h2><pre><code>#include &lt;stdlib.h&gt;

int system(const char *command);</code></pre><p>创建新进程并等待它结束，可以看作是同步创建进程。</p>
<p>调用system()会执行参数command所提供的命令，而且还可以为该命令指定参数。<br>“/bin/sh -c”会作为前缀添加到command参数前面。<br>通过这种方式，再把整个命令传递给shell。</p>
<p>实际上system()函数执行了三步操作：</p>
<ul>
<li>fork一个子进程</li>
<li>在子进程中调用exec函数去执行command</li>
<li>在父进程中调用wait去等待子进程结束</li>
</ul>
<h2 id="会话（Session）和进程组"><a href="#会话（Session）和进程组" class="headerlink" title="会话（Session）和进程组"></a><strong>会话（Session）和进程组</strong></h2><p>进程组：</p>
<ul>
<li>每个进程都属于某一个进程组</li>
<li>每个进程组都有一个进程组号，该号等于该进程组组长的PID号</li>
<li>一个进程只能为它自己或子进程设置进程组ID号</li>
</ul>
<p>会话(session)是一个或多个进程组的集合。<br>setsid()函数可以建立一个会话：</p>
<p>如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话。</p>
<ul>
<li>此进程变成该对话期的首进程</li>
<li>此进程变成一个新进程组的组长进程。</li>
<li>此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。<br>如果该进程是一个进程组的组长，此函数返回错误。</li>
<li>使任何进程不成为组长的方式：先调用fork()然后exit()父进程，此时只有子进程在运行</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a><strong>守护进程</strong></h2><p>Linux Daemon（守护进程）是运行在后台的一种特殊进程。<br>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。<br>它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。<br>Linux系统的大多数服务器就是通过守护进程实现的。<br>常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</p>
<p>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。<br>守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。</p>
<p>一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，<br>所以它是一个由init继承的孤儿进程。<br>守护进程是非交互式程序，没有控制终端，所以任何输出，<br>无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。</p>
<p>守护进程的名称通常以d结尾，比如sshd、xinetd、crond等</p>
<p>守护进程不想是任何已存在会话的成员，也不想拥有控制终端，创建守护进程所需步骤：</p>
<ul>
<li>调用fork，创建新进程，该进程将会成为守护进程</li>
<li>在守护进程的父进程中调用exit。确保父进程的父进程在其子进程结束时会退出，<br>保证了守护进程的父进程不再继续运行，而且守护进程不是首进程</li>
<li>调用setsid函数，使守护进程有一个新的进程组和会话，并作为两者的首进程。<br>保证了不存在和守护进程相关连的控制终端</li>
<li>调用chdir函数，让根目录成为守护进程的工作目录</li>
<li>关闭所有文件描述符</li>
<li>打开文件描述符0、1和2，并重定向到/dev/null</li>
</ul>
<p>代码如下：</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linux/fs.h&gt;

int main(void)
{
    pid_t pid;
    int i;

    //Create New Process
    pid = fork();
    if(-1 == pid)
        return -1;
    else if(0 == pid)
        exit(0);

    //Create new session and process group
    if(setsid() == -1)
        return -1;

    //Set the working dir to &quot;/&quot;
    if(chdir(&quot;/&quot;) == -1)
        return -1;

    //Close all open files
    for(i = 0; i &lt; NR_OPEN; i++)
        close(i);

    //Redirect fd&#39;s 0,1,2 to /dev/null
    open(&quot;/dev/null&quot;, O_RDWR);  //stdin
    dup(0); //stdout
    dup(0); //stderr

    //do its daemon thing ...
}</code></pre><p>其实我们完全可以利用daemon()函数创建守护进程，其函数原型：</p>
<pre><code>#include &lt;unistd.h&gt;

int daemon(int nochdir, int noclose);</code></pre><p>参数：</p>
<ul>
<li>nochdir：=0将当前目录更改至“/”</li>
<li>noclose：=0将标准输入、标准输出、标准错误重定向至“/dev/null”</li>
</ul>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-缓冲I/O</title>
    <url>/2014/11/02/Linux-system-programming-03-buffer-io/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p><strong>注意标准I/O调用与系统调用的区别</strong></p>
<p>针对频繁轻量级I/O请求通常会使用“用户缓冲I/O”（user-buffered I/O）来提高执行效率。</p>
<h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a><strong>标准I/O</strong></h2><p>C标准库中提供了标准I/O库（简称stdio），实现了跨平台的用户缓冲解决方案。<br>stdio不是直接操作文件描述符，而是通过唯一标识符，即<strong>文件指针（file pointer）</strong>来操作。<br>在标准C库中，文件指针和文件描述符一一映射。<br>文件指针是有指向类型定义FILE的指针表示，在&lt;stdio.h&gt;中。</p>
<p>在标准I/O中，打开的文件称为“流”（stream）。流可以被打开来读（输入流）、写（输出流）或者两者兼有。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a><strong>打开文件</strong></h2><p>文件通过fopen()打开以供读写操作：</p>
<pre><code>#include &lt;stdio.h&gt;
FILE * fopen(const char * path,const char * mode);</code></pre><p>该函数根据mode参数，按照指定模式打开path指向的文件，并给它关联上新的流。</p>
<ul>
<li>r   以只读方式打开文件，该文件必须存在。</li>
<li>r+  以可读写方式打开文件，该文件必须存在。</li>
<li>rb+ 读写打开一个二进制文件，允许读数据。</li>
<li>rt+ 读写打开一个文本文件，允许读和写。</li>
<li>w   打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>w+  打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>a   以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</li>
<li>a+  以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）</li>
<li>wb  只写打开或新建一个二进制文件；只允许写数据。</li>
<li>wb+ 读写打开或建立一个二进制文件，允许读和写。</li>
<li>wt+ 读写打开或着建立一个文本文件；允许读写。</li>
<li>at+ 读写打开一个文本文件，允许读或在文本末追加数据。</li>
<li>ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。</li>
</ul>
<p>如果成功的打开一个文件, fopen()函数返回文件指针,<br>否则返回空指针(NULL)。由此可判断文件打开是否成功：</p>
<pre><code>FILE *stream;
stream = fopen(&quot;/etc/text.c&quot;, &quot;r&quot;);
if(!stream)
    /*error*/</code></pre><h2 id="通过文件描述符打开流"><a href="#通过文件描述符打开流" class="headerlink" title="通过文件描述符打开流"></a><strong>通过文件描述符打开流</strong></h2><p>fdopen()函数用于在一个已经打开的文件描述符上打开一个流:</p>
<pre><code>#include &lt;stdio.h&gt;
FILE fdopen(int fd, const char *mode);</code></pre><p>其第1个参数表示一个已经打开的文件描述符，<br>第2个参数mode的意义和fopen()函数的第2个参数一样。<br>只有一点不同的是，由于文件已经被打开，所以fdopen函数不会创建文件，<br>而且也不会将文件截短为0，这一点要特别注意。<br>这两步操作在打开该文件描述符的时候已经完成。</p>
<h2 id="关闭流"><a href="#关闭流" class="headerlink" title="关闭流"></a><strong>关闭流</strong></h2><p>fclose()函数用来关闭一个由fopen()函数打开的文件 , 其调用格式为: </p>
<pre><code>int fclose(FILE *stream); </code></pre><p>该函数返回一个整型数。当文件关闭成功时, 返回0,　否则返回一个非零值。<br>可以根据函数的返回值判断文件是否关闭成功。 </p>
<h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a><strong>从流中读取数据</strong></h2><p><strong>为了成功调用读写函数，必须保证流以适当的模式打开。</strong></p>
<p>字节操作：</p>
<pre><code>#include &lt;stdio.h&gt;

int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
int ungetc(int c, FILE *stream);    //将字符放回到流中</code></pre><p>行操作：</p>
<pre><code>#include &lt;stdio.h&gt;

char * fgets(char *str, int size, FILE *stream);
int fputs(const char *str, FILE *stream);</code></pre><p>二进制操作，用于读写复杂的二进制数据，例如C语言的结构体：</p>
<pre><code>#include &lt;stdio.h&gt;

size_t fread(void *buf, size_t size, size_t nr, FILE *stream);
size_t fwrite(void *buf, size_t size, size_t nr, FILE *stream);</code></pre><h2 id="缓冲I-O示例"><a href="#缓冲I-O示例" class="headerlink" title="缓冲I/O示例"></a><strong>缓冲I/O示例</strong></h2><pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    FILE *in, *out;
    struct pirate {
        char name[100];
        unsigned long booty;
        unsigned int beard_len;
    } p, blackbeard = {&quot;Edward Teach&quot;, 950, 48};

    out = fopen(&quot;data&quot;, &quot;w&quot;);
    if(!out) {
        perror(&quot;fopen&quot;);
        return 1;
    }

    if(!fwrite(&amp;blackbeard, sizeof(struct pirate), 1, out)) {
        perror(&quot;fwrite&quot;);
        return 1;
    }

    if(fclose(out)) {
        perror(&quot;fclose&quot;);
        return 1;
    }

    in = fopen(&quot;data&quot;, &quot;r&quot;);
    if(!in) {
        perror(&quot;fopen&quot;);
        return 1;
    }

    if(!fread(&amp;p, sizeof(struct pirate), 1, in)) {
        perror(&quot;fwrite&quot;);
        return 1;
    }

    if(fclose(out)) {
        perror(&quot;fclose&quot;);
        return 1;
    }

    printf(&quot;name = %s booty = %lu beard_len = %u&quot;, p.name, p.booty, p.beard_len);

}</code></pre><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a><strong>定位流</strong></h2><pre><code>int fseek(FILE *stream, long offset, int whence);</code></pre><p>　　第一个参数stream为文件指针<br>　　第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移<br>　　第三个参数whence设定从文件的哪里开始偏移,可能取值为：SEEK_CUR、 SEEK_END 或 SEEK_SET<br>　　* SEEK_SET： 文件开头<br>　　* SEEK_CUR： 当前位置<br>　　* SEEK_END： 文件结尾</p>
<p>其他函数：</p>
<pre><code>int fsetpos(FILE *stream, fpos_t *pos); //fseek(stream, pos, SEEK_SET);
void rewind(FILE *stream);  //fseek(stream, 0, SEEK_SET);</code></pre><p>获取当前流位置的函数：</p>
<pre><code>long ftell(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);</code></pre><h2 id="刷新流"><a href="#刷新流" class="headerlink" title="刷新流"></a><strong>刷新流</strong></h2><pre><code>#include &lt;stdio.h&gt;

int fflush(FILE *stream);</code></pre><p>调用该函数时，stream指向的流中所有未写入的数据会被flush到内核中。<br>如果stream为NULL，进程中所有的stream会被flush。</p>
<p><strong>C函数库维持的缓冲区和内核本身的缓冲区之间的区别：</strong><br>C函数库维持的缓冲器存在于用户空间，调用的性能提升来自于用户空间，运行的是用话代码，而不是系统调用。<br>只有当需要访问磁盘介质时，才会发起系统调用。</p>
<p>fflush()函数的功能只是把用户缓冲区的数据写入到内核缓冲中，<br>但并不保证数据最终会写到物理介质上。如果需要这个功能，应该使用fsync()等函数。<br><strong>为了确保数据最终会备份存储，应该先保证用户缓冲区数据写到内核缓冲，然后保证内核缓冲写到磁盘介质上。</strong></p>
<h2 id="控制缓冲"><a href="#控制缓冲" class="headerlink" title="控制缓冲"></a><strong>控制缓冲</strong></h2><pre><code>int setvbuf( FILE *stream, char *buffer, int mode, size_t size );</code></pre><p>函数setvbuf()设置用于stream(流)的缓冲区到buffer(缓冲区),其大小为size(大小). mode(方式)可以是:</p>
<ul>
<li>_IOFBF, 表示完全缓冲 </li>
<li>_IOLBF, 表示线缓冲 </li>
<li>_IONBF, 表示无缓存</li>
</ul>
<p>在关闭流时，其使用的缓冲区必须存在，要注意自定义的缓冲区位于局部作用域时的有效性。例如：</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char buf[BUFSIZ];

    setvbuf(stdout, buf, _IOFBF, BUFSIZ);

    return 0;
    /* &#39;buf&#39; exits scope and is freed, but stdout isn&#39;t closed until later */
}</code></pre><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>标准I/O最大的诟病是两次拷贝带来的性能开销。<br>当读数据时，标准I/O会向内核发起read()系统调用，把数据从内核中复制到标准I/O缓冲区。<br>当应用通过标准I/O如fgets()发起读请求时，又会从标准I/O缓冲区拷贝到指定缓冲区。<br>写入请求时：数据先从指定缓冲区拷贝到标准I/O缓冲区，然后执行系统调用从标准I/O缓冲区写入内核。</p>
<p>与底层的系统调用相比，标准I/O为高层接口。</p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-I/O多路复用</title>
    <url>/2014/10/30/Linux-system-programming-03-io/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<p>I/O多路复用支持应用同时在多个文件描述符上阻塞，并在其中某个可以读写使收到通知。<br>在设计上遵循以下原则：</p>
<ul>
<li>I/O多路复用：当任何一个文件描述符I/O就绪时进行通知</li>
<li>都不可用？在有可用文件描述符之前一直处于睡眠状态</li>
<li>唤醒：某个文件描述符可用？</li>
<li>处理所有I/O就绪的文件描述符，没有阻塞</li>
<li>返回1，重新开始</li>
</ul>
<p>Linux提供了三种I/O多路复用方案：select、poll和epoll。首先讨论前两种，<br>epoll是Linux内核为处理大批量文件描述符而作了改进的poll，<br>是Linux下多路复用IO接口select/poll的增强版本，<br>它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h2><p>select()函数是4.2 BSD UNIX中引入的系统调用，其原型为:</p>
<pre><code>int select(int numfds, 
            fd_set *readfds, 
            fd_set *writefds, 
            fd_set *exceptfds, 
            struct timeval *timeout);</code></pre><p>其中readfds/writefds/exceptfds分别是select()监听的读/写和异常处理的文件描述符集合，<br>numfds的值是需要检查的最大的文件描述符加1。<br>timeout参数是一个指向struct timeval类型的指针，<br>它可以使select()在等待timeout时间后若没有文件描述符准备好则返回。</p>
<p>对于后四个参数来说如果不需要设置相关内容，传递NULL即可。</p>
<p>内核提供了以下宏用于监听描述符集合的设置与检查</p>
<pre><code>FD_ZERO(fd_set *fdset)          //清除文件描述符集合
FD_SET(int fd, fd_set *fdset)   //将一个文件描述符添加到文件描述符集合中
FD_CLR(int fd, fd_set *fdset)   //将一个文件描述符从文件描述符集合中移除
FD_ISSET(int fd, fd_set *fdset) //判断文件描述符是否被置位</code></pre><p>当应用程序使用FD_ZERO/FD_SET/FD_CLR宏设置好要监听的文件描述符集合后，<br>调用select()函数执行监听，如果没有一个描述符准备好IO并且没有指定超时时间，<br>那么select()函数会一直等待下去不会返回。<br>如果没有一个描述符处于I/O就绪状态并且指定了超时时间，那么在超时时间之后，<br>select()函数会返回，<strong>返回时，在不同的UNIX系统中，该结构体是未定义的，<br>因此每次调用必须（和文件描述符集一起）重新初始化</strong>。</p>
<p>当函数正常返回后，监听的文件描述符集合中没有准备好的文件描述符会被删除，<br>只剩下已经准备好的文件描述符，之后可以使用FD_ISSET(fd, set)宏来判断set集合中是否有fd文件描述符来判断fd是否准备好IO。</p>
<p>示例代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;

#define MAX_LISTEN 5
#define PORT 1987
#define IP &quot;127.0.0.1&quot;

int main()
{
    int conn_fd;
    int sock_fd = socket(AF_INET,SOCK_STREAM,0);
    if (sock_fd &lt; 0) {
        perror(&quot;create socket failed&quot;);
        exit(1);
    }

    struct sockaddr_in addr_client;
    int client_size = sizeof(struct sockaddr_in);

    struct sockaddr_in addr_serv;
    memset(&amp;addr_serv, 0, sizeof(addr_serv));
    addr_serv.sin_family = AF_INET;
    addr_serv.sin_port = htons(PORT);
    addr_serv.sin_addr.s_addr = inet_addr(IP);

    if (bind(sock_fd,(struct sockaddr *)&amp;addr_serv,sizeof(struct sockaddr_in)) &lt; 0) {
        perror(&quot;bind error&quot;);
        exit(1);
    }

    if (listen(sock_fd,MAX_LISTEN) &lt; 0) {
        perror(&quot;listen failed&quot;);
        exit(1);
    }

    int recv_num;
    int send_num;
    char recv_buf[100];
    char send_buf[100]; 

    //用一个数组记录描述符的状态
    int i, ready, max_fd;
    int client[FD_SETSIZE];
    for (i = 0;i &lt; FD_SETSIZE;i ++) {
        client[i] = -1;
    }

    fd_set readset;
    max_fd = sock_fd;

    //最大可用描述符的个数，一般受操作系统内核的设置影响，环境下这个值是1024
    printf(&quot;max fd num %d\n&quot;,FD_SETSIZE);

    while (1) {

        //重置监听的描述符
        FD_ZERO(&amp;readset);
        FD_SET(sock_fd,&amp;readset);
        for (i = 0;i &lt; FD_SETSIZE;i ++) {
            if (client[i] == 1) {
                FD_SET(i, &amp;readset);
            }
        }

        //开始监听描述符，是异步的，不会阻塞
        ready = select(max_fd+1, &amp;readset, NULL, NULL, NULL);

        //可用描述符如果是创建连接描述符，则创建一个新的连接
        if (FD_ISSET(sock_fd, &amp;readset)) {
            conn_fd = accept(sock_fd, (struct sockaddr *)&amp;addr_client, &amp;client_size);
            if (conn_fd &lt; 0) {
                perror(&quot;accept failed&quot;);
                exit(1);
            }

            FD_SET(conn_fd, &amp;readset);
            FD_CLR(sock_fd, &amp;readset);

            if (conn_fd &gt; max_fd) {
                max_fd = conn_fd;
            }
            client[conn_fd] = 1;    
        }

        //检查所有的描述符，查看可读的是哪个，针对它进行IO读写
        for (i = 0; i &lt; FD_SETSIZE; i ++) {
            if (FD_ISSET(i, &amp;readset)) {

                recv_num = recv(i, recv_buf, sizeof(recv_buf), 0);
                if (recv_num &lt;= 0) {
                    FD_CLR(i, &amp;readset);
                    client[i] = -1;
                }
                recv_buf[recv_num] = &#39;\0&#39;;
                memset(send_buf,0,sizeof(send_buf));
                sprintf(send_buf, &quot;server proc got %d bytes\n&quot;, recv_num);
                send_num = send(i, send_buf, strlen(send_buf), 0);
                if (send_num &lt;= 0) {
                    FD_CLR(i, &amp;readset);
                    client[i] = -1;
                }
            }
        }
    }

    close(sock_fd);
    return 0;
}</code></pre><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h2><p>poll()函数是System V中引入的系统调用，其原型为:</p>
<pre><code>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</code></pre><p>select()使用了基于文件描述符的三位掩码的解决方案，效率不高；<br>poll()使用了有nfds个pollfd结构体构成的数组，fds指针指向该数组。<br>pollfd结构体定义如下:</p>
<pre><code>sruct pollfd {
    int fd;         //文件描述符
    short events;   //等待的事件
    short revents;  //实际发生了的事件
};</code></pre><p>每一个pollfd结构体指定了一个被监视的文件描述符，<br>可以传递多个结构体，指示poll()监视多个文件描述符。<br>每个结构体的events域是监视该文件描述符的事件掩码，<br>由用户来设置这个域。<br>revents域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。</p>
<p>events域中请求的任何事件都可能在revents域中返回。合法的事件如下：</p>
<pre><code>POLLIN        有数据可读。
POLLRDNORM        有普通数据可读。
POLLRDBAND        有优先数据可读。
POLLPRI        有紧迫数据可读。
POLLOUT        写数据不会导致阻塞。
POLLWRNORM        写普通数据不会导致阻塞。
POLLWRBAND        写优先数据不会导致阻塞。
POLLMSGSIGPOLL        消息可用。</code></pre><p>此外，revents域中还可能返回下列事件：</p>
<pre><code>POLLER        指定的文件描述符发生错误。
POLLHUP        指定的文件描述符挂起事件。
POLLNVAL        指定的文件描述符非法。</code></pre><p>这些事件在events域中无意义，因为它们在合适的时候总是会从revents中返回。<br>使用poll()和select()不一样，你不需要显式地请求异常情况报告。</p>
<p>POLLIN | POLLPRI等价于select()的读事件，POLLOUT |POLLWRBAND等价于select()的写事件。<br>POLLIN等价于POLLRDNORM |POLLRDBAND，而POLLOUT则等价于POLLWRNORM。</p>
<p>例如，要同时监视一个文件描述符是否可读和可写，<br>我们可以设置 events为POLLIN |POLLOUT。<br>在poll返回时，我们可以检查revents中的标志，<br>对应于文件描述符请求的events结构体。<br>如果POLLIN事件被设置，则文件描述符可以被读取而不阻塞。<br>如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。<br>这些标志并不是互斥的：它们可能被同时设置，<br>表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。</p>
<p>timeout参数指定等待的毫秒数，无论I/O是否准备好，poll都会返回。<br>timeout指定为负数值表示无限超时，使poll()一直挂起直到一个指定事件发生；<br>timeout为0指示poll调用立即返回并列出准备好I/O的文件描述符，<br>但并不等待其它的事件。这种情况下，poll()就像它的名字那样，一旦选举出来，立即返回。</p>
<p><strong>返回值和错误代码</strong></p>
<p>成功时，poll()返回结构体中revents域不为0的文件描述符个数；<br>如果在超时前没有任何事件发生，poll()返回0；<br>失败时，poll()返回-1，并设置errno为下列值之一：</p>
<pre><code>EBADF　　       一个或多个结构体中指定的文件描述符无效。 
EFAULTfds　　 指针指向的地址超出进程的地址空间。 
EINTR　　　　  请求的事件之前产生一个信号，调用可以重新发起。 
EINVALnfds　　参数超出PLIMIT_NOFILE值。 
ENOMEM　　     可用内存不足，无法完成请求。</code></pre><p>示例代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;poll.h&gt;

#define TIMEOUT 5

int main(void)
{
    struct pollfd fds[2];
    int ret;

    //watch stdin for input
    fds[0].fd = STDIN_FILENO;
    fds[0].events = POLLIN;

    //watch stdout for ability to write
    fds[1].fd = STDOUT_FILENO;
    fds[1].events = POLLOUT;

    ret = poll(fds, 2, TIMEOUT*1000);
    if(-1 == ret) {
        perror(&quot;poll&quot;);
        return 1;
    }

    if(!ret) {
        printf(&quot;%d seconds elapsed.\n&quot;, TIMEOUT);
        return 0;
    }

    if(fds[0].revents &amp; POLLIN)
        printf(&quot;stdin is readable\n&quot;);

    if(fds[1].revents &amp; POLLOUT)
        printf(&quot;stdout is writable\n&quot;);

    return 0;
}</code></pre><p>在实际应用中，不需要在每次调用时都重新构建pollfd结构体。<br>该结构体会被重复传递多次，内核会在必要时把revents清空。</p>
<h2 id="poll-和select-区别"><a href="#poll-和select-区别" class="headerlink" title="poll()和select()区别"></a><strong>poll()和select()区别</strong></h2><p>select()和poll()函数本质上没有多大差别，<br>管理多个描述符也是进行轮询，根据描述符的状态进行处理，<br>但是poll没有最大文件描述符数量的限制。<br>并且select()返回后，之前没有准备好的文件描述符会从集合当中删除，<br>这样如果下次需要再次添加所有文件描述符或者使用两个相同的文件描述符集合，<br>一个用于备份，一个用于监听，比较复杂。poll不需要这个复杂的操作，不需要重新构建pollfd结构体。<br>poll和select同样存在一个缺点就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，<br>而无论这些文件描述符是否就绪。<br>它的开销随着文件描述符数量的增加而线性增加。</p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>P2P设备和Miracast设备发现过程</title>
    <url>/2014/10/21/p2p-find/</url>
    <content><![CDATA[<ul>
<li>toc<br>{:toc}</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="*"></a>*</h2><p>P2P Device Discovery用于P2P Devcie能够互相发现并构建P2P Group</p>
<p>WFD Devcie Discovery用于WFD Device能够互相发现并构建WFD Session，基于P2P技术，与之相比较多了WFD[协议2]内容</p>
<h2 id="P2P-Device-Discovery"><a href="#P2P-Device-Discovery" class="headerlink" title="P2P Device Discovery"></a>P2P Device Discovery</h2><p>P2P Device<br>Discovery consists of two major phases: Scan and Find, which are described in<br>detail in the following sections. <strong>P2P设备发现主要有Scan和Find两个阶段</strong></p>
<p>Device Discovery uses Probe Request and Probe Response frames to<br>exchange device information. The P2P Devices in a P2P Group are discovered<br>via a Probe Response frame from the P2P Group Owner.<strong>P2P设备发现利用Probe Request帧和Probe Response帧来发现周围P2P设备</strong></p>
<p>A P2P Device shall not respond to Probe Request frames unless it is:<br><strong>允许对Probe Request帧进行应答（发送Probe Response帧）的三种情况</strong></p>
<ul>
<li>a P2P Group Owner or</li>
<li>in the Listen State, or</li>
<li>a P2P Device associated with an infrastructure AP on the channel on<br>which the Probe Request was sent — in which case the P2P Device may<br>respond provided it is not already a member of a P2P Group.</li>
</ul>
<p>A P2P Device shall not transmit Beacon frames unless it is a P2P Group Owner. <strong>只有P2P GO才可以发送Beacon帧（信标帧）</strong></p>
<h3 id="Listen-State"><a href="#Listen-State" class="headerlink" title="Listen State"></a>Listen State</h3><p>In the Listen State a P2P Device dwells on a given channel,<br>termed the Listen Channel. This is a channel chosen from the list of Social<br>Channels. Channels 1, 6, and 11 in the 2.4 GHz band shall be used as the<br>Social Channels. The Listen Channel shall be chosen at the beginning of the<br>Device Discovery and shall remain the same until P2P Discovery completes.<br><strong>P2P Device在Device Discovery开始时在1,6,11频段中选择一个作为Listen Channel，<br>一旦选择好后，在整个P2P Discovery阶段就不再更改</strong></p>
<p>A P2P Device in the Listen State shall only reply to Probe Request frames that<br>contain the P2P IE, the P2P Wildcard SSID element, a Wildcard BSSID, and a<br>Destination Address that is either the broadcast address or its P2P Device<br>Address.<br><strong>P2P Device监听Probe Request帧并回复Probe Response帧。只处理那些包含了P2P IE信息的Probe Request帧</strong></p>
<p>One or more P2P IEs and the WSC IE shall be inserted after other information<br>elements in the Probe Response frames transmitted by a P2P Device.<br><strong>P2P IEs和WSC IE插入到Probe Response帧的尾部</strong></p>
<h3 id="Scan-Phase"><a href="#Scan-Phase" class="headerlink" title="Scan Phase"></a>Scan Phase</h3><p>In the Scan Phase, devices collect information about surrounding devices or networks<br>by scanning all supported channels.<br>The P2P Device in the Scan Phase shall not reply to Probe Request frames.<br><strong>P2P Device会在各个频段上发送Probe Request帧。<br>P2P Device在这一阶段中不会处理来自其他设备的Probe Request帧</strong></p>
<h3 id="Find-Phase"><a href="#Find-Phase" class="headerlink" title="Find Phase"></a>Find Phase</h3><p>The Find Phase is used to ensure that two simultaneously searching P2P<br>Devices arrive on a common channel to enable communication. This is<br>achieved by cycling between states where the P2P Device waits on a fixed<br>channel for Probe Request frames (the Listen State) or sends Probe Request<br>frames on a fixed list of channels (the Search State).<br><strong>Find Phase确保当两个设备处于同一频段，一方发送的帧才能被对方接收到，用于建立连接。<br>Search State中，P2P Device将发送Probe Request帧，<br>而Listen State中，它将接收其他设备的Probe Request帧并回复Probe Response帧</strong></p>
<p>In the Find Phase, a P2P Device shall alternate between the<br>Listen and Search states as specified below.<br><strong>P2P Device将在Search State和Listen State之间来回切换</strong></p>
<p>The duration of each Listen State within the Find Phase shall be a random<br>integer of 100 TU Intervals. This random number shall be no greater than the<br>maxDiscoverableInterval value and no less than the minDiscoverableInterval.<br>Default values for maxDiscoverableInterval and minDiscoverableInterval values<br>are 3 and 1 respectively. The randomness in the time spent in the Listen state is<br>to avoid a case where two P2P Devices in the Find Phase are in lock-step and<br>thus will never find each other. While in the Listen State within the Find Phase a<br>P2P Device shall be constantly available on the Listen Channel.<br><strong>在Find Phase中，Listen State的时间是100TU的整数倍，倍数值是一个随机数，<br>位于minDiscoverableInterval和maxDiscoverableInterval之间。<br>这两个值默认为1和3，而厂商可以修改。选择随机倍数的原因是为了防止两个Device进入Lock-Step，<br>即两个Device同时进入Listen State，等待相同的时间后又同时进入Search State。<br>如此，双方都无法处理对方的Probe Request信息（Search State中，Device只发送Probe Request）</strong></p>
<p>P2P Devices in the Search State shall transmit one or more Probe Request<br>frames on each of the Social Channels.<br><strong>处于Find Phase中的Search State时，它将在1,6,11频段上发送Probe Request帧</strong></p>
<p>A P2P Device in the Search State shall not reply to Probe Request frames.<br><strong>处于Find Phase中的Search State时，不会对Probe Request帧作出应答</strong></p>
<p>流程图如下：</p>
<p><img src="http://img.blog.csdn.net/20140319210923265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSW5ub3N0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<ul>
<li>Device Discovery开始</li>
<li>Sacn Phase，所有频段发送Probe Request帧</li>
<li>Find Phase，Listen Channel确定，不一定一样。在Listen State和Search State中切换</li>
<li>Listen State持续时间是100TU的随机整数倍，避免Lock-Step，只监听应答带有P2P IEs的Probe Request帧</li>
<li>Search State在channel1、6、11上发送Probe Request，不响应Probe Request帧</li>
<li>Find Phase中在Listen和Search中切换，一旦在某一个相同的channel上，完成Probe Request和Probe Response，即完成设备发现</li>
<li>图中最终设备在channel 6上完成Devcie Found</li>
</ul>
<p><strong>针对各个帧中所必须的内容，例如P2P IEs、WSC等，协议中有明确描述。</strong></p>
<h2 id="WFD-Devcie-Discovery"><a href="#WFD-Devcie-Discovery" class="headerlink" title="WFD Devcie Discovery"></a>WFD Devcie Discovery</h2><p>Wi-Fi Display Device Discovery builds upon the P2P Device Discovery mechanisms defined in [协议1]<br>enabling a WFD Device to quickly find a peer WFD Device and to determine whether a connection may be<br>established for a subsequent WFD Session.<br><strong>WFD Devcie Discovery基于P2P Device Discovery技术，用于找到WFD device并确认是否可以建立WFD Session</strong></p>
<p>A WFD Device shall comply with all procedures as specified for P2P Device Discovery in [协议1] with the<br>following additions.</p>
<ul>
<li><p>A WFD Device shall include the WFD Information Element (WFD IE) in all beacon, probe<br>request and probe response frames. The WFD IE carries basic information such as device-type and<br>device-status as specified in section 5.1.1 so as to facilitate an optimal connection with a peer<br>WFD Device. If a WFD Device is acting as a GO and receives a Probe Request frame containing a<br>WFD IE, then that WFD Device shall respond with a Probe Response frame containing the<br>information of its WFD capable client(s) as specified in section 5.1.11.</p>
</li>
<li><p>A WFD Device that is associated with an infrastructure AP, and that is operating as a Wi-Fi P2P<br>device, should respond to Probe Requests containing a P2P IE, a WFD IE, and a P2P wildcard<br>SSID. The Probe Response frame shall have the P2P IE and the WFD IE. This Probe Response<br>frame should be transmitted on the channel on which the Probe Request was received.</p>
</li>
<li><p><strong>WFD 设备在所有的beacon、probe request和probe response帧中有WFD IE，含有WFD Device的基本信息。<br>当一个WFD Device作为P2P GO并且收到一个含有WFD IE的Probe Request帧时，应该以一个含有它的WFD capable client(s)<br>的Probe Response帧作为应答</strong></p>
</li>
<li><p><strong>当WFD Device与一个infrastructure AP连接，并且作为P2P设备操作时，对Probe Requests帧的应答Probe Response帧<br>应该含有P2P IE、WFD IE、P2P wildcard SSID。</strong></p>
</li>
</ul>
<p><strong>在P2P Devcie Discovery基础上添加WFD IE可以实现WFD Device Discovery！！</strong></p>
<h2 id="相关数据帧分析"><a href="#相关数据帧分析" class="headerlink" title="相关数据帧分析"></a>相关数据帧分析</h2><ul>
<li>抓包环境    ：Omnipeek + winxp + Dlink DWA-125</li>
<li>P2P GO      ：Wifi-MT7601</li>
<li>WFD Sink    ：Wifi-MT7601</li>
<li>P2P Client  ：Phone-Huawei3C</li>
<li>WFD Source  ：Phone-Huawei3C</li>
</ul>
<p><strong>涉及三种数据帧</strong>：</p>
<ul>
<li><p>Beacon</p>
</li>
<li><p>Probe Request</p>
</li>
<li><p>Probe Response</p>
</li>
<li><p><strong>P2P IE : <code>OUI=50-6F-9A</code> 和 <code>OUI Type=0x9</code></strong></p>
</li>
<li><p><strong>WFD IE : <code>OUI=50-6F-9A</code> 和 <code>OUI Type=0xA</code></strong></p>
</li>
</ul>
<h3 id="Beacon帧"><a href="#Beacon帧" class="headerlink" title="Beacon帧"></a>Beacon帧</h3><p>普通的网络中AP发送的Beacon不带有P2P IE、WFD IE等信息，数据帧如下：</p>
<p><img src="/images/miracast/Normal_Beacon.JPG" alt="Normal Beacon" title="Normal Beacon"></p>
<p>做为GO的P2P设备发送的Beacon带有P2P IE、WFD IE等信息，数据帧如下：</p>
<p><img src="/images/miracast/Wfd_Beacon.JPG" alt="WFD Beacon" title="WFD Beacon"></p>
<p>其中涉及WFD IE的数据高亮如下：</p>
<p><img src="/images/miracast/Wfd_Beacon_data.JPG" alt="WFD Beacon Data" title="WFD Beacon Data for WFD IE"></p>
<p>根据 <code>OUI=50-6F-9A</code> 和 <code>OUI Type=0xA</code> 可以确认为WFD IE（WFD Information Element），其他数据解析如下：</p>
<ul>
<li>Subelement ID = 0x0 : WFD Device Information</li>
<li>Length = 0x0006 : Len段之后的数据长度</li>
<li>WFD Device Information = 0x0011 : 二进制数据0000 0000 0001 0001<ul>
<li>WFD Device Type bits 1:0 = 01b ： <strong>Primary Sink 说明是接收显示设备</strong></li>
<li>WFD Session Availability bits 5:4 = 01b ： Available for WFD Session</li>
<li>PC bit 7 = 0b : Preferred Connectivity (PC): P2P</li>
</ul>
</li>
<li>Session Management Control Port = 0x1c44 : 默认端口7236</li>
</ul>
<h3 id="Probe-Request帧"><a href="#Probe-Request帧" class="headerlink" title="Probe Request帧"></a>Probe Request帧</h3><p>P2P Devcie和WFD Source进行设备发现时发送的Probe Request帧有一些区别，主要是是否含有WFD IE，数据帧如下：</p>
<p>P2P Probe Request数据帧，只包含P2P IE：</p>
<p><img src="/images/miracast/P2P_Probe_Req.JPG" alt="P2P Probe Request" title="P2P Probe Request(No WFD IE)"></p>
<p>WFD Probe Request数据帧，包含P2P IE和WFD IE：</p>
<p><img src="/images/miracast/WFD_Probe_Req.JPG" alt="WFD Probe Request" title="WFD Probe Request(with WFD IE)"></p>
<p>WFD ID内容解析如下：</p>
<ul>
<li>Subelement ID = 0x0 : WFD Device Information</li>
<li>Length = 0x0006 : Len段之后的数据长度</li>
<li>WFD Device Information = 0x0010 : 二进制数据0000 0000 0001 0000<ul>
<li>WFD Device Type bits 1:0 = 00b ： <strong>WFD Source 说明是发送设备</strong></li>
<li>WFD Session Availability bits 5:4 = 01b ： Available for WFD Session</li>
<li>PC bit 7 = 0b : Preferred Connectivity (PC): P2P</li>
</ul>
</li>
<li>Session Management Control Port = 0x1c44 : 默认端口7236</li>
</ul>
<p><strong>根据数据帧内容可以知道:是否进行WFD Devcie Discovery取决于Probe Request帧中是否带有WFD IE！</strong></p>
<h3 id="Probe-Response帧"><a href="#Probe-Response帧" class="headerlink" title="Probe Response帧"></a>Probe Response帧</h3><p>Probe Request有两种格式，但是对Request的响应Probe Response只有一种格式，不论请求中是否有WFD IE，<br>Probe Response中都有WFD IE，数据帧如下：</p>
<p><img src="/images/miracast/WFD_Probe_Rsp.JPG" alt="WFD Probe Response" title="WFD Probe Response"></p>
<p>数据帧中看不到对WFD IE的解析，是因为Omnipeek软件的版本比较低，对WFD的协议支持不够，具体WFD IE数据如下：</p>
<p><img src="/images/miracast/WFD_Probe_Rsp_data.JPG" alt="WFD Probe Response" title="WFD Probe Response Date for WFD IE"></p>
<p>数据解析如下：</p>
<ul>
<li>Head : DD 29 50 6F 9A 0A</li>
<li>WFD Device Information : 00 00 06 00 11 1C 44 00 00 </li>
<li>Associated BSSID : 01 00 06 28 C6 8E 3C 93 B4</li>
<li>Coupled Sink Information : 06 00 07 00 00 00 00 00 00 00</li>
<li>Alternative MAC Address : 0A 00 06 00 11 7F 21 B3 77</li>
</ul>
<p><strong>根据Probe Request中是否含有WFD IE，当收到Probe Response时完成P2P Device 或 WFD Device Discovery！</strong></p>
<h2 id="相关标准协议"><a href="#相关标准协议" class="headerlink" title="相关标准协议"></a>相关标准协议</h2><ul>
<li>Wi-Fi Peer-to-Peer (P2P) Technical Specification Version 1.2</li>
<li>Wi-Fi Display Technical Specification v1.0.0</li>
<li>Wi-Fi Protected Setup Specification 1.0h</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>P2P</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-基本概念</title>
    <url>/2014/10/20/Linux-system-programming/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<h2 id="Linux系统编程的基础"><a href="#Linux系统编程的基础" class="headerlink" title="Linux系统编程的基础"></a><strong>Linux系统编程的基础</strong></h2><ul>
<li><strong>系统调用</strong>，系统编程始于系统调用，也终于系统调用。syscall是为了从操作系统请求一些服务或资源发起的函数调用。</li>
<li><strong>C库</strong>，是UNIX应用程序的核心。在现代Linux系统中，C库由GNU libc提供，简称glibc。<br>glibc中除了标准C库之外，还提供了系统调用封装、线程支持和基本应用工具。</li>
<li><strong>C编译器</strong>，标准C编译器是由GNU编译工具集（GNU Compiler Collection，gcc）提供的。</li>
</ul>
<h2 id="Linux编程的概念"><a href="#Linux编程的概念" class="headerlink" title="Linux编程的概念"></a><strong>Linux编程的概念</strong></h2><h3 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a><strong>文件和文件系统</strong></h3><p>文件是Linux系统中最基础最重要的抽象。Linux遵循一切皆文件的理念。因此，很多交互是通过读写文件来完成。</p>
<p>文件必须先打开才能访问。打开方式有只读、只写和读写模式。文件打开之后是通过<strong>唯一描述符</strong>来引用，<br>在Linux内核中，文件用一个整数表示（C语言的int类型），称为<strong>文件描述符</strong>（file descriptor，简称fd）。<br>文件描述符在用户空间共享，用户程序通过文件描述符可以直接访问文件。<br><strong>Linux系统编程的大部分工作都会涉及打开、操纵、关闭以及其他文件描述符操作。</strong></p>
<ul>
<li>普通文件（regular files），包含以字节流（线性数据）组织的数据。</li>
<li>目录和链接（diectory and link），目录是可读名称（文件名）到索引编号之间的映射。名称和索引节点之间的配对称为链接。</li>
<li>硬链接（hard links），不同名称的多个链接映射到同一个索引节点时，称该链接为硬链接</li>
<li>符号链接（symbolic links），类似于普通文件，有自己的索引节点和数据块，包含要链接文件的绝对路径。</li>
<li>特殊文件（special file），指以文件来表示的内核对象。Linux只支持以下四种设备：<ul>
<li>块设备文件</li>
<li>字符设备文件</li>
<li>命名管道（named pipes），通常称为FIFO，是以文件描述符作为通信信道的进程间通信（IPC）机制</li>
<li>UNIX域套接字（socket），进程间通信的高级形式</li>
</ul>
</li>
<li>文件系统和命名空间，Linux提供全局统一的文件和命名空间</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h3><p>进程是执行时的目标代码：活动的、正在运行的程序。但不仅仅包含目标代码，它还包含数据、资源、状态和虚拟计算机。</p>
<p>进程的生命周期从可执行代码开始，在Linux下，最常见的格式称为“可执行和可链接格式（Executable and Linkable Format，ELF）”。<br>包含多个元数据、多个代码段和数据段。代码段是线性目标代码块，可以加载到线性内存块中。</p>
<p>最重要和通用的段是文本段、数据段和bss段。</p>
<ul>
<li>文本段，包含可执行代码和只读数据如常量</li>
<li>数据段，包含初始化的数据</li>
<li>bss段，包含未初始化的全局数据。<strong>因为C标准规定C变量的默认值为0，因此没有必要在磁盘上将0保存到目标代码中。<br>相反的，根据目标代码可以很容易列举出bss段中未初始化的变量，内核在加载到内存时可以映射bss段中的全0页面，<br>bss段的设计完全出于性能优化。bss是block started by symbol的简称。</strong></li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h4><p>每个进程包含一个或多个<strong>执行线程</strong>（通常简称线程threads）。线程是进程内的活动单元。</p>
<p>线程包括栈、处理器状态、目标代码的当前位置（pc）。进程的其他部分由所有线程共享，最主要的是进程地址空间。</p>
<p>在用户空间，Linux依据POSIX 1003.1c实现线程模型（称为Pthreads）。目前Linux线程实现称为POSIX Threading Library（NPTL）。</p>
<h4 id="进程层次结构"><a href="#进程层次结构" class="headerlink" title="进程层次结构"></a><strong>进程层次结构</strong></h4><p>每个进程都有唯一的正整数标识，称为进程ID（pid）。在Linux中，进程有严格的层次结构，即进程树。<br>进程树的根是第一个进程，称为init进程，通常是init程序。新的进程通过调用fork()创建，原进程称为父进程，<br>fork()创建的新进程为子进程。当进程结束时，并不会立即从系统中删除。相反地，内核将在内存中保存该进程的部分内容，<br>允许父进程查询其状态，这被称为<strong>等待终止进程</strong>。一旦父进程确认某个子进程已经终止，该子进程就会完全被删除。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a><strong>信号</strong></h3><p>信号是一种单向异步通知机制。信号可能从内核发送到进程，也可能从进程发送到内核，或者进程发送给自己。<br>信号一般用于通知进程发生了某些事件，如段错误或按下ctrl-C。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a><strong>进程间通信</strong></h3><p>允许进程间交换信息并通知彼此所发生的事件是操作系统最重要的工作之一。Linux支持的进程间通信机制包括：</p>
<ul>
<li>管道</li>
<li>命名管道</li>
<li>信号量</li>
<li>消息队列</li>
<li>共享内存</li>
<li>快速用户空间互斥（futex）</li>
</ul>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><strong>头文件</strong></h3><p>内核本身和glibc提供大量用于系统编程的头文件，包括标准C库（&lt;string.h&gt;）以及一些UNIX（&lt;unistd.h&gt;）</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h3><p>在系统编程中，错误是通过函数返回值和errno描述。glibc为库函数和系统调用提供<strong>透明errno</strong>支持。<br>变量errno在&lt;errno.h&gt;中定义如下：<br>    extern int errno;</p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>System Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-文件I/O</title>
    <url>/2014/10/20/Linux-system-programming-02/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p><strong>专注于用户空间的系统级编程–即内核之上的所有内容。</strong></p>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a><strong>open()</strong></h2><p>函数头文件及原型：</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(const char * pathname, int flags);
int open(const char * pathname, int flags, mode_t mode);</code></pre><p>参数<code>pathname</code>指向欲打开的文件路径字符串。文件打开方式是根据参数<code>flags</code>值来确认的。</p>
<ul>
<li><strong>O_RDONLY</strong> 以只读方式打开文件</li>
<li><strong>O_WRONLY</strong> 以只写方式打开文件</li>
<li><strong>O_RDWR</strong> 以可读写方式打开文件</li>
</ul>
<p>上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.</p>
<ul>
<li><strong>O_CREAT</strong> 若欲打开的文件不存在则自动建立该文件.</li>
<li><strong>O_EXCL</strong> 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.</li>
<li><strong>O_NOCTTY</strong> 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.</li>
<li><strong>O_TRUNC</strong> 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.</li>
<li><strong>O_APPEND</strong> 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.</li>
<li><strong>O_NONBLOCK</strong> 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.</li>
<li><strong>O_NDELAY</strong> 同O_NONBLOCK.</li>
<li><strong>O_SYNC</strong> 以同步的方式打开文件.</li>
<li><strong>O_NOFOLLOW</strong> 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.</li>
<li><strong>O_DIRECTORY</strong> 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败。</li>
</ul>
<p>参数<code>mode</code>则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到umask值所影响, 因此该文件权限应该为 (mode-umaks).</p>
<ul>
<li><strong>S_IRWXU00700</strong> 权限, 代表该文件所有者具有可读、可写及可执行的权限.</li>
<li><strong>S_IRUSR</strong> 或<strong>S_IREAD</strong>, 00400 权限, 代表该文件所有者具有可读取的权限.</li>
<li><strong>S_IWUSR</strong> 或<strong>S_IWRITE</strong>, 00200 权限, 代表该文件所有者具有可写入的权限.</li>
<li><strong>S_IXUSR</strong> 或<strong>S_IEXEC</strong>, 00100 权限, 代表该文件所有者具有可执行的权限.</li>
<li><strong>S_IRWXG</strong> 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.</li>
<li><strong>S_IRGRP</strong> 00040 权限, 代表该文件用户组具有可读的权限.</li>
<li><strong>S_IWGRP</strong> 00020 权限, 代表该文件用户组具有可写入的权限.</li>
<li><strong>S_IXGRP</strong> 00010 权限, 代表该文件用户组具有可执行的权限.</li>
<li><strong>S_IRWXO</strong> 00007 权限, 代表其他用户具有可读、可写及可执行的权限.</li>
<li><strong>S_IROTH</strong> 00004 权限, 代表其他用户具有可读的权限</li>
<li><strong>S_IWOTH</strong> 00002 权限, 代表其他用户具有可写入的权限.</li>
<li><strong>S_IXOTH</strong> 00001 权限, 代表其他用户具有可执行的权限.</li>
</ul>
<p>例如：<strong>S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IROTH 等效于 0664</strong></p>
<p>返回值：若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1. 错误代码：</p>
<ul>
<li><strong>EEXIST</strong> 参数pathname 所指的文件已存在, 却使用了O_CREAT 和O_EXCL 旗标.</li>
<li><strong>EACCESS</strong> 参数pathname 所指的文件不符合所要求测试的权限.</li>
<li><strong>EROFS</strong> 欲测试写入权限的文件存在于只读文件系统内.</li>
<li><strong>EFAULT</strong> 参数pathname 指针超出可存取内存空间.</li>
<li><strong>EINVAL</strong> 参数mode 不正确.</li>
<li><strong>ENAMETOOLONG</strong> 参数 pathname 太长.</li>
<li><strong>ENOTDIR</strong> 参数pathname 不是目录.</li>
<li><strong>ENOMEM</strong> 核心内存不足.</li>
<li><strong>ELOOP</strong> 参数pathname 有过多符号连接问题.</li>
<li><strong>EIO</strong> I/O 存取错误.</li>
</ul>
<h3 id="creat"><a href="#creat" class="headerlink" title="creat()"></a><strong>creat()</strong></h3><p>O_WRONLY | O_CREAT | O_TRUNC 的组合经常被使用，因此专门有个系统调用提供这个功能：</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int creat(const char *name, mode_t mode);</code></pre><p>典型的creat()调用如下：</p>
<pre><code>int fd;
fd = creat(filename, 0664);</code></pre><p>等效于：</p>
<pre><code>int fd;
fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0664);</code></pre><h2 id="read"><a href="#read" class="headerlink" title="read()"></a><strong>read()</strong></h2><p>每次调用read()函数，会从fd指向的文件的当前偏移开始读取len字节到buf所指向的内存中。调用成功则返回写入buf中的字节数；<br>出错时，返回-1，并设置errno值。函数原型：</p>
<pre><code>#include &lt;unistd.h&gt;
ssize_t read(int fd, void *buf, size_t len);</code></pre><p>调用read()的返回值：</p>
<ul>
<li>返回值等于len，结果和预期一致</li>
<li>返回值大于0，但小于len，有很多原因：读取过程中信号中断、出错、提前到达EOF等</li>
<li>返回值为0，EOF，没有更多可读数据</li>
<li>返回值为-1，errno为EINTR，表示读取任何字节之前接收到信号。调用可以重新执行</li>
<li>返回值为-1，errno为EAGAIN，表示当前没有数据可用，读取操作会阻塞，请求应稍后重新执行</li>
<li>返回值为-1，errno非EINTR或EAGAIN，表示更严重错误，重新执行也不会成功</li>
</ul>
<p>读取所有字节且处理了异常情况的示例：</p>
<pre><code>ssize_t ret;
while(len != 0 &amp;&amp; (ret = read(fd, buf, len)) != 0) {
    if(ret == -1) {
        if(errno == EINTR)
            continue;
        perror(&quot;read&quot;);
        break;
    }
    len -= ret;
    buf += ret;
}</code></pre><h2 id="write"><a href="#write" class="headerlink" title="write()"></a><strong>write()</strong></h2><p>write()调用会从文件描述符fd指向的文件的当前位置开始，将buf中至多count个字节写入到文件中。<br>执行成功时返回写入的字节数，并更新文件位置。出错时，返回-1，并设置errno值。函数原型：</p>
<pre><code>#include &lt;unistd.h&gt;
ssize_t write(int fd, const void *buf, size_t count);</code></pre><h2 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a><strong>同步I/O</strong></h2><p>为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了系统调用sync()、fsync()和fdatasync()，函数原型：</p>
<pre><code>#include &lt;unistd.h&gt;
void sync(void);
int fsync(int fd);
int fdatasync(int fd);</code></pre><p>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。</p>
<p>fsync函数只对由文件描述符fd指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。<br>该效用会回写数据和元数据，如创建的时间戳以及索引节点中的其他属性。<br>因为文件的数据和metadata通常存在硬盘的不同地方，因此fsync至少需要两次IO写操作。</p>
<p>fdatasync函数类似于fsync，区别在于fdatasync只会写入数据以及之后要访问文件所需要的元数据，<br>例如，会将文件大小回写，但是不保证所有非基础的元数据也写到磁盘上，比fsync函数执行更快。</p>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a><strong>关闭文件</strong></h2><p>当程序完成对某个文件的操作后，可以通过系统调用close()取消文件描述符到对应文件的映射：</p>
<pre><code>#include &lt;unistd.h&gt;
int close(int fd);</code></pre><p>调用之后，先前给定的文件描述符不再有效，内核可以重用它。</p>
<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a><strong>lseek()</strong></h2><p>每一个已打开的文件都有一个读写位置, 当打开文件时通常其读写位置是指向文件开头,<br>若是以附加的方式打开文件(如O_APPEND), 则读写位置会指向文件尾.<br>当read()或write()时, 读写位置会随之增加,lseek()便是用来控制该文件的读写位置.<br>参数fd为已打开的文件描述词, 参数pos为根据参数origin来移动读写位置的位移数.</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
off_t lseek(int fd, off_t pos, int origin);</code></pre><p>参数 <code>origin</code> 为下列其中一种:</p>
<ul>
<li><strong>SEEK_SET</strong> 参数pos即为新的读写位置.</li>
<li><strong>SEEK_CUR</strong> 以目前的读写位置往后增加pos个位移量.</li>
<li><strong>SEEK_END</strong> 将读写位置指向文件尾后再增加pos个位移量. 当origin值为SEEK_CUR 或SEEK_END 时, 参数pos允许负值的出现.</li>
</ul>
<p>示例：</p>
<ul>
<li>欲将读写位置移到文件开头时:lseek(int fd, 0, SEEK_SET);</li>
<li>欲将读写位置移到文件尾时:lseek(int fd, 0, SEEK_END);</li>
<li>想要取得目前文件位置时:lseek(int fd, 0, SEEK_CUR);</li>
</ul>
<p>返回值：当调用成功时则返回目前的读写位置, 也就是距离文件开头多少个字节. 若有错误则返回-1, errno 会存放错误代码.</p>
<h2 id="文件截短"><a href="#文件截短" class="headerlink" title="文件截短"></a><strong>文件截短</strong></h2><p>Linux提供两个系统调用支持文件截短，原型如下：</p>
<pre><code>#inclide &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
int ftruncate(int fd, off_t len);
int truncate(const char *path, off_t len);</code></pre><p>这两个系统调用都将文件截短为参数len指定的长度。成功时返回0，出错时返回-1并设置相应errno值。<br>len小于原文件大小时，新文件长度变为len，介于之前len和原文件大小之间的数据被丢弃，不可再读。<br>len大于原文件大小时，新扩展出来的字节使用0来填充。</p>
]]></content>
      <categories>
        <category>Linux System Programming</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>wpa_supplicant模块及代码结构</title>
    <url>/2014/10/19/wpa-supplicant-introduction/</url>
    <content><![CDATA[<p>wpa_supplicant is a WPA(Wi-Fi Protected Access) Supplicant for Linux,<br>BSD and Windows with support for WPA and WPA2 (IEEE 802.11i / RSN).<br>Supplicant is the IEEE 802.1X/WPA component that <strong>is used in the client stations</strong>.<br>It implements key negotiation with a WPA Authenticator<br>and it can optionally control roaming<br>and IEEE 802.11 authentication/association of the wlan driver.</p>
<h2 id="wpa-supplicant模块结构"><a href="#wpa-supplicant模块结构" class="headerlink" title="wpa_supplicant模块结构"></a><a href="http://w1.fi/wpa_supplicant/" target="_blank" rel="noopener" title="wpa_supplicant">wpa_supplicant模块结构</a></h2><p>wpa_supplicant模块图如下：</p>
<p><img src="http://w1.fi/wpa_supplicant/devel/_wpa_supplicant.png" alt=""></p>
<h3 id="Event-loop-事件循环模块"><a href="#Event-loop-事件循环模块" class="headerlink" title="Event loop/事件循环模块"></a><strong>Event loop/事件循环模块</strong></h3><p>wpa_supplicant uses a single process/thread model<br>and an event loop to provide callbacks on events<br>(registered timeout, received packet, signal).<br>eloop.h defines the event loop interface. eloop.c is<br>an implementation of such an event loop using select() and sockets.<br>This is suitable for most UNIX/POSIX systems.<br>When porting to other operating systems,<br>it may be necessary to replace that implementation with OS specific<br>mechanisms that provide similar functionality.</p>
<p>wpa_supplicant采用单线程模式，基于事件驱动（event loop）。</p>
<h3 id="l2-packet-link-layer-access-LLC包模块"><a href="#l2-packet-link-layer-access-LLC包模块" class="headerlink" title="l2_packet (link layer access)/LLC包模块"></a><strong>l2_packet (link layer access)/LLC包模块</strong></h3><p>wpa_supplicant needs to have access to<br>sending and receiving layer 2 (link layer) packets with two Ethertypes:<br>EAP-over-LAN (EAPOL) 0x888e and RSN pre-authentication 0x88c7. l2_packet.h<br>defines the interfaces used for this in the core wpa_supplicant implementation.</p>
<h3 id="Configuration-配置模块"><a href="#Configuration-配置模块" class="headerlink" title="Configuration/配置模块"></a><strong>Configuration/配置模块</strong></h3><p>wpa_supplicant implements a configuration interface<br>that allows the backend to be easily replaced in order to read<br>configuration data from a suitable source depending on the target<br>platform. config.c implements the generic code that can be shared with<br>all configuration backends. Each backend is implemented in its own config_*.c file.</p>
<h3 id="Driver-interface-驱动接口模块"><a href="#Driver-interface-驱动接口模块" class="headerlink" title="Driver interface/驱动接口模块"></a><strong>Driver interface/驱动接口模块</strong></h3><p>Unless the target OS and driver is already supported,<br>most porting projects have to implement a driver wrapper.<br>This may be done by adding a new driver interface module or<br>modifying an existing module (driver_*.c) if the new target<br>is similar to one of them. Driver wrapper implementation describes<br>the details of the driver interface<br>and discusses the tasks involved in porting this part of wpa_supplicant.</p>
<h3 id="Control-interface-控制接口模块"><a href="#Control-interface-控制接口模块" class="headerlink" title="Control interface/控制接口模块"></a><strong>Control interface/控制接口模块</strong></h3><p>wpa_supplicant uses a control interface<br>to allow external processed to get status information<br>and to control the operations. Currently, this is implemented with<br>socket based communication; both UNIX domain sockets and UDP sockets are supported.<br>If the target OS does not support sockets,<br>this interface will likely need to be modified to<br>use another mechanism like message queues.<br>The control interface is optional component,<br>so it is also possible to run wpa_supplicant without porting this part.</p>
<h3 id="Driver-events-驱动事件模块"><a href="#Driver-events-驱动事件模块" class="headerlink" title="Driver events/驱动事件模块"></a><strong>Driver events/驱动事件模块</strong></h3><p>wpa_supplicant needs to receive event callbacks<br>when certain events occur<br>(association, disassociation, Michael MIC failure, scan results available, PMKSA caching candidate).<br>These events and the callback details are defined in<br>driver.h (wpa_supplicant_event() function and enum wpa_event_type).</p>
<h3 id="XXX-state-machine-状态机模块"><a href="#XXX-state-machine-状态机模块" class="headerlink" title="XXX state machine/状态机模块"></a><strong>XXX state machine/状态机模块</strong></h3><p>WPA/WPA2 state machine,EAP state machine(RFC4137),EAPOL state machine(802.1X).</p>
<h2 id="wpa-supplicant代码结构"><a href="#wpa-supplicant代码结构" class="headerlink" title="wpa_supplicant代码结构"></a><a href="http://w1.fi/wpa_supplicant/devel/code_structure.html" target="_blank" rel="noopener" title="wpa_supplicant">wpa_supplicant代码结构</a></h2><p>wpa_supplicant implementation is divided into number of independent modules.<br>Core code includes functionality for controlling the network selection,<br>association, and configuration. Independent modules include WPA code<br>(key handshake, PMKSA caching, pre-authentication),<br>EAPOL state machine, and EAP state machine and methods.<br>In addition, there are number of separate files for generic helper functions.</p>
<p>Both WPA and EAPOL/EAP state machines can be used separately<br>in other programs than wpa_supplicant. As an example,<br>the included test programs eapol_test and preauth_test are using these modules.</p>
<p>Driver interface API is defined in driver.h<br>and all hardware/driver dependent functionality is implemented in driver_*.c.</p>
<p>wpa_supplicant的实现被分成几个独立的模块。<br>核心代码功能包括控制网络选择、连接和配置。<br>独立模块包括WPA代码（key handshake，PMKSA缓存，预认证），EAPOL状态机和EAP状态机和方法。<br>另外，还有一些具有通用帮助功能的单独文件。</p>
<p>WPA和EAPOL/EAP状态机可以单独的用于其它的程序中。<br>代码中有eapol_test和preauth_test实例代码使用这另个模块。</p>
<ul>
<li>wpa_supplicant core functionality/核心功能</li>
<li>Generic helper functions/通用辅助</li>
<li>Cryptographic functions/加密功能</li>
<li>TLS library/TLS库</li>
<li>Configuration/配置</li>
<li>Control interface/控制接口</li>
<li>WPA supplicant/WPA提供</li>
<li>EAP peer/EAP点</li>
<li>EAPOL supplicant/EAPOL提供</li>
<li>Windows port/windosw端口</li>
<li>Test programs/测试程序</li>
</ul>
<p>Driver interface API在driver.h中定义的，所有硬件/驱动相关的功能都是在driver_*.c中实现的。</p>
<h3 id="wpa-supplicant-core-functionality-核心功能"><a href="#wpa-supplicant-core-functionality-核心功能" class="headerlink" title="wpa_supplicant core functionality/核心功能"></a><strong>wpa_supplicant core functionality/核心功能</strong></h3><ul>
<li>wpa_supplicant.c 程序初始化、控制主循环。</li>
<li>main.c main()用于类UNIX或Windows操作系统设置参数配置wpa_supplicant。</li>
<li>events.c 驱动事件处理；wpa_supplicant_enent()和相关功能。</li>
<li>wpa_supplicant_i.h 核心功能和的内部定义；在独立的模块中不应该包含这个头文件。</li>
</ul>
<h3 id="Generic-helper-functions-通用辅助"><a href="#Generic-helper-functions-通用辅助" class="headerlink" title="Generic helper functions/通用辅助"></a><strong>Generic helper functions/通用辅助</strong></h3><p>wpa_supplicant使用同样的辅助功能，其中的一些与hostapd共用的。目前使用代码如下：</p>
<ul>
<li>eloop.c和eloop.h 事件循环（select()循环，具有可选超时、socket读数据回调和信号回调）</li>
<li>common.c和common.h Common辅助函数。</li>
<li>defs.h 多个文件共用定义</li>
<li>l2_packet.h, l2_packet_linux.c,和 l2_packet_pcap.c Layer2（连接层）访问包装<br>（包括linux本地的实现和对libdnet/libpcap的包装）函数。<br>在移植到libdnet/libpcap不支持的新系统的时候需要添加新的l2_packet实现。<br>可以用Makefile来选择包含那个l2_packet实现。<br>l2_packet_linux.c使用linux packet sockets，l2_packet_pcap.c使用libpcap和libdnet，具有更好的移植性</li>
<li>pcsc_funcs.c and pcsc_funcs.h Wrapper for PC/SC lite SIM and smart card readers</li>
<li>priv_netlink.h 来自linux内核文件的私有版本的网络连接定义，它可以被C库头文件替代once suitable version becomes commonly available。</li>
<li>version.h 版本号定义</li>
<li>wireless.h 来自内核的linux wireless extension私有版本定义；可以被C库头文件代替once suitable version becomes commonly available。</li>
</ul>
<h3 id="Cryptographic-functions-加密功能"><a href="#Cryptographic-functions-加密功能" class="headerlink" title="Cryptographic functions/加密功能"></a><strong>Cryptographic functions/加密功能</strong></h3><ul>
<li>md5.c and md5.h MD5算法 (如果TLS支持开启，使用加密库取代) HMAC-MD5 (键入校验码以验证信息真伪)</li>
<li>rc4.c and rc4.h RC4算法（广播/默认密钥加密）</li>
<li>sha1.c and sha1.h SHA-1算法 (如果TLS支持开启，使用加密库取代) HMAC-SHA-1 (键入校验码以验证信息真伪) PRF-SHA-1 (pseudorandom (key/nonce generation) function) PBKDF2-SHA-1 (ASCII passphrase to shared secret) T-PRF (for EAP-FAST) TLS-PRF (RFC 2246)</li>
<li>sha256.c and sha256.h SHA-256算法 (如果TLS支持开启，使用加密库取代)</li>
<li>aes_wrap.c, aes_wrap.h, aes.c AES算法 (如果TLS支持开启，使用加密库取代), AES Key Wrap Algorithm with 128-bit KEK, RFC3394 (broadcast/default key encryption), One-Key CBC MAC (OMAC1) hash with AES-128, AES-128 CTR mode encryption, AES-128 EAX mode encryption/decryption, AES-128 CBC</li>
<li>crypto.h crypto库封装定义</li>
<li>crypto_openssl.c libcrypto封装函数 (OpenSSL)</li>
<li>crypto_internal.c crypto封装函数内部实现</li>
<li>crypto_gnutls.c libgcrypt封装函数(used by GnuTLS)</li>
<li>ms_funcs.c and ms_funcs.h MSCHAPV2 和 LEAP 帮助函数</li>
<li>tls.h TLS库封装定义</li>
<li>tls_none.c Dummy implementation of TLS library wrapper for cases where TLS functionality is not included.</li>
<li>tls_openssl.c TLS library wrapper for openssl</li>
<li>tls_internal.c TLS library for internal TLS implementation</li>
<li>tls_gnutls.c TLS library wrapper for GnuTLS</li>
</ul>
<h3 id="TLS-Transport-Layer-Security，传输层安全协议-library-TLS库"><a href="#TLS-Transport-Layer-Security，传输层安全协议-library-TLS库" class="headerlink" title="TLS(Transport Layer Security，传输层安全协议) library/TLS库"></a><strong>TLS(Transport Layer Security，传输层安全协议) library/TLS库</strong></h3><ul>
<li>asn1.c and asn1.h ASN.1 DER编码分析</li>
<li>bignum.c and bignum.h 大数运算（Big number math）</li>
<li>rsa.c and rsa.h RSA加密算法</li>
<li>x509v3.c and x509v3.h X.509v3数字证书分析和处理</li>
<li>tlsv1_client.c, tlsv1_client.h TLSv1客户端 (RFC 2246)</li>
<li>tlsv1_client_i.h TLSv1 client内部结构体</li>
<li>tlsv1_client_read.c TLSv1 客户端: 读握手信息</li>
<li>tlsv1_client_write.c TLSv1 客户端: 写握手信息</li>
<li>tlsv1_common.c and tlsv1_common.h TLSv1通用规则和定义（routines and definitions）</li>
<li>tlsv1_cred.c and tlsv1_cred.h TLSv1证书</li>
<li>tlsv1_record.c and tlsv1_record.h TLSv1记录协议</li>
</ul>
<h3 id="Configuration-配置"><a href="#Configuration-配置" class="headerlink" title="Configuration/配置"></a><strong>Configuration/配置</strong></h3><ul>
<li>config_ssid.h 每个网络的配置项定义</li>
<li>config.h wpa_supplicant的配置定义</li>
<li>config.c 配置解析器和命令函数</li>
<li>config_file.c 文本配置文件后端(e.g., wpa_supplicant.conf)</li>
<li>config_winreg.c 配置Windows注册表后端(Configuration backend for Windows registry)</li>
</ul>
<h3 id="Control-interface-控制接口"><a href="#Control-interface-控制接口" class="headerlink" title="Control interface/控制接口"></a><strong>Control interface/控制接口</strong></h3><p>wpa_supplicant有一个可以被外部程序用来得到状态信息和进行管理操作的控制接口。<br>在wpa_supplicant的发行版中包括命令行接口（wpa_cli）和图形接口（wpa_gui）。</p>
<ul>
<li>ctrl_iface.c 和 ctrl_iface.h wpa_supplicant-side的控制接口</li>
<li>ctrl_iface_unix.c 基于 UNIX domain sockets 的控制接口后端</li>
<li>ctrl_iface_udp.c 基于 UDP sockets 的控制接口后端</li>
<li>ctrl_iface_named_pipe.c 基于 Windows named pipes 的控制接口后端</li>
<li>wpa_ctrl.c and wpa_ctrl.h 提供给外部程序访问wpa_supplicant控制接口的库函数</li>
<li>wpa_cli.c 使用wpa_supplicant控制接口的示例程序</li>
</ul>
<h3 id="WPA-supplicant-WPA提供"><a href="#WPA-supplicant-WPA提供" class="headerlink" title="WPA supplicant/WPA提供"></a><strong>WPA supplicant/WPA提供</strong></h3><ul>
<li>wpa.c and wpa.h WPA 的状态机和4-Way/Group Key握手处理</li>
<li>preauth.c and preauth.h PMKSA缓存 和 预认证 (RSN/WPA2)</li>
<li>wpa_i.h WPA代码内部定义；其他模块不要包含该头文件</li>
</ul>
<h3 id="EAP-peer-EAP点"><a href="#EAP-peer-EAP点" class="headerlink" title="EAP peer/EAP点"></a><strong>EAP peer/EAP点</strong></h3><p>EAP点实现作为一个独立模块可以用在其他程序中。</p>
<ul>
<li>eap.c and eap.h EAP状态机和方法接口</li>
<li>eap_defs.h EAP通用定义</li>
<li>eap_i.h EAP状态机和方法内部定义，不应该被其他模块包含</li>
<li>eap_sim_common.c and eap_sim_common.h EAP-SIM 和 EAP-AKA 通用代码</li>
<li>eap_tls_common.c and eap_tls_common.h EAP-PEAP, EAP-TTLS, 和 EAP-FAST 通用代码</li>
<li>eap_tlv.c and eap_tlv.h EAP-PEAP 和 EAP-FAST 的 EAP-TLV 代码</li>
<li>eap_ttls.c and eap_ttls.h EAP-TTLS</li>
<li>eap_pax.c, eap_pax_common.h, eap_pax_common.c EAP-PAX</li>
<li>eap_psk.c, eap_psk_common.h, eap_psk_common.c EAP-PSK (note: WPA-PSK不需要)</li>
<li>eap_sake.c, eap_sake_common.h, eap_sake_common.c EAP-SAKE</li>
<li>eap_gpsk.c, eap_gpsk_common.h, eap_gpsk_common.c EAP-GPSK</li>
<li>eap_aka.c, eap_fast.c, eap_gtc.c, eap_leap.c, eap_md5.c, eap_mschapv2.c, eap_otp.c, eap_peap.c, eap_sim.c, eap_tls.c 其他EPA实现方法</li>
</ul>
<h3 id="EAPOL-supplicant-EAPOL提供"><a href="#EAPOL-supplicant-EAPOL提供" class="headerlink" title="EAPOL supplicant/EAPOL提供"></a><strong>EAPOL supplicant/EAPOL提供</strong></h3><ul>
<li>eapol_supp_sm.c and eapol_supp_sm.h EAPOL supplicant state machine and IEEE 802.1X processing</li>
</ul>
<h3 id="Windows-port-windosw端口"><a href="#Windows-port-windosw端口" class="headerlink" title="Windows port/windosw端口"></a><strong>Windows port/windosw端口</strong></h3><ul>
<li>ndis_events.c 代码以更易于使用的方式从NdisMIndicateStatus()接收事件并分发它们到wpa_supplicant driver_ndis.c</li>
<li>win_if_list.c 监听当前网络接口的外部程序</li>
</ul>
<h3 id="Test-programs-测试程序"><a href="#Test-programs-测试程序" class="headerlink" title="Test programs/测试程序"></a><strong>Test programs/测试程序</strong></h3><ul>
<li>radius_client.c and radius_client.h 用于eapol测试的RADIUS认证客户端</li>
<li>radius.c and radius.h 用于eapol测试的RADIUS消息处理</li>
<li>eapol_test.c 独立EAP测试工具和集成RADIUS认证客户端</li>
<li>preauth_test.c 独立RSN预认证工具</li>
<li>wpa_passphrase.c WPA ASCII密码转为PSK</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://w1.fi/wpa_supplicant/" target="_blank" rel="noopener">Linux WPA/WPA2/IEEE 802.1X Supplicant</a>，wpa_supplicant官方说明文档</li>
<li><a href="http://w1.fi/wpa_supplicant/devel/" target="_blank" rel="noopener">wpa_supplicant/hostapd 2.0</a>，wpa_supplicant和hostapd开发者文档</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>wifi</tag>
        <tag>wpa_supplicant</tag>
      </tags>
  </entry>
  <entry>
    <title>Miracast资料收集</title>
    <url>/2014/10/19/miracast-links/</url>
    <content><![CDATA[<h2 id="Miracast"><a href="#Miracast" class="headerlink" title="Miracast"></a>Miracast</h2><ul>
<li><a href="http://www.raspberrypi.org/forums/viewtopic.php?t=60636" target="_blank" rel="noopener">树莓派Miracast开源项目Piracast</a></li>
<li><a href="https://github.com/codemonkeyricky/piracast" target="_blank" rel="noopener">树莓派Piracast GitHub地址</a></li>
<li><a href="https://github.com/chenbd/miracle" target="_blank" rel="noopener">Miracast开源项目miracle</a></li>
<li><a href="http://processors.wiki.ti.com/index.php/OMAP_Wireless_Connectivity_NLCP_WiFi_Direct_Configuration_Scripts" target="_blank" rel="noopener">TI WiFi Direct Configuration Scripts</a></li>
<li><a href="http://dishingtech.blogspot.com/2012/01/realtek-wi-fi-direct-programming-guide.html" target="_blank" rel="noopener">Realtek Wi-Fi Direct Programming Guide</a></li>
<li><a href="https://wiki.tizen.org/wiki/IVI/Wi-Fi_Direct" target="_blank" rel="noopener">Wi-Fi_Direct</a></li>
<li><a href="http://thangamaniarun.wordpress.com/2013/04/07/how-to-setup-wi-fi-direct-on-androidubuntu-terminal-part2/" target="_blank" rel="noopener">How to Setup Wi-Fi Direct on Android/Ubuntu Terminal</a></li>
<li><a href="http://blog.csdn.net/lele_cheny/article/details/20220921" target="_blank" rel="noopener">WFD RTSP M1-M15</a></li>
</ul>
<h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><ul>
<li><a href="http://wireless.kernel.org/en/developers/p2p/howto" target="_blank" rel="noopener">P2P Howto</a></li>
<li><a href="http://lists.shmoo.com/pipermail/hostap/2013-January/027174.html" target="_blank" rel="noopener">P2P_FIND log</a></li>
<li><a href="http://svn.dd-wrt.com/browser/src/router/hostapd-wps/wpa_supplicant/README-P2P?rev=16495" target="_blank" rel="noopener">wpa_supplicant README-P2P</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Miracast</tag>
        <tag>P2P</tag>
        <tag>WFD</tag>
      </tags>
  </entry>
  <entry>
    <title>makedown-syntax</title>
    <url>/2014/10/04/makedown-syntax/</url>
    <content><![CDATA[<hr>
<p>layout: post<br>title: Makedown语法简介<br>description:<br>category: 编辑<br>tags: makedown</p>
<hr>
<ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#quote">引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#hr">分隔线</a></li>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#img">图片</a></li>
<li><a href="#backslash">反斜杠</a></li>
</ul>
<hr>
<h2 id="p">段落和换行</h2>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>简单说：连续两个回车完成对段落的换行。</p>
<h2 id="header">标题</h2>

<p>在Markdown当中设置标题，有两种方式：<br>第一种：通过在文字下方添加四个以上的“=”和“-”，他们分别表示一级标题和二级标题。例如：</p>
<pre><code>H1
=======
H2
-------</code></pre><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><p>第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）例如：</p>
<pre><code># H1
## H2
##### H5</code></pre><h1 id="H1-1"><a href="#H1-1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2-1"><a href="#H2-1" class="headerlink" title="H2"></a>H2</h2><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h2 id="quote">引用</h2>

<p>通过在文字开头添加“&gt;”表示块注释。区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：                                                      </p>
<pre><code>&gt; This is the first level of quoting.
&gt;   
&gt; &gt; This is nested blockquote.
&gt;   
&gt; Back to the first level.</code></pre><blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; ## 这是一个标题。
&gt;   
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。</code></pre><blockquote>
<h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2><ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
</blockquote>
<h2 id="list">列表</h2>

<p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre><code>*   Red
*   Green
*   Blue</code></pre><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>等同于：</p>
<pre><code>+   Red
+   Green
+   Blue</code></pre><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>也等同于：</p>
<pre><code>-   Red
-   Green
-   Blue</code></pre><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>有序列表则使用数字接着一个英文句点：</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish</code></pre><ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<h2 id="code">代码</h2>

<p>实现方式有两种：</p>
<p>第一种：简单文字出现一个代码框。使用`（<code>不是单引号而是左上角的ESC下面~中的</code>）</p>
<pre><code>`&lt;blockquote&gt;`</code></pre><p><code>&lt;blockquote&gt;</code></p>
<p>第二种：大片文字需要实现代码框。使用Tab和四个空格。</p>
<pre><code>int main()
{
//
}</code></pre><h2 id="hr">分隔线</h2>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p>
<pre><code>***
---</code></pre><hr>
<hr>
<h2 id="link">链接</h2>

<p>Markdown中有两种方式实现链接，分别为内联方式和引用方式，不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>内联方式：</p>
<pre><code>This is an [example link](http://example.com/).</code></pre><p>This is an <a href="http://example.com/" target="_blank" rel="noopener">example link</a>.</p>
<p>引用方式：</p>
<pre><code>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].  
...
[1]: http://google.com/        &quot;Google&quot; 
[2]: http://search.yahoo.com/  &quot;Yahoo Search&quot; 
[3]: http://search.msn.com/    &quot;MSN Search&quot;</code></pre><p>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].<br>…<br>[1]: <a href="http://google.com/" target="_blank" rel="noopener">http://google.com/</a>        “Google”<br>[2]: <a href="http://search.yahoo.com/" target="_blank" rel="noopener">http://search.yahoo.com/</a>  “Yahoo Search”<br>[3]: <a href="http://search.msn.com/" target="_blank" rel="noopener">http://search.msn.com/</a>    “MSN Search”</p>
<h2 id="em">强调</h2>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如： </p>
<p>1个为斜体，两个为粗体。</p>
<pre><code>*single asterisks*
_single underscores_
**double asterisks**
__double underscores__</code></pre><p><em>single asterisks</em><br><em>single underscores</em><br><strong>double asterisks</strong><br><strong>double underscores</strong></p>
<p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<pre><code>un*frigging*believable</code></pre><p>un<em>frigging</em>believable</p>
<p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code>\*this text is surrounded by literal asterisks\*</code></pre><p>*this text is surrounded by literal asterisks*</p>
<h2 id="img">图片</h2>

<p>图片的处理方式和链接的处理方式，非常的类似。</p>
<p>内联方式：</p>
<pre><code>![alt text](/path/to/img.jpg &quot;Title&quot;)</code></pre><p>引用方式：</p>
<pre><code>![alt text][id] 
...
[id]: /path/to/img.jpg &quot;Title&quot;</code></pre><h2 id="backslash">反斜杠</h2>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\*literal asterisks\*</code></pre><p>*literal asterisks*</p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号</code></pre><p>References：</p>
<ul>
<li><a href="http://wowubuntu.com/markdown/#em" target="_blank" rel="noopener">http://wowubuntu.com/markdown/#em</a></li>
<li><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="noopener">http://wowubuntu.com/markdown/basic.html</a></li>
<li><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">http://daringfireball.net/projects/markdown/syntax</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux Wi-Fi编程API</title>
    <url>/2014/10/04/wifi-introduction/</url>
    <content><![CDATA[<script type="text/javascript">
$(document).ready(function(){
        $("h2,h3,h4,h5,h6").each(function(i,item){
            var tag = $(item).get(0).localName;
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
            });
        });
</script>
<div id="category"></div>

<hr>
<p>Linux平台上目前常用的专门针对无线网络设备<a href="http://wireless.kernel.org/en/developers/Documentation/Wireless-Extensions" target="_blank" rel="noopener">编程的API有两套</a>:</p>
<ul>
<li><p>最早的一套API由HP公司员工Jean Tourrilhes于1997年开发，全称为Linux Wireless Extensions。一般缩写为wex或wext。这套API使得用户空间的程序能通过ioctl函数来控制无线网卡驱动。</p>
</li>
<li><p>后来Linux又提供了 <code>cfg80211</code> 和 <code>nl80211</code> 两套编程接口用于替代 <code>wext</code> 。其中，cfg80211用于驱动开发，而nl80211 API供用户空间进程使用以操作那些利用cfg80211 API开发的无线网卡驱动。</p>
</li>
</ul>
<h2 id="Linux-Wireless-Extensions介绍"><a href="#Linux-Wireless-Extensions介绍" class="headerlink" title="Linux Wireless Extensions介绍"></a>Linux Wireless Extensions介绍</h2><p>wext的用法相当简单。Linux平台中，wext API定义于wireless.h文件。其内部的数据结构定义、变量命名等都和80211规范中定义的原语有着莫大的关系。</p>
<h3 id="常用数据结构–wireless-h"><a href="#常用数据结构–wireless-h" class="headerlink" title="常用数据结构–wireless.h"></a><strong>常用数据结构–wireless.h</strong></h3><pre><code>//该结构体专门用于往 socket 句柄传递 ioctrl 控制参数。
struct  iwreq
{
    union
    {
        char    ifrn_name[IFNAMSIZ];    /* if name, e.g. &quot;eth0&quot; */                                                             
    } ifr_ifrn;

    /* Data part (defined just above) */
    union   iwreq_data  u;
};

union   iwreq_data
{
    /* Config - generic */
    char        name[IFNAMSIZ];
    /* Name : used to verify the presence of  wireless extensions.
    * Name of the protocol/provider... */

    struct iw_point essid;      /* Extended network name */
    struct iw_param nwid;       /* network id (or domain - the cell) */
    struct iw_freq  freq;       /* frequency or channel :
                                * 0-1000 = channel
                                * &gt; 1000 = frequency in Hz */

    struct iw_param sens;       /* signal level threshold */
    struct iw_param bitrate;    /* default bit rate */
    struct iw_param txpower;    /* default transmit power */
    struct iw_param rts;        /* RTS threshold threshold */
    struct iw_param frag;       /* Fragmentation threshold */
    __u32       mode;       /* Operation mode */
    struct iw_param retry;      /* Retry limits &amp; lifetime */

    struct iw_point encoding;   /* Encoding stuff : tokens */
    struct iw_param power;      /* PM duration/timeout */
    struct iw_quality qual;     /* Quality part of statistics */

    struct sockaddr ap_addr;    /* Access point address */
    struct sockaddr addr;       /* Destination address (hw/mac) */

    struct iw_param param;      /* Other small parameters */
    struct iw_point data;       /* Other large parameters */
};

//专门用于触发无线网卡发起扫描请求的数据结构 iw_scan_req
struct  iw_scan_req
{
    __u8        scan_type; /* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */
    __u8        essid_len;
    __u8        num_channels; /* num entries in channel_list;
                            * 0 = scan all allowed channels */
    __u8        flags; /* reserved as padding; use zero, this may
                        * be used in the future for adding flags
                        * to request different scan behavior */
    struct sockaddr bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
                            * individual address of a specific BSS */

    /*
    * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
    * the current ESSID. This allows scan requests for specific ESSID
    * without having to change the current ESSID and potentially breaking
    * the current association.
    */
    __u8        essid[IW_ESSID_MAX_SIZE];

    /*
    * Optional parameters for changing the default scanning behavior.
    * These are based on the MLME-SCAN.request from IEEE Std 802.11.
    * TU is 1.024 ms. If these are set to 0, driver is expected to use
    * reasonable default values. min_channel_time defines the time that
    * will be used to wait for the first reply on each channel. If no
    * replies are received, next channel will be scanned after this. If
    * replies are received, total time waited on the channel is defined by
    * max_channel_time.
    */
    __u32       min_channel_time; /* in TU */
    __u32       max_channel_time; /* in TU */

    struct iw_freq  channel_list[IW_MAX_FREQUENCIES];
};</code></pre><h3 id="wext-API-使用实例–wpa-supplicant"><a href="#wext-API-使用实例–wpa-supplicant" class="headerlink" title="wext API 使用实例–wpa_supplicant"></a><strong>wext API 使用实例–wpa_supplicant</strong></h3><p>wpa_supplicant-1.1/src/drivers/driver_wext.c文件就是以wext API来与无线网卡工作交互的代码，示例如下：</p>
<pre><code>int wpa_driver_wext_scan(void *priv, struct wpa_driver_scan_params *params)
{
    struct wpa_driver_wext_data *drv = priv;
    struct iwreq iwr;   //定义个iwreq对象
    int ret = 0, timeout;
    struct iw_scan_req req; //定义一个iw_scan_req对象
    const u8 *ssid = params-&gt;ssids[0].ssid;                                                                                    
    size_t ssid_len = params-&gt;ssids[0].ssid_len;

    if (ssid_len &gt; IW_ESSID_MAX_SIZE) {
        wpa_printf(MSG_DEBUG, &quot;%s: too long SSID (%lu)&quot;,
                __FUNCTION__, (unsigned long) ssid_len);
        return -1;
    }    

    os_memset(&amp;iwr, 0, sizeof(iwr));
    os_strlcpy(iwr.ifr_name, drv-&gt;ifname, IFNAMSIZ);    //为iwr的ifr_name传递需操作的网卡设备名

    if (ssid &amp;&amp; ssid_len) {
        os_memset(&amp;req, 0, sizeof(req)); //设置iw_scan_req的信息
        req.essid_len = ssid_len;
        req.bssid.sa_family = ARPHRD_ETHER;
        os_memset(req.bssid.sa_data, 0xff, ETH_ALEN);
        os_memcpy(req.essid, ssid, ssid_len);
        iwr.u.data.pointer = (caddr_t) &amp;req;
        iwr.u.data.length = sizeof(req);
        iwr.u.data.flags = IW_SCAN_THIS_ESSID; //IW_SCAN_THIS_ESSID表示只扫描指定ESSID的无线网络
    }    
    /*
    ioctl_sock指向一个socket 句柄,其创建时候的代码如下:
    ioctl_sock = socket(PF_INET,SOCK_DGRAM,0)
    SIOCSIWSCAN用于通知驱动进行无线网络扫描
    */
    if (ioctl(drv-&gt;ioctl_sock, SIOCSIWSCAN, &amp;iwr) &lt; 0) {
        perror(&quot;ioctl[SIOCSIWSCAN]&quot;);
        ret = -1;
    }

    //other source code

    return ret;
}</code></pre><h2 id="nl80211介绍"><a href="#nl80211介绍" class="headerlink" title="nl80211介绍"></a>nl80211介绍</h2><p>目前Linux平台代替wext框架的是nl80211和cfg80211，其中cfg80211用于Kernel网卡驱动开发，nl80211 API则供用户空间进程使用。</p>
<p>在nl80211框架中，用户空间进程与Kernel通信没有使用wext中的ioctl，而是采用netlink机制。虽然nl80211.h仅是定义了一些枚举值和有限的数据结构，但其操作比较复杂。netlink是Linux平台上一种基于socket的IPC通信机制，它支持：</p>
<ul>
<li>用户空间进程和Kernel通信</li>
<li>用户空间中进程间通信</li>
</ul>
<h3 id="netlink编程"><a href="#netlink编程" class="headerlink" title="netlink编程"></a>netlink编程</h3><p>netlink是一种基于socket的IPC通信机制，所以它需要解决如下两个问题。</p>
<ul>
<li>寻址：即如何定位通信对象。</li>
<li>双方通信的数据格式：socket编程中，通信双方传递的数据格式是由应用程序自己决定的。那么netlink是否有其自定义的数据格式呢？</li>
</ul>
<h4 id="netlink-socket创建及绑定"><a href="#netlink-socket创建及绑定" class="headerlink" title="netlink socket创建及绑定"></a><strong>netlink socket创建及绑定</strong></h4><p>netlink使用前，需要通过socket调用创建一个socket句柄，而socket函数的原型如下。</p>
<pre><code>int socket(int domain, int type, int protocol);</code></pre><p>对于netlink编程来说，注意以下事项。</p>
<ul>
<li>domain：必须设置为AF_NETLINK，表示此socket句柄将用于netlink。</li>
<li>type：netlink是基于消息的IPC通信，所以该值为SOCK_DGRAM。注意，对netlink编程来说，内核并不区分type的值是SOCK_DGRAM还是SOCK_RAW。</li>
<li>protocol：该值可根据需要设为NETLINK_ROUTE、NETLINK_NETFILTER。不同的协议代表Kernel中不同的子系统。例如NETLINK_ROUTE代表通信对象将是Kernel中负责route的子系统，而NETLINK_NETFILTER代表通信对象将是Kernel中负责Netfilter的子系统，而第2章碰到的NETLINK_KOBJECT_UEVENT则代表应用程序希望接收来自Kernel中的uevent消息。</li>
</ul>
<p>使用netlink通信时，如何保证确保通信双方能正确定位对方呢？原来，在netlink中，通信的另一方地址由一个数据类型为sockaddr_nl的结构体来唯一标示。该结构体的原型如下。</p>
<pre><code>[--&gt;netlink.h]
struct sockaddr_nl {
    // nl_family取值必须为AF_NETLINK或PF_NETLINK
    sa_family_t nl_family;
    unsigned short nl_pad;   // 该值暂时无用，必须设为0
    /*
    nl_pid看起来是用于存储进程pid的，但实际上它只是用于标示一个netlink socket。所以，用户空间
    只要保证进程内该值的唯一性即可。另外，如果该值为0，表示通信的目标是Kernel。
    */
    __u32 nl_pid;
    /*
    每一个netlink协议都支持最多32个多播组，加入多播组的成员都能接收到对应的多播消息。
    例如NETLINK_ROUTE协议就有RTMGRP_LINK和RTMGRP_IPV4_IFADDR等多个多播组。每个多播组对应
    不同的消息。之所以采用多播的方式，是因为它能减少消息发送/接收的次数。
    nl_groups为0，表示只处理单播消息。
    */
    __u32 nl_groups;
};</code></pre><p>设置好地址后，通过bind函数将该地址和socket句柄绑定，这样通信的另一方就正式确定了。</p>
<p>关于socket创建以及bind的使用，读者可参考下面的例子。</p>
<pre><code>struct sockaddr_nl sa;

memset(&amp;sa, 0, sizeof(sa));
sa.nl_family = AF_NETLINK;
sa.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;
// sa.nl_pid已经通过memset函数置为0了，代表此次netlink通信的目标是Kernel
fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
bind(fd, (struct sockaddr *) &amp;sa, sizeof(sa));</code></pre><p>netlink中关于protocol和多播group的取值比较分散，而且Linux的man手册更新赶不上代码的更新速度。建议读者通过netlink.h寻找protocol的取值。通过protocol对应的头文件去寻找多播group的定义。例如rtnetlink.h就定义了RTMGRP_LINK等多播组。</p>
<h4 id="netlink消息类型和标志"><a href="#netlink消息类型和标志" class="headerlink" title="netlink消息类型和标志"></a>netlink消息类型和标志</h4><p>netlink的消息及处理是netlink编程中较为复杂的一部分。netlink中，所有消息都有一个消息头，该头由结构体nlmsghdr表达，原型如下。</p>
<pre><code>struct nlmsghdr {
    __u32        nlmsg_len; // 整个消息的长度，包括消息头
    __u16        nlmsg_type; // 消息类型，详情见后文
    __u16        nlmsg_flags; // 附加标志
    __u32        nlmsg_seq; // 消息序列号
    __u32        nlmsg_pid; // 发送该消息的nl_pid。该值为0,表示数据来自内核
};</code></pre><p>netlink定义了三种消息类型（type），分别如下。</p>
<ul>
<li>NLMSG_NOOP：无操作，程序可直接丢弃这类消息。</li>
<li>NLMSG_ERROR：代表错误消息。这类消息携带的信息由结构体struct nlmsgerr表达。</li>
<li>NLMSG_DONE：如果某个信息的数据量较大，需要分成多个netlink消息发送的话，NLMSG_DONE表示这是此信息最后一个消息分片包。</li>
</ul>
<p>从C/S角度来看，netlink消息可分为另外三种类型。</p>
<ul>
<li>Request消息：代表客户端向服务端发起的请求。这类消息必须为nlmsg_flags设置NLM_F_REQUEST标志位。同时，客户端最好为nlmsg_seq设置一个独一无二的值，以区分自己发送的不同请求。</li>
<li>Response消息：该类消息作为服务端对客户端请求的回应。对应的消息类型是NLMSG_ERROR。注意，如果服务器处理请求成功，也返回该值。只不过nlmsgerr的error变量值为0。</li>
<li>Notification消息：用于服务端向客户端发送通知。由于它不对应任何请求，故nlmsg_seq一般取值为0。</li>
</ul>
<p>对于Response消息，无论服务端处理请求是否成功，都会返回NLMSG_ERROR消息，其对应的数据类型是nlmsgerr，原型如下。</p>
<pre><code>struct nlmsgerr {
    int error;   // 值为负代表错误码，值为0表示请求处理成功
    // 携带对应请求消息的消息头
    // 由于只返回消息头，故客户端必须根据消息头中的nlmsg_seq找到具体的消息
    struct nlmsghdr msg;
};</code></pre><p>下面来看参数nlmsg_flags，它比type复杂，常设的位值有（通过“|”运算符将不同值“或”在一起）。</p>
<ul>
<li>NLM_F_REQUEST：代表请求消息。</li>
<li>NLM_F_MULTI：代表消息分片中的一个。理论上说，由于nlmsghdr中的nlmsg_len为32位，其最大消息长度可达4GB，但内核实现时，最大消息的长度只有一个页面（一般为4KB）。如果有大于4KB的信息要传递，就需将其分成多个消息发送。除最后一个分片消息外，其余消息都需置NLM_F_MULTI位。当然，结合上文所述，最后一个分片消息需要设置nlmsg_type为NLMSG_DONE。</li>
<li>NLM_F_ACK：该标志将强制服务端接收并处理完请求后回复ACK给客户端。</li>
</ul>
<h4 id="netlink消息的处理"><a href="#netlink消息的处理" class="headerlink" title="netlink消息的处理"></a>netlink消息的处理</h4><p>对于socket编程来说，一般客户端会分配一个buffer用于接收数据，而后续解析该buffer中的netlink消息其实也是一件比较麻烦的事情。另外，由于netlink对消息的大小有字节对齐的要求，所以应用程序在构造自己的netlink消息时，也比较麻烦。不过好在netlink为我们提供了一些帮助宏，利用这些宏，netlink消息就不再麻烦了。以下代码为netlink消息处理时常用的一些宏。</p>
<pre><code>NLMSG_ALIGN(len)// 获取len按4字节补齐后的长度。例如，如果len为1，则该宏返回的值应是4
// 整个消息包的长度，包括消息头和数据长度len。该值用于填充消息头中的nlmsg_len参数
NLMSG_LENGTH(len)
// 返回按4字节对齐后整个消息包的长度。它和NLMSG_LENGTH最大的不同是该宏将长度按4字节对齐
NLMSG_SPACE(len)   // 该宏等于NLMSG_ALIGN(NLMSG_LENGTH(len))
NLMSG_DATA(nlh)   // 获取消息中的数据起始地址
// 用于分片消息的处理。可获取下一条分片消息。其用法见下文例子
NLMSG_NEXT(nlh,len)
NLMSG_OK(nlh,len)   // 用于判断接收到的数据是否包含一个完整的netlink消息
// 用于返回数据的长度。注意，由于netlink消息在创建时会按4字节补齐
// 所以其数据真正的长度不能通过nlms_len来判断
NLMSG_PAYLOAD(nlh,len)</code></pre><p>netlink消息解析的例子。</p>
<pre><code>// 本例基于linux netlink手册。可通过man 7 netlink查阅
int len;
char buf[4096];
struct iovec iov = { buf, sizeof(buf) };
struct sockaddr_nl sa;
struct msghdr msg;  // 用于recvmsg系统调用，和netlink没关系
struct nlmsghdr *nh;

msg = { (void *)&amp;sa, sizeof(sa), &amp;iov, 1, NULL, 0, 0 };
len = recvmsg(fd, &amp;msg, 0); // recvmsg返回，可能存储了多条netlink消息

// 开始接受接收buffer，注意NLMSG_NEXT宏，其内部会对len长度进行修改，以调整到下一个消息的起始
for (nh = (struct nlmsghdr *) buf; NLMSG_OK(nh, len);
        nh = NLMSG_NEXT (nh, len)) {
    /* The end of multipart message. */
    if (nh-&gt;nlmsg_type == NLMSG_DONE){
        return;   // 分片消息处理
    }
    if (nh-&gt;nlmsg_type == NLMSG_ERROR){
        struct nlmsgerr* pError = （struct nlmsgerr*）NLMSG_DATA(nh);
        // 获取nlmsgerr的内容
        ...... /* 错误或ACK处理*/
    }
    void* data = NLMSG_DATA(nh); // 获取数据的起始地址
    ......// 处理数据
}</code></pre><p>netlink的消息收发和普通的socket消息收发一样，这里不赘述。</p>
<h4 id="netlink编程小结"><a href="#netlink编程小结" class="headerlink" title="netlink编程小结"></a>netlink编程小结</h4><p>netlink强制要求每个netlink消息都包含消息头，其实它还定义了一个名为nlattr的结构体，用于规范载荷（Payload）的数据类型。其目的是希望Payload以属性（attribute）的方式来描述自己。struct nlattr结构非常简单，如下所示。</p>
<pre><code>struct nlattr {
    __u16     nla_len;  // 属性长度
    __u16     nla_type;  // 属性类型
};</code></pre><p>netlink虽然复用了socket编程以方便应用程序和内核通信，但因为其文档很少，而且不同protocol往往还有自己特定的数据结构，所以实际使用过程中难度较大。</p>
<h3 id="libnl开源库"><a href="#libnl开源库" class="headerlink" title="libnl开源库"></a>libnl开源库</h3><p>鉴于netlink的复杂性，开源世界提供了几个比较完备的基于netlink编程的框架，其中最著名的就是<strong><a href="http://www.infradead.org/~tgr/libnl/" target="_blank" rel="noopener">libnl</a></strong>，框架图如下：</p>
<p><img src="http://www.infradead.org/~tgr/libnl/layer_diagram.png" alt=""></p>
<p>以下三个库都基于其核心库libnl。</p>
<ul>
<li>libnl-route：用于和Kernel中的Routing子系统交互。</li>
<li>libnl-nf：用于和Kernel中的Netfilter子系统交互。</li>
<li>libnl-genl：用于和Kernel中的Generic Netlink模块交互。</li>
</ul>
<h4 id="nl-sock结构体的使用"><a href="#nl-sock结构体的使用" class="headerlink" title="nl_sock结构体的使用"></a>nl_sock结构体的使用</h4><p>libnl以面向对象的方式重新封装了netlink原有的API。其使用时必须分配一个nl_sock结构体。下面展示了和它相关的一些API及使用方法。</p>
<pre><code>#include &lt;netlink/socket.h&gt;
// 分配和释放nl_sock结构体
struct nl_sock *nl_socket_alloc(void)
void nl_socket_free(struct nl_sock *sk)
// nl_connet内部将通过bind函数将netlink socket和protocol对应的模块进行绑定
int nl_connect(struct nl_sock *sk, int protocol)</code></pre><p>linbl还可为每个nl_sock设置消息处理函数，相关API如下。</p>
<pre><code>// 为nl_sock对象设置一个回调函数，当该socket上收到消息后，就会回调此函数进行处理
// 回调函数及参数封装在结构体struct nl_cb中
void nl_socket_set_cb(struct nl_sock *sk, struct nl_cb *cb);
// 获取该nl_sock设置的回调函数信息
struct nl_cb *nl_socket_get_cb(const struct nl_sock *sk);</code></pre><p>注意，以上两个函数没有文档说明。建议使用另外一个控制力度更为精细的API。</p>
<pre><code>/*
   此API对消息接收及处理的力度更为精细，其中：
   type类型包括NL_CB_ACK、NL_CB_SEQ_CHECK、NL_CB_INVALID等，可用于处理底层不同netlink消息的情况。
   例如，当收到的netlink消息无效时，将调用NL_CB_INVALIDE设置的回调函数进行处理。
   nl_cb_kinds指定消息回调函数的类型，可选值有NL_CB_CUSTOM，代表用户设置的回调函数，NL_CB_DEFAULT
   代表默认的处理函数。
   回调函数的返回值包括以下。
   NL_OK:表示处理正常。
   NL_SKIP：表示停止当前netlink消息分析，转而去分析接收buffer中下一条netlink消息（消息分
   　　　 片的情况）。
   NL_STOP：表示停止此次接收buffer中的消息分析。
 */
int nl_socket_modify_cb(struct nl_sock *sk,
        enum nl_cb_type type, enum nl_cb_kind kind,
        nl_recvmsg_msg_cb_t func, void *arg);</code></pre><p>另外，netlink还可设置错误消息（即专门处理nlmsgerr数据）处理回调函数，相关API如下。</p>
<pre><code>#include &lt;netlink/handlers.h&gt;  // 必须包含此头文件
// 设置错误消息处理
int nl_cb_err(struct nl_cb *cb, enum nl_cb_kind kind,
        nl_recvmsg_err_cb_t func, void * arg);
typedef int(* nl_recvmsg_err_cb_t)(struct sockaddr_nl *nla,
        struct nlmsgerr *nlerr, void *arg);</code></pre><h4 id="libnl中的消息处理"><a href="#libnl中的消息处理" class="headerlink" title="libnl中的消息处理"></a>libnl中的消息处理</h4><p>libnl定义了自己的消息结构体struct nl_msg。不过它也提供API直接处理netlink的消息。常用的API如下。</p>
<pre><code>#include &lt;netlink/msg.h&gt;   // 必须包含这个头文件
// 下面这两个函数计算netlink消息体中对应部分的长度
int nlmsg_size(int payloadlen);  // 请参考图来理解这两个函数返回值的意义
int nlmsg_total_size(int payloadlen);</code></pre><p>关于netlink消息的长度如图所示：</p>
<p><img src="http://www.2cto.com/uploadfile/2014/0526/20140526010248822.jpg" alt=""></p>
<p>其他可直接处理netlink消息的API如下。</p>
<pre><code>struct nlmsghdr *nlmsg_next(struct nlmsghdr *hdr, int *remaining);
int nlmsg_ok(const struct nlmsghdr *hdr, int remaining);
/*定义一个消息处理的for循环宏，其值等于
for (int rem = len, pos = head; nlmsg_ok(pos, rem);\
    pos = nlmsg_next(pos, &amp;rem))
*/
#define nlmsg_for_each(pos,head,en)   </code></pre><p>也可以通过libnl定义的消息结构体nl_msg进行相关操作，和nl_msg有关的API如下。</p>
<pre><code>struct nl_msg *nlmsg_alloc(void);
void nlmsg_free(struct nl_msg *msg);
// nl_msg内部肯定会指向一个netlink消息头实例，下面这个函数用于填充netlink消息头
struct nlmsghdr *nlmsg_put(struct nl_msg *msg,
        uint32_t port, uint32_t seqnr,
        int nlmsg_type, int payload, int nlmsg_flags);</code></pre><h4 id="libnl中的消息发送和接收"><a href="#libnl中的消息发送和接收" class="headerlink" title="libnl中的消息发送和接收"></a>libnl中的消息发送和接收</h4><p>netlink直接利用系统调用（如send、recv、sendmsg、recvmsg等）进行数据收发，而libnl封装了自己特有的数据收发API。其中和发送有关的几个主要API如下。</p>
<pre><code>// 直接发送netlink消息
int nl_sendto (struct nl_sock *sk, void *buf, size_t size)
    // 发送nl_msg消息
int nl_send (struct nl_sock *sk, struct nl_msg *msg)
    int nl_send_simple(struct nl_sock *sk, int type,
            int flags,void *buf, size_t size);</code></pre><p>常用的数据接收API如下。</p>
<pre><code>// 核心接收函数。nla参数用于存储发送端的地址信息。creds用于存储权限相关的信息
int nl_recv(struct nl_sock *sk, struct sockaddr_nl *nla,
        unsigned char **buf, struct ucred **creds)
    // 内部通过nl_recv接收消息，然后通过cb回调结构体中的回调函数传给接收者
int nl_recvmsgs (struct nl_sock *sk, struct nl_cb *cb)</code></pre><h4 id="libnl-genl-API介绍"><a href="#libnl-genl-API介绍" class="headerlink" title="libnl-genl API介绍"></a>libnl-genl API介绍</h4><p>libnl-genl封装了对generic netlink模块的处理，它基于libnl，一条genl消息的结构如图所示。</p>
<p><img src="http://www.2cto.com/uploadfile/2014/0526/20140526010303990.jpg" alt=""></p>
<p>其中，genlmsghdr的原型如下。</p>
<pre><code>struct genlmsghdr {
    __u8 cmd;  // cmd和version都和具体的案例有关
    __u8 version;
    __u16 reserved; // 保留
};</code></pre><p>genl常用的API如下。</p>
<pre><code>// 和libnl的nl_connect类型，只不过协议类型为GENERIC_NETLINK
int genl_connect (struct nl_sock *sk)
// genlmsg_put用于填充图中的nlmsghdr、genlmsghder和用户自定义的消息头。详细内容见下文
void* genlmsg_put (struct nl_msg *msg, uint32_t port,
        uint32_t seq, int family, int hdrlen,
        int flags, uint8_t cmd, uint8_t version)
// 用于获取genl消息中携带的nlattr内容
struct nlattr* genlmsg_attrdata(const struct genlmsghdr *gnlh,int hdrlen)   </code></pre><p>另外，genl还有几个比较重要的API，它们和genl机制的内核实现有关，这里仅简单介绍其中几点内容。为实现genl机制，内核创建了一个虚拟的Generic Netlink Bus。所有genl的使用者（包含内核模块或用户空间进程）都会注册到此Bus上。这些使用者注册时，都需要填充一个名为genl_family的数据结构，该结构是一种身份标示。所以某一方只要设置好genlmsg_put中的family参数，数据就能传递到对应的模块。</p>
<p>family是一个整型，可读性较差，所以genl使用者往往会指定一个字符串作为family name。而family name和family的对应关系则由genl中另外一个重要模块去处理。这个模块就是genl中的Controller，它也是Generic Bus使用者。其family name为“nlctrl”，只不过它的family是固定的，目前取值为16（一般为它定义一个NETLINK_GENERIC宏）。Controller的一个重要作用就是为其他注册者建立family name和family之间关系，也就是动态为其他注册者分配family编号。另外，Controller也支持查询，即返回当前Kernel中注册的所有genl模块的family name和family的值。</p>
<p>对用户空间程序来说，只要知道family的值，就可和指定模块进行通信了。libnl-genl封装了上述操作，并提供了几个常用的API。</p>
<pre><code>// 根据family name字符串去查询family，该函数内部实现将发送查询消息给Controller
int  genl_ctrl_resolve (struct nl_sock *sk, const char *name)
/*
如果每次都向Controller去查询family编号将严重影响效率，所以libnl-genl会把查询到的信息
缓存起来。
下面这个函数将分配一个nl_cache列表，其内容存储了当前注册到Generic Netlink Bus上所有注
册者的信息。
*/
int genl_ctrl_alloc_cache (struct nl_sock *sk, struct nl_cache **result)
// 根据family name从缓存中获取对应的genl_family信息
struct genl_family * genl_ctrl_search_by_name
    (struct nl_cache *cache, const char *name)</code></pre><h3 id="nl80211实例"><a href="#nl80211实例" class="headerlink" title="nl80211实例"></a>nl80211实例</h3><p>简单来说，nl80211的核心就是通过netlink机制向Kernel中的无线网卡驱动发送特定的消息。只不过这些消息的类型、参数等都由nl80211.h定义。此处通过一个案例，学习如何通过nl80211触发网卡进行无线网络扫描。</p>
<pre><code>[--&gt;driver_nl80211.c::wpa_driver_nl80211_scan]
static int wpa_driver_nl80211_scan(void *priv,
    struct wpa_driver_scan_params *params)
{
    struct i802_bss *bss = priv;
    struct wpa_driver_nl80211_data *drv = bss-&gt;drv;
    int ret = -1, timeout;
    struct nl_msg *msg, *rates = NULL; // 定义两个nl_msg对象，rates和P2P有关，读者可忽略它

    drv-&gt;scan_for_auth = 0;
    // 创建nl80211消息，其中NL80211_CMD_TRIGGER_SCAN是Nl80211定义的命令，用于触发网络扫描
    msg = nl80211_scan_common(drv, NL80211_CMD_TRIGGER_SCAN, params);
    ......// P2P 处理
    // 发送netlink消息
    ret = send_and_recv_msgs(drv, msg, NULL, NULL);
    msg = NULL;
    if (ret)
        goto nla_put_failure;
    ......// wpa_supplicant其他处理
    ......// 错误处理
        return ret;
}</code></pre><p>上面代码中构造无线网络扫描nl_msg的重要函数nl80211_scan_common代码如下所示。</p>
<pre><code>[--&gt;driver_nl80211.c::nl80211_scan_common]
static struct nl_msg * nl80211_scan_common
    (struct wpa_driver_nl80211_data *drv, u8 cmd,
    struct wpa_driver_scan_params *params)
{
    struct nl_msg *msg;
    int err;
    size_t i;
    // 分配一个nl_msg对象
    msg = nlmsg_alloc();
    /*
    调用nl80211_cmd函数填充nl_msg中的信息，其内部代码如下。
    static void * nl80211_cmd(struct wpa_driver_nl80211_data *drv,
    struct nl_msg *msg, int flags, uint8_t cmd){
    return genlmsg_put(msg, 0, 0, drv-&gt;global-&gt;nl80211_id,0, flags, cmd, 0);
    }
    */
    nl80211_cmd(drv, msg, 0, cmd);
    /*
    nl80211消息的参数通过netlink中的nlattr来存储。NL80211_ATTR_IFINDEX代表
    此次操作所指定的网络设备编号。
    */
    nla_put_u32(msg, NL80211_ATTR_IFINDEX, drv-&gt;ifindex);

    if (params-&gt;num_ssids) {
        struct nl_msg *ssids = nlmsg_alloc();
        for (i = 0; i &lt; params-&gt;num_ssids; i++) {
            nla_put(ssids, i + 1, params-&gt;ssids[i].ssid_len,params-&gt;ssids[i].ssid);
            ......
        }
        // netlink支持消息嵌套，即属性中携带的数据可以是另外一个nl_msg消息
        err = nla_put_nested(msg, NL80211_ATTR_SCAN_SSIDS, ssids);
        nlmsg_free(ssids);
        ......
    }
    ......// 其他处理
        return msg;
    ......// 错误处理
}</code></pre><p>由上面的例子可知，nl80211其实就是利用netlink机制将一些802.11相关的命令和参数发送给驱动去执行。这些命令和参数信息可通过nl80211头文件查询。</p>
<p>首先，nl80211_copy.h定义其支持的命令，如下所示。</p>
<pre><code>[--&gt;nl80211_copy.h]
enum nl80211_commands {
    NL80211_CMD_UNSPEC,
    NL80211_CMD_GET_WIPHY,
    NL80211_CMD_SET_WIPHY,
    ......
    NL80211_CMD_GET_INTERFACE,   
    NL80211_CMD_SET_INTERFACE,
    ......
    NL80211_CMD_SET_BSS,
    NL80211_CMD_SET_REG,
    ......// 一共定义了94条命令
}</code></pre><p>然后定义属性的取值，如下所示。</p>
<pre><code>enum nl80211_attrs {
    NL80211_ATTR_UNSPEC,
    NL80211_ATTR_WIPHY,
    NL80211_ATTR_WIPHY_NAME,
    NL80211_ATTR_IFINDEX,
    NL80211_ATTR_IFNAME,
    NL80211_ATTR_IFTYPE,
    NL80211_ATTR_MAC,
    ......// 一共定义了155条属性
}</code></pre><p>相比wext而言，nl80211的使用难度明显要复杂，其中重要原因是它是基于netlink编程的。而且，如果没有libnl的支持，相信使用难度会更大。但从Wi-Fi角度来看，nl80211和wext到没有太大区别，二者都是紧紧围绕MAC层service来设计数据结构的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>wifi</tag>
        <tag>wext</tag>
        <tag>cfg80211</tag>
        <tag>nl80211</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables简介</title>
    <url>/2014/10/04/iptables-introduction/</url>
    <content><![CDATA[<p>iptables是Linux系统中最重要的<strong>网络管控工具</strong>。它与Kernel中的netfilter模块配合工作，<br>其主要功能是为netfilter设置一些过滤（filter）或网络地址转换（NAT）的规则。当Kernel收到网络数据包后，<br>将会依据iptables设置的规则进行相应的操作。</p>
<h2 id="iptables原理"><a href="#iptables原理" class="headerlink" title="iptables原理"></a>iptables原理</h2><p>iptables的语法比较复杂，但工作原理较易理解。清楚iptables的前提是理解它的<strong>表（Table）、链（Chain）和规则（Rule）</strong>。<br>三者关系如下图所示：</p>
<p><img src="http://static.thegeekstuff.com/wp-content/uploads/2011/01/iptables-table-chain-rule-structure.png" alt="tables"></p>
<a id="more"></a>

<ul>
<li><p>iptables内部（其实是Kernel的netfilter模块）维护着四个Table，分别是filter、nat、mangle和raw，它们对应着不同的功能：</p>
<ul>
<li>filter，iptables默认使用的表，用于数据包的过滤</li>
<li>nat，控制网络地址转换的表</li>
<li>mangle，修改包的信息，例如修改包的TTL值</li>
<li>raw，根据链接状态进行相关处理，属于iptables的高级用法</li>
</ul>
</li>
<li><p>Table中定义了Chain。一个Table可以支持多个Chain，Chain实际上是Rule的集合，每个Table都有默认的Chain。例如<br>filter表默认的Chain有INPUT、OUTPUT、FORWARD。用户可以自定义Chain，也可以修改Chain中的Rule。</p>
</li>
<li><p>Rule就是iptables工作的规则。首先，系统将检查要处理的数据包是否满足Rule设置的条件，如果满足则执行Rule中设置的<br>目标（Target），否则继续执行Chain中的下一条Rule。</p>
</li>
</ul>
<h2 id="iptables-Target和常用参数"><a href="#iptables-Target和常用参数" class="headerlink" title="iptables Target和常用参数"></a>iptables Target和常用参数</h2><p>iptables中的Rule有四个默认定义的Target，如下：</p>
<ul>
<li><p>ACCEPT：接收数据包</p>
</li>
<li><p>DROP：直接丢弃数据包。没有任何信息反馈给数据源端</p>
</li>
<li><p>RETURN：返回到调用Chain，略过后续的Rule处理</p>
</li>
<li><p>QUEUE：数据返回到用户空间处理</p>
<p>  <em>iptables的扩展Target还支持REJECT。相对于DROP而言，REJECT会反馈信息给数据源端。目前只有INPUT、OUTPUT、FORWARD<br>  以及被这三个链调用的自定义链支持REJECT。</em></p>
</li>
</ul>
<p><strong>常用参数如下</strong>：</p>
<ul>
<li>-t：指定table。默认为filter表</li>
<li>-N：创建一条新的Chain</li>
<li>-L,–list：显示指定Table的Chain和Rule信息</li>
<li>-A,–append chain rule-specification：在指定Chain的末尾添加一条Rule</li>
<li>-D,–delete chain rule-specification：删除指定Chain中满足rule-specification的那条Rule</li>
<li>-I,–insert chain [rule num] rule-specification：为指定Chain插入一条Rule</li>
</ul>
<p>Rule-specification描述该Rule的匹配条件以及目标动作，参数如下：</p>
<ul>
<li>-i：指定接收数据包的网卡名</li>
<li>-o：指定发出数据包的网卡名</li>
<li>-p：指定协议</li>
<li>-s,–source address[/mask]：指定数据包的源IP地址</li>
<li>-j,–jump target：跳转到指定目标，如ACCEPT、DROP等</li>
</ul>
<h2 id="经过iptables的数据包的流程介绍"><a href="#经过iptables的数据包的流程介绍" class="headerlink" title="经过iptables的数据包的流程介绍"></a>经过iptables的数据包的流程介绍</h2><p>一个数据包到达时,是怎么依次穿过各个链和表的,见下图：</p>
<p><img src="http://img1.51cto.com/attachment/201304/204152898.png" alt=""></p>
<p><strong>基本步骤如下：</strong></p>
<ul>
<li>数据包到达网络接口，比如 eth0。 </li>
<li>进入 raw 表的 PREROUTING 链，这个链的作用是赶在连接跟踪之前处理数据包。 </li>
<li>如果进行了连接跟踪，在此处理。 </li>
<li>进入 mangle 表的 PREROUTING 链，在此可以修改数据包，比如 TOS 等。 </li>
<li>进入 nat 表的 PREROUTING 链，可以在此做DNAT，但不要做过滤。 </li>
<li>决定路由，看是交给本地主机还是转发给其它主机。 </li>
</ul>
<p>*<em>到了这里我们就得分两种不同的情况进行讨论了，一种情况就是数据包要转发给其它主机，这时候它会依次经过： *</em></p>
<ul>
<li>进入 mangle 表的 FORWARD 链，这里也比较特殊，这是在第一次路由决定之后，在进行最后的路由决定之前，我们仍然可以对数据包进行某些修改。 </li>
<li>进入 filter 表的 FORWARD 链，在这里我们可以对所有转发的数据包进行过滤。需要注意的是：经过这里的数据包是转发的，方向是双向的。 </li>
<li>进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改。 </li>
<li>进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤。 </li>
<li>进入出去的网络接口。完毕。 </li>
</ul>
<p>*<em>另一种情况是，数据包就是发给本地主机的，那么它会依次穿过： *</em></p>
<ul>
<li>进入 mangle 表的 INPUT 链，这里是在路由之后，交由本地主机之前，我们也可以进行一些相应的修改。 </li>
<li>进入 filter 表的 INPUT 链，在这里我们可以对流入的所有数据包进行过滤，无论它来自哪个网络接口。 </li>
<li>交给本地主机的应用程序进行处理。 </li>
<li>处理完毕后进行路由决定，看该往那里发出。 </li>
<li>进入 raw 表的 OUTPUT 链，这里是在连接跟踪处理本地的数据包之前。 </li>
<li>连接跟踪对本地的数据包进行处理。 </li>
<li>进入 mangle 表的 OUTPUT 链，在这里我们可以修改数据包，但不要做过滤。 </li>
<li>进入 nat 表的 OUTPUT 链，可以对防火墙自己发出的数据做 NAT 。 </li>
<li>再次进行路由决定。 </li>
<li>进入 filter 表的 OUTPUT 链，可以对本地出去的数据包进行过滤。 </li>
<li>进入 mangle 表的 POSTROUTING 链，同上一种情况的第9步。注意，这里不光对经过防火墙的数据包进行处理，还对防火墙自己产生的数据包进行处理。 </li>
<li>进入 nat 表的 POSTROUTING 链，同上一种情况的第10步。 </li>
<li>进入出去的网络接口。完毕。</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.thegeekstuff.com/2011/01/iptables-fundamentals" target="_blank" rel="noopener">“Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals”</a></li>
<li><a href="http://selboo.com/post/721/" target="_blank" rel="noopener">“iptables的相关概念和数据包的流程”</a>，介绍了iptables中各个Table及Chain的处理顺序</li>
<li><a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html" target="_blank" rel="noopener">“Iptables 指南 1.1.19”</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
</search>
