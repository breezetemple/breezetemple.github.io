<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT日记</title>
  
  <subtitle>Life is Now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-07T04:41:36.157Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Breeze.Temple</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>scrapy使用</title>
    <link href="http://yoursite.com/2020/03/30/python-scrapy/"/>
    <id>http://yoursite.com/2020/03/30/python-scrapy/</id>
    <published>2020-03-30T05:40:08.000Z</published>
    <updated>2020-04-07T04:41:36.157Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html" target="_blank" rel="noopener">scrapy</a> 爬虫框架编写爬虫</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>安装 <code>pip3 install scrapy --user</code></li><li>css 选择器 <a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">CSS选择器笔记</a></li><li>xpath 选择器 <a href="https://www.jianshu.com/p/539356db0c0c" target="_blank" rel="noopener">scrapy提取数据之：xpath选择器</a></li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>使用 <code>scrapy shell urls</code> 进行调试</p><ol><li>配置默认请求头<pre><code>&gt;&gt;&gt; settings.DEFAULT_REQUEST_HEADERS = { &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, &#39;Accept-Language&#39;: &#39;en&#39;, &#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 \ (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&#39;}</code></pre></li><li>使用 <code>fetch(urls)</code> 命令来抓取测试的页面，解析为 <code>response</code></li><li>使用 <code>response.css</code> 分析页面</li></ol><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><ol><li><code>scrapy startproject projectname</code> 新建项目</li><li><code>scrapy genspider demo demo.com</code> 新建爬虫</li></ol><pre><code class="shell">$ scrapy startproject DemoNew Scrapy project &#39;Demo&#39;, using template directory &#39;~/.local/lib/python3.6/site-packages/scrapy/templates/project&#39;, created in:    ~/python/crawler/scrapy/DemoYou can start your first spider with:    cd Demo    scrapy genspider example example.com$ cd Demo$ scrapy genspider demo demo.com$ tree.├── Demo│   ├── __init__.py│   ├── items.py│   ├── middlewares.py│   ├── pipelines.py│   ├── __pycache__│   │   ├── __init__.cpython-36.pyc│   │   └── settings.cpython-36.pyc│   ├── settings.py│   └── spiders│       ├── demo.py│       ├── __init__.py│       └── __pycache__│           └── __init__.cpython-36.pyc└── scrapy.cfg4 directories, 11 files</code></pre><ul><li><code>items.py</code> 数据模型文件</li><li><code>middlewares.py</code> 中间件文件，配置所有中间件</li><li><code>pipelines.py</code> 管道文件，用于处理数据输出</li><li><code>settings.py</code> 配置文件</li><li><code>demo.py</code> 爬虫文件</li><li><code>scrapy.cfg</code> 整个Scrapy的配置文件，由Scrapy自动生成</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件 <code>settings.py</code></p><ol><li><code>LOG_LEVEL = &#39;WARNING&#39;</code> 输出级别</li><li><code>ROBOTSTXT_OBEY = False</code></li><li><code>FEED_EXPORT_ENCODING = &#39;utf-8&#39;</code> 支持中文</li></ol><h2 id="爬虫实现"><a href="#爬虫实现" class="headerlink" title="爬虫实现"></a>爬虫实现</h2><p>生成的爬虫文件如下</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider):    name = &#39;demo&#39;    allowed_domains = [&#39;demo.com&#39;]    start_urls = [&#39;http://demo.com/&#39;]    def parse(self, response):        pass</code></pre><p>所有的 Spider 类都必须得继承 scrapy.Spider，其中 <code>name</code>、<code>start_urls</code> 以及 <code>parse</code> 成员方法是每个 Spider 类必须要声明的。详细见<a href="https://docs.scrapy.org/en/latest/topics/spiders.html?highlight=Spider#spiders" target="_blank" rel="noopener">Spider</a></p><p>需要定义 <code>start_urls</code> 或者重写 <code>start_requests</code> 方法，两者都必须是可迭代对象</p><pre><code class="python">class Demo(scrapy.Spider):    name = &quot;demo&quot;    allowed_domains = [&quot;demo.com&quot;]    def start_requests(self):        yield Request(url=&#39;https://demo.com/p/&#39;, headers=headers, callback=self.parse_rank)    def parse_rank(self, response):        for item in response.css(&#39;article&gt;a&#39;):            name = item.css(&#39;.post-card-title::text&#39;).get()            link = item.css(&#39;::attr(href)&#39;).get()            print(&quot;\033[1;31m[%s]: %s\033[0m\n&quot; % (name, link))            yield Request(url=link, headers=headers, callback=self.parse_one)        next_page = response.css(&#39;ol&gt;li.next&#39;).css(&#39;a::attr(href)&#39;).get()        if next_page:            print(&quot;%s&quot; % next_page)            yield Request(next_page, callback=self.parse_rank)    def parse_one(self, response):        for src in response.css(&#39;div#post[role=main] p img::attr(src)&#39;).getall():            print(&quot;\033[1;32m%s\n\033[0m&quot; % src)            item = HaosuItem()            item[&#39;src&#39;] = src            yield item</code></pre><blockquote><p>所有具备解析功能的函数都应该返回 Item 或 Requests</p></blockquote><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>在 <code>item.py</code> 中定义数据模型</p><pre><code>class HaosuItem(scrapy.Item):    # define the fields for your item here like:    src = scrapy.Field()    pass</code></pre><p>数据填充并返回 <code>item</code> 见上述函数 <code>parse_one</code></p><h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>Scrapy 提供了一个 item pipeline 用于下载</p><pre><code class="python">from scrapy.pipelines.images import ImagesPipelineimport scrapyclass HaosuPipeline(ImagesPipeline):    def get_media_requests(self, item, info):        yield scrapy.Request(item[&#39;src&#39;])</code></pre><p>从 <code>item</code> 中获取下载地址并下载，修改 <code>setting.py</code> 开启管道</p><pre><code>ITEM_PIPELINES = {    &#39;haosu.pipelines.HaosuPipeline&#39;: 5,}IMAGES_STORE = &#39;image&#39;</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="shell">$ scrapy crawl demo</code></pre><h2 id="Scrapy-体系结构"><a href="#Scrapy-体系结构" class="headerlink" title="Scrapy 体系结构"></a>Scrapy 体系结构</h2><ul><li><a href="https://docs.scrapy.org/en/latest/topics/architecture.html" target="_blank" rel="noopener">Architecture overview</a></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://juejin.im/post/5cfc6f716fb9a07ea7130308" target="_blank" rel="noopener">Scrapy简明教程</a></li><li><a href="https://docs.scrapy.org/en/latest/index.html" target="_blank" rel="noopener">Scrapy 2.0 documentation</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;a href=&quot;https://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scrapy&lt;/a&gt; 爬虫框架编写爬虫&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Python/Spider/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="spider" scheme="http://yoursite.com/tags/spider/"/>
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 搜索技巧</title>
    <link href="http://yoursite.com/2020/03/25/searching-on-github/"/>
    <id>http://yoursite.com/2020/03/25/searching-on-github/</id>
    <published>2020-03-25T12:01:05.000Z</published>
    <updated>2020-04-07T04:41:36.157Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 搜索技巧，用于准确搜索到相关资源</p><ul><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-on-github" target="_blank" rel="noopener">Searching on GitHub</a><ul><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories" target="_blank" rel="noopener">Searching for repositories</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/finding-files-on-github" target="_blank" rel="noopener">Finding files on GitHub</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-topics" target="_blank" rel="noopener">Searching topics</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-code" target="_blank" rel="noopener">Searching code</a></li><li>…</li></ul></li><li><a href="https://github.com/trending" target="_blank" rel="noopener">GitHub Trending</a></li><li><a href="https://github.com/topics" target="_blank" rel="noopener">GitHub Topics</a></li><li><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">GitHub中文排行榜</a></li><li><a href="https://www.jianshu.com/p/7321caea2a08" target="_blank" rel="noopener">Github 搜索技巧</a></li><li><a href="https://sspai.com/post/46061" target="_blank" rel="noopener">掌握 3 个搜索技巧，在 GitHub 上快速找到实用软件资源</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub 搜索技巧，用于准确搜索到相关资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.github.com/en/github/searching-for-information-on-github/searching-on-github&quot; 
      
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/categories/Tools/GitHub/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="searching" scheme="http://yoursite.com/tags/searching/"/>
    
  </entry>
  
  <entry>
    <title>ARM stack backtrace的实现</title>
    <link href="http://yoursite.com/2020/03/17/arm-stack-backtrace/"/>
    <id>http://yoursite.com/2020/03/17/arm-stack-backtrace/</id>
    <published>2020-03-17T06:09:46.000Z</published>
    <updated>2020-04-07T04:41:36.157Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 arm 体系下如何实现 stack backtrace</p><a id="more"></a><h2 id="APCS"><a href="#APCS" class="headerlink" title="APCS"></a>APCS</h2><p>APCS (ARM Procedure Call Standard)，ARM 过程调用标准规范了 arm 寄存器的使用、过程调用时出栈和入栈的约定。如下图示意：</p><p><img src="/images/linux/apcs_t.png" alt=""></p><p>函数的栈帧由 <code>fp</code> 和 <code>sp</code> 标记边界。如果编译器遵循APCS，形成结构化的函数调用栈，就可以解析当前栈(callee)结构，从而得到调用栈(caller)的结构，这样就输出了整个回溯栈。</p><p>编译器选项 <code>-g</code> 生成栈帧信息 <code>.debug_frame</code></p><pre><code class="shell">$ readelf -S output/out.elfThere are 18 section headers, starting at offset 0x1bb0fd0:节头：  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .text             PROGBITS        90000000 001000 6c132c 04  AX  0   0 1024  [ 2] .devtab           PROGBITS        906c132c 6c232c 000c8c 00  WA  0   0  8  [ 3] .bss              NOBITS          906c1fb8 6c2fb8 16a568 00  WA  0   0  8  [ 4] .debug_abbrev     PROGBITS        00000000 6c2fb8 0b82a7 00      0   0  1  [ 5] .debug_info       PROGBITS        00000000 77b25f a37035 00      0   0  1  [ 6] .debug_line       PROGBITS        00000000 11b2294 3bb5fc 00      0   0  1  [ 7] .debug_pubnames   PROGBITS        00000000 156d890 04911e 00      0   0  1  [ 8] .debug_pubtypes   PROGBITS        00000000 15b69ae 166807 00      0   0  1  [ 9] .debug_aranges    PROGBITS        00000000 171d1b5 018900 00      0   0  1  [10] .debug_str        PROGBITS        00000000 1735ab5 0c4732 01  MS  0   0  1  [11] .comment          PROGBITS        00000000 17fa1e7 0000cf 01  MS  0   0  1  [12] .debug_frame      PROGBITS        00000000 17fa2b8 08c8b0 00      0   0  4  [13] .debug_ranges     PROGBITS        00000000 1886b68 056380 00      0   0  1  [14] .debug_loc        PROGBITS        00000000 18dcee8 2d402b 00      0   0  1  [15] .shstrtab         STRTAB          00000000 1bb0f13 0000bd 00      0   0  1  [16] .symtab           SYMTAB          00000000 1bb12a0 071130 10     17 14593  4  [17] .strtab           STRTAB          00000000 1c223d0 086411 00      0   0  1</code></pre><p>内核编译选项</p><pre><code class="makefile">ifeq ($(CONFIG_FRAME_POINTER),y)KBUILD_CFLAGS   +=-fno-omit-frame-pointer -mapcs -mno-sched-prologendif</code></pre><h2 id="unwind"><a href="#unwind" class="headerlink" title="unwind"></a>unwind</h2><p>APCS的缺陷是，维护栈框的指令过多，栈消耗大，占用的寄存器也过多，比如每次调用都必须将 <code>r11,r12,lr,pc</code> 入栈。使用unwind就能避免这些问题，生产指令的效率要有用的多。它的原理是记录每个函数的入栈指令(一般比APCS的入栈要少的多)到特殊的段 <code>.ARM.unwind_idx</code> <code>.ARM.unwind_tab</code>。</p><pre><code class="shell">$ readelf -S vmlinuxThere are 33 section headers, starting at offset 0xa33ba8:节头：  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .head.text        PROGBITS        c0008000 008000 00026c 00  AX  0   0  4  [ 2] .text             PROGBITS        c0100000 010000 55e3dc 00  AX  0   0 64  [ 3] .fixup            PROGBITS        c065e3dc 56e3dc 00001c 00  AX  0   0  4  [ 4] .rodata           PROGBITS        c0700000 570000 105fc8 00  WA  0   0 4096  [ 5] __bug_table       PROGBITS        c0805fc8 675fc8 0057a8 00   A  0   0  4  [ 6] __ksymtab         PROGBITS        c080b770 67b770 006e28 00   A  0   0  4  [ 7] __ksymtab_gpl     PROGBITS        c0812598 682598 005d10 00   A  0   0  4  [ 8] __ksymtab_strings PROGBITS        c08182a8 6882a8 01e235 00   A  0   0  1  [ 9] __param           PROGBITS        c08364e0 6a64e0 000d34 00   A  0   0  4  [10] __modver          PROGBITS        c0837214 6a7214 000dec 00   A  0   0  4  [11] __ex_table        PROGBITS        c0838000 6a8000 001038 00   A  0   0  8  [12] .ARM.unwind_idx   ARM_EXIDX       c0839038 6a9038 0273d8 00  AL 17   0  4  [13] .ARM.unwind_tab   PROGBITS        c0860410 6d0410 003630 00   A  0   0  4  [14] .notes            NOTE            c0863a40 6d3a40 000024 00  AX  0   0  4  [15] .vectors          PROGBITS        ffff0000 6e0000 000020 00  AX  0   0  4  [16] .stubs            PROGBITS        ffff1000 6e1000 0002ac 00  AX  0   0 32  [17] .init.text        PROGBITS        c09002e0 6f02e0 0440d0 00  AX  0   0 32  [18] .exit.text        PROGBITS        c09443b0 7343b0 000ee4 00  AX  0   0  4  [19] .init.arch.info   PROGBITS        c0945294 735294 0000d0 00   A  0   0  4  [20] .init.tagtable    PROGBITS        c0945364 735364 000048 00   A  0   0  4  [21] .init.smpalt      PROGBITS        c09453ac 7353ac 00bd10 00   A  0   0  4  [22] .init.pv_table    PROGBITS        c09510bc 7410bc 00064c 00   A  0   0  1  [23] .init.data        PROGBITS        c0952000 742000 00a194 00  WA  0   0 4096  [24] .data..percpu     PROGBITS        c095d000 74d000 0067cc 00  WA  0   0 64  [25] .data             PROGBITS        c0a00000 760000 0609ac 00  WA  0   0 64  [26] .data..page_align PROGBITS        c0a61000 7c1000 001000 00  WA  0   0 4096  [27] .bss              NOBITS          c0a62000 7c2000 03260c 00  WA  0   0 64  [28] .comment          PROGBITS        00000000 7c2000 00004e 01  MS  0   0  1  [29] .ARM.attributes   ARM_ATTRIBUTES  00000000 7c204e 00002f 00      0   0  1  [30] .symtab           SYMTAB          00000000 7c2080 167560 10     31 77680  4  [31] .strtab           STRTAB          00000000 9295e0 10a46c 00      0   0  1  [32] .shstrtab         STRTAB          00000000 a33a4c 00015a 00      0   0  1$ objdump -D vmlinuc04ee72c &lt;__skb_recv_datagram&gt;:c04ee72c:       e3110040        tst     r1, #64 ; 0x40c04ee730:       e92d43f0        push    {r4, r5, r6, r7, r8, r9, lr}c04ee734:       e1a09003        mov     r9, r3c04ee738:       05903144        ldreq   r3, [r0, #324]  ; 0x144c04ee73c:       e24dd014        sub     sp, sp, #20$ readelf -u .ARM.unwind_idx vmlinux0xc04ee72c &lt;__skb_recv_datagram&gt;: 0x8004adb0  Compact model index: 0  0x04      vsp = vsp + 20  0xad      pop {r4, r5, r6, r7, r8, r9, r14}  0xb0      finish</code></pre><p>输出了函数的地址和对应的编码。接下输出的是编码对应的出栈伪指令，这些伪指令正好是函数栈操作的逆过程，用于回溯。</p><p>内核编译选项</p><pre><code class="makefile">ifeq ($(CONFIG_ARM_UNWIND),y)CFLAGS_ABI  +=-funwind-tablesendif</code></pre><h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>APCS会产生更多的代码指令，对性能有影响，使用unwind的方式会生成额外的段，但不影响性能。</p><p>文件 <code>arch/arm/kernel/traps.c</code></p><pre><code class="c">#ifdef CONFIG_ARM_UNWINDstatic inline void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk){    unwind_backtrace(regs, tsk);}#elsestatic void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk){    unsigned int fp, mode;    int ok = 1;    printk(&quot;Backtrace: &quot;);    if (!tsk)        tsk = current;    if (regs) {        fp = frame_pointer(regs);        mode = processor_mode(regs);    } else if (tsk != current) {        fp = thread_saved_fp(tsk);        mode = 0x10;    } else {        asm(&quot;mov %0, fp&quot; : &quot;=r&quot; (fp) : : &quot;cc&quot;);        mode = 0x10;    }    if (!fp) {        pr_cont(&quot;no frame pointer&quot;);        ok = 0;    } else if (verify_stack(fp)) {        pr_cont(&quot;invalid frame pointer 0x%08x&quot;, fp);        ok = 0;    } else if (fp &lt; (unsigned long)end_of_stack(tsk))        pr_cont(&quot;frame pointer underflow&quot;);    pr_cont(&quot;\n&quot;);    if (ok)        c_backtrace(fp, mode);}#endif</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/itismine/article/details/4752489" target="_blank" rel="noopener">APCS，ARM 过程调用标准(ARM Procedure Call Standard) </a></li><li><a href="https://www.linuxidc.com/Linux/2013-03/81247.htm" target="_blank" rel="noopener">ARM FP寄存器及frame pointer介绍</a></li><li><a href="https://www.alivepea.me/prog/how-backtrace-work/" target="_blank" rel="noopener">Stack backtrace 的实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 arm 体系下如何实现 stack backtrace&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="backtrace" scheme="http://yoursite.com/tags/backtrace/"/>
    
      <category term="unwind" scheme="http://yoursite.com/tags/unwind/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核符号表的生成和查找</title>
    <link href="http://yoursite.com/2020/03/11/linux-kernel-all-syms/"/>
    <id>http://yoursite.com/2020/03/11/linux-kernel-all-syms/</id>
    <published>2020-03-11T03:12:09.000Z</published>
    <updated>2020-04-07T04:41:36.157Z</updated>
    
    <content type="html"><![CDATA[<p><code>printk</code> 可以根据地址打印函数名/符号名，记录内核符号表生成及使用过程</p><a id="more"></a><h2 id="System-map"><a href="#System-map" class="headerlink" title="System.map"></a>System.map</h2><p>System.map 文件是编译内核时生成的，它记录了内核中的符号列表，以及符号在内存中的虚拟地址，由脚本 <code>scripts/mksysmap</code> 生成</p><h2 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h2><p>内核必须打开 <code>CONFIG_KALLSYMS</code> 编译选项，和 System.map 的区别是<strong>它同时包含了内核模块的符号列表</strong>，是在内核启动后生成的，位于文件系统的 /proc 目录下，实现代码见 <code>kernel/kallsyms.c</code></p><h2 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h2><p><strong>System.map 和内核启动后的 /proc/kallsyms 文件中的符号表只是给我们看的，内核不会使用它们</strong>，而是在编译内核时，向 vmlinux 嵌入了一个符号表</p><p>内核符号表如何嵌入内核查看文件 <code>scripts/link-vmlinux.sh</code></p><h3 id="内核符号表结构"><a href="#内核符号表结构" class="headerlink" title="内核符号表结构"></a>内核符号表结构</h3><p>由工具 <code>scripts/kallsyms</code> 生成，工具源码在同目录，用法如下</p><pre><code>nm -n vmlinux | scripts/kallsyms [--all-symbols] &gt; symbols.S</code></pre><p>使用 nm 工具获得符号表之后进行整理得到汇编文件，包括 6 个全局变量</p><ul><li><code>kallsyms_addresses</code> 数组，存放所有符号的地址列表，按地址升序排列</li><li><code>kallsyms_num_syms</code> 符号的数量</li><li><code>kallsyms_names</code> 数组，存放所有符号的名称，和 <code>kallsyms_addresses</code> 一一对应</li><li><code>kallsyms_markers</code> 存储索引用于加速搜索</li><li><code>kallsyms_token_table</code> 数组，存储压缩字符串</li><li><code>kallsyms_token_index</code> 记录每个 token 首字符在 <code>kallsyms_token_table</code> 中的偏移</li></ul><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><pre><code>c0008000 T _textc0008000 T stextc000808c t __create_page_tables</code></pre><p>计算符号 <code>c000808c t __create_page_tables</code> 偏移为 <code>0x8c</code>，从 <code>kallsyms_addresses</code> 中得到索引为 <code>2</code></p><pre><code>kallsyms_addresses:     PTR _text + 0     PTR _text + 0     PTR _text + 0x8ckallsyms_names:    .byte 0x04, 0x9b, 0xef, 0x78, 0x74    .byte 0x05, 0x54, 0x5f, 0xef, 0x78, 0x74    .byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73kallsyms_markers:    PTR 0    PTR 2917    PTR 5993</code></pre><p>根据 <code>2 &gt;&gt; 8</code> 计算出在 <code>kallsyms_markers</code> 第一组 <code>PTR 0</code>，指出起始字符的偏移在 <code>kallsyms_names[0]</code>，同时根据 <code>2 &amp;&amp; 0xFF</code> 找到具体位置</p><p><code>.byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73</code> 为压缩字符，需要根据 <code>kallsyms_token_table</code> 解析</p><ul><li>0x0a 长度</li><li>0xff <code>t_</code></li><li>0xe1 <code>_c</code></li><li>0xf5 <code>re</code></li><li>0x8b <code>ate_</code></li><li>0xa7 <code>pa</code></li><li>0x18 <code>get_</code></li><li>0xfd <code>ta</code></li><li>0x62 <code>b</code></li><li>0xd2 <code>le</code></li><li>0x73 <code>s</code></li></ul><p><code>t__create_page_tables</code> 其中 <code>t</code> 为符号类型，去除之后为 <code>__create_page_tables</code></p><h3 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h3><p>内核文件参照 <code>kernel/kallsyms.c</code> 提供接口用于内核符号表查找</p><ul><li><code>get_symbol_pos</code> 根据地址查找索引及偏移</li><li><code>module_address_lookup</code> 内核模块符号查找</li><li><code>get_symbol_offset</code> 根据 <code>kallsyms_markers</code> 获取偏移</li><li><code>kallsyms_expand_symbol</code> 获取符号名</li><li><code>kallsyms_get_symbol_type</code> 获取符号类型</li></ul><p>例如函数 <code>kallsyms_lookup</code></p><pre><code class="c">if (is_ksym_addr(addr)) {    unsigned long pos;    pos = get_symbol_pos(addr, symbolsize, offset);    /* Grab name */    kallsyms_expand_symbol(get_symbol_offset(pos),                   namebuf, KSYM_NAME_LEN);    if (modname)        *modname = NULL;    return namebuf;}/* See if it&#39;s in a module. */return module_address_lookup(addr, symbolsize, offset, modname,                 namebuf);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;printk&lt;/code&gt; 可以根据地址打印函数名/符号名，记录内核符号表生成及使用过程&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="kallsyms" scheme="http://yoursite.com/tags/kallsyms/"/>
    
  </entry>
  
  <entry>
    <title>USB 通信设备类与 USB Dongle 拨号</title>
    <link href="http://yoursite.com/2020/03/11/usb-3g-and-usb-cdc/"/>
    <id>http://yoursite.com/2020/03/11/usb-3g-and-usb-cdc/</id>
    <published>2020-03-11T01:40:47.000Z</published>
    <updated>2020-04-07T04:41:36.157Z</updated>
    
    <content type="html"><![CDATA[<ul><li>USB 通信设备类</li><li>USB Dongle 拨号</li></ul><a id="more"></a><h2 id="Defined-Class-Codes"><a href="#Defined-Class-Codes" class="headerlink" title="Defined Class Codes"></a>Defined Class Codes</h2><p><a href="https://www.usb.org/defined-class-codes" target="_blank" rel="noopener">Defined Class Codes</a></p><p>例如：</p><ul><li><code>02h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass02h" target="_blank" rel="noopener">Communications and CDC Control</a></li><li><code>08h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass08h" target="_blank" rel="noopener">Mass Storage</a></li><li><code>09h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass09h" target="_blank" rel="noopener">Hub</a></li><li><code>0Ah</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass0Ah" target="_blank" rel="noopener">CDC-Data</a></li><li><code>EFh</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClassEFh" target="_blank" rel="noopener">Miscellaneous</a></li></ul><p>Linux4.9 <code>include/uapi/linux/usb/ch9.h</code> 可以看到各个定义值</p><h2 id="Communications-Class-Subclass-Codes"><a href="#Communications-Class-Subclass-Codes" class="headerlink" title="Communications Class Subclass Codes"></a>Communications Class Subclass Codes</h2><p>USB 的 CDC 类是 USB 通信设备类（Communication Device Class）的简称。CDC 类是 USB 组织定义的一类专门给各种通信设备（电信通信设备和中速网络通信设备）使用的 USB 子类。</p><p>具体列表见文档 Universal Serial Bus Class Definitions for Communications Devices 4.3章节：</p><ul><li><code>00h</code> RESERVED</li><li><code>01h</code> Direct Line Control Model [USBPSTN1.2]</li><li><code>02h</code> Abstract Control Model [USBPSTN1.2]</li><li><code>03h</code> Telephone Control Model [USBPSTN1.2]</li><li><code>04h</code> Multi-Channel Control Model [USBISDN1.2]</li><li><code>05h</code> CAPI Control Model [USBISDN1.2]</li><li><code>06h</code> Ethernet Networking Control Model [USBECM1.2]</li><li><code>07h</code> ATM Networking Control Model [USBATM1.2]</li><li><code>08h</code> Wireless Handset Control Model [USBWMC1.1]</li><li><code>09h</code> Device Management [USBWMC1.1]</li><li><code>0Ah</code> Mobile Direct Line Model [USBWMC1.1]</li><li><code>0Bh</code> OBEX [USBWMC1.1]</li><li><code>0Ch</code> Ethernet Emulation Model [USBEEM1.0]</li><li><code>0Dh</code> Network Control Model [USBNCM1.0]</li><li><code>0Eh</code> Mobile Broadband Interface Model [USBMBIM1.0]</li><li><code>0Dh-7Fh</code> RESERVED (future use)</li><li><code>80-FEh</code> RESERVED (vendor specific)</li></ul><h2 id="Linux4-9-内核实现"><a href="#Linux4-9-内核实现" class="headerlink" title="Linux4.9 内核实现"></a>Linux4.9 内核实现</h2><p>构造 USB 设备宏定义</p><pre><code class="c">/** * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces * @cl: bInterfaceClass value * @sc: bInterfaceSubClass value * @pr: bInterfaceProtocol value * * This macro is used to create a struct usb_device_id that matches a * specific class of interfaces. */#define USB_INTERFACE_INFO(cl, sc, pr) \    .match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \    .bInterfaceClass = (cl), \    .bInterfaceSubClass = (sc), \    .bInterfaceProtocol = (pr)</code></pre><p>例如：</p><pre><code class="c">/* Telit LE922A6 in MBIM composition */{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x1041, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),  .driver_info = (unsigned long)&amp;cdc_mbim_info_avoid_altsetting_toggle,},{    USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_EEM,            USB_CDC_PROTO_EEM),    .driver_info = (unsigned long) &amp;eem_info,},/* Telit LE910 V2 */{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x0036,    USB_CLASS_COMM,    USB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),  .driver_info = (unsigned long)&amp;wwan_noarp_info,},</code></pre><p>内核文件</p><pre><code class="shell">$ find -name &quot;cdc_*&quot;./include/linux/usb/cdc_ncm.h./drivers/net/usb/cdc_mbim.c./drivers/net/usb/cdc_ncm.c./drivers/net/usb/cdc_ether.c./drivers/net/usb/cdc_eem.c./drivers/net/usb/cdc_ether.o./drivers/net/usb/cdc_subset.c./Documentation/networking/cdc_mbim.txt</code></pre><h2 id="Rndis"><a href="#Rndis" class="headerlink" title="Rndis"></a>Rndis</h2><p>在文件 <code>drivers/net/usb/rndis_host.c</code> 中发现如下代码</p><pre><code class="c">static const struct usb_device_id   products [] = {{    /* 2Wire HomePortal 1000SW */    USB_DEVICE_AND_INTERFACE_INFO(0x1630, 0x0042,                      USB_CLASS_COMM, 2 /* ACM */, 0x0ff),    .driver_info = (unsigned long) &amp;rndis_poll_status_info,}, {    /* RNDIS is MSFT&#39;s un-official variant of CDC ACM */    USB_INTERFACE_INFO(USB_CLASS_COMM, 2 /* ACM */, 0x0ff),    .driver_info = (unsigned long) &amp;rndis_info,}, {    /* &quot;ActiveSync&quot; is an undocumented variant of RNDIS, used in WM5 */    USB_INTERFACE_INFO(USB_CLASS_MISC, 1, 1),    .driver_info = (unsigned long) &amp;rndis_poll_status_info,}, {    /* RNDIS for tethering */    USB_INTERFACE_INFO(USB_CLASS_WIRELESS_CONTROLLER, 1, 3),    .driver_info = (unsigned long) &amp;rndis_info,},    { },        // END};MODULE_DEVICE_TABLE(usb, products);</code></pre><blockquote><p>RNDIS是一个以太网端口 （ Ethernet port ）。最开始是微软控制的，用以取代 CDC Ethernet 的协议。Linux 支持它仅仅是因为微软不支持 CDC以太网标准。</p></blockquote><h2 id="USB-Dongle-拨号"><a href="#USB-Dongle-拨号" class="headerlink" title="USB Dongle 拨号"></a>USB Dongle 拨号</h2><blockquote><p>Many modern (and most LTE) usb modems provide <strong>qmi, mbim, ncm, rndis</strong> protocol for connection instead of legacy <strong>ppp</strong> protocol, they are faster and better, overall recommended. For more information:</p></blockquote><ul><li>qmi and mbim, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ltedongle" target="_blank" rel="noopener">How To Use LTE modem in QMI mode for WAN connection</a></li><li>ncm, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ethernetoverusb_ncm" target="_blank" rel="noopener">How To Use LTE modem in NCM mode for WAN connection</a></li><li>rndis, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ethernetoverusb_rndis" target="_blank" rel="noopener">How To Use LTE modem in RNDIS mode for WAN connection</a></li></ul><h2 id="内核设备列表"><a href="#内核设备列表" class="headerlink" title="内核设备列表"></a>内核设备列表</h2><p>USB 设备需要关心 <code>ProductID</code> 和 <code>VendorID</code>，用于表示某一种具体的设备，例如文件 <code>unusual_devs.h</code> 列举了非常规设备列表，表示这些设备需要特殊处理</p><pre><code class="c">/* * Reported by fangxiaozhi &lt;huananhu@huawei.com&gt; * This brings the HUAWEI data card devices into multi-port mode */UNUSUAL_DEV(  0x12d1, 0x1001, 0x0000, 0x0000,        &quot;HUAWEI MOBILE&quot;,        &quot;Mass Storage&quot;,        USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,        0),UNUSUAL_DEV(  0x12d1, 0x1003, 0x0000, 0x0000,        &quot;HUAWEI MOBILE&quot;,        &quot;Mass Storage&quot;,        USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,        0),</code></pre><h2 id="Add-New-USB-Dongle"><a href="#Add-New-USB-Dongle" class="headerlink" title="Add New USB Dongle"></a>Add New USB Dongle</h2><p>在内核中增加普通 USB Dongle 设备，修改 <code>drivers/usb/serial/option.c</code> 中的数组 <code>option_ids</code></p><pre><code class="c">{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1C0B, 0xff, 0xff, 0xff) },{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1C05, 0xff, 0xff, 0xff) },</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/kangear/article/details/37605811" target="_blank" rel="noopener">USB中CDC-ECM的了解和配置</a></li><li><a href="https://wenku.baidu.com/view/fd16907e011ca300a6c3903e.html" target="_blank" rel="noopener">RNDIS,ECM及MBIM报文简述</a></li><li><a href="https://openwrt.org/docs/guide-user/network/wan/wwan/3gdongle" target="_blank" rel="noopener">Use 3g/UMTS USB Dongle for WAN connection</a></li><li><a href="https://stackoverflow.com/questions/20299434/whats-different-in-usb-class-when-the-devices-are-modem" target="_blank" rel="noopener">What’s different in USB class when the devices are modem?</a></li><li><a href="https://www.iteye.com/blog/javatome-1205027" target="_blank" rel="noopener">Linux那些事儿之我是U盘(18)</a></li><li><a href="https://blog.csdn.net/cfy_phonex/article/details/22684005" target="_blank" rel="noopener">Android f_rndis 分析笔记</a></li><li><a href="https://wenku.baidu.com/view/a1e2c42d4b73f242336c5fa0.html" target="_blank" rel="noopener">RNDIS原理分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;USB 通信设备类&lt;/li&gt;
&lt;li&gt;USB Dongle 拨号&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="USB" scheme="http://yoursite.com/categories/Linux/USB/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="rndis" scheme="http://yoursite.com/tags/rndis/"/>
    
      <category term="usb" scheme="http://yoursite.com/tags/usb/"/>
    
      <category term="3g" scheme="http://yoursite.com/tags/3g/"/>
    
      <category term="ppp" scheme="http://yoursite.com/tags/ppp/"/>
    
      <category term="usb-cdc" scheme="http://yoursite.com/tags/usb-cdc/"/>
    
      <category term="ecm" scheme="http://yoursite.com/tags/ecm/"/>
    
      <category term="mbim" scheme="http://yoursite.com/tags/mbim/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核栈溢出检测</title>
    <link href="http://yoursite.com/2020/03/09/linux-kernel-stack/"/>
    <id>http://yoursite.com/2020/03/09/linux-kernel-stack/</id>
    <published>2020-03-09T02:22:33.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>监测内核栈使用情况，分析 crash 问题</p><a id="more"></a><p><code>thread_info</code> 位于内核栈底部，一旦溢出会破坏相关信息，有时会报错，但更多的是不直接报错，而是各种奇怪的panic</p><p><img src="/images/linux/kstack-smash.png" alt="kernel stack"></p><h2 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h2><p>开启 <code>debugfs</code> 使用如下方法监控内核栈的大小和深度</p><pre><code># mount -t debugfs nodev /sys/kernel/debug# echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled# cat /sys/kernel/debug/tracing/stack_max_size# cat /sys/kernel/debug/tracing/stack_trace</code></pre><h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><h3 id="CONFIG-DEBUG-STACK-USAGE"><a href="#CONFIG-DEBUG-STACK-USAGE" class="headerlink" title="CONFIG_DEBUG_STACK_USAGE"></a>CONFIG_DEBUG_STACK_USAGE</h3><pre><code>Symbol: DEBUG_STACK_USAGE [=y]Type  : booleanPrompt: Stack utilization instrumentation  Location:    -&gt; Kernel hacking(1)   -&gt; Memory Debugging  Defined at lib/Kconfig.debug:562  Depends on: DEBUG_KERNEL [=y] &amp;&amp; !IA64</code></pre><p>用于跟踪内核栈的溢出错误，一个内核栈溢出错误的明显的现象是产生 oops 错误却没有列出系统的调用栈信息。该选项将使内核进行栈溢出检查，并使内核进行栈使用的统计</p><h3 id="DEBUG-STACK-OVERFLOW"><a href="#DEBUG-STACK-OVERFLOW" class="headerlink" title="DEBUG_STACK_OVERFLOW"></a>DEBUG_STACK_OVERFLOW</h3><p>内核未提供 arm 配置选项，可以参照 <a href="https://www.alivepea.me/kernel/kernel-overflow/" target="_blank" rel="noopener">patch 检测内核的堆栈溢出</a></p><h3 id="CONFIG-STACK-TRACER"><a href="#CONFIG-STACK-TRACER" class="headerlink" title="CONFIG_STACK_TRACER"></a>CONFIG_STACK_TRACER</h3><pre><code>Symbol: STACK_TRACER [=n]   Type  : boolean   Prompt: Trace max stack     Location:       -&gt; Kernel hacking         -&gt; Tracers (FTRACE [=y])     Defined at kernel/trace/Kconfig:381     Depends on: TRACING_SUPPORT [=y] &amp;&amp; FTRACE [=y] &amp;&amp; HAVE_FUNCTION_TRACER [=y]     Selects: FUNCTION_TRACER [=n] &amp;&amp; STACKTRACE [=y] &amp;&amp; KALLSYMS [=y]</code></pre><p>参照文档 <code>Documentation/trace/ftrace.txt</code> 使用如下</p><pre><code># echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled# cat stack_max_size2928# cat stack_trace       Depth    Size   Location    (18 entries)       -----    ----   -------- 0)     2928     224   update_sd_lb_stats+0xbc/0x4ac 1)     2704     160   find_busiest_group+0x31/0x1f1 2)     2544     256   load_balance+0xd9/0x662 3)     2288      80   idle_balance+0xbb/0x130 4)     2208     128   __schedule+0x26e/0x5b9 5)     2080      16   schedule+0x64/0x66 6)     2064     128   schedule_timeout+0x34/0xe0 7)     1936     112   wait_for_common+0x97/0xf1 8)     1824      16   wait_for_completion+0x1d/0x1f 9)     1808     128   flush_work+0xfe/0x11910)     1680      16   tty_flush_to_ldisc+0x1e/0x2011)     1664      48   input_available_p+0x1d/0x5c12)     1616      48   n_tty_poll+0x6d/0x13413)     1568      64   tty_poll+0x64/0x7f14)     1504     880   do_select+0x31e/0x51115)      624     400   core_sys_select+0x177/0x21616)      224      96   sys_select+0x91/0xb917)      128     128   system_call_fastpath+0x16/0x1b</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监测内核栈使用情况，分析 crash 问题&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="debugfs" scheme="http://yoursite.com/tags/debugfs/"/>
    
      <category term="crash" scheme="http://yoursite.com/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>打印用户态段错误信息</title>
    <link href="http://yoursite.com/2020/03/05/linux-user-debug/"/>
    <id>http://yoursite.com/2020/03/05/linux-user-debug/</id>
    <published>2020-03-05T02:01:09.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>user_debug</code> 打印由用户态引起的 oops 信息</p><a id="more"></a><p><a href="https://www.cnblogs.com/lifexy/p/8045191.html" target="_blank" rel="noopener">Linux应用调试-修改内核来打印用户态的oops</a></p><ul><li>Linux 4.9</li><li>arm arch</li></ul><h2 id="Linux-内核错误处理"><a href="#Linux-内核错误处理" class="headerlink" title="Linux 内核错误处理"></a>Linux 内核错误处理</h2><p>文件 <code>arch/arm/mm/fsr-2level.c</code></p><pre><code class="c">{ do_bad,       SIGSEGV, 0,     &quot;vector exception&quot;         },{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },{ do_bad,       SIGKILL, 0,     &quot;terminal exception&quot;           },{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },{ do_translation_fault, SIGSEGV, SEGV_MAPERR,   &quot;section translation fault&quot;    },{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },{ do_page_fault,    SIGSEGV, SEGV_MAPERR,   &quot;page translation fault&quot;       },{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;section domain fault&quot;         },{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;page domain fault&quot;        },{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },{ do_sect_fault,    SIGSEGV, SEGV_ACCERR,   &quot;section permission fault&quot;     },{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },{ do_page_fault,    SIGSEGV, SEGV_ACCERR,   &quot;page permission fault&quot;        },</code></pre><ul><li><code>do_translation_fault</code> 调用 <code>do_bad_area</code></li><li><code>do_page_fault</code> 调用 <code>__do_user_fault</code> 或 <code>__do_kernel_fault</code></li><li><code>do_sect_fault</code> 调用 <code>do_bad_area</code></li></ul><pre><code class="c">/*                                                                               * Oops.  The kernel tried to access some page that wasn&#39;t present.              */                                                                             static void                                                                     __do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,             struct pt_regs *regs)                                                 {                                                                                   /*                                                                               * Are we prepared to handle this kernel fault?                                  */                                                                             if (fixup_exception(regs))                                                          return;                                                                     /*                                                                               * No handler, we&#39;ll have to terminate things with extreme prejudice.            */                                                                             bust_spinlocks(1);                                                              pr_alert(&quot;Unable to handle kernel %s at virtual address %08lx\n&quot;,                    (addr &lt; PAGE_SIZE) ? &quot;NULL pointer dereference&quot; :                               &quot;paging request&quot;, addr);                                                   show_pte(mm, addr);                                                             die(&quot;Oops&quot;, regs, fsr);                                                         bust_spinlocks(0);                                                              do_exit(SIGKILL);                                                           }/* * Something tried to access memory that isn&#39;t in our memory map.. * User mode accesses just cause a SIGSEGV */static void__do_user_fault(struct task_struct *tsk, unsigned long addr,        unsigned int fsr, unsigned int sig, int code,        struct pt_regs *regs){    struct siginfo si;#ifdef CONFIG_DEBUG_USER    if (((user_debug &amp; UDBG_SEGV) &amp;&amp; (sig == SIGSEGV)) ||        ((user_debug &amp; UDBG_BUS)  &amp;&amp; (sig == SIGBUS))) {        printk(KERN_DEBUG &quot;%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\n&quot;,               tsk-&gt;comm, sig, addr, fsr);        show_pte(tsk-&gt;mm, addr);        show_regs(regs);    }#endif    tsk-&gt;thread.address = addr;    tsk-&gt;thread.error_code = fsr;    tsk-&gt;thread.trap_no = 14;    si.si_signo = sig;    si.si_errno = 0;    si.si_code = code;    si.si_addr = (void __user *)addr;    force_sig_info(sig, &amp;si, tsk);}void do_bad_area(unsigned long addr, unsigned int fsr, struct pt_regs *regs){    struct task_struct *tsk = current;    struct mm_struct *mm = tsk-&gt;active_mm;    /*     * If we are in kernel mode at this point, we     * have no context to handle this fault with.     */    if (user_mode(regs))        __do_user_fault(tsk, addr, fsr, SIGSEGV, SEGV_MAPERR, regs);    else        __do_kernel_fault(mm, addr, fsr, regs);}</code></pre><p>可以看出 <code>__do_kernel_fault</code> 为内核态 oops 输出，<code>__do_user_fault</code> 为用户态输出，同时需要满足</p><ol><li>定义 <code>CONFIG_DEBUG_USER</code></li><li>设置 <code>user_debug</code></li></ol><h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><ul><li><code>Kernel hacking</code> -&gt; <code>Verbose user fault messages</code></li><li><code>user_debug</code> 见文档 <code>kernel-parameters.txt</code>，在 cmdline 中增加 <code>user_debug=31</code><pre><code class="txt">  user_debug= [KNL,ARM]          Format: &lt;int&gt;          See arch/arm/Kconfig.debug help text.              1 - undefined instruction events              2 - system calls              4 - invalid data aborts              8 - SIGSEGV faults              16 - SIGBUS faults          Example: user_debug=31</code></pre><pre><code class="c">unsigned int user_debug;static int __init user_debug_setup(char *str){  get_option(&amp;str, &amp;user_debug);  return 1;}__setup(&quot;user_debug=&quot;, user_debug_setup);</code></pre></li></ul><p>修改之后测试会输出调试信息，但不包括栈信息</p><h2 id="打印应用栈数据"><a href="#打印应用栈数据" class="headerlink" title="打印应用栈数据"></a>打印应用栈数据</h2><p>参考 <code>__do_kernel_fault</code> 中打印栈信息函数</p><pre><code class="c">if (!user_mode(regs) || in_interrupt()) {    dump_mem(KERN_EMERG, &quot;Stack: &quot;, regs-&gt;ARM_sp,         THREAD_SIZE + (unsigned long)task_stack_page(tsk));    dump_backtrace(regs, tsk);    dump_instr(KERN_EMERG, regs);}</code></pre><p>通过sp寄存器里存的栈地址，每打印一个栈地址里的32位数据, 栈地址便加4</p><p>在 <code>__do_user_fault</code> 中修改如下</p><pre><code class="c">unsigned long ret;unsigned long val;int i = 0;printk(&quot;Stack: \n&quot;);while(i &lt; 1024){    if(copy_from_user(&amp;val, (const void __user *)(regs-&gt;ARM_sp + i*4), 4)){        break;    }    i++;    printk(&quot;%08x &quot;, val);    if(i%8 == 0)        printk(&quot;\n&quot;);}printk(&quot;\n end of stack \n&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;user_debug&lt;/code&gt; 打印由用户态引起的 oops 信息&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="oops" scheme="http://yoursite.com/tags/oops/"/>
    
  </entry>
  
  <entry>
    <title>gcc 编译选项 -fomit-frame-pointer</title>
    <link href="http://yoursite.com/2020/02/26/gcc-options-fomit-frame-pointer/"/>
    <id>http://yoursite.com/2020/02/26/gcc-options-fomit-frame-pointer/</id>
    <published>2020-02-26T05:34:12.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>编译选项 <code>-fomit-frame-pointer</code> 与 <code>-fno-omit-frame-pointer</code> 对汇编及调试影响</p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>栈是向下生长的。所谓向下生长是指从 内存高地址 -&gt; 低地址 的路径延伸</li><li>有两个重要的指针用于维护栈信息<ul><li>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。  由于栈的地址大小是从上到下从大到小，所以ESP指在栈的最底端</li><li>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。指在栈的最顶端</li></ul></li></ul><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>手册中对 <code>-fomit-frame-pointer</code> 描述如下</p><blockquote><p>Don’t keep the frame pointer in a register for functions that don’t need one.  This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions.  It also makes debugging impossible on some machines.<br>Enabled at levels -O, -O2, -O3, -Os.</p></blockquote><p>当使用 <code>-O0</code> 时不会开启上述选项，编译器会在栈空间中保存额外信息用于调试，即 <code>frame pointer</code></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="c">int add(int a, int b){    return a + b ;}</code></pre><p>汇编对比如下</p><pre><code class="shell">$ gcc -fno-omit-frame-pointer test.c$ csky-elf-objdump -dS a.out00008934 &lt;add&gt;:    8934:    2470          subi    r0, r0, 8    8936:    9800          st    r8, (r0, 0)    8938:    2470          subi    r0, r0, 8    893a:    1208          mov    r8, r0    893c:    9208          st    r2, (r8, 0)    893e:    9318          st    r3, (r8, 4)    8940:    8608          ld    r6, (r8, 0)    8942:    8718          ld    r7, (r8, 4)    8944:    1c67          addu    r7, r7, r6    8946:    1272          mov    r2, r7    8948:    1280          mov    r0, r8    894a:    2070          addi    r0, r0, 8    894c:    8640          ld    r6, (r0, 16)    894e:    8800          ld    r8, (r0, 0)    8950:    2070          addi    r0, r0, 8    8952:    00cf          jmp    r15$ gcc -fomit-frame-pointer test.c$ objdump -dS a.out00008934 &lt;add&gt;:    8934:    2470          subi    r0, r0, 8    8936:    9200          st    r2, (r0, 0)    8938:    9310          st    r3, (r0, 4)    893a:    8600          ld    r6, (r0, 0)    893c:    8710          ld    r7, (r0, 4)    893e:    1c67          addu    r7, r7, r6    8940:    1272          mov    r2, r7    8942:    2070          addi    r0, r0, 8    8944:    8640          ld    r6, (r0, 16)    8946:    00cf          jmp    r15</code></pre><p>可以看到在栈上多开辟一些空间用于存储 <code>frame pointer</code></p><p>不开启优化时更能反映出压栈及出栈的操作，在这个过程中不会有 <code>fp</code> 操作</p><pre><code class="disass">00008934 &lt;add&gt;:    # 开辟栈空间 8B    8934:    2470          subi    r0, r0, 8    # 第一个参数 r2 入栈    8936:    9200          st    r2, (r0, 0)    # 第二个参数 r3 入栈    8938:    9310          st    r3, (r0, 4)    # 加载并执行子程序 a + b    893a:    8600          ld    r6, (r0, 0)    893c:    8710          ld    r7, (r0, 4)    893e:    1c67          addu    r7, r7, r6    # 赋值给 r2 作为函数返回值    8940:    1272          mov    r2, r7    # 释放栈    8942:    2070          addi    r0, r0, 8    8944:    8640          ld    r6, (r0, 16)    # 返回调用函数栈    8946:    00cf          jmp    r15</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/HedpatCzw/article/details/50380128" target="_blank" rel="noopener">关于-fno-omit-frame-pointer与-fomit-frame-pointer</a></li><li><a href="https://jijing.site/riscv/20190428_function_call.html" target="_blank" rel="noopener">C函数调用和汇编代码分析</a></li><li><a href="http://blog.sina.com.cn/s/blog_a558c25a0101l9yd.html" target="_blank" rel="noopener">Linux下Call Stack追溯的实现机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译选项 &lt;code&gt;-fomit-frame-pointer&lt;/code&gt; 与 &lt;code&gt;-fno-omit-frame-pointer&lt;/code&gt; 对汇编及调试影响&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
      <category term="bt" scheme="http://yoursite.com/tags/bt/"/>
    
      <category term="stack frame" scheme="http://yoursite.com/tags/stack-frame/"/>
    
  </entry>
  
  <entry>
    <title>基于 Markdown 生成幻灯片</title>
    <link href="http://yoursite.com/2020/02/17/pandoc-with-reveal-js/"/>
    <id>http://yoursite.com/2020/02/17/pandoc-with-reveal-js/</id>
    <published>2020-02-17T13:39:37.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>将 Markdown 转换为幻灯片</p><ul><li><a href="https://github.com/adamzap/landslide" target="_blank" rel="noopener">landslide</a> Generate HTML5 slideshows from markdown, ReST, or textile</li><li><a href="https://github.com/marp-team/marp" target="_blank" rel="noopener">Marp</a> Marp is the ecosystem to write your presentation with plain Markdown.</li><li><a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a></li><li><a href="https://github.com/jacksingleton/hacker-slides" target="_blank" rel="noopener">hacker-slides</a> You can write markdown on the left, and preview your presentation on the right.</li></ul><p>使用 Pandoc 和 <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">Reveal.js</a> 幻灯片演示框架将 Markdown 转换为幻灯片</p><a id="more"></a><h2 id="Pandoc-amp-Reveal-js"><a href="#Pandoc-amp-Reveal-js" class="headerlink" title="Pandoc &amp; Reveal.js"></a>Pandoc &amp; Reveal.js</h2><ul><li><a href="https://github.com/hakimel/reveal.js/releases" target="_blank" rel="noopener">reveal.js release</a> 将文件夹放在同目录</li><li>支持<a href="https://help.github.com/en/github/writing-on-github" target="_blank" rel="noopener">GitHub Markdown</a>语法</li><li>支持如下主题<ul><li>black: Black background, white text, blue links (default theme)</li><li>white: White background, black text, blue links</li><li>league: Gray background, white text, blue links (default theme for reveal.js &lt; 3.0.0)</li><li>beige: Beige background, dark text, brown links</li><li>sky: Blue background, thin dark text, blue links</li><li>night: Black background, thick white text, orange links</li><li>serif: Cappuccino background, gray text, brown links</li><li>simple: White background, black text, blue links</li><li>solarized: Cream-colored background, dark green text, blue links</li></ul></li></ul><pre><code class="shell">$ pandoc slides.md -o slides.html -t revealjs -s -V theme=beige</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://juejin.im/entry/5b20c950f265da6e1c4aed8e" target="_blank" rel="noopener">4 种基于 Markdown 的幻灯片生成器</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将 Markdown 转换为幻灯片&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/adamzap/landslide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;landslide&lt;/a&gt; Generate HTML5 slideshows from markdown, ReST, or textile&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/marp-team/marp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Marp&lt;/a&gt; Marp is the ecosystem to write your presentation with plain Markdown.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pandoc.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pandoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jacksingleton/hacker-slides&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hacker-slides&lt;/a&gt; You can write markdown on the left, and preview your presentation on the right.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 Pandoc 和 &lt;a href=&quot;https://github.com/hakimel/reveal.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reveal.js&lt;/a&gt; 幻灯片演示框架将 Markdown 转换为幻灯片&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Tools/Markdown/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="pandoc" scheme="http://yoursite.com/tags/pandoc/"/>
    
      <category term="reveal.js" scheme="http://yoursite.com/tags/reveal-js/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 发布 Hexo Blog</title>
    <link href="http://yoursite.com/2020/01/19/github-actions-ci-hexo/"/>
    <id>http://yoursite.com/2020/01/19/github-actions-ci-hexo/</id>
    <published>2020-01-19T09:16:07.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用 Travis CI 实现了自动生成并发布 Hexo 博客，现在切换到 GitHub Actions</p><a id="more"></a><h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><ul><li>源码仓库，私有</li><li>发布仓库，xxx.github.io</li></ul><p>有两种方式可以用于 GitHub Actions 发布 Blog</p><ul><li>ssh-key，分别提交 key 到两个仓库，参考 <a href="https://juejin.im/post/5da03d5e6fb9a04e046bc3a2" target="_blank" rel="noopener">用 GitHub Actions 自动化发布Hexo网站到 GitHub Pages</a></li><li>token，参考 <a href="https://www.jianshu.com/p/7940fe40885d" target="_blank" rel="noopener">Hexo 使用 Github Actions 自动更新</a></li></ul><h2 id="source仓库"><a href="#source仓库" class="headerlink" title="source仓库"></a>source仓库</h2><p>打开仓库设置，在 <code>Secrets</code> 选项中，点击 <code>Add a new secret</code>，新建 <code>GH_TOKEN</code></p><p>添加 <code>Github Actions</code> 文件</p><pre><code class="yaml">name: Hexo Auto-Deployon: [push]jobs:  build:    name: Hexo Auto-Deploy by GitHub Actions    runs-on: ubuntu-latest    steps:    - name: 1. git checkout...      uses: actions/checkout@v1    - name: 2. setup nodejs...      uses: actions/setup-node@v1    - name: 3. install hexo...      run: |        npm install hexo-cli -g        npm install    - name: 4. hexo generate public files...      run: |        hexo clean        hexo g      - name: 5. deploy &#39;public files&#39; to &#39;xxx.github.io&#39; repo...      env:        GH_REF: https://shenbo:${{ secrets.GH_TOKEN }}@github.com/shenbo/shenbo.github.io.git      run: |        git config --global user.name &quot;shenbo&quot;        git config --global user.email &quot;shenbo@hotmail.com&quot;        git clone ${GH_REF} hexo-public        cp -rf public/* hexo-public/                cd hexo-public        git add .        git commit -am &quot;Deployed by GitHub Actions ...&quot;        git push origin master</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前使用 Travis CI 实现了自动生成并发布 Hexo 博客，现在切换到 GitHub Actions&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Tools/Hexo/"/>
    
      <category term="CI" scheme="http://yoursite.com/categories/Tools/CI/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="ci" scheme="http://yoursite.com/tags/ci/"/>
    
      <category term="GitHub Actions" scheme="http://yoursite.com/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>32/64系统支撑库导致 Bear 编译失败</title>
    <link href="http://yoursite.com/2020/01/10/bear-cmake-error/"/>
    <id>http://yoursite.com/2020/01/10/bear-cmake-error/</id>
    <published>2020-01-10T03:27:38.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Bear 生成 <code>compile_commands.json</code> 时需要编译 32位库，记录错误及解决过程</p><a id="more"></a><h2 id="Bear"><a href="#Bear" class="headerlink" title="Bear"></a>Bear</h2><p>编译命令及错误</p><pre><code class="shell">$ cmake .. -DCMAKE_C_COMPILER_ARG1=&quot;-m32&quot;; VERBOSE=1 make all    Linking C executable cmTC_8b292    /usr/local/bin/cmake -E cmake_link_script CMakeFiles/cmTC_8b292.dir/link.txt --verbose=1    /usr/bin/cc -m32      -rdynamic CMakeFiles/cmTC_8b292.dir/testCCompiler.c.o  -o cmTC_8b292    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc    /usr/bin/ld: 找不到 -lgcc    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc    /usr/bin/ld: 找不到 -lgcc</code></pre><p>可以看到原因是找不到 <code>libgcc.a</code></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>系统为 <code>ubuntu18.04</code>，可以找到 <code>/usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a</code>，需要安装32位支持库</p><pre><code class="shell">$ sudo apt-cache search libgcclibgcc1 - GCC 支持库lib32gcc-7-dev - GCC support library (32 bit development files)$ sudo apt install lib32gcc-7-dev$ fd libgcc.agcc/x86_64-linux-gnu/7/32/libgcc.agcc/x86_64-linux-gnu/7/libgcc.a</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Bear 生成 &lt;code&gt;compile_commands.json&lt;/code&gt; 时需要编译 32位库，记录错误及解决过程&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Make" scheme="http://yoursite.com/categories/Tools/Make/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
      <category term="cmake" scheme="http://yoursite.com/tags/cmake/"/>
    
      <category term="make" scheme="http://yoursite.com/tags/make/"/>
    
      <category term="bear" scheme="http://yoursite.com/tags/bear/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 BRE ERE PCRE 区别</title>
    <link href="http://yoursite.com/2019/12/27/regular-expression/"/>
    <id>http://yoursite.com/2019/12/27/regular-expression/</id>
    <published>2019-12-27T06:35:30.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>了解正则表达式标准，各个之间存在一些差异</p><ul><li>BRE (Basic Regular Expressions)</li><li>ERE (Extended Regular Expressions)</li><li>PCRE (Perl Compatible Regular Expressions)</li></ul><a id="more"></a><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><table class="table table-bordered table-striped">  <thead>    <tr><th>What</th><th>Syntax</th><th>Comments/gotchas</th></tr>  </thead>  <tbody id="programs-languages" class="subgroup">    <tr><th colspan="3">Programming languages</th></tr>    <tr><td><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a></td><td>PCRE</td><td>PCRE is actually a separate implementation from Perl's, with <a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions#Differences_from_Perl" target="_blank" rel="noopener">slight differences</a></td></tr>    <tr><td><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code> standard lib</a></td><td>Python's own syntax (Perl-inspired)</td><td></td></tr>    <tr><td><a href="http://ruby-doc.org/core-2.2.0/Regexp.html" target="_blank" rel="noopener">Ruby</a></td><td>Ruby's own syntax (Perl-inspired)</td><td></td></tr>    <tr><td><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">Java's java.util.regex</a></td><td>Almost PCRE</td><td></td></tr>    <tr><td><a href="http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="noopener">Boost.Regex</a></td><td>PCRE</td><td></td></tr>  </tbody>  <tbody id="programs-editors" class="subgroup">    <tr><th colspan="3">Text editors</th></tr>    <tr><td><a href="http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html" target="_blank" rel="noopener">Eclipse</a></td><td>PCRE</td><td></td></tr>    <tr><td>Emacs</td><td>?</td><td></td></tr>    <tr><td>Netbeans</td><td>PCRE</td><td></td></tr>    <tr><td>Notepad++</td><td>PCRE (Boost.Regex)</td><td></td></tr>    <tr><td>PyCharm</td><td>PCRE</td><td>Perl-inspired</td></tr>    <tr><td>Sublime Text</td><td>?</td><td></td></tr>    <tr><td>UltraEdit</td><td>PCRE</td><td></td></tr>    <tr><td>ViM</td><td>ViM</td><td></td></tr>  </tbody>  <tbody id="programs-cmdline" class="subgroup">    <tr><th colspan="3">Command-line tools</th></tr>    <tr><td>awk</td><td>ERE</td><td>might depend on the implementation</td></tr>    <tr><td>grep</td><td>BRE, <code>egrep</code> for ERE, <code>grep -P</code> for PCRE (optional)</td><td></td></tr>    <tr><td>less</td><td>ERE</td><td>usually; man page says "regular expression library supplied by your system"</td></tr>    <tr><td>screen</td><td>plain text</td><td></td></tr>    <tr><td>sed</td><td>BRE, <code>-E</code> switches to ERE</td><td></td></tr>  </tbody></table><h2 id="语法差异"><a href="#语法差异" class="headerlink" title="语法差异"></a>语法差异</h2><table class="table table-bordered table-striped">  <thead>    <tr><th>What</th><th><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a>/PCRE</th><th><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code></a></th><th>POSIX (BRE)</th><th>POSIX extended (ERE)</th><th>ViM</th></tr>  </thead>  <tbody id="syntax-basics" class="subgroup">    <tr><th colspan="6">Basics</th></tr>    <tr><td>Custom character class</td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td></tr>    <tr><td>Negated custom character class</td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td></tr>    <tr><td>\ special in class?</td><td>yes</td><td>yes</td><td>no, <code>]</code> escaped if comes first</td><td>no, <code>]</code> escaped if comes first</td><td>yes</td></tr>    <tr><td>Ranges</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td><code>[a-z]</code>, <code>-</code> escaped if first or last</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td></td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td></tr>    <tr><td>Alternation</td><td><code>|</code></td><td><code>|</code></td><td><code>\|</code></td><td><code>|</code></td><td><code>\|</code> <code>\&amp;</code> (low precedence)</td></tr>    <tr><td>Escaped character</td><td><code>\033</code> <code>\x1B</code> <code>\x{1234}</code> <code>\N{name}</code> <code>\N{U+263D}</code></td><td><code>\x12</code></td><td class="na"></td><td class="na"></td><td><code>\%d123</code> <code>\%x2A</code> <code>\%u1234</code> <code>\%U1234ABCD</code></td></tr>  </tbody>  <tbody id="syntax-characters" class="subgroup">    <tr><th colspan="6">Character classes</th></tr>    <tr><td>Any character (except newline)</td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td></tr>    <tr><td>Any character (including newline)</td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\_.</code></td></tr>    <tr><td>Match a "word" character (alphanumeric plus <code>_</code>)</td><td><code>\w</code> <code>[[:word:]]</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td></tr>    <tr><td>Case</td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td class="na"></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>\u</code> <code>[[:upper:]]</code> / <code>\l</code> <code>[[:lower:]]</code></td></tr>    <tr><td>Match a non-"word" character</td><td><code>\W</code></td><td><code>\W</code></td><td class="na"></td><td class="na"></td><td><code>\W</code></td></tr>    <tr><td>Match a whitespace character (except newline)</td><td class="na"></td><td class="na"></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td></tr>    <tr><td>Whitespace including newline</td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code></td><td class="na"></td><td class="na"></td><td><code>\_s</code></td></tr>    <tr><td>Match a non-whitespace character</td><td><code>\S</code></td><td><code>\S</code></td><td><code>[^[:space:]]</code></td><td><code>[^[:space:]]</code></td><td><code>\S</code> <code>[^[:space:]]</code></td></tr>    <tr><td>Match a digit character</td><td><code>\d</code> <code>[[:digit:]]</code></td><td><code>\d</code></td><td><code>[[:digit:]]</code></td><td><code>[[:digit:]]</code></td><td><code>\d</code> <code>[[:digit:]]</code></td></tr>    <tr><td>Match a non-digit character</td><td><code>\D</code></td><td><code>\D</code></td><td><code>[^[:digit:]]</code></td><td><code>[^[:digit:]]</code></td><td><code>\D</code> <code>[^[:digit:]]</code></td></tr>    <tr><td>Any hexadecimal digit</td><td><code>[[:xdigit:]]</code></td><td class="na"></td><td><code>[[:xdigit:]]</code></td><td><code>[[:xdigit:]]</code></td><td><code>\x</code> <code>[[:xdigit:]]</code></td></tr>    <tr><td>Any octal digit</td><td></td><td class="na"></td><td></td><td></td><td><code>\o</code></td></tr>    <tr><td>Any graphical character excluding "word" characters</td><td><code>[[:punct:]]</code></td><td class="na"></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td></tr>    <tr><td>Any alphabetical character</td><td><code>[[:alpha:]]</code></td><td class="na"></td><td><code>[[:alpha:]]</code></td><td><code>[[:alpha:]]</code></td><td><code>\a</code> <code>[[:alpha:]]</code></td></tr>    <tr><td>Non-alphabetical character</td><td></td><td class="na"></td><td><code>[^[:alpha:]]</code></td><td><code>[^[:alpha:]]</code></td><td><code>\A</code> <code>[^[:alpha:]]</code></td></tr>    <tr><td>Any alphanumerical character</td><td><code>[[:alnum:]]</code></td><td class="na"></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td></tr>    <tr><td>ASCII</td><td><code>[[:ascii:]]</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>Character equivalents (e = é = è) (as per locale)</td><td></td><td class="na"></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td></tr>  </tbody>  <tbody id="syntax-assert" class="subgroup">    <tr><th colspan="6">Zero-width assertions</th></tr>    <tr><td>Word boundary</td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\&lt;</code> / <code>\&gt;</code></td></tr>    <tr><td>Anywhere but word boundary</td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td class="na"></td></tr>    <tr><td>Beginning of line/string</td><td><code>^</code> / <code>\A</code></td><td><code>^</code> / <code>\A</code></td><td><code>^</code></td><td><code>^</code></td><td><code>^</code> (beginning of pattern ) <code>\_^</code></td></tr>    <tr><td>End of line/string</td><td><code>$</code> / <code>\Z</code></td><td><code>$</code> / <code>\Z</code></td><td><code>$</code></td><td><code>$</code></td><td><code>$</code> (end of pattern) <code>\_$</code></td></tr>  </tbody>  <tbody id="syntax-groups" class="subgroup">    <tr><th colspan="6">Captures and groups</th></tr>    <tr><td>Capturing group</td><td><code>(...)</code> <code>(?&lt;name&gt;...)</code></td><td><code>(...)</code> <code>(?P&lt;name&gt;...)</code></td><td><code>\(...\)</code></td><td><code>(...)</code></td><td><code>\(...\)</code></td></tr>    <tr><td>Non-capturing group</td><td><code>(?:...)</code></td><td><code>(?:...)</code></td><td class="na"></td><td class="na"></td><td><code>\%(...\)</code></td></tr>    <tr><td>Backreference to a specific group.</td><td><code>\1</code> <code>\g1</code> <code>\g{-1}</code></td><td><code>\1</code></td><td><code>\1</code></td><td><code>\1</code> non-official</td><td><code>\1</code></td></tr>    <tr><td>Named backreference</td><td><code>\g{name}</code> <code>\k&lt;name&gt;</code></td><td><code>(?P=name)</code></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>  </tbody>  <tbody id="syntax-lookaround" class="subgroup">    <tr><th colspan="6">Look-around</th></tr>    <tr><td>Positive look-ahead</td><td><code>(?=...)</code></td><td><code>(?=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@=</code></td></tr>    <tr><td>Negative look-ahead</td><td><code>(?!...)</code></td><td><code>(?!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@!</code></td></tr>    <tr><td>Positive look-behind</td><td><code>(?&lt;=...)</code></td><td><code>(?&lt;=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;=</code></td></tr>    <tr><td>Negative look-behind</td><td><code>(?&lt;!...)</code></td><td><code>(?&lt;!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;!</code></td></tr>  </tbody>  <tbody id="syntax-multiplicity" class="subgroup">    <tr><th colspan="6">Multiplicity</th></tr>    <tr><td>0 or 1</td><td><code>?</code></td><td><code>?</code></td><td><code>\?</code></td><td><code>?</code></td><td><code>\?</code></td></tr>    <tr><td>0 or more</td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td></tr>    <tr><td>1 or more</td><td><code>+</code></td><td><code>+</code></td><td><code>\+</code></td><td><code>+</code></td><td><code>\+</code></td></tr>    <tr><td>Specific number</td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n\}</code> <code>\{n,m\}</code> <code>\{n,\}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n}</code> <code>\{n,m}</code> <code>\{n,}</code></td></tr>    <tr><td>0 or 1, non-greedy</td><td><code>??</code></td><td><code>??</code></td><td class="na"></td><td class="na"></td><td></td></tr>    <tr><td>0 or more, non-greedy</td><td><code>*?</code></td><td><code>*?</code></td><td class="na"></td><td class="na"></td><td><code>\{-}</code></td></tr>    <tr><td>1 or more, non-greedy</td><td><code>+?</code></td><td><code>+?</code></td><td class="na"></td><td class="na"></td><td></td></tr>    <tr><td>Specific number, non-greedy</td><td><code>{n,m}?</code> <code>{n,}?</code></td><td><code>{n,m}?</code> <code>{n,}?</code></td><td class="na"></td><td class="na"></td><td><code>\{-n,m}</code> <code>\{-n,}</code></td></tr>    <tr><td>0 or 1, don't give back on backtrack</td><td><code>?+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>0 or more, don't give back on backtrack</td><td><code>*+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>1 or more, don't give back on backtrack</td><td><code>++</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>Specific number, don't give back on backtrack</td><td><code>{n,m}+</code> <code>{n,}+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>  </tbody>  <tbody id="syntax-other" class="subgroup">    <tr><th colspan="6">Other</th></tr>    <tr><td>Independent non-backtracking pattern</td><td><code>(?&gt;...)</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&gt;</code></td></tr>    <tr><td>Make case-sensitive/insensitive</td><td><code>(?i)</code> / <code>(?-i)</code></td><td><code>(?i)</code> / <code>(?-i)</code></td><td class="na"></td><td class="na"></td><td><code>\c</code> / <code>\C</code></td></tr>  </tbody></table><p>BRE ERE 需要注意 <code>()</code> <code>{}</code> 的区别，另外都不支持 <code>\d\D</code></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://liujiacai.net/blog/2014/12/07/regexp-favors/" target="_blank" rel="noopener">正则表达式“派别”简述</a></li><li><a href="https://en.wikipedia.org/wiki/Regular_expression#Character_classes" target="_blank" rel="noopener">Regular expression</a></li><li><a href="https://blog.csdn.net/yufenghyc/article/details/51078107" target="_blank" rel="noopener">grep中使用”\d”匹配数字不成功的原因</a></li><li><a href="https://remram44.github.io/regex-cheatsheet/regex.html" target="_blank" rel="noopener">Regex cheatsheet</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解正则表达式标准，各个之间存在一些差异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BRE (Basic Regular Expressions)&lt;/li&gt;
&lt;li&gt;ERE (Extended Regular Expressions)&lt;/li&gt;
&lt;li&gt;PCRE (Perl Compatible Regular Expressions)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="RE" scheme="http://yoursite.com/categories/Tools/RE/"/>
    
    
      <category term="grep" scheme="http://yoursite.com/tags/grep/"/>
    
      <category term="sed" scheme="http://yoursite.com/tags/sed/"/>
    
      <category term="awk" scheme="http://yoursite.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Doxygen 注释语法</title>
    <link href="http://yoursite.com/2019/12/27/doxygen-syntax/"/>
    <id>http://yoursite.com/2019/12/27/doxygen-syntax/</id>
    <published>2019-12-27T02:20:07.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Doxygen 来生成文档需要遵从的注释语法</p><a id="more"></a><h2 id="开源工程"><a href="#开源工程" class="headerlink" title="开源工程"></a>开源工程</h2><p>可以搜索参考用法</p><ul><li><a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></li><li><a href="https://github.com/LiamBindle/MQTT-C.git" target="_blank" rel="noopener">MQTT</a></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释块<pre><code>/*** comment text here*/int x = 0;</code></pre></li><li>行尾注释<pre><code>int x = 0; ///&lt; comment text here</code></pre></li><li>单行注释<pre><code>/// comment text hereint x = 0;</code></pre></li></ul><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>注释块中可以使用一些特殊的标记，比如 <code>brief</code> 标记，官方称为 <code>Special Commands</code></p><ul><li><a href="http://www.doxygen.nl/manual/commands.html" target="_blank" rel="noopener">Special Commands</a></li><li><a href="https://www.cnblogs.com/benhuan/p/3302114.html" target="_blank" rel="noopener">翻译</a></li></ul><p>例如</p><ul><li><code>\struct &lt;name&gt; [&lt;header-file&gt;] [&lt;header-name&gt;]</code></li><li><code>\typedef (typedef declaration)</code></li><li><code>\brief { brief description }</code></li></ul><p>标记可以有两种书写方式 <code>\param</code> 或者 <code>@param</code>，每个命令有一个或多个参数，每个参数都有明确的范围：</p><ul><li><code>&lt;&gt;</code> 参数是一个单独单词</li><li><code>()</code> 参数一直到命令所在的结束</li><li><code>[]</code> 参数是可选的</li><li><code>{}</code> 参数一直延伸到本段结束。一个段落的结束以一个空行来标识，或者是一个段落标记</li></ul><h2 id="常用标记"><a href="#常用标记" class="headerlink" title="常用标记"></a>常用标记</h2><ul><li><code>\brief { brief description }</code> 可以省略</li><li><code>\param &#39;[&#39;dir&#39;]&#39; &lt;parameter-name&gt; { parameter description }</code><pre><code>/*** @param[out] dest The memory area to copy to.* @param[in]  src  The memory area to copy from.* @param[in]  n    The number of bytes to copy*/void memcpy(void *dest, const void *src, size_t n);</code></pre></li><li><code>\return { description of the return value }</code> 返回说明</li><li><code>\retval &lt;return value&gt; { description }</code> 返回值</li><li><code>\ref &lt;name&gt; [&quot;(text)&quot;]</code> 引用<pre><code>/*** @return 程序执行成功与否*     @retval 0 程序执行成功*     @retval 1 程序执行失败* @note 这里只是一个简单的例子*/int main(int argc, char* argv[])</code></pre></li><li><code>\note { text }</code> 标注需要特别注意的地方</li><li><code>\deprecated { description }</code></li><li><code>\warning { warning message }</code> 接口容易出错的地方</li><li><code>\sa { references }</code> <code>\see { references }</code></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Example <a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></p><pre><code>*** Initialize the AVCodecContext to use the given AVCodec. Prior to using this* function the context has to be allocated with avcodec_alloc_context3().** The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),* avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for* retrieving a codec.** @warning This function is not thread safe!** @note Always call this function before using decoding routines (such as* @ref avcodec_receive_frame()).** @code* avcodec_register_all();* av_dict_set(&amp;opts, &quot;b&quot;, &quot;2.5M&quot;, 0);* codec = avcodec_find_decoder(AV_CODEC_ID_H264);* if (!codec)*     exit(1);** context = avcodec_alloc_context3(codec);** if (avcodec_open2(context, codec, opts) &lt; 0)*     exit(1);* @endcode** @param avctx The context to initialize.* @param codec The codec to open this context for. If a non-NULL codec has been*              previously passed to avcodec_alloc_context3() or*              for this context, then this parameter MUST be either NULL or*              equal to the previously passed codec.* @param options A dictionary filled with AVCodecContext and codec-private options.*                On return this object will be filled with options that were not found.** @return zero on success, a negative value on error* @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),*      av_dict_set(), av_opt_find().*/</code></pre><p>注释 <code>struct</code></p><pre><code>/** * @struct AC3HeaderInfo * Coded AC-3 header values up to the lfeon element, plus derived values. */typedef struct AC3HeaderInfo {    /** @name Coded elements     * @{     */    uint16_t sync_word;    uint16_t crc1;    uint8_t sr_code;    uint8_t bitstream_id;    uint8_t bitstream_mode;    uint8_t channel_mode;    uint8_t lfe_on;    uint8_t frame_type;    int substreamid;                        ///&lt; substream identification    int center_mix_level;                   ///&lt; Center mix level index    int surround_mix_level;                 ///&lt; Surround mix level index    uint16_t channel_map;    int num_blocks;                         ///&lt; number of audio blocks    int dolby_surround_mode;    /** @} */    /** @name Derived values     * @{     */    uint8_t sr_shift;    uint16_t sample_rate;    uint32_t bit_rate;    uint8_t channels;    uint16_t frame_size;    uint64_t channel_layout;    /** @} */} AC3HeaderInfo;/** * @brief Example class的简易说明 * * 本范例说明Example class。 * 这是一个极为简单的范例。 * */class Example {    private:        int var1 ; ///&lt; 这是一个private的变数    public:        int var2 ; ///&lt; 这是一个public的变数成员。        int var3 ; ///&lt; 这是另一个public的变数成员。        void ExFunc1(void);        int ExFunc2(int a, char b);        char *ExFunc3(char *c) ;};</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="http://blog.guorongfei.com/2016/11/20/doxygen-usage/" target="_blank" rel="noopener">使用 Doxygen 生成文档注释</a></li><li><a href="http://www.doxygen.nl/manual/index.html" target="_blank" rel="noopener">Doxygen Manual</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Doxygen 来生成文档需要遵从的注释语法&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Doxygen" scheme="http://yoursite.com/categories/Tools/Doxygen/"/>
    
    
      <category term="doxygen" scheme="http://yoursite.com/tags/doxygen/"/>
    
  </entry>
  
  <entry>
    <title>使用 LSP 搭建代码补全环境</title>
    <link href="http://yoursite.com/2019/12/25/vim-lsp/"/>
    <id>http://yoursite.com/2019/12/25/vim-lsp/</id>
    <published>2019-12-25T02:07:51.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>Language Server Protocol (LSP) 用于架接编辑器与具体语言，实现各种功能。</p><a id="more"></a><h2 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h2><p><a href="https://zhuanlan.zhihu.com/p/37290578" target="_blank" rel="noopener">Vim 8 中 C/C++ 符号索引：LSP 篇</a></p><p>LSP 是一套通信协议，遵从 LSP 规范的客户端（各种编辑器/IDE）可以通过众多 LSP 服务端按协议标准进行通信，由客户端完成用户界面相关的事情，由服务端提编程语言相关的：补全，定义引用查找，诊断，帮助文档，重构等服务。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">coc.nvim</a><br><a href="https://segmentfault.com/a/1190000017785227" target="_blank" rel="noopener">Vim的新一代补全插件：coc.nvim</a></p><p>使用 <code>vim-plug</code> 安装</p><pre><code class="vim">&quot; Use release branch (Recommend)Plug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>执行 <code>:CocConfig</code> 生成配置文件 <code>~/.vim/coc-settings.json</code></p><p>例如</p><pre><code>&quot;diagnostic.enable&quot;:        Set to false to disable diagnostic display,  default: true</code></pre><p>在 <code>coc-settings.json</code> 中添加</p><pre><code class="json">&quot;diagnostic.enable&quot;: false,</code></pre><h2 id="安装内置插件"><a href="#安装内置插件" class="headerlink" title="安装内置插件"></a>安装内置插件</h2><p><a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions" target="_blank" rel="noopener">内置插件支持列表</a><br><a href="https://github.com/fannheyward/coc-marketplace" target="_blank" rel="noopener">coc-marketplace</a><br><a href="https://www.npmjs.com/search?q=keywords%3Acoc.nvim" target="_blank" rel="noopener">coc.nvim on npm</a></p><p>例如：</p><ul><li>coc-json for <code>json</code>.</li><li>coc-tsserver for <code>javascript</code> and <code>typescript</code>.</li><li>coc-html for <code>html</code>, <code>handlebars</code> and <code>razor</code>.</li><li>coc-css for <code>css</code>, <code>scss</code> and <code>less</code>.</li><li>coc-ember for ember projects.</li><li>coc-vetur for <code>vue</code>, use vetur.</li><li>coc-phpls for <code>php</code>, use intelephense-docs.</li><li>coc-java for <code>java</code>, use eclipse.jdt.ls.</li></ul><p>使用 <code>:CocInstall coc-xxx</code> 安装，位于 <code>/.config/coc/extensions/node_modules</code>，配置文件 <code>coc-settings.json</code></p><p>例如 <code>coc-python</code> 需要忽略特定错误，查看 <a href="https://github.com/neoclide/coc-python" target="_blank" rel="noopener">配置</a> 添加如下内容</p><pre><code class="json">&quot;python.linting.flake8Args&quot;: [&quot;--ignore=E501&quot;]</code></pre><h2 id="安装-LSP"><a href="#安装-LSP" class="headerlink" title="安装 LSP"></a>安装 LSP</h2><p><a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers" target="_blank" rel="noopener">Language servers</a></p><p>支持多种 LSP，例如：</p><ul><li>Python</li><li>C/C++</li><li>Lua</li></ul><p>选择 <a href="https://github.com/MaskRay/ccls" target="_blank" rel="noopener">ccls</a> 作为 C LSP</p><p>编译安装如下</p><pre><code class="shell">$ git clone --depth=1 --recursive https://github.com/MaskRay/ccls$ wget -c http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz$ tar xf clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz$ cd ccls$ cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=$PWD/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04$ cmake --build Release</code></pre><p>在 <code>coc-settings.json</code> 中添加配置</p><pre><code class="json">&quot;ccls&quot;: {                                                                     &quot;command&quot;: &quot;~/.vim/ccls/ccls/Release/ccls&quot;,                    &quot;filetypes&quot;: [&quot;c&quot;, &quot;cpp&quot;, &quot;objc&quot;, &quot;objcpp&quot;],                              &quot;rootPatterns&quot;: [&quot;.ccls&quot;, &quot;compile_commands.json&quot;, &quot;.vim/&quot;, &quot;.git/&quot;, &quot;.hg/&quot;],      &quot;initializationOptions&quot;: {                                                    &quot;cache&quot;: {                                                                    &quot;directory&quot;: &quot;/tmp/ccls&quot;                                              }                                                                     }                                                                     }</code></pre><p><code>ccls</code> 运行依赖于 <code>compile_commands.json</code>，使用 <code>Bear</code> 生成此文件</p><pre><code class="shell">$ Bear make</code></pre><h2 id="vimrc-配置"><a href="#vimrc-配置" class="headerlink" title=".vimrc 配置"></a>.vimrc 配置</h2><p><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">Example vim configuration</a><br><a href="https://github.com/MaskRay/ccls/wiki/coc.nvim" target="_blank" rel="noopener">ccls coc.nvim配置</a></p><pre><code class="vim">nmap &lt;silent&gt; &lt;M-j&gt; &lt;Plug&gt;(coc-definition)nmap &lt;silent&gt; &lt;C-,&gt; &lt;Plug&gt;(coc-references)nn &lt;silent&gt; K :call CocActionAsync(&#39;doHover&#39;)&lt;cr&gt;&quot; basesnn &lt;silent&gt; xb :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;)&lt;cr&gt;&quot; bases of up to 3 levelsnn &lt;silent&gt; xB :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;levels&#39;:3})&lt;cr&gt;&quot; derivednn &lt;silent&gt; xd :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;derived&#39;:v:true})&lt;cr&gt;&quot; derived of up to 3 levelsnn &lt;silent&gt; xD :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;derived&#39;:v:true,&#39;levels&#39;:3})&lt;cr&gt;&quot; callernn &lt;silent&gt; xc :call CocLocations(&#39;ccls&#39;,&#39;$ccls/call&#39;)&lt;cr&gt;&quot; calleenn &lt;silent&gt; xC :call CocLocations(&#39;ccls&#39;,&#39;$ccls/call&#39;,{&#39;callee&#39;:v:true})&lt;cr&gt;&quot; $ccls/member&quot; member variables / variables in a namespacenn &lt;silent&gt; xm :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;)&lt;cr&gt;&quot; member functions / functions in a namespacenn &lt;silent&gt; xf :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;,{&#39;kind&#39;:3})&lt;cr&gt;&quot; nested classes / types in a namespacenn &lt;silent&gt; xs :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;,{&#39;kind&#39;:2})&lt;cr&gt;nmap &lt;silent&gt; xt &lt;Plug&gt;(coc-type-definition)&lt;cr&gt;nn &lt;silent&gt; xv :call CocLocations(&#39;ccls&#39;,&#39;$ccls/vars&#39;)&lt;cr&gt;nn &lt;silent&gt; xV :call CocLocations(&#39;ccls&#39;,&#39;$ccls/vars&#39;,{&#39;kind&#39;:1})&lt;cr&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Language Server Protocol (LSP) 用于架接编辑器与具体语言，实现各种功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Editor" scheme="http://yoursite.com/categories/Tools/Editor/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
      <category term="lsp" scheme="http://yoursite.com/tags/lsp/"/>
    
      <category term="completion" scheme="http://yoursite.com/tags/completion/"/>
    
  </entry>
  
  <entry>
    <title>指定运行时动态库位置</title>
    <link href="http://yoursite.com/2019/12/19/gcc-run-path/"/>
    <id>http://yoursite.com/2019/12/19/gcc-run-path/</id>
    <published>2019-12-19T08:39:27.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>指定运行时动态库路径</p><ul><li>gcc参数指定 <code>-Wl,-rpath=${LD_PATH}</code></li><li>设置环境变量 <code>export LD_LIBRARY_PATH=${LD_PATH}</code></li><li>配置文件 <code>/etc/ld.so.conf</code></li></ul><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>编译 <code>mosquitto</code> 得到几个可执行文件，运行时出现错误</p><pre><code class="shell">$ ./mosquitto_sub --help./mosquitto_sub: error while loading shared libraries: libmosquitto.so.1: cannot open shared object file: No such file or directory$ ldd mosquitto_sub    linux-vdso.so.1 (0x00007fffe178b000)    libmosquitto.so.1 =&gt; not found    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc8c9ca5000)    /lib64/ld-linux-x86-64.so.2 (0x00007fc8ca2a3000)</code></pre><p>找不到 <code>libmosquitto.so.1</code>， 需要指定路径</p><h2 id="GCC参数"><a href="#GCC参数" class="headerlink" title="GCC参数"></a>GCC参数</h2><pre><code class="shell">-Wl,-rpath=${LD_PATH}</code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre><code class="shell">$ export LD_LIBRARY_PATH=../lib$ ldd mosquitto_sub    linux-vdso.so.1 (0x00007ffd3410b000)    libmosquitto.so.1 =&gt; ../lib/libmosquitto.so.1 (0x00007f4ecc2d5000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4ecbee4000)    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f4ecbcdc000)    libssl.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007f4ecba74000)    libcrypto.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007f4ecb631000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f4ecb412000)    /lib64/ld-linux-x86-64.so.2 (0x00007f4ecc6fb000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4ecb20e000)</code></pre><p>只在当前 shell 有效</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>修改 <code>/etc/ld.so.conf</code> 文件以添加私有路径</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指定运行时动态库路径&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc参数指定 &lt;code&gt;-Wl,-rpath=${LD_PATH}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置环境变量 &lt;code&gt;export LD_LIBRARY_PATH=${LD_PATH}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置文件 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Linker" scheme="http://yoursite.com/categories/C/Linker/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
    
      <category term="shared" scheme="http://yoursite.com/tags/shared/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 静态模板使用</title>
    <link href="http://yoursite.com/2019/12/18/makefile-static-pattern-rule/"/>
    <id>http://yoursite.com/2019/12/18/makefile-static-pattern-rule/</id>
    <published>2019-12-18T09:28:15.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>Makefile 静态模板的使用</p><pre><code class="makefile">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;    &lt;commands&gt;</code></pre><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code class="shell">$ tree -L 2.├── dirA│   ├── dirA_1.c│   ├── dirA_2.c│   └── include├── makefile├── output│   └── objects└── dirB    ├── include    └── dirB.c</code></pre><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><pre><code class="makefile">SRC = $(shell find . -iname &quot;*.c&quot;)SRC = $(wildcard dirA/*.c) \      $(wildcard dirB/*.c)</code></pre><p>Makefile 规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数 <code>wildcard</code></p><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><pre><code class="makefile">OBJ = $(SRC:.c=.o)OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))</code></pre><ul><li><code>OBJ = $(SRC:.c=.o)</code> 这个表示 <code>.obj</code> 与 <code>.c</code> 位于同一个目录下</li><li><code>OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))</code> <code>.obj</code> 统一放到 <code>$(objects_dir)</code> 目录下</li></ul><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><pre><code class="makefile">SUBDIR = dirASUBDIR += dirBCFLAGS += $(patsubst %, -I%, $(SUBDIR))</code></pre><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="静态模板"><a href="#静态模板" class="headerlink" title="静态模板"></a>静态模板</h3><pre><code class="makefile">SRC = $(wildcard dirA/*.c) \      $(wildcard dirB/*.c)OBJ = $(SRC:.c=.o)$(TARGET): $(OBJ)    @echo &quot;Generating new lib\033[1;31m: $@\033[0m&quot;    @$(AR) -rcs $@ $^$(OBJ): %.o: %.c    @echo &quot;compiling \033[032m[$(CC)]\033[0m&quot;: $&lt;    @$(CC) -c $(CFLAGS) $&lt; -o $@</code></pre><h3 id="obj-文件制定路径"><a href="#obj-文件制定路径" class="headerlink" title="obj 文件制定路径"></a>obj 文件制定路径</h3><pre><code class="makefile">SRC = $(wildcard dirA/*.c) \      $(wildcard dirB/*.c)OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))$(TARGET): $(OBJ)    @echo &quot;Generating new lib\033[1;31m: $@\033[0m&quot;    @$(AR) -rcs $@ $^$(objects_dir)/%.o: %.c dirmake    @echo &quot;compiling \033[032m[$(CC)]\033[0m&quot;: $&lt;    @$(CC) -c $(CFLAGS) $&lt; -o $@</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://seisman.github.io/how-to-write-makefile/rules.html#id8" target="_blank" rel="noopener">静态模式</a></li><li><a href="https://seisman.github.io/how-to-write-makefile/rules.html#id3" target="_blank" rel="noopener">规则的语法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Makefile 静态模板的使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;&amp;lt;targets ...&amp;gt; : &amp;lt;target-pattern&amp;gt; : &amp;lt;prereq-patterns ...&amp;gt;
    &amp;lt;commands&amp;gt;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Make" scheme="http://yoursite.com/categories/Tools/Make/"/>
    
      <category term="Makefile" scheme="http://yoursite.com/categories/C/Makefile/"/>
    
    
      <category term="makefile" scheme="http://yoursite.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>Linker 及 ld 脚本分析</title>
    <link href="http://yoursite.com/2019/12/11/linker-and-lds-file/"/>
    <id>http://yoursite.com/2019/12/11/linker-and-lds-file/</id>
    <published>2019-12-11T06:41:04.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>链接器工作过程及链接脚本文件 <code>.lds</code> 分析</p><a id="more"></a><h2 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h2><p>链接器将多目标文件生成最终可执行文件，示意图如下</p><p><img src="/images/gnu/linker.png" alt="Linker Role"></p><p>在链接过程中执行如下操作</p><ol><li>Symbol Resolution - 符号解析<ul><li>多文件声明与调用</li><li>调用替换为具体函数入口</li></ul></li><li>Relocation - 重定位<ul><li>相同段合并，例如 <code>.text</code></li><li>Section Placement, 各段在内存中的位置</li></ul></li></ol><p>详细解释见 <a href="https://www.bravegnu.org/gnu-eprog/linker.html" target="_blank" rel="noopener">Linker</a></p><h2 id="Linker-Script-File"><a href="#Linker-Script-File" class="headerlink" title="Linker Script File"></a>Linker Script File</h2><p>控制链接器行为的脚本文件，一般后缀为 <code>.lds</code>。如果不指定，存在默认脚本，使用 <code>ld --verbose</code> 查看</p><p><a href="https://www.bravegnu.org/gnu-eprog/lds.html" target="_blank" rel="noopener">Linker Script File</a></p><pre><code class="lds">SECTIONS { ❶        . = 0x00000000; ❷        .text : { ❸                abc.o (.text);                def.o (.text);        }}</code></pre><ol><li><code>SECTIONS</code> 脚本各段组成及位置</li><li><code>.</code> 定位器符号</li><li><code>.text</code> 由 <code>abc.o</code> 和 <code>def.o</code> 中的 <code>.text</code> 组成</li></ol><h2 id="LMA-vs-VMA"><a href="#LMA-vs-VMA" class="headerlink" title="LMA vs VMA"></a>LMA vs VMA</h2><ul><li><code>LMA</code> (load memory address 加载内存地址或进程地址空间地址）</li><li><code>VMA</code> (virtual memory address 虚拟内存地址或程序地址空间地址）</li></ul><blockquote><p>VMA 是执行输出文件时 section 所在的地址，而 LMA 是加载输出文件时 section 所在的地址。一般而言，某 section 的 VMA == LMA. 但在嵌入式系统中，经常存在加载地址和执行地址不同的情况：比如将输出文件加载到开发板的 flash 中（由 LMA 指定）, 而在运行时将位于 flash 中的输出文件复制到 SDRAM 中（由 VMA 指定）。</p></blockquote><h2 id="SECTIONS-命令"><a href="#SECTIONS-命令" class="headerlink" title="SECTIONS 命令"></a>SECTIONS 命令</h2><p><code>SECTIONS</code> 命令告诉 ld 如何把输入文件的 sections 映射到输出文件的各个 section: 如何将输入 section 合为输出 section; 如何把输出 section 放入 VMA 和 LMA</p><pre><code>SECTIONS{    SECTIONS-COMMAND    SECTIONS-COMMAND    ...}</code></pre><p>SECTION-COMMAND 有四种：</p><ol><li>ENTRY 命令</li><li>符号赋值语句</li><li>一个输出 section 的描述 (output section description)</li><li>一个 section 叠加描述 (overlay description)</li></ol><h3 id="ENTRY-命令"><a href="#ENTRY-命令" class="headerlink" title="ENTRY 命令"></a>ENTRY 命令</h3><p>将符号 <code>SYMBOL</code> 的值设置成入口地址</p><pre><code>ENTRY(SYMBOL)</code></pre><h3 id="符号赋值"><a href="#符号赋值" class="headerlink" title="符号赋值"></a>符号赋值</h3><ul><li>对符号的赋值只对全局变量起作用</li><li>赋值语句包含 4 个语法元素：符号名、操作符、表达式、分号；一个也不能少</li><li><code>.</code> 是一个特殊的符号，它是定位器，一个位置指针，指向程序地址空间内的某位置。该符号只能在 SECTIONS 命令内使用</li></ul><h3 id="叠加描述"><a href="#叠加描述" class="headerlink" title="叠加描述"></a>叠加描述</h3><p>覆盖图描述使两个或多个不同的 section 占用同一块程序地址空间。覆盖图管理代码负责将 section 的拷入和拷出。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>格式如下</p><pre><code>SECTION-NAME [ADDRESS] [(TYPE)] : [AT(LMA)]{    OUTPUT-SECTION-COMMAND    OUTPUT-SECTION-COMMAND    …} [&gt;REGION] [AT&gt;LMA_REGION] [:PHDR HDR ...] [=FILLEXP]</code></pre><ul><li><code>ALIGN</code> 地址对齐</li><li>文件通配符</li><li><code>.</code> 定位符</li><li><code>KEEP</code></li><li><code>AT</code> 修改 LMA</li><li><code>&gt;REGION</code> 修改 VMA</li></ul><h2 id="MEMORY-命令"><a href="#MEMORY-命令" class="headerlink" title="MEMORY 命令"></a>MEMORY 命令</h2><p>在默认情形下，连接器可以为 section 在程序地址空间内分配任意位置的存储区域。并通过输出 section 描述的 <code>&gt;REGION</code> 属性显示地将该输出 section 限定于在程序地址空间内的某块存储区域，当存储区域大小不能满足要求时，连接器会报告该错误。</p><pre><code>MEMORY{    NAME1 [(ATTR)] : ORIGIN = ORIGIN1, LENGTH = LEN2    NAME2 [(ATTR)] : ORIGIN = ORIGIN2, LENGTH = LEN2    ...}</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="lds">MEMORY{    sram  :   ORIGIN = 0x00100000,    LENGTH = 0x8000    ddram :   ORIGIN = 0x80000000,    LENGTH = 0x100000}ENTRY(ResetEntry)SECTIONS {    . = ALIGN(4);    .text :    {        sram/*(.text*)        sram/*(.data*)        sram/*(.rodata*)        *(.reset_patch)        *(.sram_text)        *(.sram)    } &gt; sram    . = ALIGN(0x8000);    .data :    {        *(.text*)        . = ALIGN(4);        *(.data*)        *(.rodata*)        . = ALIGN(16);    } &gt; ddram    . = ALIGN(4);    .bss :    {        . = ALIGN(4);        __bss_start__ = .;        *(.bss*)        *(COMMON)        . = ALIGN(4);        __bss_end__ = .;    } &gt; ddram}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://www.cnblogs.com/li-hao/p/4107964.html" target="_blank" rel="noopener">Linux 下的 lds 链接脚本详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接器工作过程及链接脚本文件 &lt;code&gt;.lds&lt;/code&gt; 分析&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Linker" scheme="http://yoursite.com/categories/C/Linker/"/>
    
    
      <category term="ld" scheme="http://yoursite.com/tags/ld/"/>
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="lds" scheme="http://yoursite.com/tags/lds/"/>
    
      <category term="linker" scheme="http://yoursite.com/tags/linker/"/>
    
  </entry>
  
  <entry>
    <title>objdump 解析目标文件各个段</title>
    <link href="http://yoursite.com/2019/12/10/nm-code-segment/"/>
    <id>http://yoursite.com/2019/12/10/nm-code-segment/</id>
    <published>2019-12-10T05:32:47.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>目标文件 <code>.o</code> 中 <code>text</code>、 <code>bss</code>、 <code>data</code> 和 <code>rodata</code> 区别和联系</p><a id="more"></a><p>目标文件只是ELF文件的<strong>可重定位文件(Relocatable file)</strong>，常用分析ELF文件工具如下</p><ol><li>objdump</li><li>readelf</li><li>nm</li></ol><h2 id="text"><a href="#text" class="headerlink" title=".text"></a>.text</h2><p>代码段，也有可能包含一些只读的常数变量，例如字符串常量等。只读。</p><h2 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h2><p>没有初始化的和初始化为0的全局变量和静态变量，并不给该段的数据分配空间，只是记录数据所需空间的大小，运行时在栈上分配。</p><h2 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h2><p>已初始化非0全局变量和静态变量，需要分配空间用于存储数据。</p><h2 id="rodata"><a href="#rodata" class="headerlink" title=".rodata"></a>.rodata</h2><p><code>ro</code> 表示为只读数据段，存放C中的字符串和常量，优化后会只存储一份。常量并不一定在此段，有可能存放在代码段。</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre><code class="c">static int x1 = 0;static int x2 = 1234;int main(){    return 0;}</code></pre><p>使用 <code>objdump -x -s -d a.out</code> 查找如下</p><pre><code>00000000006bb330 l     O .bss   0000000000000004 x100000000006b90f0 l     O .data  0000000000000004 x2.Contents of section .data: 6b90e0 00000000 00000000 00000000 00000000  ................ 6b90f0 34120000 00000000 00080000 00000000  4...............</code></pre><p><code>x1</code> 放入 <code>.bss</code> 段；<code>x2</code> 放入 <code>.data</code> 段。</p><h2 id="nm-vs-objdump"><a href="#nm-vs-objdump" class="headerlink" title="nm vs objdump"></a>nm vs objdump</h2><p><code>nm</code> 与 <code>objdump</code> 标志不统一，需要注意区分</p><h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h3><a href="/2015/04/05/nm-symbols/" title="nm symbols 类型及程序组成">nm symbols 类型及程序组成</a><p>查看详细信息 <code>man nm</code></p><h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>查看详细信息 <code>man objdump</code></p><ul><li><code>l</code> local</li><li><code>g</code> global</li><li><code>u</code> unique global</li><li><code>!</code> both global and local</li><li><code>w</code> weak</li><li><code>C</code> The symbol denotes a constructor</li><li><code>W</code> warning</li><li><code>I</code> The symbol is an indirect reference to another symbol</li><li><code>i</code> a function to be evaluated during reloc processing</li><li><code>d</code> a debugging symbol</li><li><code>D</code> a dynamic symbol</li><li><code>F</code> function</li><li><code>f</code> file</li><li><code>O</code> object</li></ul><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><pre><code class="shell">$ tree.├── a.out├── one.c   // extern unsigned long start_time;├── two.c   // unsigned long start_time = 0;└── main.c  // start_time = _get_time();$ nm one.o | grep start_time00000004 C start_time$ nm two.o | grep start_time00000000 B start_time$ nm main.o | grep start_time00000004 C start_time$ nm a.out | grep start_time97d6c6c4 B start_time$ objdump -x -s a.out | grep start_time97d6c6c4 g     O .bss    00000004 start_time 0640 0e000067 5f737461 72745f74 696d6500  ...start_time. 1ae0 675f7374 6172745f 74696d65 00df0e00  start_time....$ objdump -x -s one.o | grep start_time00000004       O *COM*    00000004 start_time00000ef5 ADDR32   start_time0000003c ADDR32   start_time$ objdump -x -s main.o | grep start_time00000004       O *COM*    00000004 start_time00000262 ADDR32   start_time000000e4 ADDR32   start_time$ objdump -x -s two.o | grep start_time 32 .bss.start_time 00000004  00000000  00000000  000015c8  2**200000000 l    d  .bss.start_time    00000000 .bss.start_time00000000 g     O .bss.start_time    00000004 start_time000006d7 ADDR32   .bss.start_time</code></pre><p>注意变量 <code>start_time</code> 在各个文件中的标志</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.51cto.com/12810168/2321531" target="_blank" rel="noopener">程序的结构体系（十）</a></li><li><a href="https://www.jianshu.com/p/863b279c941e" target="_blank" rel="noopener">使用readelf和objdump解析目标文件</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目标文件 &lt;code&gt;.o&lt;/code&gt; 中 &lt;code&gt;text&lt;/code&gt;、 &lt;code&gt;bss&lt;/code&gt;、 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;rodata&lt;/code&gt; 区别和联系&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Linker" scheme="http://yoursite.com/categories/C/Linker/"/>
    
    
      <category term="ld" scheme="http://yoursite.com/tags/ld/"/>
    
      <category term="nm" scheme="http://yoursite.com/tags/nm/"/>
    
      <category term="objdump" scheme="http://yoursite.com/tags/objdump/"/>
    
      <category term="readelf" scheme="http://yoursite.com/tags/readelf/"/>
    
  </entry>
  
  <entry>
    <title>抓取 JS 动态生成网页数据</title>
    <link href="http://yoursite.com/2019/12/06/python-requests-dynamic-webpages/"/>
    <id>http://yoursite.com/2019/12/06/python-requests-dynamic-webpages/</id>
    <published>2019-12-06T02:43:27.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>静态网页使用 <code>bs4</code> + <code>requests</code> 进行抓取<br>动态网页数据不在 HTML 中，需要分析之后设计程序</p><a id="more"></a><blockquote><p>转载 <a href="https://www.jianshu.com/p/9de3be54abc1" target="_blank" rel="noopener">网络数据抓取-JS动态生成数据-Python-requests爬虫</a></p></blockquote><h2 id="理解页面"><a href="#理解页面" class="headerlink" title="理解页面"></a>理解页面</h2><p><img src="/images/spider/4324074-6bc9881ca058cf06.webp" alt="动态填充数据页面流程"></p><blockquote><p>能够动态请求数据和填充数据的代码就是 Html 网页内运行的 JavaScript 脚本代码，它们可以做各种事情，尤其善于玩弄数据。</p></blockquote><h2 id="理解数据请求Request"><a href="#理解数据请求Request" class="headerlink" title="理解数据请求Request"></a>理解数据请求Request</h2><p>使用 <code>chrome</code> 开发者工具分析 <code>Network</code></p><h2 id="发送数据请求"><a href="#发送数据请求" class="headerlink" title="发送数据请求"></a>发送数据请求</h2><p>复制请求地址</p><pre><code class="python">requests.get(url, headers=User_Agents[0], timeout=50)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态网页使用 &lt;code&gt;bs4&lt;/code&gt; + &lt;code&gt;requests&lt;/code&gt; 进行抓取&lt;br&gt;动态网页数据不在 HTML 中，需要分析之后设计程序&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Python/Spider/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="bs4" scheme="http://yoursite.com/tags/bs4/"/>
    
      <category term="requests" scheme="http://yoursite.com/tags/requests/"/>
    
      <category term="spider" scheme="http://yoursite.com/tags/spider/"/>
    
  </entry>
  
  <entry>
    <title>提高 github 下载速度</title>
    <link href="http://yoursite.com/2019/12/03/improve-github-download-speed/"/>
    <id>http://yoursite.com/2019/12/03/improve-github-download-speed/</id>
    <published>2019-12-03T02:52:05.000Z</published>
    <updated>2020-04-07T04:41:36.153Z</updated>
    
    <content type="html"><![CDATA[<p>修改 <code>hosts</code> 提高 github 下载速度</p><a id="more"></a><h2 id="提供速度"><a href="#提供速度" class="headerlink" title="提供速度"></a>提供速度</h2><p>在 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 使用 IP Lookup 查询下面三个域名地址</p><ul><li>140.82.113.4 github.com</li><li>199.232.5.194 github.global.ssl.fastly.net</li><li>140.82.113.10 codeload.github.com</li></ul><p>将上述信息添加到 <code>/etc/hosts</code> 中并重启网络服务</p><pre><code class="shell">$ sudo /etc/init.d/networking restart</code></pre><h2 id="减少下载量"><a href="#减少下载量" class="headerlink" title="减少下载量"></a>减少下载量</h2><pre><code class="shell">$ git clone repo_url --depth=1</code></pre><p>只下载最新版本，而不是带有全部历史版本的仓库</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改 &lt;code&gt;hosts&lt;/code&gt; 提高 github 下载速度&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/categories/Tools/GitHub/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hosts" scheme="http://yoursite.com/tags/hosts/"/>
    
  </entry>
  
</feed>
