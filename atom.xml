<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT日记</title>
  
  <subtitle>Life is Now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-12T02:31:13.454Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Breeze.Temple</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git 带有参数的别名</title>
    <link href="http://yoursite.com/2020/05/12/git-advanced-aliases-with-arguments/"/>
    <id>http://yoursite.com/2020/05/12/git-advanced-aliases-with-arguments/</id>
    <published>2020-05-12T01:38:13.000Z</published>
    <updated>2020-05-12T02:31:13.454Z</updated>
    
    <content type="html"><![CDATA[<p>git 别名以及使用参数相关注意事项</p><a id="more"></a><h2 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h2><p><a href="https://git.wiki.kernel.org/index.php/Aliases#Advanced_aliases_with_arguments" target="_blank" rel="noopener">Aliases</a></p><p>git 别名配置在文件 <code>~/.gitconfig</code> 中，存在两种别名</p><ol><li>git 命令别名，内置命令</li><li>非 git 命令别名，使用前缀<code>!</code>，运行在 shell</li></ol><pre><code>[alias]    ci = commit    br = branch    push-view = !sh -c &#39;git origin HEAD:refs/for/$1&#39; -    gitkconflict = !gitk --left-right HEAD...MERGE_HEAD</code></pre><h2 id="Advanced-aliases-with-parameters"><a href="#Advanced-aliases-with-parameters" class="headerlink" title="Advanced aliases with parameters"></a>Advanced aliases with parameters</h2><blockquote><p>Starting with version 1.5.3, git supports appending the arguments to commands prefixed with “!”, too. If you need to perform a reordering, or to use an argument twice, you can use this trick:</p></blockquote><pre><code>[alias]    example = !sh -c &#39;ls $2 $1&#39; -</code></pre><ul><li><code>!</code> 在 shell 中运行</li><li><code>$1</code> 为第一个参数</li></ul><p>另外一种方式，封装为 <code>bash</code> 函数 <code>f</code>：</p><pre><code>[alias]    files = &quot;!f() { git diff --name-status \&quot;$1^\&quot; \&quot;$1\&quot;; }; f&quot;</code></pre><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>调试输出信息</p><pre><code>$ GIT_TRACE=1 git push-view test</code></pre><p>或者使用 <code>gdb</code> 调试</p><pre><code>[alias]    debug = !GIT_PAGER= gdb --args git</code></pre><p>用法 <code>git debug push-view test</code></p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>定义 gerrit review alias 为</p><pre><code>[alias]  ...  push-for-review = push origin HEAD:refs/for/master  push-for-review-branch = !git push origin HEAD:refs/for/$1  push-as-draft = push origin HEAD:refs/drafts/master  push-as-draft-branch = !git push origin HEAD:refs/drafts/$1  ...</code></pre><p>调试如下</p><pre><code class="shell">$ GIT_TRACE=1 git push-for-review-branch test16:38:33.280667 git.c:344               trace: built-in: git push origin HEAD:refs/for/test testTo ssh://192.168.110.254:29418/misc   d9d506f..20c5d70  test -&gt; test * [new branch]      HEAD -&gt; refs/for/test</code></pre><p>尾巴上多出一个参数导致直接合并，不理解为什么？<code>$@</code> 解析问题？<br><a href="https://stackoverflow.com/questions/3321492/git-alias-with-positional-parameters" target="_blank" rel="noopener">stackoverflow - Git alias with positional parameters</a>解释如下</p><blockquote><p>The sh -c ‘..’ – and f() {..}; f options both cleanly handle the “$@” parameters in different ways (see with GIT_TRACE). Appending “#” to an alias would also allow positional parameters without leaving the trailing ones.</p></blockquote><p>修改为</p><pre><code>[alias]  ...  push-for-review = push origin HEAD:refs/for/master  push-for-review-branch = &quot;!git push origin HEAD:refs/for/$1 #&quot;  push-as-draft = push origin HEAD:refs/drafts/master  push-as-draft-branch = &quot;!git push origin HEAD:refs/drafts/$1 #&quot;  ...</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 别名以及使用参数相关注意事项&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/Tools/Git/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="alias" scheme="http://yoursite.com/tags/alias/"/>
    
  </entry>
  
  <entry>
    <title>基于 coc.nvim python 补全</title>
    <link href="http://yoursite.com/2020/05/08/coc-python-completion/"/>
    <id>http://yoursite.com/2020/05/08/coc-python-completion/</id>
    <published>2020-05-08T05:35:57.000Z</published>
    <updated>2020-05-12T02:31:13.454Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>coc.nvim</code> 配置 python 补全</p><ul><li>coc-jedi</li><li>coc-python <em>配置失败</em></li><li>python LSP <em>配置失败</em></li></ul><a id="more"></a><h2 id="python-LSP"><a href="#python-LSP" class="headerlink" title="python LSP"></a>python LSP</h2><ul><li><a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers" target="_blank" rel="noopener">Python LS</a></li><li><a href="https://github.com/palantir/python-language-server" target="_blank" rel="noopener">python-language-server</a></li></ul><p>需要配置 <code>coc-settings.json</code></p><p><strong>LSP重启5次失败</strong></p><h2 id="coc-python"><a href="#coc-python" class="headerlink" title="coc-python"></a>coc-python</h2><p><strong>推荐使用</strong>，<code>coc-settings.json</code> 中不能配置 <code>LSP</code></p><ul><li><a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers" target="_blank" rel="noopener">Python LS</a></li><li><a href="https://github.com/neoclide/coc-python" target="_blank" rel="noopener">coc-python</a></li></ul><p>支持两种：</p><ol><li>jedi (工作不正常)</li><li>MPLS (网络原因，不能正常下载)</li></ol><h2 id="coc-jedi"><a href="#coc-jedi" class="headerlink" title="coc-jedi"></a>coc-jedi</h2><ul><li><a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions" target="_blank" rel="noopener">coc-extensions</a></li><li><a href="https://github.com/pappasam/coc-jedi" target="_blank" rel="noopener">coc-jedi</a></li><li><a href="https://github.com/pappasam/jedi-language-server" target="_blank" rel="noopener">jedi-language-server</a></li></ul><p><strong>与 <code>coc-python</code> 冲突，需要先卸载</strong>，基于 <code>jedi-language-server</code></p><pre><code class="shell">$ python3 -m pip install --user pipx$ pipx install jedi-language-server</code></pre><p><code>coc-settings.json</code> 配置如下</p><pre><code class="json">  &quot;jedi.enable&quot;: true,  &quot;jedi.trace.server&quot;: &quot;messages&quot;,  &quot;jedi.diagnostics.enable&quot;: true,  &quot;jedi.diagnostics.didOpen&quot;: true,  &quot;jedi.diagnostics.didChange&quot;: true,  &quot;jedi.diagnostics.didSave&quot;: true</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;coc.nvim&lt;/code&gt; 配置 python 补全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coc-jedi&lt;/li&gt;
&lt;li&gt;coc-python &lt;em&gt;配置失败&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;python LSP &lt;em&gt;配置失败&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Editor" scheme="http://yoursite.com/categories/Tools/Editor/"/>
    
    
      <category term="lsp" scheme="http://yoursite.com/tags/lsp/"/>
    
      <category term="coc" scheme="http://yoursite.com/tags/coc/"/>
    
      <category term="jedi" scheme="http://yoursite.com/tags/jedi/"/>
    
  </entry>
  
  <entry>
    <title>GDB Tips</title>
    <link href="http://yoursite.com/2020/05/07/gdb-ptype/"/>
    <id>http://yoursite.com/2020/05/07/gdb-ptype/</id>
    <published>2020-05-07T08:46:48.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 使用技巧</p><ul><li>启动</li><li>dump</li><li>ptype</li><li>set</li><li>info</li><li>disassemble</li></ul><a id="more"></a><h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><p>默认读取当前目录下的 <code>.gdbinit</code>，使用 <code>-nx</code>不读取 <code>.gdbinit</code> 配置</p><pre><code class="shell">$ gdb test # 常用于下载调试test$ gdb -nx test # 常用于查看当前状态</code></pre><h2 id="独立调试信息记载"><a href="#独立调试信息记载" class="headerlink" title="独立调试信息记载"></a>独立调试信息记载</h2><p><code>test</code> 编译参数为 <code>-O0 -g -ggdb</code></p><ul><li>获取调试信息 <code>objcopy --only-keep-debug test test.debug</code></li><li>gdb 中加载 <code>symbol-file test.debug</code></li><li>分离的调试信息重新链接到可执行问题 <code>objcopy --add-gnu-debuglink test.debug test</code></li></ul><h2 id="Dump-Memory"><a href="#Dump-Memory" class="headerlink" title="Dump Memory"></a>Dump Memory</h2><pre><code class="gdb">(gdb) help dumpDump target code/data to a local file.List of dump subcommands:dump binary -- Write target code/data to a raw binary filedump ihex -- Write target code/data to an intel hex filedump memory -- Write contents of memory to a raw binary filedump srec -- Write target code/data to an srec filedump tekhex -- Write target code/data to a tekhex filedump value -- Write the value of an expression to a raw binary filedump verilog -- Write target code/data to a verilog hex fileType &quot;help dump&quot; followed by dump subcommand name for full documentation.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.Command name abbreviations are allowed if unambiguous.(gdb) help dump memoryWrite contents of memory to a raw binary file.Arguments are FILE START STOP.  Writes the contents of memory within therange [START .. STOP) to the specified FILE in raw target ordered bytes.</code></pre><p>语法 <code>dump memory file $START $END</code></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><ul><li><code>b *func</code> 断点在 <code>func</code> 入栈之前</li><li><code>ni/si</code> 汇编指令级单步执行</li><li><code>disassemble func</code> 反汇编 func</li><li><code>disassemble /m func</code> 反汇编 func，带有源代码信息</li><li><code>disassemble $pc-20,$pc+20</code> 反汇编执行区间代码</li><li><code>watch *(int *)0x8049aa4</code> 内存读写断点</li><li><code>rwatch *(int *)0x8049aa4</code> 内存读断点</li><li><code>awatch *(int *)0x8049aa4</code> 内存读写断点</li><li><code>display /i $pc</code> 显示当前汇编指令</li><li><code>info r</code> 查看寄存器</li><li><code>i r rx</code> 查看rx寄存器</li></ul><h2 id="ptype-查看类型"><a href="#ptype-查看类型" class="headerlink" title="ptype 查看类型"></a>ptype 查看类型</h2><p>用于查看符号类型 <code>ptype symbol|var</code></p><pre><code class="gdb">(gdb) ptype struct filetype = struct file {    cyg_uint32 f_flag;    cyg_uint16 f_ucount;    cyg_uint16 f_type;    cyg_uint32 f_syncmode;    fileops *f_ops;    off_t f_offset;    CYG_ADDRWORD f_data;    CYG_ADDRWORD f_xops;    cyg_mtab_entry *f_mte;    list_head f_node;    cyg_uint8 f_valid;}</code></pre><p>使用 <code>set print type xxx</code> 配置</p><h2 id="whatis-查看类型"><a href="#whatis-查看类型" class="headerlink" title="whatis 查看类型"></a>whatis 查看类型</h2><p><code>whatis var</code></p><h2 id="info-address"><a href="#info-address" class="headerlink" title="info address"></a>info address</h2><p><code>info address symbol</code></p><blockquote><p>Describe where the data for symbol is stored. For a register variable, this says which register it is kept in. For a non-register local variable, this prints the stack-frame offset at which the variable is always stored.</p></blockquote><p>查找给定符号的存储地址</p><h2 id="info-symbol"><a href="#info-symbol" class="headerlink" title="info symbol"></a>info symbol</h2><p><code>info symbol addr</code></p><blockquote><p>Print the name of a symbol which is stored at the address addr. If no symbol is stored exactly at addr, GDB prints the nearest symbol and an offset from it</p><pre><code class="gdb">(gdb) info symbol 0x54320_initialize_vx + 396 in section .text</code></pre></blockquote><p>查找给定地址的变量或函数的名称</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ol><li><a href="https://www.cnblogs.com/zengkefu/p/5618041.html" target="_blank" rel="noopener">GDB技巧整理</a></li><li><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Symbols.html" target="_blank" rel="noopener">16 Examining the Symbol Table</a></li><li><a href="https://stackoverflow.com/questions/866721/how-to-generate-gcc-debug-symbol-outside-the-build-target" target="_blank" rel="noopener">How to generate gcc debug symbol outside the build target?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 使用技巧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动&lt;/li&gt;
&lt;li&gt;dump&lt;/li&gt;
&lt;li&gt;ptype&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;info&lt;/li&gt;
&lt;li&gt;disassemble&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
      <category term="ptype" scheme="http://yoursite.com/tags/ptype/"/>
    
  </entry>
  
  <entry>
    <title>GDB打印二维数组</title>
    <link href="http://yoursite.com/2020/05/07/print-2d-array-in-gdb/"/>
    <id>http://yoursite.com/2020/05/07/print-2d-array-in-gdb/</id>
    <published>2020-05-07T04:50:37.000Z</published>
    <updated>2020-05-12T02:31:13.454Z</updated>
    
    <content type="html"><![CDATA[<ul><li>打印数组 <code>p *matrix@length</code></li><li>打印二维数组 <code>p *matrix@cols@rows</code></li><li>打印二维数组 <code>printMatrix matrix cols rows</code><pre><code>define printMatrix  set $arr = $arg0  set $rows = $arg1  set $cols = $arg2  set $i = 0  printf &quot;\n&quot;  while $i &lt; $rows      set $j = 0      while $j &lt; $cols          printf &quot;%02d, &quot;,$arr[$i][$j]          set $j = $j + 1      end      printf &quot;\n&quot;      set $i = $i + 1  endend</code></pre></li></ul><a id="more"></a><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><pre><code class="c">#include &lt;stdio.h&gt;int matrix[10][10];void print(int matrix[10][10]){    int i, j;    for (i = 0; i &lt; 10; ++i)    {        for (j = 0; j &lt; 10; ++j)            printf(&quot;%d &quot;, matrix[i][j]);        printf(&quot;\n&quot;);    }}int main(){    int i, j;    for (i = 0; i &lt; 10; ++i)        for (j = 0; j &lt; 10; ++j)            matrix[i][j] = i*10 + j;    return 0;}</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>(gdb) p *matrix[1]@10$6 = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}(gdb) p *matrix[1]@5@2$7 = {{10, 11, 12, 13, 14}, {15, 16, 17, 18, 19}}(gdb) source a.gdb(gdb) printMatrix matrix 10 1000, 01, 02, 03, 04, 05, 06, 07, 08, 09,10, 11, 12, 13, 14, 15, 16, 17, 18, 19,20, 21, 22, 23, 24, 25, 26, 27, 28, 29,30, 31, 32, 33, 34, 35, 36, 37, 38, 39,40, 41, 42, 43, 44, 45, 46, 47, 48, 49,50, 51, 52, 53, 54, 55, 56, 57, 58, 59,60, 61, 62, 63, 64, 65, 66, 67, 68, 69,70, 71, 72, 73, 74, 75, 76, 77, 78, 79,80, 81, 82, 83, 84, 85, 86, 87, 88, 89,90, 91, 92, 93, 94, 95, 96, 97, 98, 99,</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;打印数组 &lt;code&gt;p *matrix@length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打印二维数组 &lt;code&gt;p *matrix@cols@rows&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打印二维数组 &lt;code&gt;printMatrix matrix cols rows&lt;/code&gt;&lt;pre&gt;&lt;code&gt;define printMatrix
  set $arr = $arg0
  set $rows = $arg1
  set $cols = $arg2
  set $i = 0
  printf &amp;quot;\n&amp;quot;
  while $i &amp;lt; $rows
      set $j = 0
      while $j &amp;lt; $cols
          printf &amp;quot;%02d, &amp;quot;,$arr[$i][$j]
          set $j = $j + 1
      end
      printf &amp;quot;\n&amp;quot;
      set $i = $i + 1
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>GDB扩展脚本</title>
    <link href="http://yoursite.com/2020/05/07/Extending-GDB/"/>
    <id>http://yoursite.com/2020/05/07/Extending-GDB/</id>
    <published>2020-05-07T03:10:39.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 扩展</p><ul><li>GDB Commands</li><li>python script</li></ul><a id="more"></a><h2 id="GDB-脚本"><a href="#GDB-脚本" class="headerlink" title="GDB 脚本"></a>GDB 脚本</h2><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Sequences.html#Sequences" target="_blank" rel="noopener">Canned Sequences of Commands</a><br><a href="https://github.com/gdbinit/Gdbinit/blob/master/gdbinit" target="_blank" rel="noopener">Gdbinit</a></p><p>在 <code>.gdbinit</code> 中增加如下代码自定义函数</p><pre><code>define print_list    set $list=$arg0    while($list)        printf &quot;%d\t&quot;,$list-&gt;val        set $list=$list-&gt;next    end    printf &quot;\n&quot;enddocument print_listSyntax: print_list listend</code></pre><h2 id="Python-脚本"><a href="#Python-脚本" class="headerlink" title="Python 脚本"></a>Python 脚本</h2><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Python.html#Python" target="_blank" rel="noopener">Extending GDB using Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GDB Commands&lt;/li&gt;
&lt;li&gt;python script&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gerrit命名空间</title>
    <link href="http://yoursite.com/2020/05/07/gerrit-namespace/"/>
    <id>http://yoursite.com/2020/05/07/gerrit-namespace/</id>
    <published>2020-05-07T01:21:04.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>Gerrit 命名空间 <code>refs/for/&lt;branch&gt;</code> 用于代码评审，以及相关 alias</p><a id="more"></a><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>Branches, remote-tracking branches, and tags 等等都是对 commite 的引用（reference），引用都以 <code>refs/...</code>”表示</p><ul><li>remote branch: origin/git_int(=refs/remotes/origin/git_int)</li><li>local tag: v2.0(=refs/tags/v2.0)</li><li>local branch: git_int(=refs/heads/git_int)</li></ul><h2 id="refs-for"><a href="#refs-for" class="headerlink" title="refs/for"></a>refs/for</h2><p><code>refs/for/&lt;branch&gt;</code> 用于 gerrit 代码评审</p><blockquote><p>Gerrit uses the <strong>refs/for/</strong> prefix to map the concept of “Pushing for Review” to the git protocol.</p></blockquote><p>git 命令 <code>git push origin HEAD:refs/for/&lt;BRANCH_NAME&gt;</code></p><h2 id="refs-changes"><a href="#refs-changes" class="headerlink" title="refs/changes"></a>refs/changes</h2><p>提交到 gerrit 的代码如下格式</p><blockquote><p>For the git client, it looks like every push goes to the same branch, such as refs/for/master. In fact, for each commit pushed to this ref, Gerrit creates a new ref under a refs/changes/ namespace, which Gerrit uses to track these commits. These references use the following format: refs/changes/[CD]/[ABCD]/[EF]</p></blockquote><ul><li>[CD] is the last two digits of the change number</li><li>[ABCD] is the change number</li><li>[EF] is the patch set number</li></ul><h2 id="refs-head"><a href="#refs-head" class="headerlink" title="refs/head"></a>refs/head</h2><p><code>refs/head/&lt;branch&gt;</code> 用于绕过评审直接提交代码，可能会因为权限控制导致提交失败</p><pre><code>! [remote rejected] master -&gt; master (prohibited by Gerrit)</code></pre><p>git 命令 <code>git push origin &lt;BRANCH_NAME&gt;</code></p><h2 id="refs-drafts"><a href="#refs-drafts" class="headerlink" title="refs/drafts"></a>refs/drafts</h2><p>草稿箱，仅 owner 以及邀请用户可见</p><pre><code>git push origin HEAD:refs/drafts/&lt;BRANCH_NAME&gt;</code></pre><h2 id="git-alias"><a href="#git-alias" class="headerlink" title="git alias"></a>git alias</h2><pre><code>[alias]  ...  push-for-review = push origin HEAD:refs/for/master  push-for-review-branch = !git push origin HEAD:refs/for/$1  push-as-draft = push origin HEAD:refs/drafts/master  push-as-draft-branch = !git push origin HEAD:refs/drafts/$1  ...</code></pre><blockquote><p>两个携带参数的 alias 存在问题，git version 2.17.1<br>git push-for-review-branch test 展开为 git push origin HEAD:refs/for/test test，多了一个参数导致直接合并到git仓库中</p></blockquote><pre><code class="shell">$ GIT_TRACE=1 git push-for-review-branch testTo ssh://192.168.110.254:29418/misc   d9d506f..20c5d70  test -&gt; test * [new branch]      HEAD -&gt; refs/for/test</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gerrit 命名空间 &lt;code&gt;refs/for/&amp;lt;branch&amp;gt;&lt;/code&gt; 用于代码评审，以及相关 alias&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Gerrit" scheme="http://yoursite.com/categories/Tools/Gerrit/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="gerrit" scheme="http://yoursite.com/tags/gerrit/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 安装与配置</title>
    <link href="http://yoursite.com/2020/04/17/mysql-installation-and-configuration/"/>
    <id>http://yoursite.com/2020/04/17/mysql-installation-and-configuration/</id>
    <published>2020-04-17T03:04:03.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>记录 ubuntu18.04 安装并配置 MySQL</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell">$ sudo apt install mysql-server</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用命令出现如下错误，<a href="https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost" target="_blank" rel="noopener">原因及解决方法</a></p><pre><code class="shell">$ mysql -ui root -pERROR 1698 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39;$ sudo mysql -u root # I had to use &quot;sudo&quot; since is new installationmysql&gt; USE mysql;mysql&gt; SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User             | Host      | plugin                |+------------------+-----------+-----------------------+| root             | localhost | auth_socket           || mysql.session    | localhost | mysql_native_password || mysql.sys        | localhost | mysql_native_password || debian-sys-maint | localhost | mysql_native_password |+------------------+-----------+-----------------------+4 rows in set (0.00 sec)mysql&gt; CREATE USER &#39;sql-test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sql-test&#39;@&#39;localhost&#39;;ERROR 1133 (42000): Can&#39;t find any matching row in the user tablemysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sql-test&#39;@&#39;localhost&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; UPDATE user SET plugin=&#39;auth_socket&#39; WHERE User=&#39;sql-test&#39;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User             | Host      | plugin                |+------------------+-----------+-----------------------+| root             | localhost | auth_socket           || mysql.session    | localhost | mysql_native_password || mysql.sys        | localhost | mysql_native_password || debian-sys-maint | localhost | mysql_native_password || sql-test         | localhost | auth_socket           |+------------------+-----------+-----------------------+5 rows in set (0.00 sec)mysql&gt; UPDATE user SET plugin=&#39;mysql_native_password&#39; WHERE User=&#39;sql-test&#39;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; exit;$ sudo service mysql restart$ mysql -u sql-tesmysql&gt;</code></pre><p>其他命令：</p><ol><li>检查MySQL服务器占用端口 <code>netstat -nlt|grep 3306</code></li><li>检查MySQL服务器系统进程 <code>ps -aux|grep mysql</code></li><li>查看数据库的字符集编码 <code>show variables like &#39;%char%&#39;;</code></li><li>重启 <code>service mysqld restart</code></li></ol><h2 id="pymysql简单使用"><a href="#pymysql简单使用" class="headerlink" title="pymysql简单使用"></a>pymysql简单使用</h2><ul><li>创建数据库<pre><code class="python">pymysql.connect(host=&#39;127.0.0.1&#39;, user=&#39;test&#39;, passwd=&#39;&#39;, use_unicode=True)cursor = self.connect.cursor()cursor.execute(&quot;create database if not exists sql-test&quot;)</code></pre></li><li>选择数据库<pre><code class="python">self.cursor.execute(&quot;use sql-test;&quot;)</code></pre></li><li>创建表<pre><code class="python">sql = &quot;&quot;&quot;create table if not exists saes(  pos varchar(20),  area varchar(20),  name varchar(100),  time varchar(20));&quot;&quot;&quot;cursor.execute(sql)</code></pre></li><li>更新数据<pre><code class="python">cursor.execute(&quot;&quot;&quot;select * from saes where name = %s&quot;&quot;&quot;, item[&quot;name&quot;])ret = cursor.fetchone()if ret:  cursor.execute(      &quot;&quot;&quot;update saes set pos = %s,area = %s,          name = %s,time = %s          where name = %s&quot;&quot;&quot;,      (item[&#39;pos&#39;],      item[&#39;area&#39;],      item[&#39;name&#39;],      item[&#39;time&#39;],      item[&#39;name&#39;]))else:  cursor.execute(      &quot;&quot;&quot;insert into saes(pos,area,cku,name,time)      value (%s,%s,%s,%s)&quot;&quot;&quot;,      (item[&#39;pos&#39;],      item[&#39;area&#39;],      item[&#39;name&#39;],      item[&#39;time&#39;]))connect.commit()</code></pre></li><li>删除表<pre><code class="python">drop table tablename;</code></pre></li></ul><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="sql">mysql&gt; CREATE TABLE students (    -&gt; id bigint(20) NOT NULL AUTO_INCREMENT,    -&gt; name varchar(100) NOT NULL,    -&gt; gender varchar(1) NOT NULL,    -&gt; score int(11) NOT NULL,    -&gt; PRIMARY KEY (id)    -&gt; ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>指定字符集为 <code>utf8</code></p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><pre><code>create database new_dbname;--新建数据库drop database old_dbnane; --删除数据库show databases;--显示数据库use databasename;--使用数据库select database();--查看已选择的数据库show tables;--显示当前库的所有表create table tablename(fieldname1 fieldtype1,fieldname2 fieldtype2,..)[ENGINE=engine_name];--创建表drop table tablename; --删除表create table tablename select statement;--通过子查询创建表desc tablename;--查看表结构show create table tablename;--查看建表语句alter table tablename add new_fielname new_fieldtype;--新增列alter table tablename add new_fielname new_fieldtype after 列名1;--在列名1后新增列alter table tablename modify fieldname new_fieldtype;--修改列alter table tablename drop fieldname;--删除列alter table tablename_old rename tablename_new;--表重命名insert into tablename(fieldname1,fieldname2,fieldnamen) valuse(value1,value2,valuen);--增delete from tablename [where fieldname=value];--删update tablename set fieldname1=new_value where filename2=value;--改select * from tablename [where filename=value];--查truncate table tablename;--清空表中所有数据，DDL语句show engines;--查看mysql现在已提供的存储引擎:show variables like &#39;%storage_engine%&#39;;--查看mysql当前默认的存储引擎show create table tablename;--查看某张表用的存储引擎（结果的&quot;ENGINE=&quot;部分）alter table tablename ENGINE=InnoDB--修改引擎create table tablename(fieldname1 fieldtype1,fieldname2 fieldtype2,..) ENGINE=engine_name;--创建表时设置存储引擎</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 ubuntu18.04 安装并配置 MySQL&lt;/p&gt;
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>scrapy使用</title>
    <link href="http://yoursite.com/2020/03/30/python-scrapy/"/>
    <id>http://yoursite.com/2020/03/30/python-scrapy/</id>
    <published>2020-03-30T05:40:08.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html" target="_blank" rel="noopener">scrapy</a> 爬虫框架编写爬虫</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>安装 <code>pip3 install scrapy --user</code></li><li>css 选择器 <a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">CSS选择器笔记</a></li><li>xpath 选择器 <a href="https://www.jianshu.com/p/539356db0c0c" target="_blank" rel="noopener">scrapy提取数据之：xpath选择器</a></li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>使用 <code>scrapy shell urls</code> 进行调试</p><ol><li>配置默认请求头<pre><code>&gt;&gt;&gt; settings.DEFAULT_REQUEST_HEADERS = { &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, &#39;Accept-Language&#39;: &#39;en&#39;, &#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 \ (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&#39;}</code></pre></li><li>使用 <code>fetch(urls)</code> 命令来抓取测试的页面，解析为 <code>response</code></li><li>使用 <code>response.css</code> 分析页面</li></ol><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><ol><li><code>scrapy startproject projectname</code> 新建项目</li><li><code>scrapy genspider demo demo.com</code> 新建爬虫</li></ol><pre><code class="shell">$ scrapy startproject DemoNew Scrapy project &#39;Demo&#39;, using template directory &#39;~/.local/lib/python3.6/site-packages/scrapy/templates/project&#39;, created in:    ~/python/crawler/scrapy/DemoYou can start your first spider with:    cd Demo    scrapy genspider example example.com$ cd Demo$ scrapy genspider demo demo.com$ tree.├── Demo│   ├── __init__.py│   ├── items.py│   ├── middlewares.py│   ├── pipelines.py│   ├── __pycache__│   │   ├── __init__.cpython-36.pyc│   │   └── settings.cpython-36.pyc│   ├── settings.py│   └── spiders│       ├── demo.py│       ├── __init__.py│       └── __pycache__│           └── __init__.cpython-36.pyc└── scrapy.cfg4 directories, 11 files</code></pre><ul><li><code>items.py</code> 数据模型文件</li><li><code>middlewares.py</code> 中间件文件，配置所有中间件</li><li><code>pipelines.py</code> 管道文件，用于处理数据输出</li><li><code>settings.py</code> 配置文件</li><li><code>demo.py</code> 爬虫文件</li><li><code>scrapy.cfg</code> 整个Scrapy的配置文件，由Scrapy自动生成</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件 <code>settings.py</code></p><ol><li><code>LOG_LEVEL = &#39;WARNING&#39;</code> 输出级别</li><li><code>ROBOTSTXT_OBEY = False</code></li><li><code>FEED_EXPORT_ENCODING = &#39;utf-8&#39;</code> 支持中文</li></ol><h2 id="爬虫实现"><a href="#爬虫实现" class="headerlink" title="爬虫实现"></a>爬虫实现</h2><p>生成的爬虫文件如下</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider):    name = &#39;demo&#39;    allowed_domains = [&#39;demo.com&#39;]    start_urls = [&#39;http://demo.com/&#39;]    def parse(self, response):        pass</code></pre><p>所有的 Spider 类都必须得继承 scrapy.Spider，其中 <code>name</code>、<code>start_urls</code> 以及 <code>parse</code> 成员方法是每个 Spider 类必须要声明的。详细见<a href="https://docs.scrapy.org/en/latest/topics/spiders.html?highlight=Spider#spiders" target="_blank" rel="noopener">Spider</a></p><p>需要定义 <code>start_urls</code> 或者重写 <code>start_requests</code> 方法，两者都必须是可迭代对象</p><pre><code class="python">class Demo(scrapy.Spider):    name = &quot;demo&quot;    allowed_domains = [&quot;demo.com&quot;]    def start_requests(self):        yield Request(url=&#39;https://demo.com/p/&#39;, headers=headers, callback=self.parse_rank)    def parse_rank(self, response):        for item in response.css(&#39;article&gt;a&#39;):            name = item.css(&#39;.post-card-title::text&#39;).get()            link = item.css(&#39;::attr(href)&#39;).get()            print(&quot;\033[1;31m[%s]: %s\033[0m\n&quot; % (name, link))            yield Request(url=link, headers=headers, callback=self.parse_one)        next_page = response.css(&#39;ol&gt;li.next&#39;).css(&#39;a::attr(href)&#39;).get()        if next_page:            print(&quot;%s&quot; % next_page)            yield Request(next_page, callback=self.parse_rank)    def parse_one(self, response):        for src in response.css(&#39;div#post[role=main] p img::attr(src)&#39;).getall():            print(&quot;\033[1;32m%s\n\033[0m&quot; % src)            item = HaosuItem()            item[&#39;src&#39;] = src            yield item</code></pre><blockquote><p>所有具备解析功能的函数都应该返回 Item 或 Requests</p></blockquote><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>在 <code>item.py</code> 中定义数据模型</p><pre><code>class HaosuItem(scrapy.Item):    # define the fields for your item here like:    src = scrapy.Field()    pass</code></pre><p>数据填充并返回 <code>item</code> 见上述函数 <code>parse_one</code></p><h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>Scrapy 提供了一个 item pipeline 用于下载</p><pre><code class="python">from scrapy.pipelines.images import ImagesPipelineimport scrapyclass HaosuPipeline(ImagesPipeline):    def get_media_requests(self, item, info):        yield scrapy.Request(item[&#39;src&#39;])</code></pre><p>从 <code>item</code> 中获取下载地址并下载，修改 <code>setting.py</code> 开启管道</p><pre><code>ITEM_PIPELINES = {    &#39;haosu.pipelines.HaosuPipeline&#39;: 5,}IMAGES_STORE = &#39;image&#39;</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="shell">$ scrapy crawl demo</code></pre><h2 id="Scrapy-体系结构"><a href="#Scrapy-体系结构" class="headerlink" title="Scrapy 体系结构"></a>Scrapy 体系结构</h2><ul><li><a href="https://docs.scrapy.org/en/latest/topics/architecture.html" target="_blank" rel="noopener">Architecture overview</a></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://juejin.im/post/5cfc6f716fb9a07ea7130308" target="_blank" rel="noopener">Scrapy简明教程</a></li><li><a href="https://docs.scrapy.org/en/latest/index.html" target="_blank" rel="noopener">Scrapy 2.0 documentation</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;a href=&quot;https://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scrapy&lt;/a&gt; 爬虫框架编写爬虫&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Python/Spider/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="spider" scheme="http://yoursite.com/tags/spider/"/>
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 搜索技巧</title>
    <link href="http://yoursite.com/2020/03/25/searching-on-github/"/>
    <id>http://yoursite.com/2020/03/25/searching-on-github/</id>
    <published>2020-03-25T12:01:05.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 搜索技巧，用于准确搜索到相关资源</p><ul><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-on-github" target="_blank" rel="noopener">Searching on GitHub</a><ul><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories" target="_blank" rel="noopener">Searching for repositories</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/finding-files-on-github" target="_blank" rel="noopener">Finding files on GitHub</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-topics" target="_blank" rel="noopener">Searching topics</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-code" target="_blank" rel="noopener">Searching code</a></li><li>…</li></ul></li><li><a href="https://github.com/trending" target="_blank" rel="noopener">GitHub Trending</a></li><li><a href="https://github.com/topics" target="_blank" rel="noopener">GitHub Topics</a></li><li><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">GitHub中文排行榜</a></li><li><a href="https://www.jianshu.com/p/7321caea2a08" target="_blank" rel="noopener">Github 搜索技巧</a></li><li><a href="https://sspai.com/post/46061" target="_blank" rel="noopener">掌握 3 个搜索技巧，在 GitHub 上快速找到实用软件资源</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub 搜索技巧，用于准确搜索到相关资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.github.com/en/github/searching-for-information-on-github/searching-on-github&quot; 
      
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/categories/Tools/GitHub/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="searching" scheme="http://yoursite.com/tags/searching/"/>
    
  </entry>
  
  <entry>
    <title>ARM stack backtrace的实现</title>
    <link href="http://yoursite.com/2020/03/17/arm-stack-backtrace/"/>
    <id>http://yoursite.com/2020/03/17/arm-stack-backtrace/</id>
    <published>2020-03-17T06:09:46.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 arm 体系下如何实现 stack backtrace</p><a id="more"></a><h2 id="APCS"><a href="#APCS" class="headerlink" title="APCS"></a>APCS</h2><p>APCS (ARM Procedure Call Standard)，ARM 过程调用标准规范了 arm 寄存器的使用、过程调用时出栈和入栈的约定。如下图示意：</p><p><img src="/images/linux/apcs_t.png" alt=""></p><p>函数的栈帧由 <code>fp</code> 和 <code>sp</code> 标记边界。如果编译器遵循APCS，形成结构化的函数调用栈，就可以解析当前栈(callee)结构，从而得到调用栈(caller)的结构，这样就输出了整个回溯栈。</p><p>编译器选项 <code>-g</code> 生成栈帧信息 <code>.debug_frame</code></p><pre><code class="shell">$ readelf -S output/out.elfThere are 18 section headers, starting at offset 0x1bb0fd0:节头：  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .text             PROGBITS        90000000 001000 6c132c 04  AX  0   0 1024  [ 2] .devtab           PROGBITS        906c132c 6c232c 000c8c 00  WA  0   0  8  [ 3] .bss              NOBITS          906c1fb8 6c2fb8 16a568 00  WA  0   0  8  [ 4] .debug_abbrev     PROGBITS        00000000 6c2fb8 0b82a7 00      0   0  1  [ 5] .debug_info       PROGBITS        00000000 77b25f a37035 00      0   0  1  [ 6] .debug_line       PROGBITS        00000000 11b2294 3bb5fc 00      0   0  1  [ 7] .debug_pubnames   PROGBITS        00000000 156d890 04911e 00      0   0  1  [ 8] .debug_pubtypes   PROGBITS        00000000 15b69ae 166807 00      0   0  1  [ 9] .debug_aranges    PROGBITS        00000000 171d1b5 018900 00      0   0  1  [10] .debug_str        PROGBITS        00000000 1735ab5 0c4732 01  MS  0   0  1  [11] .comment          PROGBITS        00000000 17fa1e7 0000cf 01  MS  0   0  1  [12] .debug_frame      PROGBITS        00000000 17fa2b8 08c8b0 00      0   0  4  [13] .debug_ranges     PROGBITS        00000000 1886b68 056380 00      0   0  1  [14] .debug_loc        PROGBITS        00000000 18dcee8 2d402b 00      0   0  1  [15] .shstrtab         STRTAB          00000000 1bb0f13 0000bd 00      0   0  1  [16] .symtab           SYMTAB          00000000 1bb12a0 071130 10     17 14593  4  [17] .strtab           STRTAB          00000000 1c223d0 086411 00      0   0  1</code></pre><p>内核编译选项</p><pre><code class="makefile">ifeq ($(CONFIG_FRAME_POINTER),y)KBUILD_CFLAGS   +=-fno-omit-frame-pointer -mapcs -mno-sched-prologendif</code></pre><h2 id="unwind"><a href="#unwind" class="headerlink" title="unwind"></a>unwind</h2><p>APCS的缺陷是，维护栈框的指令过多，栈消耗大，占用的寄存器也过多，比如每次调用都必须将 <code>r11,r12,lr,pc</code> 入栈。使用unwind就能避免这些问题，生产指令的效率要有用的多。它的原理是记录每个函数的入栈指令(一般比APCS的入栈要少的多)到特殊的段 <code>.ARM.unwind_idx</code> <code>.ARM.unwind_tab</code>。</p><pre><code class="shell">$ readelf -S vmlinuxThere are 33 section headers, starting at offset 0xa33ba8:节头：  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .head.text        PROGBITS        c0008000 008000 00026c 00  AX  0   0  4  [ 2] .text             PROGBITS        c0100000 010000 55e3dc 00  AX  0   0 64  [ 3] .fixup            PROGBITS        c065e3dc 56e3dc 00001c 00  AX  0   0  4  [ 4] .rodata           PROGBITS        c0700000 570000 105fc8 00  WA  0   0 4096  [ 5] __bug_table       PROGBITS        c0805fc8 675fc8 0057a8 00   A  0   0  4  [ 6] __ksymtab         PROGBITS        c080b770 67b770 006e28 00   A  0   0  4  [ 7] __ksymtab_gpl     PROGBITS        c0812598 682598 005d10 00   A  0   0  4  [ 8] __ksymtab_strings PROGBITS        c08182a8 6882a8 01e235 00   A  0   0  1  [ 9] __param           PROGBITS        c08364e0 6a64e0 000d34 00   A  0   0  4  [10] __modver          PROGBITS        c0837214 6a7214 000dec 00   A  0   0  4  [11] __ex_table        PROGBITS        c0838000 6a8000 001038 00   A  0   0  8  [12] .ARM.unwind_idx   ARM_EXIDX       c0839038 6a9038 0273d8 00  AL 17   0  4  [13] .ARM.unwind_tab   PROGBITS        c0860410 6d0410 003630 00   A  0   0  4  [14] .notes            NOTE            c0863a40 6d3a40 000024 00  AX  0   0  4  [15] .vectors          PROGBITS        ffff0000 6e0000 000020 00  AX  0   0  4  [16] .stubs            PROGBITS        ffff1000 6e1000 0002ac 00  AX  0   0 32  [17] .init.text        PROGBITS        c09002e0 6f02e0 0440d0 00  AX  0   0 32  [18] .exit.text        PROGBITS        c09443b0 7343b0 000ee4 00  AX  0   0  4  [19] .init.arch.info   PROGBITS        c0945294 735294 0000d0 00   A  0   0  4  [20] .init.tagtable    PROGBITS        c0945364 735364 000048 00   A  0   0  4  [21] .init.smpalt      PROGBITS        c09453ac 7353ac 00bd10 00   A  0   0  4  [22] .init.pv_table    PROGBITS        c09510bc 7410bc 00064c 00   A  0   0  1  [23] .init.data        PROGBITS        c0952000 742000 00a194 00  WA  0   0 4096  [24] .data..percpu     PROGBITS        c095d000 74d000 0067cc 00  WA  0   0 64  [25] .data             PROGBITS        c0a00000 760000 0609ac 00  WA  0   0 64  [26] .data..page_align PROGBITS        c0a61000 7c1000 001000 00  WA  0   0 4096  [27] .bss              NOBITS          c0a62000 7c2000 03260c 00  WA  0   0 64  [28] .comment          PROGBITS        00000000 7c2000 00004e 01  MS  0   0  1  [29] .ARM.attributes   ARM_ATTRIBUTES  00000000 7c204e 00002f 00      0   0  1  [30] .symtab           SYMTAB          00000000 7c2080 167560 10     31 77680  4  [31] .strtab           STRTAB          00000000 9295e0 10a46c 00      0   0  1  [32] .shstrtab         STRTAB          00000000 a33a4c 00015a 00      0   0  1$ objdump -D vmlinuc04ee72c &lt;__skb_recv_datagram&gt;:c04ee72c:       e3110040        tst     r1, #64 ; 0x40c04ee730:       e92d43f0        push    {r4, r5, r6, r7, r8, r9, lr}c04ee734:       e1a09003        mov     r9, r3c04ee738:       05903144        ldreq   r3, [r0, #324]  ; 0x144c04ee73c:       e24dd014        sub     sp, sp, #20$ readelf -u .ARM.unwind_idx vmlinux0xc04ee72c &lt;__skb_recv_datagram&gt;: 0x8004adb0  Compact model index: 0  0x04      vsp = vsp + 20  0xad      pop {r4, r5, r6, r7, r8, r9, r14}  0xb0      finish</code></pre><p>输出了函数的地址和对应的编码。接下输出的是编码对应的出栈伪指令，这些伪指令正好是函数栈操作的逆过程，用于回溯。</p><p>内核编译选项</p><pre><code class="makefile">ifeq ($(CONFIG_ARM_UNWIND),y)CFLAGS_ABI  +=-funwind-tablesendif</code></pre><h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>APCS会产生更多的代码指令，对性能有影响，使用unwind的方式会生成额外的段，但不影响性能。</p><p>文件 <code>arch/arm/kernel/traps.c</code></p><pre><code class="c">#ifdef CONFIG_ARM_UNWINDstatic inline void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk){    unwind_backtrace(regs, tsk);}#elsestatic void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk){    unsigned int fp, mode;    int ok = 1;    printk(&quot;Backtrace: &quot;);    if (!tsk)        tsk = current;    if (regs) {        fp = frame_pointer(regs);        mode = processor_mode(regs);    } else if (tsk != current) {        fp = thread_saved_fp(tsk);        mode = 0x10;    } else {        asm(&quot;mov %0, fp&quot; : &quot;=r&quot; (fp) : : &quot;cc&quot;);        mode = 0x10;    }    if (!fp) {        pr_cont(&quot;no frame pointer&quot;);        ok = 0;    } else if (verify_stack(fp)) {        pr_cont(&quot;invalid frame pointer 0x%08x&quot;, fp);        ok = 0;    } else if (fp &lt; (unsigned long)end_of_stack(tsk))        pr_cont(&quot;frame pointer underflow&quot;);    pr_cont(&quot;\n&quot;);    if (ok)        c_backtrace(fp, mode);}#endif</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/itismine/article/details/4752489" target="_blank" rel="noopener">APCS，ARM 过程调用标准(ARM Procedure Call Standard) </a></li><li><a href="https://www.linuxidc.com/Linux/2013-03/81247.htm" target="_blank" rel="noopener">ARM FP寄存器及frame pointer介绍</a></li><li><a href="https://www.alivepea.me/prog/how-backtrace-work/" target="_blank" rel="noopener">Stack backtrace 的实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 arm 体系下如何实现 stack backtrace&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="backtrace" scheme="http://yoursite.com/tags/backtrace/"/>
    
      <category term="unwind" scheme="http://yoursite.com/tags/unwind/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核符号表的生成和查找</title>
    <link href="http://yoursite.com/2020/03/11/linux-kernel-all-syms/"/>
    <id>http://yoursite.com/2020/03/11/linux-kernel-all-syms/</id>
    <published>2020-03-11T03:12:09.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p><code>printk</code> 可以根据地址打印函数名/符号名，记录内核符号表生成及使用过程</p><a id="more"></a><h2 id="System-map"><a href="#System-map" class="headerlink" title="System.map"></a>System.map</h2><p>System.map 文件是编译内核时生成的，它记录了内核中的符号列表，以及符号在内存中的虚拟地址，由脚本 <code>scripts/mksysmap</code> 生成</p><h2 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h2><p>内核必须打开 <code>CONFIG_KALLSYMS</code> 编译选项，和 System.map 的区别是<strong>它同时包含了内核模块的符号列表</strong>，是在内核启动后生成的，位于文件系统的 /proc 目录下，实现代码见 <code>kernel/kallsyms.c</code></p><h2 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h2><p><strong>System.map 和内核启动后的 /proc/kallsyms 文件中的符号表只是给我们看的，内核不会使用它们</strong>，而是在编译内核时，向 vmlinux 嵌入了一个符号表</p><p>内核符号表如何嵌入内核查看文件 <code>scripts/link-vmlinux.sh</code></p><h3 id="内核符号表结构"><a href="#内核符号表结构" class="headerlink" title="内核符号表结构"></a>内核符号表结构</h3><p>由工具 <code>scripts/kallsyms</code> 生成，工具源码在同目录，用法如下</p><pre><code>nm -n vmlinux | scripts/kallsyms [--all-symbols] &gt; symbols.S</code></pre><p>使用 nm 工具获得符号表之后进行整理得到汇编文件，包括 6 个全局变量</p><ul><li><code>kallsyms_addresses</code> 数组，存放所有符号的地址列表，按地址升序排列</li><li><code>kallsyms_num_syms</code> 符号的数量</li><li><code>kallsyms_names</code> 数组，存放所有符号的名称，和 <code>kallsyms_addresses</code> 一一对应</li><li><code>kallsyms_markers</code> 存储索引用于加速搜索</li><li><code>kallsyms_token_table</code> 数组，存储压缩字符串</li><li><code>kallsyms_token_index</code> 记录每个 token 首字符在 <code>kallsyms_token_table</code> 中的偏移</li></ul><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><pre><code>c0008000 T _textc0008000 T stextc000808c t __create_page_tables</code></pre><p>计算符号 <code>c000808c t __create_page_tables</code> 偏移为 <code>0x8c</code>，从 <code>kallsyms_addresses</code> 中得到索引为 <code>2</code></p><pre><code>kallsyms_addresses:     PTR _text + 0     PTR _text + 0     PTR _text + 0x8ckallsyms_names:    .byte 0x04, 0x9b, 0xef, 0x78, 0x74    .byte 0x05, 0x54, 0x5f, 0xef, 0x78, 0x74    .byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73kallsyms_markers:    PTR 0    PTR 2917    PTR 5993</code></pre><p>根据 <code>2 &gt;&gt; 8</code> 计算出在 <code>kallsyms_markers</code> 第一组 <code>PTR 0</code>，指出起始字符的偏移在 <code>kallsyms_names[0]</code>，同时根据 <code>2 &amp;&amp; 0xFF</code> 找到具体位置</p><p><code>.byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73</code> 为压缩字符，需要根据 <code>kallsyms_token_table</code> 解析</p><ul><li>0x0a 长度</li><li>0xff <code>t_</code></li><li>0xe1 <code>_c</code></li><li>0xf5 <code>re</code></li><li>0x8b <code>ate_</code></li><li>0xa7 <code>pa</code></li><li>0x18 <code>get_</code></li><li>0xfd <code>ta</code></li><li>0x62 <code>b</code></li><li>0xd2 <code>le</code></li><li>0x73 <code>s</code></li></ul><p><code>t__create_page_tables</code> 其中 <code>t</code> 为符号类型，去除之后为 <code>__create_page_tables</code></p><h3 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h3><p>内核文件参照 <code>kernel/kallsyms.c</code> 提供接口用于内核符号表查找</p><ul><li><code>get_symbol_pos</code> 根据地址查找索引及偏移</li><li><code>module_address_lookup</code> 内核模块符号查找</li><li><code>get_symbol_offset</code> 根据 <code>kallsyms_markers</code> 获取偏移</li><li><code>kallsyms_expand_symbol</code> 获取符号名</li><li><code>kallsyms_get_symbol_type</code> 获取符号类型</li></ul><p>例如函数 <code>kallsyms_lookup</code></p><pre><code class="c">if (is_ksym_addr(addr)) {    unsigned long pos;    pos = get_symbol_pos(addr, symbolsize, offset);    /* Grab name */    kallsyms_expand_symbol(get_symbol_offset(pos),                   namebuf, KSYM_NAME_LEN);    if (modname)        *modname = NULL;    return namebuf;}/* See if it&#39;s in a module. */return module_address_lookup(addr, symbolsize, offset, modname,                 namebuf);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;printk&lt;/code&gt; 可以根据地址打印函数名/符号名，记录内核符号表生成及使用过程&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="kallsyms" scheme="http://yoursite.com/tags/kallsyms/"/>
    
  </entry>
  
  <entry>
    <title>USB 通信设备类与 USB Dongle 拨号</title>
    <link href="http://yoursite.com/2020/03/11/usb-3g-and-usb-cdc/"/>
    <id>http://yoursite.com/2020/03/11/usb-3g-and-usb-cdc/</id>
    <published>2020-03-11T01:40:47.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<ul><li>USB 通信设备类</li><li>USB Dongle 拨号</li></ul><a id="more"></a><h2 id="Defined-Class-Codes"><a href="#Defined-Class-Codes" class="headerlink" title="Defined Class Codes"></a>Defined Class Codes</h2><p><a href="https://www.usb.org/defined-class-codes" target="_blank" rel="noopener">Defined Class Codes</a></p><p>例如：</p><ul><li><code>02h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass02h" target="_blank" rel="noopener">Communications and CDC Control</a></li><li><code>08h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass08h" target="_blank" rel="noopener">Mass Storage</a></li><li><code>09h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass09h" target="_blank" rel="noopener">Hub</a></li><li><code>0Ah</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass0Ah" target="_blank" rel="noopener">CDC-Data</a></li><li><code>EFh</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClassEFh" target="_blank" rel="noopener">Miscellaneous</a></li></ul><p>Linux4.9 <code>include/uapi/linux/usb/ch9.h</code> 可以看到各个定义值</p><h2 id="Communications-Class-Subclass-Codes"><a href="#Communications-Class-Subclass-Codes" class="headerlink" title="Communications Class Subclass Codes"></a>Communications Class Subclass Codes</h2><p>USB 的 CDC 类是 USB 通信设备类（Communication Device Class）的简称。CDC 类是 USB 组织定义的一类专门给各种通信设备（电信通信设备和中速网络通信设备）使用的 USB 子类。</p><p>具体列表见文档 Universal Serial Bus Class Definitions for Communications Devices 4.3章节：</p><ul><li><code>00h</code> RESERVED</li><li><code>01h</code> Direct Line Control Model [USBPSTN1.2]</li><li><code>02h</code> Abstract Control Model [USBPSTN1.2]</li><li><code>03h</code> Telephone Control Model [USBPSTN1.2]</li><li><code>04h</code> Multi-Channel Control Model [USBISDN1.2]</li><li><code>05h</code> CAPI Control Model [USBISDN1.2]</li><li><code>06h</code> Ethernet Networking Control Model [USBECM1.2]</li><li><code>07h</code> ATM Networking Control Model [USBATM1.2]</li><li><code>08h</code> Wireless Handset Control Model [USBWMC1.1]</li><li><code>09h</code> Device Management [USBWMC1.1]</li><li><code>0Ah</code> Mobile Direct Line Model [USBWMC1.1]</li><li><code>0Bh</code> OBEX [USBWMC1.1]</li><li><code>0Ch</code> Ethernet Emulation Model [USBEEM1.0]</li><li><code>0Dh</code> Network Control Model [USBNCM1.0]</li><li><code>0Eh</code> Mobile Broadband Interface Model [USBMBIM1.0]</li><li><code>0Dh-7Fh</code> RESERVED (future use)</li><li><code>80-FEh</code> RESERVED (vendor specific)</li></ul><h2 id="Linux4-9-内核实现"><a href="#Linux4-9-内核实现" class="headerlink" title="Linux4.9 内核实现"></a>Linux4.9 内核实现</h2><p>构造 USB 设备宏定义</p><pre><code class="c">/** * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces * @cl: bInterfaceClass value * @sc: bInterfaceSubClass value * @pr: bInterfaceProtocol value * * This macro is used to create a struct usb_device_id that matches a * specific class of interfaces. */#define USB_INTERFACE_INFO(cl, sc, pr) \    .match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \    .bInterfaceClass = (cl), \    .bInterfaceSubClass = (sc), \    .bInterfaceProtocol = (pr)</code></pre><p>例如：</p><pre><code class="c">/* Telit LE922A6 in MBIM composition */{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x1041, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),  .driver_info = (unsigned long)&amp;cdc_mbim_info_avoid_altsetting_toggle,},{    USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_EEM,            USB_CDC_PROTO_EEM),    .driver_info = (unsigned long) &amp;eem_info,},/* Telit LE910 V2 */{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x0036,    USB_CLASS_COMM,    USB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),  .driver_info = (unsigned long)&amp;wwan_noarp_info,},</code></pre><p>内核文件</p><pre><code class="shell">$ find -name &quot;cdc_*&quot;./include/linux/usb/cdc_ncm.h./drivers/net/usb/cdc_mbim.c./drivers/net/usb/cdc_ncm.c./drivers/net/usb/cdc_ether.c./drivers/net/usb/cdc_eem.c./drivers/net/usb/cdc_ether.o./drivers/net/usb/cdc_subset.c./Documentation/networking/cdc_mbim.txt</code></pre><h2 id="Rndis"><a href="#Rndis" class="headerlink" title="Rndis"></a>Rndis</h2><p>在文件 <code>drivers/net/usb/rndis_host.c</code> 中发现如下代码</p><pre><code class="c">static const struct usb_device_id   products [] = {{    /* 2Wire HomePortal 1000SW */    USB_DEVICE_AND_INTERFACE_INFO(0x1630, 0x0042,                      USB_CLASS_COMM, 2 /* ACM */, 0x0ff),    .driver_info = (unsigned long) &amp;rndis_poll_status_info,}, {    /* RNDIS is MSFT&#39;s un-official variant of CDC ACM */    USB_INTERFACE_INFO(USB_CLASS_COMM, 2 /* ACM */, 0x0ff),    .driver_info = (unsigned long) &amp;rndis_info,}, {    /* &quot;ActiveSync&quot; is an undocumented variant of RNDIS, used in WM5 */    USB_INTERFACE_INFO(USB_CLASS_MISC, 1, 1),    .driver_info = (unsigned long) &amp;rndis_poll_status_info,}, {    /* RNDIS for tethering */    USB_INTERFACE_INFO(USB_CLASS_WIRELESS_CONTROLLER, 1, 3),    .driver_info = (unsigned long) &amp;rndis_info,},    { },        // END};MODULE_DEVICE_TABLE(usb, products);</code></pre><blockquote><p>RNDIS是一个以太网端口 （ Ethernet port ）。最开始是微软控制的，用以取代 CDC Ethernet 的协议。Linux 支持它仅仅是因为微软不支持 CDC以太网标准。</p></blockquote><h2 id="USB-Dongle-拨号"><a href="#USB-Dongle-拨号" class="headerlink" title="USB Dongle 拨号"></a>USB Dongle 拨号</h2><blockquote><p>Many modern (and most LTE) usb modems provide <strong>qmi, mbim, ncm, rndis</strong> protocol for connection instead of legacy <strong>ppp</strong> protocol, they are faster and better, overall recommended. For more information:</p></blockquote><ul><li>qmi and mbim, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ltedongle" target="_blank" rel="noopener">How To Use LTE modem in QMI mode for WAN connection</a></li><li>ncm, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ethernetoverusb_ncm" target="_blank" rel="noopener">How To Use LTE modem in NCM mode for WAN connection</a></li><li>rndis, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ethernetoverusb_rndis" target="_blank" rel="noopener">How To Use LTE modem in RNDIS mode for WAN connection</a></li></ul><h2 id="内核设备列表"><a href="#内核设备列表" class="headerlink" title="内核设备列表"></a>内核设备列表</h2><p>USB 设备需要关心 <code>ProductID</code> 和 <code>VendorID</code>，用于表示某一种具体的设备，例如文件 <code>unusual_devs.h</code> 列举了非常规设备列表，表示这些设备需要特殊处理</p><pre><code class="c">/* * Reported by fangxiaozhi &lt;huananhu@huawei.com&gt; * This brings the HUAWEI data card devices into multi-port mode */UNUSUAL_DEV(  0x12d1, 0x1001, 0x0000, 0x0000,        &quot;HUAWEI MOBILE&quot;,        &quot;Mass Storage&quot;,        USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,        0),UNUSUAL_DEV(  0x12d1, 0x1003, 0x0000, 0x0000,        &quot;HUAWEI MOBILE&quot;,        &quot;Mass Storage&quot;,        USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,        0),</code></pre><h2 id="Add-New-USB-Dongle"><a href="#Add-New-USB-Dongle" class="headerlink" title="Add New USB Dongle"></a>Add New USB Dongle</h2><p>在内核中增加普通 USB Dongle 设备，修改 <code>drivers/usb/serial/option.c</code> 中的数组 <code>option_ids</code></p><pre><code class="c">{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1C0B, 0xff, 0xff, 0xff) },{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1C05, 0xff, 0xff, 0xff) },</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/kangear/article/details/37605811" target="_blank" rel="noopener">USB中CDC-ECM的了解和配置</a></li><li><a href="https://wenku.baidu.com/view/fd16907e011ca300a6c3903e.html" target="_blank" rel="noopener">RNDIS,ECM及MBIM报文简述</a></li><li><a href="https://openwrt.org/docs/guide-user/network/wan/wwan/3gdongle" target="_blank" rel="noopener">Use 3g/UMTS USB Dongle for WAN connection</a></li><li><a href="https://stackoverflow.com/questions/20299434/whats-different-in-usb-class-when-the-devices-are-modem" target="_blank" rel="noopener">What’s different in USB class when the devices are modem?</a></li><li><a href="https://www.iteye.com/blog/javatome-1205027" target="_blank" rel="noopener">Linux那些事儿之我是U盘(18)</a></li><li><a href="https://blog.csdn.net/cfy_phonex/article/details/22684005" target="_blank" rel="noopener">Android f_rndis 分析笔记</a></li><li><a href="https://wenku.baidu.com/view/a1e2c42d4b73f242336c5fa0.html" target="_blank" rel="noopener">RNDIS原理分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;USB 通信设备类&lt;/li&gt;
&lt;li&gt;USB Dongle 拨号&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="USB" scheme="http://yoursite.com/categories/Linux/USB/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="rndis" scheme="http://yoursite.com/tags/rndis/"/>
    
      <category term="usb" scheme="http://yoursite.com/tags/usb/"/>
    
      <category term="3g" scheme="http://yoursite.com/tags/3g/"/>
    
      <category term="ppp" scheme="http://yoursite.com/tags/ppp/"/>
    
      <category term="usb-cdc" scheme="http://yoursite.com/tags/usb-cdc/"/>
    
      <category term="ecm" scheme="http://yoursite.com/tags/ecm/"/>
    
      <category term="mbim" scheme="http://yoursite.com/tags/mbim/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核栈溢出检测</title>
    <link href="http://yoursite.com/2020/03/09/linux-kernel-stack/"/>
    <id>http://yoursite.com/2020/03/09/linux-kernel-stack/</id>
    <published>2020-03-09T02:22:33.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>监测内核栈使用情况，分析 crash 问题</p><a id="more"></a><p><code>thread_info</code> 位于内核栈底部，一旦溢出会破坏相关信息，有时会报错，但更多的是不直接报错，而是各种奇怪的panic</p><p><img src="/images/linux/kstack-smash.png" alt="kernel stack"></p><h2 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h2><p>开启 <code>debugfs</code> 使用如下方法监控内核栈的大小和深度</p><pre><code># mount -t debugfs nodev /sys/kernel/debug# echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled# cat /sys/kernel/debug/tracing/stack_max_size# cat /sys/kernel/debug/tracing/stack_trace</code></pre><h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><h3 id="CONFIG-DEBUG-STACK-USAGE"><a href="#CONFIG-DEBUG-STACK-USAGE" class="headerlink" title="CONFIG_DEBUG_STACK_USAGE"></a>CONFIG_DEBUG_STACK_USAGE</h3><pre><code>Symbol: DEBUG_STACK_USAGE [=y]Type  : booleanPrompt: Stack utilization instrumentation  Location:    -&gt; Kernel hacking(1)   -&gt; Memory Debugging  Defined at lib/Kconfig.debug:562  Depends on: DEBUG_KERNEL [=y] &amp;&amp; !IA64</code></pre><p>用于跟踪内核栈的溢出错误，一个内核栈溢出错误的明显的现象是产生 oops 错误却没有列出系统的调用栈信息。该选项将使内核进行栈溢出检查，并使内核进行栈使用的统计</p><h3 id="DEBUG-STACK-OVERFLOW"><a href="#DEBUG-STACK-OVERFLOW" class="headerlink" title="DEBUG_STACK_OVERFLOW"></a>DEBUG_STACK_OVERFLOW</h3><p>内核未提供 arm 配置选项，可以参照 <a href="https://www.alivepea.me/kernel/kernel-overflow/" target="_blank" rel="noopener">patch 检测内核的堆栈溢出</a></p><h3 id="CONFIG-STACK-TRACER"><a href="#CONFIG-STACK-TRACER" class="headerlink" title="CONFIG_STACK_TRACER"></a>CONFIG_STACK_TRACER</h3><pre><code>Symbol: STACK_TRACER [=n]   Type  : boolean   Prompt: Trace max stack     Location:       -&gt; Kernel hacking         -&gt; Tracers (FTRACE [=y])     Defined at kernel/trace/Kconfig:381     Depends on: TRACING_SUPPORT [=y] &amp;&amp; FTRACE [=y] &amp;&amp; HAVE_FUNCTION_TRACER [=y]     Selects: FUNCTION_TRACER [=n] &amp;&amp; STACKTRACE [=y] &amp;&amp; KALLSYMS [=y]</code></pre><p>参照文档 <code>Documentation/trace/ftrace.txt</code> 使用如下</p><pre><code># echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled# cat stack_max_size2928# cat stack_trace       Depth    Size   Location    (18 entries)       -----    ----   -------- 0)     2928     224   update_sd_lb_stats+0xbc/0x4ac 1)     2704     160   find_busiest_group+0x31/0x1f1 2)     2544     256   load_balance+0xd9/0x662 3)     2288      80   idle_balance+0xbb/0x130 4)     2208     128   __schedule+0x26e/0x5b9 5)     2080      16   schedule+0x64/0x66 6)     2064     128   schedule_timeout+0x34/0xe0 7)     1936     112   wait_for_common+0x97/0xf1 8)     1824      16   wait_for_completion+0x1d/0x1f 9)     1808     128   flush_work+0xfe/0x11910)     1680      16   tty_flush_to_ldisc+0x1e/0x2011)     1664      48   input_available_p+0x1d/0x5c12)     1616      48   n_tty_poll+0x6d/0x13413)     1568      64   tty_poll+0x64/0x7f14)     1504     880   do_select+0x31e/0x51115)      624     400   core_sys_select+0x177/0x21616)      224      96   sys_select+0x91/0xb917)      128     128   system_call_fastpath+0x16/0x1b</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监测内核栈使用情况，分析 crash 问题&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="debugfs" scheme="http://yoursite.com/tags/debugfs/"/>
    
      <category term="crash" scheme="http://yoursite.com/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>打印用户态段错误信息</title>
    <link href="http://yoursite.com/2020/03/05/linux-user-debug/"/>
    <id>http://yoursite.com/2020/03/05/linux-user-debug/</id>
    <published>2020-03-05T02:01:09.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>user_debug</code> 打印由用户态引起的 oops 信息</p><a id="more"></a><p><a href="https://www.cnblogs.com/lifexy/p/8045191.html" target="_blank" rel="noopener">Linux应用调试-修改内核来打印用户态的oops</a></p><ul><li>Linux 4.9</li><li>arm arch</li></ul><h2 id="Linux-内核错误处理"><a href="#Linux-内核错误处理" class="headerlink" title="Linux 内核错误处理"></a>Linux 内核错误处理</h2><p>文件 <code>arch/arm/mm/fsr-2level.c</code></p><pre><code class="c">{ do_bad,       SIGSEGV, 0,     &quot;vector exception&quot;         },{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },{ do_bad,       SIGKILL, 0,     &quot;terminal exception&quot;           },{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },{ do_translation_fault, SIGSEGV, SEGV_MAPERR,   &quot;section translation fault&quot;    },{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },{ do_page_fault,    SIGSEGV, SEGV_MAPERR,   &quot;page translation fault&quot;       },{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;section domain fault&quot;         },{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;page domain fault&quot;        },{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },{ do_sect_fault,    SIGSEGV, SEGV_ACCERR,   &quot;section permission fault&quot;     },{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },{ do_page_fault,    SIGSEGV, SEGV_ACCERR,   &quot;page permission fault&quot;        },</code></pre><ul><li><code>do_translation_fault</code> 调用 <code>do_bad_area</code></li><li><code>do_page_fault</code> 调用 <code>__do_user_fault</code> 或 <code>__do_kernel_fault</code></li><li><code>do_sect_fault</code> 调用 <code>do_bad_area</code></li></ul><pre><code class="c">/*                                                                               * Oops.  The kernel tried to access some page that wasn&#39;t present.              */                                                                             static void                                                                     __do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,             struct pt_regs *regs)                                                 {                                                                                   /*                                                                               * Are we prepared to handle this kernel fault?                                  */                                                                             if (fixup_exception(regs))                                                          return;                                                                     /*                                                                               * No handler, we&#39;ll have to terminate things with extreme prejudice.            */                                                                             bust_spinlocks(1);                                                              pr_alert(&quot;Unable to handle kernel %s at virtual address %08lx\n&quot;,                    (addr &lt; PAGE_SIZE) ? &quot;NULL pointer dereference&quot; :                               &quot;paging request&quot;, addr);                                                   show_pte(mm, addr);                                                             die(&quot;Oops&quot;, regs, fsr);                                                         bust_spinlocks(0);                                                              do_exit(SIGKILL);                                                           }/* * Something tried to access memory that isn&#39;t in our memory map.. * User mode accesses just cause a SIGSEGV */static void__do_user_fault(struct task_struct *tsk, unsigned long addr,        unsigned int fsr, unsigned int sig, int code,        struct pt_regs *regs){    struct siginfo si;#ifdef CONFIG_DEBUG_USER    if (((user_debug &amp; UDBG_SEGV) &amp;&amp; (sig == SIGSEGV)) ||        ((user_debug &amp; UDBG_BUS)  &amp;&amp; (sig == SIGBUS))) {        printk(KERN_DEBUG &quot;%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\n&quot;,               tsk-&gt;comm, sig, addr, fsr);        show_pte(tsk-&gt;mm, addr);        show_regs(regs);    }#endif    tsk-&gt;thread.address = addr;    tsk-&gt;thread.error_code = fsr;    tsk-&gt;thread.trap_no = 14;    si.si_signo = sig;    si.si_errno = 0;    si.si_code = code;    si.si_addr = (void __user *)addr;    force_sig_info(sig, &amp;si, tsk);}void do_bad_area(unsigned long addr, unsigned int fsr, struct pt_regs *regs){    struct task_struct *tsk = current;    struct mm_struct *mm = tsk-&gt;active_mm;    /*     * If we are in kernel mode at this point, we     * have no context to handle this fault with.     */    if (user_mode(regs))        __do_user_fault(tsk, addr, fsr, SIGSEGV, SEGV_MAPERR, regs);    else        __do_kernel_fault(mm, addr, fsr, regs);}</code></pre><p>可以看出 <code>__do_kernel_fault</code> 为内核态 oops 输出，<code>__do_user_fault</code> 为用户态输出，同时需要满足</p><ol><li>定义 <code>CONFIG_DEBUG_USER</code></li><li>设置 <code>user_debug</code></li></ol><h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><ul><li><code>Kernel hacking</code> -&gt; <code>Verbose user fault messages</code></li><li><code>user_debug</code> 见文档 <code>kernel-parameters.txt</code>，在 cmdline 中增加 <code>user_debug=31</code><pre><code class="txt">  user_debug= [KNL,ARM]          Format: &lt;int&gt;          See arch/arm/Kconfig.debug help text.              1 - undefined instruction events              2 - system calls              4 - invalid data aborts              8 - SIGSEGV faults              16 - SIGBUS faults          Example: user_debug=31</code></pre><pre><code class="c">unsigned int user_debug;static int __init user_debug_setup(char *str){  get_option(&amp;str, &amp;user_debug);  return 1;}__setup(&quot;user_debug=&quot;, user_debug_setup);</code></pre></li></ul><p>修改之后测试会输出调试信息，但不包括栈信息</p><h2 id="打印应用栈数据"><a href="#打印应用栈数据" class="headerlink" title="打印应用栈数据"></a>打印应用栈数据</h2><p>参考 <code>__do_kernel_fault</code> 中打印栈信息函数</p><pre><code class="c">if (!user_mode(regs) || in_interrupt()) {    dump_mem(KERN_EMERG, &quot;Stack: &quot;, regs-&gt;ARM_sp,         THREAD_SIZE + (unsigned long)task_stack_page(tsk));    dump_backtrace(regs, tsk);    dump_instr(KERN_EMERG, regs);}</code></pre><p>通过sp寄存器里存的栈地址，每打印一个栈地址里的32位数据, 栈地址便加4</p><p>在 <code>__do_user_fault</code> 中修改如下</p><pre><code class="c">unsigned long ret;unsigned long val;int i = 0;printk(&quot;Stack: \n&quot;);while(i &lt; 1024){    if(copy_from_user(&amp;val, (const void __user *)(regs-&gt;ARM_sp + i*4), 4)){        break;    }    i++;    printk(&quot;%08x &quot;, val);    if(i%8 == 0)        printk(&quot;\n&quot;);}printk(&quot;\n end of stack \n&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;user_debug&lt;/code&gt; 打印由用户态引起的 oops 信息&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="oops" scheme="http://yoursite.com/tags/oops/"/>
    
  </entry>
  
  <entry>
    <title>gcc 编译选项 -fomit-frame-pointer</title>
    <link href="http://yoursite.com/2020/02/26/gcc-options-fomit-frame-pointer/"/>
    <id>http://yoursite.com/2020/02/26/gcc-options-fomit-frame-pointer/</id>
    <published>2020-02-26T05:34:12.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>编译选项 <code>-fomit-frame-pointer</code> 与 <code>-fno-omit-frame-pointer</code> 对汇编及调试影响</p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>栈是向下生长的。所谓向下生长是指从 内存高地址 -&gt; 低地址 的路径延伸</li><li>有两个重要的指针用于维护栈信息<ul><li>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。  由于栈的地址大小是从上到下从大到小，所以ESP指在栈的最底端</li><li>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。指在栈的最顶端</li></ul></li></ul><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>手册中对 <code>-fomit-frame-pointer</code> 描述如下</p><blockquote><p>Don’t keep the frame pointer in a register for functions that don’t need one.  This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions.  It also makes debugging impossible on some machines.<br>Enabled at levels -O, -O2, -O3, -Os.</p></blockquote><p>当使用 <code>-O0</code> 时不会开启上述选项，编译器会在栈空间中保存额外信息用于调试，即 <code>frame pointer</code></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="c">int add(int a, int b){    return a + b ;}</code></pre><p>汇编对比如下</p><pre><code class="shell">$ gcc -fno-omit-frame-pointer test.c$ csky-elf-objdump -dS a.out00008934 &lt;add&gt;:    8934:    2470          subi    r0, r0, 8    8936:    9800          st    r8, (r0, 0)    8938:    2470          subi    r0, r0, 8    893a:    1208          mov    r8, r0    893c:    9208          st    r2, (r8, 0)    893e:    9318          st    r3, (r8, 4)    8940:    8608          ld    r6, (r8, 0)    8942:    8718          ld    r7, (r8, 4)    8944:    1c67          addu    r7, r7, r6    8946:    1272          mov    r2, r7    8948:    1280          mov    r0, r8    894a:    2070          addi    r0, r0, 8    894c:    8640          ld    r6, (r0, 16)    894e:    8800          ld    r8, (r0, 0)    8950:    2070          addi    r0, r0, 8    8952:    00cf          jmp    r15$ gcc -fomit-frame-pointer test.c$ objdump -dS a.out00008934 &lt;add&gt;:    8934:    2470          subi    r0, r0, 8    8936:    9200          st    r2, (r0, 0)    8938:    9310          st    r3, (r0, 4)    893a:    8600          ld    r6, (r0, 0)    893c:    8710          ld    r7, (r0, 4)    893e:    1c67          addu    r7, r7, r6    8940:    1272          mov    r2, r7    8942:    2070          addi    r0, r0, 8    8944:    8640          ld    r6, (r0, 16)    8946:    00cf          jmp    r15</code></pre><p>可以看到在栈上多开辟一些空间用于存储 <code>frame pointer</code></p><p>不开启优化时更能反映出压栈及出栈的操作，在这个过程中不会有 <code>fp</code> 操作</p><pre><code class="disass">00008934 &lt;add&gt;:    # 开辟栈空间 8B    8934:    2470          subi    r0, r0, 8    # 第一个参数 r2 入栈    8936:    9200          st    r2, (r0, 0)    # 第二个参数 r3 入栈    8938:    9310          st    r3, (r0, 4)    # 加载并执行子程序 a + b    893a:    8600          ld    r6, (r0, 0)    893c:    8710          ld    r7, (r0, 4)    893e:    1c67          addu    r7, r7, r6    # 赋值给 r2 作为函数返回值    8940:    1272          mov    r2, r7    # 释放栈    8942:    2070          addi    r0, r0, 8    8944:    8640          ld    r6, (r0, 16)    # 返回调用函数栈    8946:    00cf          jmp    r15</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/HedpatCzw/article/details/50380128" target="_blank" rel="noopener">关于-fno-omit-frame-pointer与-fomit-frame-pointer</a></li><li><a href="https://jijing.site/riscv/20190428_function_call.html" target="_blank" rel="noopener">C函数调用和汇编代码分析</a></li><li><a href="http://blog.sina.com.cn/s/blog_a558c25a0101l9yd.html" target="_blank" rel="noopener">Linux下Call Stack追溯的实现机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译选项 &lt;code&gt;-fomit-frame-pointer&lt;/code&gt; 与 &lt;code&gt;-fno-omit-frame-pointer&lt;/code&gt; 对汇编及调试影响&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
      <category term="bt" scheme="http://yoursite.com/tags/bt/"/>
    
      <category term="stack frame" scheme="http://yoursite.com/tags/stack-frame/"/>
    
  </entry>
  
  <entry>
    <title>基于 Markdown 生成幻灯片</title>
    <link href="http://yoursite.com/2020/02/17/pandoc-with-reveal-js/"/>
    <id>http://yoursite.com/2020/02/17/pandoc-with-reveal-js/</id>
    <published>2020-02-17T13:39:37.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>将 Markdown 转换为幻灯片</p><ul><li><a href="https://github.com/adamzap/landslide" target="_blank" rel="noopener">landslide</a> Generate HTML5 slideshows from markdown, ReST, or textile</li><li><a href="https://github.com/marp-team/marp" target="_blank" rel="noopener">Marp</a> Marp is the ecosystem to write your presentation with plain Markdown.</li><li><a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a></li><li><a href="https://github.com/jacksingleton/hacker-slides" target="_blank" rel="noopener">hacker-slides</a> You can write markdown on the left, and preview your presentation on the right.</li></ul><p>使用 Pandoc 和 <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">Reveal.js</a> 幻灯片演示框架将 Markdown 转换为幻灯片</p><a id="more"></a><h2 id="Pandoc-amp-Reveal-js"><a href="#Pandoc-amp-Reveal-js" class="headerlink" title="Pandoc &amp; Reveal.js"></a>Pandoc &amp; Reveal.js</h2><ul><li><a href="https://github.com/hakimel/reveal.js/releases" target="_blank" rel="noopener">reveal.js release</a> 将文件夹放在同目录</li><li>支持<a href="https://help.github.com/en/github/writing-on-github" target="_blank" rel="noopener">GitHub Markdown</a>语法</li><li>支持如下主题<ul><li>black: Black background, white text, blue links (default theme)</li><li>white: White background, black text, blue links</li><li>league: Gray background, white text, blue links (default theme for reveal.js &lt; 3.0.0)</li><li>beige: Beige background, dark text, brown links</li><li>sky: Blue background, thin dark text, blue links</li><li>night: Black background, thick white text, orange links</li><li>serif: Cappuccino background, gray text, brown links</li><li>simple: White background, black text, blue links</li><li>solarized: Cream-colored background, dark green text, blue links</li></ul></li></ul><pre><code class="shell">$ pandoc slides.md -o slides.html -t revealjs -s -V theme=beige</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://juejin.im/entry/5b20c950f265da6e1c4aed8e" target="_blank" rel="noopener">4 种基于 Markdown 的幻灯片生成器</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将 Markdown 转换为幻灯片&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/adamzap/landslide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;landslide&lt;/a&gt; Generate HTML5 slideshows from markdown, ReST, or textile&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/marp-team/marp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Marp&lt;/a&gt; Marp is the ecosystem to write your presentation with plain Markdown.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pandoc.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pandoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jacksingleton/hacker-slides&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hacker-slides&lt;/a&gt; You can write markdown on the left, and preview your presentation on the right.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 Pandoc 和 &lt;a href=&quot;https://github.com/hakimel/reveal.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reveal.js&lt;/a&gt; 幻灯片演示框架将 Markdown 转换为幻灯片&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Tools/Markdown/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="pandoc" scheme="http://yoursite.com/tags/pandoc/"/>
    
      <category term="reveal.js" scheme="http://yoursite.com/tags/reveal-js/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 发布 Hexo Blog</title>
    <link href="http://yoursite.com/2020/01/19/github-actions-ci-hexo/"/>
    <id>http://yoursite.com/2020/01/19/github-actions-ci-hexo/</id>
    <published>2020-01-19T09:16:07.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用 Travis CI 实现了自动生成并发布 Hexo 博客，现在切换到 GitHub Actions</p><a id="more"></a><h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><ul><li>源码仓库，私有</li><li>发布仓库，xxx.github.io</li></ul><p>有两种方式可以用于 GitHub Actions 发布 Blog</p><ul><li>ssh-key，分别提交 key 到两个仓库，参考 <a href="https://juejin.im/post/5da03d5e6fb9a04e046bc3a2" target="_blank" rel="noopener">用 GitHub Actions 自动化发布Hexo网站到 GitHub Pages</a></li><li>token，参考 <a href="https://www.jianshu.com/p/7940fe40885d" target="_blank" rel="noopener">Hexo 使用 Github Actions 自动更新</a></li></ul><h2 id="source仓库"><a href="#source仓库" class="headerlink" title="source仓库"></a>source仓库</h2><p>打开仓库设置，在 <code>Secrets</code> 选项中，点击 <code>Add a new secret</code>，新建 <code>GH_TOKEN</code></p><p>添加 <code>Github Actions</code> 文件</p><pre><code class="yaml">name: Hexo Auto-Deployon: [push]jobs:  build:    name: Hexo Auto-Deploy by GitHub Actions    runs-on: ubuntu-latest    steps:    - name: 1. git checkout...      uses: actions/checkout@v1    - name: 2. setup nodejs...      uses: actions/setup-node@v1    - name: 3. install hexo...      run: |        npm install hexo-cli -g        npm install    - name: 4. hexo generate public files...      run: |        hexo clean        hexo g      - name: 5. deploy &#39;public files&#39; to &#39;xxx.github.io&#39; repo...      env:        GH_REF: https://shenbo:${{ secrets.GH_TOKEN }}@github.com/shenbo/shenbo.github.io.git      run: |        git config --global user.name &quot;shenbo&quot;        git config --global user.email &quot;shenbo@hotmail.com&quot;        git clone ${GH_REF} hexo-public        cp -rf public/* hexo-public/                cd hexo-public        git add .        git commit -am &quot;Deployed by GitHub Actions ...&quot;        git push origin master</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前使用 Travis CI 实现了自动生成并发布 Hexo 博客，现在切换到 GitHub Actions&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Tools/Hexo/"/>
    
      <category term="CI" scheme="http://yoursite.com/categories/Tools/CI/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="ci" scheme="http://yoursite.com/tags/ci/"/>
    
      <category term="GitHub Actions" scheme="http://yoursite.com/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>32/64系统支撑库导致 Bear 编译失败</title>
    <link href="http://yoursite.com/2020/01/10/bear-cmake-error/"/>
    <id>http://yoursite.com/2020/01/10/bear-cmake-error/</id>
    <published>2020-01-10T03:27:38.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Bear 生成 <code>compile_commands.json</code> 时需要编译 32位库，记录错误及解决过程</p><a id="more"></a><h2 id="Bear"><a href="#Bear" class="headerlink" title="Bear"></a>Bear</h2><p>编译命令及错误</p><pre><code class="shell">$ cmake .. -DCMAKE_C_COMPILER_ARG1=&quot;-m32&quot;; VERBOSE=1 make all    Linking C executable cmTC_8b292    /usr/local/bin/cmake -E cmake_link_script CMakeFiles/cmTC_8b292.dir/link.txt --verbose=1    /usr/bin/cc -m32      -rdynamic CMakeFiles/cmTC_8b292.dir/testCCompiler.c.o  -o cmTC_8b292    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc    /usr/bin/ld: 找不到 -lgcc    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc    /usr/bin/ld: 找不到 -lgcc</code></pre><p>可以看到原因是找不到 <code>libgcc.a</code></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>系统为 <code>ubuntu18.04</code>，可以找到 <code>/usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a</code>，需要安装32位支持库</p><pre><code class="shell">$ sudo apt-cache search libgcclibgcc1 - GCC 支持库lib32gcc-7-dev - GCC support library (32 bit development files)$ sudo apt install lib32gcc-7-dev$ fd libgcc.agcc/x86_64-linux-gnu/7/32/libgcc.agcc/x86_64-linux-gnu/7/libgcc.a</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Bear 生成 &lt;code&gt;compile_commands.json&lt;/code&gt; 时需要编译 32位库，记录错误及解决过程&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Make" scheme="http://yoursite.com/categories/Tools/Make/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
      <category term="cmake" scheme="http://yoursite.com/tags/cmake/"/>
    
      <category term="make" scheme="http://yoursite.com/tags/make/"/>
    
      <category term="bear" scheme="http://yoursite.com/tags/bear/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 BRE ERE PCRE 区别</title>
    <link href="http://yoursite.com/2019/12/27/regular-expression/"/>
    <id>http://yoursite.com/2019/12/27/regular-expression/</id>
    <published>2019-12-27T06:35:30.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>了解正则表达式标准，各个之间存在一些差异</p><ul><li>BRE (Basic Regular Expressions)</li><li>ERE (Extended Regular Expressions)</li><li>PCRE (Perl Compatible Regular Expressions)</li></ul><a id="more"></a><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><table class="table table-bordered table-striped">  <thead>    <tr><th>What</th><th>Syntax</th><th>Comments/gotchas</th></tr>  </thead>  <tbody id="programs-languages" class="subgroup">    <tr><th colspan="3">Programming languages</th></tr>    <tr><td><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a></td><td>PCRE</td><td>PCRE is actually a separate implementation from Perl's, with <a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions#Differences_from_Perl" target="_blank" rel="noopener">slight differences</a></td></tr>    <tr><td><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code> standard lib</a></td><td>Python's own syntax (Perl-inspired)</td><td></td></tr>    <tr><td><a href="http://ruby-doc.org/core-2.2.0/Regexp.html" target="_blank" rel="noopener">Ruby</a></td><td>Ruby's own syntax (Perl-inspired)</td><td></td></tr>    <tr><td><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">Java's java.util.regex</a></td><td>Almost PCRE</td><td></td></tr>    <tr><td><a href="http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="noopener">Boost.Regex</a></td><td>PCRE</td><td></td></tr>  </tbody>  <tbody id="programs-editors" class="subgroup">    <tr><th colspan="3">Text editors</th></tr>    <tr><td><a href="http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html" target="_blank" rel="noopener">Eclipse</a></td><td>PCRE</td><td></td></tr>    <tr><td>Emacs</td><td>?</td><td></td></tr>    <tr><td>Netbeans</td><td>PCRE</td><td></td></tr>    <tr><td>Notepad++</td><td>PCRE (Boost.Regex)</td><td></td></tr>    <tr><td>PyCharm</td><td>PCRE</td><td>Perl-inspired</td></tr>    <tr><td>Sublime Text</td><td>?</td><td></td></tr>    <tr><td>UltraEdit</td><td>PCRE</td><td></td></tr>    <tr><td>ViM</td><td>ViM</td><td></td></tr>  </tbody>  <tbody id="programs-cmdline" class="subgroup">    <tr><th colspan="3">Command-line tools</th></tr>    <tr><td>awk</td><td>ERE</td><td>might depend on the implementation</td></tr>    <tr><td>grep</td><td>BRE, <code>egrep</code> for ERE, <code>grep -P</code> for PCRE (optional)</td><td></td></tr>    <tr><td>less</td><td>ERE</td><td>usually; man page says "regular expression library supplied by your system"</td></tr>    <tr><td>screen</td><td>plain text</td><td></td></tr>    <tr><td>sed</td><td>BRE, <code>-E</code> switches to ERE</td><td></td></tr>  </tbody></table><h2 id="语法差异"><a href="#语法差异" class="headerlink" title="语法差异"></a>语法差异</h2><table class="table table-bordered table-striped">  <thead>    <tr><th>What</th><th><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a>/PCRE</th><th><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code></a></th><th>POSIX (BRE)</th><th>POSIX extended (ERE)</th><th>ViM</th></tr>  </thead>  <tbody id="syntax-basics" class="subgroup">    <tr><th colspan="6">Basics</th></tr>    <tr><td>Custom character class</td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td></tr>    <tr><td>Negated custom character class</td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td></tr>    <tr><td>\ special in class?</td><td>yes</td><td>yes</td><td>no, <code>]</code> escaped if comes first</td><td>no, <code>]</code> escaped if comes first</td><td>yes</td></tr>    <tr><td>Ranges</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td><code>[a-z]</code>, <code>-</code> escaped if first or last</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td></td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td></tr>    <tr><td>Alternation</td><td><code>|</code></td><td><code>|</code></td><td><code>\|</code></td><td><code>|</code></td><td><code>\|</code> <code>\&amp;</code> (low precedence)</td></tr>    <tr><td>Escaped character</td><td><code>\033</code> <code>\x1B</code> <code>\x{1234}</code> <code>\N{name}</code> <code>\N{U+263D}</code></td><td><code>\x12</code></td><td class="na"></td><td class="na"></td><td><code>\%d123</code> <code>\%x2A</code> <code>\%u1234</code> <code>\%U1234ABCD</code></td></tr>  </tbody>  <tbody id="syntax-characters" class="subgroup">    <tr><th colspan="6">Character classes</th></tr>    <tr><td>Any character (except newline)</td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td></tr>    <tr><td>Any character (including newline)</td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\_.</code></td></tr>    <tr><td>Match a "word" character (alphanumeric plus <code>_</code>)</td><td><code>\w</code> <code>[[:word:]]</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td></tr>    <tr><td>Case</td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td class="na"></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>\u</code> <code>[[:upper:]]</code> / <code>\l</code> <code>[[:lower:]]</code></td></tr>    <tr><td>Match a non-"word" character</td><td><code>\W</code></td><td><code>\W</code></td><td class="na"></td><td class="na"></td><td><code>\W</code></td></tr>    <tr><td>Match a whitespace character (except newline)</td><td class="na"></td><td class="na"></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td></tr>    <tr><td>Whitespace including newline</td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code></td><td class="na"></td><td class="na"></td><td><code>\_s</code></td></tr>    <tr><td>Match a non-whitespace character</td><td><code>\S</code></td><td><code>\S</code></td><td><code>[^[:space:]]</code></td><td><code>[^[:space:]]</code></td><td><code>\S</code> <code>[^[:space:]]</code></td></tr>    <tr><td>Match a digit character</td><td><code>\d</code> <code>[[:digit:]]</code></td><td><code>\d</code></td><td><code>[[:digit:]]</code></td><td><code>[[:digit:]]</code></td><td><code>\d</code> <code>[[:digit:]]</code></td></tr>    <tr><td>Match a non-digit character</td><td><code>\D</code></td><td><code>\D</code></td><td><code>[^[:digit:]]</code></td><td><code>[^[:digit:]]</code></td><td><code>\D</code> <code>[^[:digit:]]</code></td></tr>    <tr><td>Any hexadecimal digit</td><td><code>[[:xdigit:]]</code></td><td class="na"></td><td><code>[[:xdigit:]]</code></td><td><code>[[:xdigit:]]</code></td><td><code>\x</code> <code>[[:xdigit:]]</code></td></tr>    <tr><td>Any octal digit</td><td></td><td class="na"></td><td></td><td></td><td><code>\o</code></td></tr>    <tr><td>Any graphical character excluding "word" characters</td><td><code>[[:punct:]]</code></td><td class="na"></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td></tr>    <tr><td>Any alphabetical character</td><td><code>[[:alpha:]]</code></td><td class="na"></td><td><code>[[:alpha:]]</code></td><td><code>[[:alpha:]]</code></td><td><code>\a</code> <code>[[:alpha:]]</code></td></tr>    <tr><td>Non-alphabetical character</td><td></td><td class="na"></td><td><code>[^[:alpha:]]</code></td><td><code>[^[:alpha:]]</code></td><td><code>\A</code> <code>[^[:alpha:]]</code></td></tr>    <tr><td>Any alphanumerical character</td><td><code>[[:alnum:]]</code></td><td class="na"></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td></tr>    <tr><td>ASCII</td><td><code>[[:ascii:]]</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>Character equivalents (e = é = è) (as per locale)</td><td></td><td class="na"></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td></tr>  </tbody>  <tbody id="syntax-assert" class="subgroup">    <tr><th colspan="6">Zero-width assertions</th></tr>    <tr><td>Word boundary</td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\&lt;</code> / <code>\&gt;</code></td></tr>    <tr><td>Anywhere but word boundary</td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td class="na"></td></tr>    <tr><td>Beginning of line/string</td><td><code>^</code> / <code>\A</code></td><td><code>^</code> / <code>\A</code></td><td><code>^</code></td><td><code>^</code></td><td><code>^</code> (beginning of pattern ) <code>\_^</code></td></tr>    <tr><td>End of line/string</td><td><code>$</code> / <code>\Z</code></td><td><code>$</code> / <code>\Z</code></td><td><code>$</code></td><td><code>$</code></td><td><code>$</code> (end of pattern) <code>\_$</code></td></tr>  </tbody>  <tbody id="syntax-groups" class="subgroup">    <tr><th colspan="6">Captures and groups</th></tr>    <tr><td>Capturing group</td><td><code>(...)</code> <code>(?&lt;name&gt;...)</code></td><td><code>(...)</code> <code>(?P&lt;name&gt;...)</code></td><td><code>\(...\)</code></td><td><code>(...)</code></td><td><code>\(...\)</code></td></tr>    <tr><td>Non-capturing group</td><td><code>(?:...)</code></td><td><code>(?:...)</code></td><td class="na"></td><td class="na"></td><td><code>\%(...\)</code></td></tr>    <tr><td>Backreference to a specific group.</td><td><code>\1</code> <code>\g1</code> <code>\g{-1}</code></td><td><code>\1</code></td><td><code>\1</code></td><td><code>\1</code> non-official</td><td><code>\1</code></td></tr>    <tr><td>Named backreference</td><td><code>\g{name}</code> <code>\k&lt;name&gt;</code></td><td><code>(?P=name)</code></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>  </tbody>  <tbody id="syntax-lookaround" class="subgroup">    <tr><th colspan="6">Look-around</th></tr>    <tr><td>Positive look-ahead</td><td><code>(?=...)</code></td><td><code>(?=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@=</code></td></tr>    <tr><td>Negative look-ahead</td><td><code>(?!...)</code></td><td><code>(?!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@!</code></td></tr>    <tr><td>Positive look-behind</td><td><code>(?&lt;=...)</code></td><td><code>(?&lt;=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;=</code></td></tr>    <tr><td>Negative look-behind</td><td><code>(?&lt;!...)</code></td><td><code>(?&lt;!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;!</code></td></tr>  </tbody>  <tbody id="syntax-multiplicity" class="subgroup">    <tr><th colspan="6">Multiplicity</th></tr>    <tr><td>0 or 1</td><td><code>?</code></td><td><code>?</code></td><td><code>\?</code></td><td><code>?</code></td><td><code>\?</code></td></tr>    <tr><td>0 or more</td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td></tr>    <tr><td>1 or more</td><td><code>+</code></td><td><code>+</code></td><td><code>\+</code></td><td><code>+</code></td><td><code>\+</code></td></tr>    <tr><td>Specific number</td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n\}</code> <code>\{n,m\}</code> <code>\{n,\}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n}</code> <code>\{n,m}</code> <code>\{n,}</code></td></tr>    <tr><td>0 or 1, non-greedy</td><td><code>??</code></td><td><code>??</code></td><td class="na"></td><td class="na"></td><td></td></tr>    <tr><td>0 or more, non-greedy</td><td><code>*?</code></td><td><code>*?</code></td><td class="na"></td><td class="na"></td><td><code>\{-}</code></td></tr>    <tr><td>1 or more, non-greedy</td><td><code>+?</code></td><td><code>+?</code></td><td class="na"></td><td class="na"></td><td></td></tr>    <tr><td>Specific number, non-greedy</td><td><code>{n,m}?</code> <code>{n,}?</code></td><td><code>{n,m}?</code> <code>{n,}?</code></td><td class="na"></td><td class="na"></td><td><code>\{-n,m}</code> <code>\{-n,}</code></td></tr>    <tr><td>0 or 1, don't give back on backtrack</td><td><code>?+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>0 or more, don't give back on backtrack</td><td><code>*+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>1 or more, don't give back on backtrack</td><td><code>++</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>Specific number, don't give back on backtrack</td><td><code>{n,m}+</code> <code>{n,}+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>  </tbody>  <tbody id="syntax-other" class="subgroup">    <tr><th colspan="6">Other</th></tr>    <tr><td>Independent non-backtracking pattern</td><td><code>(?&gt;...)</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&gt;</code></td></tr>    <tr><td>Make case-sensitive/insensitive</td><td><code>(?i)</code> / <code>(?-i)</code></td><td><code>(?i)</code> / <code>(?-i)</code></td><td class="na"></td><td class="na"></td><td><code>\c</code> / <code>\C</code></td></tr>  </tbody></table><p>BRE ERE 需要注意 <code>()</code> <code>{}</code> 的区别，另外都不支持 <code>\d\D</code></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://liujiacai.net/blog/2014/12/07/regexp-favors/" target="_blank" rel="noopener">正则表达式“派别”简述</a></li><li><a href="https://en.wikipedia.org/wiki/Regular_expression#Character_classes" target="_blank" rel="noopener">Regular expression</a></li><li><a href="https://blog.csdn.net/yufenghyc/article/details/51078107" target="_blank" rel="noopener">grep中使用”\d”匹配数字不成功的原因</a></li><li><a href="https://remram44.github.io/regex-cheatsheet/regex.html" target="_blank" rel="noopener">Regex cheatsheet</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解正则表达式标准，各个之间存在一些差异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BRE (Basic Regular Expressions)&lt;/li&gt;
&lt;li&gt;ERE (Extended Regular Expressions)&lt;/li&gt;
&lt;li&gt;PCRE (Perl Compatible Regular Expressions)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="RE" scheme="http://yoursite.com/categories/Tools/RE/"/>
    
    
      <category term="grep" scheme="http://yoursite.com/tags/grep/"/>
    
      <category term="sed" scheme="http://yoursite.com/tags/sed/"/>
    
      <category term="awk" scheme="http://yoursite.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Doxygen 注释语法</title>
    <link href="http://yoursite.com/2019/12/27/doxygen-syntax/"/>
    <id>http://yoursite.com/2019/12/27/doxygen-syntax/</id>
    <published>2019-12-27T02:20:07.000Z</published>
    <updated>2020-05-12T02:31:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Doxygen 来生成文档需要遵从的注释语法</p><a id="more"></a><h2 id="开源工程"><a href="#开源工程" class="headerlink" title="开源工程"></a>开源工程</h2><p>可以搜索参考用法</p><ul><li><a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></li><li><a href="https://github.com/LiamBindle/MQTT-C.git" target="_blank" rel="noopener">MQTT</a></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释块<pre><code>/*** comment text here*/int x = 0;</code></pre></li><li>行尾注释<pre><code>int x = 0; ///&lt; comment text here</code></pre></li><li>单行注释<pre><code>/// comment text hereint x = 0;</code></pre></li></ul><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>注释块中可以使用一些特殊的标记，比如 <code>brief</code> 标记，官方称为 <code>Special Commands</code></p><ul><li><a href="http://www.doxygen.nl/manual/commands.html" target="_blank" rel="noopener">Special Commands</a></li><li><a href="https://www.cnblogs.com/benhuan/p/3302114.html" target="_blank" rel="noopener">翻译</a></li></ul><p>例如</p><ul><li><code>\struct &lt;name&gt; [&lt;header-file&gt;] [&lt;header-name&gt;]</code></li><li><code>\typedef (typedef declaration)</code></li><li><code>\brief { brief description }</code></li></ul><p>标记可以有两种书写方式 <code>\param</code> 或者 <code>@param</code>，每个命令有一个或多个参数，每个参数都有明确的范围：</p><ul><li><code>&lt;&gt;</code> 参数是一个单独单词</li><li><code>()</code> 参数一直到命令所在的结束</li><li><code>[]</code> 参数是可选的</li><li><code>{}</code> 参数一直延伸到本段结束。一个段落的结束以一个空行来标识，或者是一个段落标记</li></ul><h2 id="常用标记"><a href="#常用标记" class="headerlink" title="常用标记"></a>常用标记</h2><ul><li><code>\brief { brief description }</code> 可以省略</li><li><code>\param &#39;[&#39;dir&#39;]&#39; &lt;parameter-name&gt; { parameter description }</code><pre><code>/*** @param[out] dest The memory area to copy to.* @param[in]  src  The memory area to copy from.* @param[in]  n    The number of bytes to copy*/void memcpy(void *dest, const void *src, size_t n);</code></pre></li><li><code>\return { description of the return value }</code> 返回说明</li><li><code>\retval &lt;return value&gt; { description }</code> 返回值</li><li><code>\ref &lt;name&gt; [&quot;(text)&quot;]</code> 引用<pre><code>/*** @return 程序执行成功与否*     @retval 0 程序执行成功*     @retval 1 程序执行失败* @note 这里只是一个简单的例子*/int main(int argc, char* argv[])</code></pre></li><li><code>\note { text }</code> 标注需要特别注意的地方</li><li><code>\deprecated { description }</code></li><li><code>\warning { warning message }</code> 接口容易出错的地方</li><li><code>\sa { references }</code> <code>\see { references }</code></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Example <a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></p><pre><code>*** Initialize the AVCodecContext to use the given AVCodec. Prior to using this* function the context has to be allocated with avcodec_alloc_context3().** The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),* avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for* retrieving a codec.** @warning This function is not thread safe!** @note Always call this function before using decoding routines (such as* @ref avcodec_receive_frame()).** @code* avcodec_register_all();* av_dict_set(&amp;opts, &quot;b&quot;, &quot;2.5M&quot;, 0);* codec = avcodec_find_decoder(AV_CODEC_ID_H264);* if (!codec)*     exit(1);** context = avcodec_alloc_context3(codec);** if (avcodec_open2(context, codec, opts) &lt; 0)*     exit(1);* @endcode** @param avctx The context to initialize.* @param codec The codec to open this context for. If a non-NULL codec has been*              previously passed to avcodec_alloc_context3() or*              for this context, then this parameter MUST be either NULL or*              equal to the previously passed codec.* @param options A dictionary filled with AVCodecContext and codec-private options.*                On return this object will be filled with options that were not found.** @return zero on success, a negative value on error* @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),*      av_dict_set(), av_opt_find().*/</code></pre><p>注释 <code>struct</code></p><pre><code>/** * @struct AC3HeaderInfo * Coded AC-3 header values up to the lfeon element, plus derived values. */typedef struct AC3HeaderInfo {    /** @name Coded elements     * @{     */    uint16_t sync_word;    uint16_t crc1;    uint8_t sr_code;    uint8_t bitstream_id;    uint8_t bitstream_mode;    uint8_t channel_mode;    uint8_t lfe_on;    uint8_t frame_type;    int substreamid;                        ///&lt; substream identification    int center_mix_level;                   ///&lt; Center mix level index    int surround_mix_level;                 ///&lt; Surround mix level index    uint16_t channel_map;    int num_blocks;                         ///&lt; number of audio blocks    int dolby_surround_mode;    /** @} */    /** @name Derived values     * @{     */    uint8_t sr_shift;    uint16_t sample_rate;    uint32_t bit_rate;    uint8_t channels;    uint16_t frame_size;    uint64_t channel_layout;    /** @} */} AC3HeaderInfo;/** * @brief Example class的简易说明 * * 本范例说明Example class。 * 这是一个极为简单的范例。 * */class Example {    private:        int var1 ; ///&lt; 这是一个private的变数    public:        int var2 ; ///&lt; 这是一个public的变数成员。        int var3 ; ///&lt; 这是另一个public的变数成员。        void ExFunc1(void);        int ExFunc2(int a, char b);        char *ExFunc3(char *c) ;};</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="http://blog.guorongfei.com/2016/11/20/doxygen-usage/" target="_blank" rel="noopener">使用 Doxygen 生成文档注释</a></li><li><a href="http://www.doxygen.nl/manual/index.html" target="_blank" rel="noopener">Doxygen Manual</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Doxygen 来生成文档需要遵从的注释语法&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Doxygen" scheme="http://yoursite.com/categories/Tools/Doxygen/"/>
    
    
      <category term="doxygen" scheme="http://yoursite.com/tags/doxygen/"/>
    
  </entry>
  
</feed>
