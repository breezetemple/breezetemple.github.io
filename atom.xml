<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT日记</title>
  
  <subtitle>Life is Now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-11T03:39:19.051Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Breeze.Temple</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分析 ELF 段和符号大小</title>
    <link href="http://yoursite.com/2020/07/31/how-to-analyze-size-of-ELF-sections-and-symbol/"/>
    <id>http://yoursite.com/2020/07/31/how-to-analyze-size-of-ELF-sections-and-symbol/</id>
    <published>2020-07-31T06:55:21.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>使用工具分析 ELF 以了解内存占用</p><ul><li>nm</li><li>size</li><li>readelf</li></ul><a id="more"></a><h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h2><pre><code class="shell">$ nm --print-size --size-sort a.out$ nm --print-size --size-sort --radix=d a.out</code></pre><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><pre><code class="shell">$ size a.out   text       data        bss        dec        hex    filename   1900        628         16       2544        9f0    a.out$ size -A -d a.out</code></pre><h2 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h2><pre><code class="shell">$ readelf -e a.out</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用工具分析 ELF 以了解内存占用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nm&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;readelf&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Linker" scheme="http://yoursite.com/categories/C/Linker/"/>
    
    
      <category term="nm" scheme="http://yoursite.com/tags/nm/"/>
    
      <category term="size" scheme="http://yoursite.com/tags/size/"/>
    
  </entry>
  
  <entry>
    <title>如何调试嵌入式系统</title>
    <link href="http://yoursite.com/2020/07/23/how-to-debug-an-embedded-system/"/>
    <id>http://yoursite.com/2020/07/23/how-to-debug-an-embedded-system/</id>
    <published>2020-07-23T01:50:47.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>嵌入式系统调试的两种方式：</p><ul><li>Software Debugger<ul><li>gdbserver</li><li>redboot</li></ul></li><li>Hardware Debugger<ul><li>jtag</li><li>swd</li><li>jlink</li></ul></li></ul><a id="more"></a><h2 id="Software-Debugger"><a href="#Software-Debugger" class="headerlink" title="Software Debugger"></a>Software Debugger</h2><p><img src="/images/gnu/1595471565914.png" alt="gdbserver典型应用场景"></p><ul><li><code>gdb</code> 运行于宿主机</li><li><code>gdbserver</code> 运行于目标机，核心依赖于 <code>ptrace</code>，是轻量级的GDB调试器，担任着调试代理的角色</li><li>使用网口/串口连接通信</li></ul><p><img src="/images/gnu/1595471933130.png" alt="本地调试与远程调试"></p><h3 id="gdbserver"><a href="#gdbserver" class="headerlink" title="gdbserver"></a>gdbserver</h3><h3 id="redboot"><a href="#redboot" class="headerlink" title="redboot"></a>redboot</h3><p>eCos redboot 包含有 <code>GDB stub</code>，可当作 <code>GDB Server</code> 用</p><h2 id="Hardware-Debugger"><a href="#Hardware-Debugger" class="headerlink" title="Hardware Debugger"></a>Hardware Debugger</h2><p><img src="/images/gnu/1595471003633.png" alt="jtag典型应用场景"></p><ul><li><code>gdb</code> 运行于宿主机</li><li>需要硬件仿真器</li><li>需要芯片支持</li></ul><h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>OpenOCD（Open On-Chip Debugger）开源片上调试器，<strong>是一款开源软件</strong>。旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能。是在仿真器的辅助下完成的，仿真器是能够提供调试目标的电信号的小型硬件单元。<strong>仿真器是必须的</strong>，因为宿主机通常不具备这种电信号的直接解析功能。</p><p><img src="/images/gnu/1595472703759.png" alt="1595472703759"></p><p><img src="/images/gnu/1595473016901.png" alt="1595473016901"></p><p>分为三部分，详见<a href="https://www.slideshare.net/linaroorg/hkg18403-introducing-openocd-status-of-openocd-on-aarch64" target="_blank" rel="noopener">Introducing OpenOCD: Status of OpenOCD on AArch64</a>：</p><ul><li>Development Hardware</li><li>Debug Adapter</li><li>Host Computer</li></ul><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ol><li>Linux<ul><li>使用 JTAG 仿真器调试 Linux 内核</li><li>使用 gdbserver 调试 Linux 应用</li><li>同时使用</li><li><a href="https://blog.csdn.net/yifeng_1118/article/details/66480266" target="_blank" rel="noopener">JTAG调试内核和gdbserver冲突问题</a></li></ul></li><li>eCos<ul><li>使用 JTAG 仿真器调试，带有硬件断点/watch</li><li>使用 RedBoot 调试</li></ul></li><li>OpenOCD<ul><li>JTAG ?</li><li>SWD ?</li><li>gdbserver ?</li></ul></li></ol><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ol><li><a href="https://www.cnblogs.com/ccxikka/p/10519518.html" target="_blank" rel="noopener">gdb调试原理及qemu中的gdbserver</a></li><li><a href="https://stackoverflow.com/questions/13496389/gdb-remote-protocol-how-to-analyse-packets" target="_blank" rel="noopener">GDB remote protocol: how to analyse packets?</a></li><li><a href="https://doc.ecoscentric.com/cdt-guide/ch-debug.html" target="_blank" rel="noopener">Debugging eCos applications</a></li><li><a href="https://en.wikipedia.org/wiki/Gdbserver" target="_blank" rel="noopener">gdbserver</a></li><li><a href="https://blog.csdn.net/LEON1741/article/details/72846434" target="_blank" rel="noopener">浅论各种调试接口的区别</a></li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/jtag-debugging/index.html#" target="_blank" rel="noopener">OpenOCD JTAG 调试</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嵌入式系统调试的两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Software Debugger&lt;ul&gt;
&lt;li&gt;gdbserver&lt;/li&gt;
&lt;li&gt;redboot&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hardware Debugger&lt;ul&gt;
&lt;li&gt;jtag&lt;/li&gt;
&lt;li&gt;swd&lt;/li&gt;
&lt;li&gt;jlink&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
      <category term="jtag" scheme="http://yoursite.com/tags/jtag/"/>
    
      <category term="gdbserver" scheme="http://yoursite.com/tags/gdbserver/"/>
    
      <category term="jlink" scheme="http://yoursite.com/tags/jlink/"/>
    
      <category term="swd" scheme="http://yoursite.com/tags/swd/"/>
    
      <category term="openocd" scheme="http://yoursite.com/tags/openocd/"/>
    
  </entry>
  
  <entry>
    <title>如何正确拷贝字符串</title>
    <link href="http://yoursite.com/2020/07/20/how-to-copy-string-correctly/"/>
    <id>http://yoursite.com/2020/07/20/how-to-copy-string-correctly/</id>
    <published>2020-07-20T02:23:56.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<ul><li>strcpy</li><li>strncpy</li><li>memcpy</li><li>snprintf</li><li>strlen</li><li>sizeof</li></ul><p>正确无隐患拷贝字符串</p><a id="more"></a><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p><code>strlen</code> 运行时计算字符串长度，当字符数组中不存在 <code>\0</code> 时，计算错误</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p><code>sizeof</code> 编译时计算分配空间，字符数组大小</p><h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><pre><code class="c">    char *strcpy(char *dest, const char *src);</code></pre><p><code>strcpy</code> 提供字符串的复制，只用于字符串复制，会复制字符串的结束符。不需要指定长度，它遇到被复制字符的串结束符 <code>\0</code> 才结束，所以容易溢出</p><h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h2><pre><code class="c">    char *strncpy(char *dest, const char *src, size_t n);</code></pre><p><code>strncpy</code> 把src所指由 <code>\0</code> 结束的字符串的前n个字节复制到dest所指的数组中</p><ul><li>如果src的前n个字节不含 <code>\0</code> 字符，则结果不会以 <code>\0</code> 字符结束，<strong>对dest进行字符串运行会导致出错</strong></li><li>如果src的长度小于n个字节，则以 <code>\0</code> 填充dest直到复制完n个字节，<strong>效率低下</strong></li><li>src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串</li></ul><p><code>strncpy</code> 正确用法</p><pre><code class="c">// solution Achar dest[MAX];strncpy(dest, src, sizeof(dest)-1);dest[MAX-1] = &#39;\0&#39;;// solution Bchar dest[MAX];memset(dest, 0, sizeof(dest));strncpy(dest, src, sizeof(dest)-1);</code></pre><h2 id="正确用法"><a href="#正确用法" class="headerlink" title="正确用法"></a>正确用法</h2><ul><li>通用用法：<code>snprintf</code></li><li>性能用法：<code>memcpy</code></li></ul><h3 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf"></a>snprintf</h3><pre><code class="c">int snprintf(char *str, size_t size, const char *format, ...);</code></pre><p>使用 <code>snprintf</code> 进行字符串拷贝，防止溢出，<code>snprintf</code> 会把buf的最后一个位置保留为 <code>\0</code></p><pre><code class="c">snprintf(dest, sizeof(dest), &quot;%s&quot;, src);</code></pre><blockquote><p>当 src 长度远大于 dest 时，由于 <code>snprintf</code> 要返回 src 的字节数，需要扫描 src，会产生性能损失</p></blockquote><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><pre><code class="c">void *memcpy(void *dest, const void *src, size_t n);</code></pre><p><code>memcpy</code> 提供了一般内存的复制，对于需要复制的内容没有限制。需要考虑字符串拷贝性能时使用 <code>strlen</code> + <code>memcpy</code></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;strcpy&lt;/li&gt;
&lt;li&gt;strncpy&lt;/li&gt;
&lt;li&gt;memcpy&lt;/li&gt;
&lt;li&gt;snprintf&lt;/li&gt;
&lt;li&gt;strlen&lt;/li&gt;
&lt;li&gt;sizeof&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确无隐患拷贝字符串&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Functions" scheme="http://yoursite.com/categories/C/Functions/"/>
    
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>eCos 组件初始化</title>
    <link href="http://yoursite.com/2020/07/11/ecos-component-initialization/"/>
    <id>http://yoursite.com/2020/07/11/ecos-component-initialization/</id>
    <published>2020-07-11T02:57:29.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>eCos 组件注册及初始化</p><a id="more"></a><h2 id="eCos-组件初始化机制"><a href="#eCos-组件初始化机制" class="headerlink" title="eCos 组件初始化机制"></a>eCos 组件初始化机制</h2><blockquote><p>eCos 组件初始化利用了 C++ 静态对象实例初始化的机制</p></blockquote><p>C++ 对象在初始化时将会调用该对象类的构造函数来初始化对象</p><ul><li>对象在函数内声明，那么函数执行到对象的声明处调用类构造函数来初始化对象</li><li>对象在函数外声明，也就是<strong>将对象声明为全局对象或静态对象</strong>，那么编译器会将该对象的初始化代码地址（函数指针）写到名为 <code>.ctors</code> 节，普通程序在进入 main 函数前由操作系统的运行时库调用存储在 <code>.ctors</code> 中的函数指针列表来初始化全局或静态对象</li></ul><p>eCos HAL将调用 <code>cyg_hal_invoke_constructors</code> 函数，该函数调用存储在 <code>.ctors</code> 节中的初始化代码</p><h2 id="组件初始化"><a href="#组件初始化" class="headerlink" title="组件初始化"></a>组件初始化</h2><p>IO 组件</p><pre><code class="cxx">externC void cyg_io_init(void);class cyg_io_init_class {public:    cyg_io_init_class(void) {        cyg_io_init();    }};// And here&#39;s an instance of the class just to make the code runstatic cyg_io_init_class _cyg_io_init CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_IO);</code></pre><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><blockquote><p>初始化过程需要按照一定的次序进行。次序由 <code>CYGBLD_ATTRIB_INIT_PRI</code> 宏指定，该宏带有一个参数，该参数数值越小，那么越早调用该实例的初始化代码</p></blockquote><p>例如 <code>CYGBLD_ATTRIB_INIT_PRI(CYG_INIT_IO)</code> 展开为 <code>__attribute__((init_priority(49000)))</code></p><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>组件定义</p><pre><code class="cxx">#define MOD_IRR         cyg_irr_init_class        irr0       CYGBLD_ATTRIB_INIT_PRI( 60100 );</code></pre><h2 id="检查初始化代码"><a href="#检查初始化代码" class="headerlink" title="检查初始化代码"></a>检查初始化代码</h2><p>符号前缀 <code>_GLOBAL__sub_I</code> 表示这是静态对象初始化代码，符号中间部分的数字决定初始化次序</p><pre><code class="shell">$ nm src/out.elf | grep &quot;t _GLOBAL&quot;90039370 t _GLOBAL__D.11000_cyg_scheduler_sched_lock900389a8 t _GLOBAL__D.12000__ZN13Cyg_Interrupt15disable_counterE90070830 t _GLOBAL__D.14000__ZN9Cyg_Clock15real_time_clockE90038704 t _GLOBAL__D.24100__ZN18Cyg_HardwareThread12thread_entryEP10Cyg_Thread904382d8 t _GLOBAL__D.50000_cyg_mtab_extra90045898 t _GLOBAL__D.50000_cyg_nstab_init90044c60 t _GLOBAL__D.50000_cyg_timeval_to_ticks900722b0 t _GLOBAL__D.50000_fdlock90071cc0 t _GLOBAL__D.56000_cyg_libc_stdio_stdin9003c6b0 t _GLOBAL__D.56000_strtok9003ccd8 t _GLOBAL__D.56000__ZN20Cyg_libc_stdio_files5filesE9003d1b8 t _GLOBAL__D.56001_cyg_libc_stdio_stdout90071ba0 t _GLOBAL__D.56002_cyg_libc_stdio_stderr9006b878 t _GLOBAL__D.58000_cyg_timespec_to_ticks9006b5f4 t _GLOBAL__D.58000_pthread_mutex9006bf64 t _GLOBAL__D.58000_signal_mutex90039358 t _GLOBAL__I.11000_cyg_scheduler_sched_lock90038738 t _GLOBAL__I.12000__Z26cyg_null_exception_handlerjij90038998 t _GLOBAL__I.12000__ZN13Cyg_Interrupt15disable_counterE90070818 t _GLOBAL__I.14000__ZN9Cyg_Clock15real_time_clockE900386ec t _GLOBAL__I.24100__ZN18Cyg_HardwareThread12thread_entryEP10Cyg_Thread9006c110 t _GLOBAL__I.32000__ZN12cyg_i2c_initC2Ev90042c38 t _GLOBAL__I.36000__ZN13Cyg_WallClock9wallclockE903e18ec t _GLOBAL__I.48000_char_dev_register90436564 t _GLOBAL__I.49000_ioinit.cxx904382c0 t _GLOBAL__I.50000_cyg_mtab_extra90045880 t _GLOBAL__I.50000_cyg_nstab_init90044c48 t _GLOBAL__I.50000_cyg_timeval_to_ticks90072298 t _GLOBAL__I.50000_fdlock90071ca8 t _GLOBAL__I.56000_cyg_libc_stdio_stdin9003c698 t _GLOBAL__I.56000_strtok9003ccc0 t _GLOBAL__I.56000__ZN20Cyg_libc_stdio_files5filesE9003d1a0 t _GLOBAL__I.56001_cyg_libc_stdio_stdout90071b88 t _GLOBAL__I.56002_cyg_libc_stdio_stderr9006b860 t _GLOBAL__I.58000_cyg_timespec_to_ticks9006b5dc t _GLOBAL__I.58000_pthread_mutex9006bf4c t _GLOBAL__I.58000_signal_mutex903e1100 t _GLOBAL__I.58000_startup.cxx904554ac t _GLOBAL_OFFSET_TABLE_</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eCos 组件注册及初始化&lt;/p&gt;
    
    </summary>
    
      <category term="eCos" scheme="http://yoursite.com/categories/eCos/"/>
    
    
      <category term="ecos" scheme="http://yoursite.com/tags/ecos/"/>
    
  </entry>
  
  <entry>
    <title>匿名联合体和匿名结构体</title>
    <link href="http://yoursite.com/2020/06/10/anonymous-union-and-anonymous-struct/"/>
    <id>http://yoursite.com/2020/06/10/anonymous-union-and-anonymous-struct/</id>
    <published>2020-06-10T11:52:20.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>编译出错：</p><pre><code>main.c:9:16: error: ‘struct channel::&lt;unnamed union&gt;::dvb’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct dvb {                ^~~</code></pre><a id="more"></a><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><pre><code class="c">#include &lt;string.h&gt;struct channel {    int id;    unsigned int services_num;    int *services;    unsigned char delivery;    union {        struct dvb {            int onid;            int tsid;            int sid;        } dvb;        struct ott {            int backendid;            int channelid;        } ott;    };} ch;int main(void){    memset(&amp;ch, 0, sizeof(struct channel));}</code></pre><p>编译</p><pre><code class="bash">$ gcc main.c$ g++ main.cmain.c:9:16: error: ‘struct channel::&lt;unnamed union&gt;::dvb’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct dvb {                ^~~main.c:15:16: error: ‘struct channel::&lt;unnamed union&gt;::ott’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct ott {                ^~~$ g++ -fpermissive main.cmain.c:9:16: warning: ‘struct channel::&lt;unnamed union&gt;::dvb’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct dvb {                ^~~main.c:15:16: warning: ‘struct channel::&lt;unnamed union&gt;::ott’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct ott {                ^~~</code></pre><h2 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h2><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>增加编译选项 <code>-fpermissive</code></p><pre><code class="bash">$ gcc main.c$ g++ main.cmain.c:10:16: warning: ‘struct channel::&lt;unnamed union&gt;::dvb’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct dvb {                ^~~main.c:16:16: warning: ‘struct channel::&lt;unnamed union&gt;::ott’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct ott {                ^~~</code></pre><h3 id="II"><a href="#II" class="headerlink" title="II"></a>II</h3><p>增加 <code>union</code> 成员 <code>u</code></p><pre><code>struct channel {    int id;    unsigned int services_num;    int *services;    unsigned char delivery;    union {        struct dvb {            int onid;            int tsid;            int sid;        } dvb;        struct ott {            int backendid;            int channelid;        } ott;    } u;} ch;</code></pre><pre><code class="bash">$ gcc main.c$ g++ main.c</code></pre><h3 id="III"><a href="#III" class="headerlink" title="III"></a>III</h3><p>修改匿名 <code>union</code> 内部结构体为匿名</p><pre><code>struct channel {    int id;    unsigned int services_num;    int *services;    unsigned char delivery;    union {        struct {            int onid;            int tsid;            int sid;        };        struct {            int backendid;            int channelid;        };    };} ch;</code></pre><p>或者</p><pre><code>struct channel {    int id;    unsigned int services_num;    int *services;    unsigned char delivery;    union {        struct {            int onid;            int tsid;            int sid;        } dvb;        struct {            int backendid;            int channelid;        } ott;    };} ch;</code></pre><pre><code class="bash">$ gcc main.c$ g++ main.c</code></pre><h3 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h3><p>修改为如下同样存在问题，这种方式是一种错误，定义了 <code>struct dvb</code> 类型，但是没有定义属于该类型的任何对象</p><pre><code>struct channel {    int id;    unsigned int services_num;    int *services;    unsigned char delivery;    union {        struct dvb {            int onid;            int tsid;            int sid;        };        struct ott {            int backendid;            int channelid;        };    };} ch;</code></pre><pre><code class="bash">$ gcc main.cmain.c:13:10: warning: declaration does not declare anything         };          ^main.c:18:10: warning: declaration does not declare anything         };          ^$ g++ main.cmain.c:9:16: error: ‘struct channel::&lt;unnamed union&gt;::dvb’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct dvb {                ^~~main.c:15:16: error: ‘struct channel::&lt;unnamed union&gt;::ott’ invalid; an anonymous union can only have non-static data members [-fpermissive]         struct ott {                ^~~</code></pre><h2 id="C-union-特点"><a href="#C-union-特点" class="headerlink" title="C++ union 特点"></a>C++ <code>union</code> 特点</h2><blockquote><p>C++ 联合体中不能包含非基本类型成员变量，原因好像是因为非基本类型存在构造函数（包括默认构造函数）为了避免多层嵌套后结构的安全性</p></blockquote><p>C++ 中 <code>union</code> 里面需要的成员需要共享内存，因此<strong>静态</strong>和<strong>引用</strong>都不能用，因为他们不可能共享内存</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://www.javatt.com/p/37232" target="_blank" rel="noopener">例解 C 语言中的匿名联合体和匿名结构体</a></li><li><a href="https://en.it1352.com/article/e4fdc90b62f14d0abaf6f46a4f4ea97e.html" target="_blank" rel="noopener">anonymous union can only have non-static data members GCC c</a></li><li><a href="https://stackoverflow.com/questions/17637392/anonymous-union-can-only-have-non-static-data-members-gcc-c" target="_blank" rel="noopener">anonymous union can only have non-static data members GCC c++</a></li><li><a href="https://stackoverflow.com/questions/2253878/why-does-c-disallow-anonymous-structs" target="_blank" rel="noopener">Why does C++ disallow anonymous structs?</a></li><li><a href="https://stackoverflow.com/questions/25542390/anonymous-union-and-struct" target="_blank" rel="noopener">Anonymous union and struct</a></li><li><a href="https://www.cnblogs.com/LubinLew/p/struct_enum_union_in_cpp.html" target="_blank" rel="noopener">C++对C语言的结构、联合、枚举 这3种数据类型进行了扩展</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译出错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main.c:9:16: error: ‘struct channel::&amp;lt;unnamed union&amp;gt;::dvb’ invalid; an anonymous union can only have non-static data members [-fpermissive]
         struct dvb {
                ^~~&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
    
      <category term="union" scheme="http://yoursite.com/tags/union/"/>
    
      <category term="struct" scheme="http://yoursite.com/tags/struct/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 数据选择</title>
    <link href="http://yoursite.com/2020/06/05/pandas-data-selection/"/>
    <id>http://yoursite.com/2020/06/05/pandas-data-selection/</id>
    <published>2020-06-05T02:17:48.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 数据选择</p><ul><li><code>.loc</code> <code>.iloc</code></li><li><code>.at</code> <code>.iat</code></li><li><code>[]</code></li><li><code>.attr</code></li></ul><a id="more"></a><p><a href="https://www.pypandas.cn/docs/user_guide/indexing.html#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%8D%E5%90%8C%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">索引的不同选择</a></p><blockquote><p>标量：相对于矢量，只有大小没有方向的数值。比如 39.343434<br>向量：矢量，既有方向，也有大小的一组数值。数据表里的一行数据，或者一列数据都可以是向量。比如 DataFrame 中的一行或者一列</p></blockquote><h2 id="loc"><a href="#loc" class="headerlink" title=".loc"></a><code>.loc</code></h2><p><a href="https://www.pypandas.cn/docs/user_guide/indexing.html#%E6%8C%89%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">按标签选择</a></p><blockquote><p><code>loc</code> 返回对象降维，<code>dataframe</code> -&gt; <code>series</code> -&gt; <code>标量</code><br>切片端点包含</p></blockquote><p>不同对象类型：</p><ul><li>series: <code>s.loc[indexer]</code></li><li>dataframe: <code>df.loc[row_indexer,column_indexer]</code></li></ul><p>常用方式：</p><ul><li><code>df.loc[&#39;a&#39;]</code><blockquote><p><code>a</code> 为 index label，此处输入不是索引的整数位置</p></blockquote></li><li><code>df.loc[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]</code></li><li><code>df.loc[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], :]</code></li><li><code>df.loc[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;A&#39;:]]</code></li><li><code>s.loc[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]</code></li><li><code>df.loc[&#39;b&#39;:]</code></li><li><code>df.loc[&#39;b&#39;:&#39;d&#39;]</code><blockquote><p>包括行 <code>b</code> 和 <code>d</code></p></blockquote></li><li><code>df.loc[:, &#39;B&#39;:&#39;D&#39;]</code></li><li><code>df.loc[:, [&#39;B&#39;, &#39;D&#39;]]</code></li><li><code>df.loc[df.A &gt; 0]</code></li><li><code>df.loc[df.index.isin([&#39;a&#39;, &#39;b&#39;])]</code></li><li><code>df.loc[df.index == &#39;a&#39;]</code></li><li><code>df.loc[(df[&#39;date&#39;] &gt; &#39;2019-12&#39;) &amp; (df[&#39;date&#39;] &lt; &#39;2020-05&#39;)]</code></li><li><code>df.loc[lambda x: x[&#39;date&#39;] &gt; &#39;2019-12&#39;]</code></li><li><code>df.loc[:, lambda df: [&#39;A&#39;, &#39;B&#39;]]</code></li></ul><h2 id="iloc"><a href="#iloc" class="headerlink" title=".iloc"></a><code>.iloc</code></h2><p><a href="https://www.pypandas.cn/docs/user_guide/indexing.html#%E6%8C%89%E4%BD%8D%E7%BD%AE%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">按位置选择</a></p><blockquote><p><code>iloc</code> 返回对象降维，<code>dataframe</code> -&gt; <code>series</code> -&gt; <code>标量</code><br>切片时，开始包括，而上限是排除<br>纯粹基于整数</p></blockquote><p>不同对象类型：</p><ul><li>series: <code>s.iloc[indexer]</code></li><li>dataframe: <code>df.iloc[row_indexer,column_indexer]</code></li></ul><p>常用方式：</p><ul><li><code>df.iloc[3]</code></li><li><code>df.iloc[1, 1]</code></li><li><code>df.iloc[[3, 4, 5]]</code></li><li><code>df.iloc[[3, 4, 5], :]</code></li><li><code>df.iloc[4:]</code></li><li><code>df.iloc[4:5]</code><blockquote><p>包含行4，不包含行5</p></blockquote></li><li><code>df.iloc[:, 4:5]</code></li><li><code>df.iloc[:, [4, 5]]</code></li><li><code>df.iloc[[1, 3, 5], [1, 3]]</code></li><li><code>df.iloc[[1, 3, 5], [1:3]]</code></li><li><code>df.iloc[list(df.A&lt;0)]</code> 或 <code>df.iloc[np.array(df.A&lt;0)]</code></li><li><code>df.iloc[df.index.isin([&#39;a&#39;, &#39;c&#39;])]</code></li><li><code>df.loc[df.index == &#39;a&#39;]</code></li><li><code>df.iloc[:, lambda df: [0, 1]]</code></li></ul><h2 id="at-和-iat"><a href="#at-和-iat" class="headerlink" title=".at 和 .iat"></a><code>.at</code> 和 <code>.iat</code></h2><p><a href="https://www.pypandas.cn/docs/user_guide/indexing.html#%E5%BF%AB%E9%80%9F%E6%A0%87%E9%87%8F%E5%80%BC%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">快速标量值获取和设置</a></p><p><code>at</code> 提供基于标签的标量查找，同时 <code>iat</code> 提供类似于基于整数的查找 <code>iloc</code></p><ul><li><code>df.at[&#39;b&#39;, &#39;B&#39;]</code></li><li><code>df.iat[1, 1]</code></li></ul><h2 id=""><a href="#" class="headerlink" title="[]"></a><code>[]</code></h2><p><strong>只能输入一个维度，不能用逗号隔开输入两个维度</strong></p><p>切片操作，语法与 ndarray 完全一样，返回值的一部分和相应的标签</p><ul><li><code>s[:5]</code></li><li><code>s[::-1]</code></li><li><code>s[::2]</code></li><li><code>df[:3]</code></li><li><code>df[2:3]</code></li><li><code>df[::-1]</code></li><li><code>df[[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;]]</code></li><li><code>df[&#39;A&#39;]</code></li><li><code>df[df.A&lt;0]</code></li></ul><h2 id="attr"><a href="#attr" class="headerlink" title=".attr"></a><code>.attr</code></h2><p>用于访问列</p><ul><li><code>df.A</code></li></ul><h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><p><strong>必须使用括号进行分组</strong></p><ul><li><code>|</code></li><li><code>&amp;</code></li><li><code>~</code></li></ul><p>例如：</p><ul><li><code>s[(s &lt; -1) | (s &gt; 0.5)]</code></li><li><code>s[~(s &lt; 0)]</code></li></ul><h2 id="isin"><a href="#isin" class="headerlink" title="isin"></a><code>isin</code></h2><p><a href="https://www.pypandas.cn/docs/user_guide/indexing.html#%E4%BD%BF%E7%94%A8isin%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">使用isin进行索引</a></p><ul><li><code>s.isin([2, 4, 6])</code></li><li><code>s[s.index.isin([2, 4, 6])]</code></li><li><code>s_mi.iloc[s_mi.index.isin([(1, &#39;a&#39;), (2, &#39;b&#39;), (0, &#39;c&#39;)])]</code></li></ul><h2 id="where"><a href="#where" class="headerlink" title="where"></a><code>where</code></h2><p><a href="https://www.pypandas.cn/docs/user_guide/indexing.html#%E8%AF%A5where-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%8F%E8%94%BD" target="_blank" rel="noopener">该where()方法和屏蔽</a></p><p><code>where</code> 保证选择输出与原始数据具有相同的形状</p><pre><code class="python">In [16]: s                                                                                                                                              Out[16]: 4    03    12    21    30    4dtype: int64In [17]: s[s &gt; 2]                                                                                                                                       Out[17]: 1    30    4dtype: int64In [18]: s.where(s &gt; 2)                                                                                                                                 Out[18]: 4    NaN3    NaN2    NaN1    3.00    4.0dtype: float64</code></pre><h2 id="query"><a href="#query" class="headerlink" title="query"></a><code>query</code></h2><p><a href="https://www.pypandas.cn/docs/user_guide/indexing.html#%E8%AF%A5query-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">该query()方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pandas 数据选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.loc&lt;/code&gt; &lt;code&gt;.iloc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.at&lt;/code&gt; &lt;code&gt;.iat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.attr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Pandas" scheme="http://yoursite.com/categories/Python/Pandas/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>查找指定 commit 之间修改文件列表</title>
    <link href="http://yoursite.com/2020/05/18/git-diff-between-commits-in-git/"/>
    <id>http://yoursite.com/2020/05/18/git-diff-between-commits-in-git/</id>
    <published>2020-05-18T11:20:28.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>git diff</code> 查看指定 commit 之间修改文件列表</p><a id="more"></a><p>使用 <a href="https://github.com.cnpmjs.org/jingweno/ccat.git" target="_blank" rel="noopener">ccat</a> 为例</p><pre><code>$ git diff --name-only &lt;SHA, tag start&gt; &lt;SHA, tag end&gt;$ git diff --name-status &lt;SHA, tag start&gt; &lt;SHA, tag end&gt;</code></pre><pre><code class="shell">$ git diff --name-only 561b2d4 7cf6d90.travis.ymlREADME.mdcompletion/zsh/_ccat$ git diff --name-status 561b2d4 7cf6d90M       .travis.ymlM       README.mdA       completion/zsh/_ccat</code></pre><p>然后查看文件的具体改动</p><pre><code class="shell">$ git diff 561b2d4 7cf6d90 .travis.ymldiff --git a/.travis.yml b/.travis.ymlindex e4fed32..008ab1c 100644--- a/.travis.yml+++ b/.travis.yml@@ -1,5 +1,8 @@ sudo: false language: go go:-  - 1.8.3+  - 1.8.x+  - 1.9.x+  - 1.10.x+  - 1.11.x script: ./bin/test</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;git diff&lt;/code&gt; 查看指定 commit 之间修改文件列表&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/Tools/Git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git 带有参数的别名</title>
    <link href="http://yoursite.com/2020/05/12/git-advanced-aliases-with-arguments/"/>
    <id>http://yoursite.com/2020/05/12/git-advanced-aliases-with-arguments/</id>
    <published>2020-05-12T01:38:13.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>git 别名以及使用参数相关注意事项</p><a id="more"></a><h2 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h2><p><a href="https://git.wiki.kernel.org/index.php/Aliases#Advanced_aliases_with_arguments" target="_blank" rel="noopener">Aliases</a></p><p>git 别名配置在文件 <code>~/.gitconfig</code> 中，存在两种别名</p><ol><li>git 命令别名，内置命令</li><li>非 git 命令别名，使用前缀<code>!</code>，运行在 shell</li></ol><pre><code>[alias]    ci = commit    br = branch    push-view = !sh -c &#39;git origin HEAD:refs/for/$1&#39; -    gitkconflict = !gitk --left-right HEAD...MERGE_HEAD</code></pre><h2 id="Advanced-aliases-with-parameters"><a href="#Advanced-aliases-with-parameters" class="headerlink" title="Advanced aliases with parameters"></a>Advanced aliases with parameters</h2><blockquote><p>Starting with version 1.5.3, git supports appending the arguments to commands prefixed with “!”, too. If you need to perform a reordering, or to use an argument twice, you can use this trick:</p></blockquote><pre><code>[alias]    example = !sh -c &#39;ls $2 $1&#39; -</code></pre><ul><li><code>!</code> 在 shell 中运行</li><li><code>$1</code> 为第一个参数</li></ul><p>另外一种方式，封装为 <code>bash</code> 函数 <code>f</code>：</p><pre><code>[alias]    files = &quot;!f() { git diff --name-status \&quot;$1^\&quot; \&quot;$1\&quot;; }; f&quot;</code></pre><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>调试输出信息</p><pre><code>$ GIT_TRACE=1 git push-view test</code></pre><p>或者使用 <code>gdb</code> 调试</p><pre><code>[alias]    debug = !GIT_PAGER= gdb --args git</code></pre><p>用法 <code>git debug push-view test</code></p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>定义 gerrit review alias 为</p><pre><code>[alias]  ...  push-for-review = push origin HEAD:refs/for/master  push-for-review-branch = !git push origin HEAD:refs/for/$1  push-as-draft = push origin HEAD:refs/drafts/master  push-as-draft-branch = !git push origin HEAD:refs/drafts/$1  ...</code></pre><p>调试如下</p><pre><code class="shell">$ GIT_TRACE=1 git push-for-review-branch test16:38:33.280667 git.c:344               trace: built-in: git push origin HEAD:refs/for/test testTo ssh://192.168.110.254:29418/misc   d9d506f..20c5d70  test -&gt; test * [new branch]      HEAD -&gt; refs/for/test</code></pre><p>尾巴上多出一个参数导致直接合并，不理解为什么？<code>$@</code> 解析问题？<br><a href="https://stackoverflow.com/questions/3321492/git-alias-with-positional-parameters" target="_blank" rel="noopener">stackoverflow - Git alias with positional parameters</a>解释如下</p><blockquote><p>The sh -c ‘..’ – and f() {..}; f options both cleanly handle the “$@” parameters in different ways (see with GIT_TRACE). Appending “#” to an alias would also allow positional parameters without leaving the trailing ones.</p></blockquote><p>修改为</p><pre><code>[alias]  ...  push-for-review = push origin HEAD:refs/for/master  push-for-review-branch = &quot;!git push origin HEAD:refs/for/$1 #&quot;  push-as-draft = push origin HEAD:refs/drafts/master  push-as-draft-branch = &quot;!git push origin HEAD:refs/drafts/$1 #&quot;  ...</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 别名以及使用参数相关注意事项&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/Tools/Git/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="alias" scheme="http://yoursite.com/tags/alias/"/>
    
  </entry>
  
  <entry>
    <title>基于 coc.nvim python 补全</title>
    <link href="http://yoursite.com/2020/05/08/coc-python-completion/"/>
    <id>http://yoursite.com/2020/05/08/coc-python-completion/</id>
    <published>2020-05-08T05:35:57.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>coc.nvim</code> 配置 python 补全</p><ul><li>coc-jedi</li><li>coc-python <em>配置失败</em></li><li>python LSP <em>配置失败</em></li></ul><a id="more"></a><h2 id="python-LSP"><a href="#python-LSP" class="headerlink" title="python LSP"></a>python LSP</h2><ul><li><a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers" target="_blank" rel="noopener">Python LS</a></li><li><a href="https://github.com/palantir/python-language-server" target="_blank" rel="noopener">python-language-server</a></li></ul><p>需要配置 <code>coc-settings.json</code></p><p><strong>LSP重启5次失败</strong></p><h2 id="coc-python"><a href="#coc-python" class="headerlink" title="coc-python"></a>coc-python</h2><p><strong>推荐使用</strong>，<code>coc-settings.json</code> 中不能配置 <code>LSP</code></p><ul><li><a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers" target="_blank" rel="noopener">Python LS</a></li><li><a href="https://github.com/neoclide/coc-python" target="_blank" rel="noopener">coc-python</a></li></ul><p>支持两种：</p><ol><li>jedi (工作不正常)</li><li>MPLS (网络原因，不能正常下载)</li></ol><h2 id="coc-jedi"><a href="#coc-jedi" class="headerlink" title="coc-jedi"></a>coc-jedi</h2><ul><li><a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions" target="_blank" rel="noopener">coc-extensions</a></li><li><a href="https://github.com/pappasam/coc-jedi" target="_blank" rel="noopener">coc-jedi</a></li><li><a href="https://github.com/pappasam/jedi-language-server" target="_blank" rel="noopener">jedi-language-server</a></li></ul><p><strong>与 <code>coc-python</code> 冲突，需要先卸载</strong>，基于 <code>jedi-language-server</code></p><pre><code class="shell">$ python3 -m pip install --user pipx$ pipx install jedi-language-server</code></pre><p><code>coc-settings.json</code> 配置如下</p><pre><code class="json">  &quot;jedi.enable&quot;: true,  &quot;jedi.trace.server&quot;: &quot;messages&quot;,  &quot;jedi.diagnostics.enable&quot;: true,  &quot;jedi.diagnostics.didOpen&quot;: true,  &quot;jedi.diagnostics.didChange&quot;: true,  &quot;jedi.diagnostics.didSave&quot;: true</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;coc.nvim&lt;/code&gt; 配置 python 补全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coc-jedi&lt;/li&gt;
&lt;li&gt;coc-python &lt;em&gt;配置失败&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;python LSP &lt;em&gt;配置失败&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Editor" scheme="http://yoursite.com/categories/Tools/Editor/"/>
    
    
      <category term="lsp" scheme="http://yoursite.com/tags/lsp/"/>
    
      <category term="coc" scheme="http://yoursite.com/tags/coc/"/>
    
      <category term="jedi" scheme="http://yoursite.com/tags/jedi/"/>
    
  </entry>
  
  <entry>
    <title>GDB Tips</title>
    <link href="http://yoursite.com/2020/05/07/gdb-ptype/"/>
    <id>http://yoursite.com/2020/05/07/gdb-ptype/</id>
    <published>2020-05-07T08:46:48.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 使用技巧</p><ul><li>启动</li><li>dump</li><li>ptype</li><li>set</li><li>info</li><li>disassemble</li></ul><a id="more"></a><h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><p>默认读取当前目录下的 <code>.gdbinit</code>，使用 <code>-nx</code>不读取 <code>.gdbinit</code> 配置</p><pre><code class="shell">$ gdb test # 常用于下载调试test$ gdb -nx test # 常用于查看当前状态</code></pre><h2 id="独立调试信息记载"><a href="#独立调试信息记载" class="headerlink" title="独立调试信息记载"></a>独立调试信息记载</h2><p><code>test</code> 编译参数为 <code>-O0 -g -ggdb</code></p><ul><li>获取调试信息 <code>objcopy --only-keep-debug test test.debug</code></li><li>gdb 中加载 <code>symbol-file test.debug</code></li><li>分离的调试信息重新链接到可执行问题 <code>objcopy --add-gnu-debuglink test.debug test</code></li></ul><h2 id="Dump-Memory"><a href="#Dump-Memory" class="headerlink" title="Dump Memory"></a>Dump Memory</h2><pre><code class="gdb">(gdb) help dumpDump target code/data to a local file.List of dump subcommands:dump binary -- Write target code/data to a raw binary filedump ihex -- Write target code/data to an intel hex filedump memory -- Write contents of memory to a raw binary filedump srec -- Write target code/data to an srec filedump tekhex -- Write target code/data to a tekhex filedump value -- Write the value of an expression to a raw binary filedump verilog -- Write target code/data to a verilog hex fileType &quot;help dump&quot; followed by dump subcommand name for full documentation.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.Command name abbreviations are allowed if unambiguous.(gdb) help dump memoryWrite contents of memory to a raw binary file.Arguments are FILE START STOP.  Writes the contents of memory within therange [START .. STOP) to the specified FILE in raw target ordered bytes.</code></pre><p>语法 <code>dump memory file $START $END</code></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><ul><li><code>b *func</code> 断点在 <code>func</code> 入栈之前</li><li><code>ni/si</code> 汇编指令级单步执行</li><li><code>disassemble func</code> 反汇编 func</li><li><code>disassemble /m func</code> 反汇编 func，带有源代码信息</li><li><code>disassemble $pc-20,$pc+20</code> 反汇编执行区间代码</li><li><code>watch *(int *)0x8049aa4</code> 内存读写断点</li><li><code>rwatch *(int *)0x8049aa4</code> 内存读断点</li><li><code>awatch *(int *)0x8049aa4</code> 内存读写断点</li><li><code>display /i $pc</code> 显示当前汇编指令</li><li><code>info r</code> 查看寄存器</li><li><code>i r rx</code> 查看rx寄存器</li></ul><h2 id="ptype-查看类型"><a href="#ptype-查看类型" class="headerlink" title="ptype 查看类型"></a>ptype 查看类型</h2><p>用于查看符号类型 <code>ptype symbol|var</code></p><pre><code class="gdb">(gdb) ptype struct filetype = struct file {    cyg_uint32 f_flag;    cyg_uint16 f_ucount;    cyg_uint16 f_type;    cyg_uint32 f_syncmode;    fileops *f_ops;    off_t f_offset;    CYG_ADDRWORD f_data;    CYG_ADDRWORD f_xops;    cyg_mtab_entry *f_mte;    list_head f_node;    cyg_uint8 f_valid;}</code></pre><p>使用 <code>set print type xxx</code> 配置</p><h2 id="whatis-查看类型"><a href="#whatis-查看类型" class="headerlink" title="whatis 查看类型"></a>whatis 查看类型</h2><p><code>whatis var</code></p><h2 id="info-address"><a href="#info-address" class="headerlink" title="info address"></a>info address</h2><p><code>info address symbol</code></p><blockquote><p>Describe where the data for symbol is stored. For a register variable, this says which register it is kept in. For a non-register local variable, this prints the stack-frame offset at which the variable is always stored.</p></blockquote><p>查找给定符号的存储地址</p><h2 id="info-symbol"><a href="#info-symbol" class="headerlink" title="info symbol"></a>info symbol</h2><p><code>info symbol addr</code></p><blockquote><p>Print the name of a symbol which is stored at the address addr. If no symbol is stored exactly at addr, GDB prints the nearest symbol and an offset from it</p><pre><code class="gdb">(gdb) info symbol 0x54320_initialize_vx + 396 in section .text</code></pre></blockquote><p>查找给定地址的变量或函数的名称</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ol><li><a href="https://www.cnblogs.com/zengkefu/p/5618041.html" target="_blank" rel="noopener">GDB技巧整理</a></li><li><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Symbols.html" target="_blank" rel="noopener">16 Examining the Symbol Table</a></li><li><a href="https://stackoverflow.com/questions/866721/how-to-generate-gcc-debug-symbol-outside-the-build-target" target="_blank" rel="noopener">How to generate gcc debug symbol outside the build target?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 使用技巧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动&lt;/li&gt;
&lt;li&gt;dump&lt;/li&gt;
&lt;li&gt;ptype&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;info&lt;/li&gt;
&lt;li&gt;disassemble&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
      <category term="ptype" scheme="http://yoursite.com/tags/ptype/"/>
    
  </entry>
  
  <entry>
    <title>ddd调试嵌入式系统</title>
    <link href="http://yoursite.com/2020/05/07/ddd-with-cross-debugger/"/>
    <id>http://yoursite.com/2020/05/07/ddd-with-cross-debugger/</id>
    <published>2020-05-07T08:25:26.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>后台启动 <code>gdbserver</code></p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><pre><code class=".gdbinit">set $cr18=0x7dhandle SIGPIPE nostopset print pretty</code></pre><pre><code class="shell">$ ddd --debugger arm-linux-gnueabihf-gdb output/out.elf</code></pre><p>启动之后执行</p><pre><code class="gdb">tar jtag jtag://127.0.1.1:1025loadr</code></pre><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ol><li><a href="https://blog.51cto.com/mirage1993/1750756" target="_blank" rel="noopener">宇宙最强调试器DDD</a></li><li><a href="https://www.shuzhiduo.com/A/A7zg83MoJ4/" target="_blank" rel="noopener">DDD——让天下没有难调的程序</a></li><li><a href="http://www.dilnetpc.com/mHT5280-14.pdf" target="_blank" rel="noopener">How to use the DDD on the top of the GNU Cross Debugger</a></li><li><a href="https://www.gnu.org/software/ddd/" target="_blank" rel="noopener">DDD</a></li><li><a href="https://sourceware.org/gdb/wiki/GDB%20Front%20Ends" target="_blank" rel="noopener">GDB front ends and other tools</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;0&quot;&gt;&lt;a href=&quot;#0&quot; class=&quot;headerlink&quot; title=&quot;0&quot;&gt;&lt;/a&gt;0&lt;/h2&gt;&lt;p&gt;后台启动 &lt;code&gt;gdbserver&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;I&quot;&gt;&lt;a href=&quot;#I&quot;
      
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
      <category term="ddd" scheme="http://yoursite.com/tags/ddd/"/>
    
  </entry>
  
  <entry>
    <title>GDB打印二维数组</title>
    <link href="http://yoursite.com/2020/05/07/print-2d-array-in-gdb/"/>
    <id>http://yoursite.com/2020/05/07/print-2d-array-in-gdb/</id>
    <published>2020-05-07T04:50:37.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<ul><li>打印数组 <code>p *matrix@length</code></li><li>打印二维数组 <code>p *matrix@cols@rows</code></li><li>打印二维数组 <code>printMatrix matrix cols rows</code><pre><code>define printMatrix  set $arr = $arg0  set $rows = $arg1  set $cols = $arg2  set $i = 0  printf &quot;\n&quot;  while $i &lt; $rows      set $j = 0      while $j &lt; $cols          printf &quot;%02d, &quot;,$arr[$i][$j]          set $j = $j + 1      end      printf &quot;\n&quot;      set $i = $i + 1  endend</code></pre></li></ul><a id="more"></a><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><pre><code class="c">#include &lt;stdio.h&gt;int matrix[10][10];void print(int matrix[10][10]){    int i, j;    for (i = 0; i &lt; 10; ++i)    {        for (j = 0; j &lt; 10; ++j)            printf(&quot;%d &quot;, matrix[i][j]);        printf(&quot;\n&quot;);    }}int main(){    int i, j;    for (i = 0; i &lt; 10; ++i)        for (j = 0; j &lt; 10; ++j)            matrix[i][j] = i*10 + j;    return 0;}</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>(gdb) p *matrix[1]@10$6 = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}(gdb) p *matrix[1]@5@2$7 = {{10, 11, 12, 13, 14}, {15, 16, 17, 18, 19}}(gdb) source a.gdb(gdb) printMatrix matrix 10 1000, 01, 02, 03, 04, 05, 06, 07, 08, 09,10, 11, 12, 13, 14, 15, 16, 17, 18, 19,20, 21, 22, 23, 24, 25, 26, 27, 28, 29,30, 31, 32, 33, 34, 35, 36, 37, 38, 39,40, 41, 42, 43, 44, 45, 46, 47, 48, 49,50, 51, 52, 53, 54, 55, 56, 57, 58, 59,60, 61, 62, 63, 64, 65, 66, 67, 68, 69,70, 71, 72, 73, 74, 75, 76, 77, 78, 79,80, 81, 82, 83, 84, 85, 86, 87, 88, 89,90, 91, 92, 93, 94, 95, 96, 97, 98, 99,</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;打印数组 &lt;code&gt;p *matrix@length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打印二维数组 &lt;code&gt;p *matrix@cols@rows&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打印二维数组 &lt;code&gt;printMatrix matrix cols rows&lt;/code&gt;&lt;pre&gt;&lt;code&gt;define printMatrix
  set $arr = $arg0
  set $rows = $arg1
  set $cols = $arg2
  set $i = 0
  printf &amp;quot;\n&amp;quot;
  while $i &amp;lt; $rows
      set $j = 0
      while $j &amp;lt; $cols
          printf &amp;quot;%02d, &amp;quot;,$arr[$i][$j]
          set $j = $j + 1
      end
      printf &amp;quot;\n&amp;quot;
      set $i = $i + 1
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>GDB扩展脚本</title>
    <link href="http://yoursite.com/2020/05/07/Extending-GDB/"/>
    <id>http://yoursite.com/2020/05/07/Extending-GDB/</id>
    <published>2020-05-07T03:10:39.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 扩展</p><ul><li>GDB Commands</li><li>python script</li></ul><a id="more"></a><h2 id="GDB-脚本"><a href="#GDB-脚本" class="headerlink" title="GDB 脚本"></a>GDB 脚本</h2><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Sequences.html#Sequences" target="_blank" rel="noopener">Canned Sequences of Commands</a><br><a href="https://github.com/gdbinit/Gdbinit/blob/master/gdbinit" target="_blank" rel="noopener">Gdbinit</a></p><p>在 <code>.gdbinit</code> 中增加如下代码自定义函数</p><pre><code>define print_list    set $list=$arg0    while($list)        printf &quot;%d\t&quot;,$list-&gt;val        set $list=$list-&gt;next    end    printf &quot;\n&quot;enddocument print_listSyntax: print_list listend</code></pre><h2 id="Python-脚本"><a href="#Python-脚本" class="headerlink" title="Python 脚本"></a>Python 脚本</h2><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Python.html#Python" target="_blank" rel="noopener">Extending GDB using Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GDB Commands&lt;/li&gt;
&lt;li&gt;python script&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/Tools/GDB/"/>
    
    
      <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>gerrit命名空间</title>
    <link href="http://yoursite.com/2020/05/07/gerrit-namespace/"/>
    <id>http://yoursite.com/2020/05/07/gerrit-namespace/</id>
    <published>2020-05-07T01:21:04.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>Gerrit 命名空间 <code>refs/for/&lt;branch&gt;</code> 用于代码评审，以及相关 alias</p><a id="more"></a><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>Branches, remote-tracking branches, and tags 等等都是对 commite 的引用（reference），引用都以 <code>refs/...</code>”表示</p><ul><li>remote branch: origin/git_int(=refs/remotes/origin/git_int)</li><li>local tag: v2.0(=refs/tags/v2.0)</li><li>local branch: git_int(=refs/heads/git_int)</li></ul><h2 id="refs-for"><a href="#refs-for" class="headerlink" title="refs/for"></a>refs/for</h2><p><code>refs/for/&lt;branch&gt;</code> 用于 gerrit 代码评审</p><blockquote><p>Gerrit uses the <strong>refs/for/</strong> prefix to map the concept of “Pushing for Review” to the git protocol.</p></blockquote><p>git 命令 <code>git push origin HEAD:refs/for/&lt;BRANCH_NAME&gt;</code></p><h2 id="refs-changes"><a href="#refs-changes" class="headerlink" title="refs/changes"></a>refs/changes</h2><p>提交到 gerrit 的代码如下格式</p><blockquote><p>For the git client, it looks like every push goes to the same branch, such as refs/for/master. In fact, for each commit pushed to this ref, Gerrit creates a new ref under a refs/changes/ namespace, which Gerrit uses to track these commits. These references use the following format: refs/changes/[CD]/[ABCD]/[EF]</p></blockquote><ul><li>[CD] is the last two digits of the change number</li><li>[ABCD] is the change number</li><li>[EF] is the patch set number</li></ul><h2 id="refs-head"><a href="#refs-head" class="headerlink" title="refs/head"></a>refs/head</h2><p><code>refs/head/&lt;branch&gt;</code> 用于绕过评审直接提交代码，可能会因为权限控制导致提交失败</p><pre><code>! [remote rejected] master -&gt; master (prohibited by Gerrit)</code></pre><p>git 命令 <code>git push origin &lt;BRANCH_NAME&gt;</code></p><h2 id="refs-drafts"><a href="#refs-drafts" class="headerlink" title="refs/drafts"></a>refs/drafts</h2><p>草稿箱，仅 owner 以及邀请用户可见</p><pre><code>git push origin HEAD:refs/drafts/&lt;BRANCH_NAME&gt;</code></pre><h2 id="git-alias"><a href="#git-alias" class="headerlink" title="git alias"></a>git alias</h2><pre><code>[alias]  ...  push-for-review = push origin HEAD:refs/for/master  push-for-review-branch = !git push origin HEAD:refs/for/$1  push-as-draft = push origin HEAD:refs/drafts/master  push-as-draft-branch = !git push origin HEAD:refs/drafts/$1  ...</code></pre><blockquote><p>两个携带参数的 alias 存在问题，git version 2.17.1<br>git push-for-review-branch test 展开为 git push origin HEAD:refs/for/test test，多了一个参数导致直接合并到git仓库中</p></blockquote><pre><code class="shell">$ GIT_TRACE=1 git push-for-review-branch testTo ssh://192.168.110.254:29418/misc   d9d506f..20c5d70  test -&gt; test * [new branch]      HEAD -&gt; refs/for/test</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gerrit 命名空间 &lt;code&gt;refs/for/&amp;lt;branch&amp;gt;&lt;/code&gt; 用于代码评审，以及相关 alias&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Gerrit" scheme="http://yoursite.com/categories/Tools/Gerrit/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="gerrit" scheme="http://yoursite.com/tags/gerrit/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 安装与配置</title>
    <link href="http://yoursite.com/2020/04/17/mysql-installation-and-configuration/"/>
    <id>http://yoursite.com/2020/04/17/mysql-installation-and-configuration/</id>
    <published>2020-04-17T03:04:03.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>记录 ubuntu18.04 安装并配置 MySQL</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell">$ sudo apt install mysql-server</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用命令出现如下错误，<a href="https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost" target="_blank" rel="noopener">原因及解决方法</a></p><pre><code class="shell">$ mysql -ui root -pERROR 1698 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39;$ sudo mysql -u root # I had to use &quot;sudo&quot; since is new installationmysql&gt; USE mysql;mysql&gt; SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User             | Host      | plugin                |+------------------+-----------+-----------------------+| root             | localhost | auth_socket           || mysql.session    | localhost | mysql_native_password || mysql.sys        | localhost | mysql_native_password || debian-sys-maint | localhost | mysql_native_password |+------------------+-----------+-----------------------+4 rows in set (0.00 sec)mysql&gt; CREATE USER &#39;sql-test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sql-test&#39;@&#39;localhost&#39;;ERROR 1133 (42000): Can&#39;t find any matching row in the user tablemysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sql-test&#39;@&#39;localhost&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; UPDATE user SET plugin=&#39;auth_socket&#39; WHERE User=&#39;sql-test&#39;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; SELECT User, Host, plugin FROM mysql.user;+------------------+-----------+-----------------------+| User             | Host      | plugin                |+------------------+-----------+-----------------------+| root             | localhost | auth_socket           || mysql.session    | localhost | mysql_native_password || mysql.sys        | localhost | mysql_native_password || debian-sys-maint | localhost | mysql_native_password || sql-test         | localhost | auth_socket           |+------------------+-----------+-----------------------+5 rows in set (0.00 sec)mysql&gt; UPDATE user SET plugin=&#39;mysql_native_password&#39; WHERE User=&#39;sql-test&#39;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; exit;$ sudo service mysql restart$ mysql -u sql-tesmysql&gt;</code></pre><p>其他命令：</p><ol><li>检查MySQL服务器占用端口 <code>netstat -nlt|grep 3306</code></li><li>检查MySQL服务器系统进程 <code>ps -aux|grep mysql</code></li><li>查看数据库的字符集编码 <code>show variables like &#39;%char%&#39;;</code></li><li>重启 <code>service mysqld restart</code></li></ol><h2 id="pymysql简单使用"><a href="#pymysql简单使用" class="headerlink" title="pymysql简单使用"></a>pymysql简单使用</h2><ul><li>创建数据库<pre><code class="python">pymysql.connect(host=&#39;127.0.0.1&#39;, user=&#39;test&#39;, passwd=&#39;&#39;, use_unicode=True)cursor = self.connect.cursor()cursor.execute(&quot;create database if not exists sql-test&quot;)</code></pre></li><li>选择数据库<pre><code class="python">self.cursor.execute(&quot;use sql-test;&quot;)</code></pre></li><li>创建表<pre><code class="python">sql = &quot;&quot;&quot;create table if not exists saes(  pos varchar(20),  area varchar(20),  name varchar(100),  time varchar(20));&quot;&quot;&quot;cursor.execute(sql)</code></pre></li><li>更新数据<pre><code class="python">cursor.execute(&quot;&quot;&quot;select * from saes where name = %s&quot;&quot;&quot;, item[&quot;name&quot;])ret = cursor.fetchone()if ret:  cursor.execute(      &quot;&quot;&quot;update saes set pos = %s,area = %s,          name = %s,time = %s          where name = %s&quot;&quot;&quot;,      (item[&#39;pos&#39;],      item[&#39;area&#39;],      item[&#39;name&#39;],      item[&#39;time&#39;],      item[&#39;name&#39;]))else:  cursor.execute(      &quot;&quot;&quot;insert into saes(pos,area,cku,name,time)      value (%s,%s,%s,%s)&quot;&quot;&quot;,      (item[&#39;pos&#39;],      item[&#39;area&#39;],      item[&#39;name&#39;],      item[&#39;time&#39;]))connect.commit()</code></pre></li><li>删除表<pre><code class="python">drop table tablename;</code></pre></li></ul><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="sql">mysql&gt; CREATE TABLE students (    -&gt; id bigint(20) NOT NULL AUTO_INCREMENT,    -&gt; name varchar(100) NOT NULL,    -&gt; gender varchar(1) NOT NULL,    -&gt; score int(11) NOT NULL,    -&gt; PRIMARY KEY (id)    -&gt; ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>指定字符集为 <code>utf8</code></p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><pre><code>create database new_dbname;--新建数据库drop database old_dbnane; --删除数据库show databases;--显示数据库use databasename;--使用数据库select database();--查看已选择的数据库show tables;--显示当前库的所有表create table tablename(fieldname1 fieldtype1,fieldname2 fieldtype2,..)[ENGINE=engine_name];--创建表drop table tablename; --删除表create table tablename select statement;--通过子查询创建表desc tablename;--查看表结构show create table tablename;--查看建表语句alter table tablename add new_fielname new_fieldtype;--新增列alter table tablename add new_fielname new_fieldtype after 列名1;--在列名1后新增列alter table tablename modify fieldname new_fieldtype;--修改列alter table tablename drop fieldname;--删除列alter table tablename_old rename tablename_new;--表重命名insert into tablename(fieldname1,fieldname2,fieldnamen) valuse(value1,value2,valuen);--增delete from tablename [where fieldname=value];--删update tablename set fieldname1=new_value where filename2=value;--改select * from tablename [where filename=value];--查truncate table tablename;--清空表中所有数据，DDL语句show engines;--查看mysql现在已提供的存储引擎:show variables like &#39;%storage_engine%&#39;;--查看mysql当前默认的存储引擎show create table tablename;--查看某张表用的存储引擎（结果的&quot;ENGINE=&quot;部分）alter table tablename ENGINE=InnoDB--修改引擎create table tablename(fieldname1 fieldtype1,fieldname2 fieldtype2,..) ENGINE=engine_name;--创建表时设置存储引擎</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 ubuntu18.04 安装并配置 MySQL&lt;/p&gt;
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>scrapy使用</title>
    <link href="http://yoursite.com/2020/03/30/python-scrapy/"/>
    <id>http://yoursite.com/2020/03/30/python-scrapy/</id>
    <published>2020-03-30T05:40:08.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html" target="_blank" rel="noopener">scrapy</a> 爬虫框架编写爬虫</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>安装 <code>pip3 install scrapy --user</code></li><li>css 选择器 <a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">CSS选择器笔记</a></li><li>xpath 选择器 <a href="https://www.jianshu.com/p/539356db0c0c" target="_blank" rel="noopener">scrapy提取数据之：xpath选择器</a></li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>使用 <code>scrapy shell urls</code> 进行调试</p><ol><li>配置默认请求头<pre><code>&gt;&gt;&gt; settings.DEFAULT_REQUEST_HEADERS = { &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, &#39;Accept-Language&#39;: &#39;en&#39;, &#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 \ (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&#39;}</code></pre></li><li>使用 <code>fetch(urls)</code> 命令来抓取测试的页面，解析为 <code>response</code></li><li>使用 <code>response.css</code> 分析页面</li></ol><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><ol><li><code>scrapy startproject projectname</code> 新建项目</li><li><code>scrapy genspider demo demo.com</code> 新建爬虫</li></ol><pre><code class="shell">$ scrapy startproject DemoNew Scrapy project &#39;Demo&#39;, using template directory &#39;~/.local/lib/python3.6/site-packages/scrapy/templates/project&#39;, created in:    ~/python/crawler/scrapy/DemoYou can start your first spider with:    cd Demo    scrapy genspider example example.com$ cd Demo$ scrapy genspider demo demo.com$ tree.├── Demo│   ├── __init__.py│   ├── items.py│   ├── middlewares.py│   ├── pipelines.py│   ├── settings.py│   └── spiders│       ├── demo.py│       └── __init__.py└── scrapy.cfg4 directories, 11 files</code></pre><ul><li><code>items.py</code> 数据模型文件</li><li><code>middlewares.py</code> 中间件文件，配置所有中间件</li><li><code>pipelines.py</code> 管道文件，用于处理数据输出</li><li><code>settings.py</code> 配置文件</li><li><code>demo.py</code> 爬虫文件</li><li><code>scrapy.cfg</code> 整个Scrapy的配置文件，由Scrapy自动生成</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件 <code>settings.py</code></p><ol><li><code>LOG_LEVEL = &#39;WARNING&#39;</code> 输出级别</li><li><code>ROBOTSTXT_OBEY = False</code></li><li><code>FEED_EXPORT_ENCODING = &#39;utf-8&#39;</code> 支持中文</li></ol><h2 id="爬虫实现"><a href="#爬虫实现" class="headerlink" title="爬虫实现"></a>爬虫实现</h2><p>生成的爬虫文件如下</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider):    name = &#39;demo&#39;    allowed_domains = [&#39;demo.com&#39;]    start_urls = [&#39;http://demo.com/&#39;]    def parse(self, response):        pass</code></pre><p>所有的 Spider 类都必须得继承 scrapy.Spider，其中 <code>name</code>、<code>start_urls</code> 以及 <code>parse</code> 成员方法是每个 Spider 类必须要声明的。详细见<a href="https://docs.scrapy.org/en/latest/topics/spiders.html?highlight=Spider#spiders" target="_blank" rel="noopener">Spider</a></p><p>需要定义 <code>start_urls</code> 或者重写 <code>start_requests</code> 方法，两者都必须是可迭代对象</p><pre><code class="python">class Demo(scrapy.Spider):    name = &quot;demo&quot;    allowed_domains = [&quot;demo.com&quot;]    def start_requests(self):        yield Request(url=&#39;https://demo.com/p/&#39;, headers=headers, callback=self.parse_rank)    def parse_rank(self, response):        for item in response.css(&#39;article&gt;a&#39;):            name = item.css(&#39;.post-card-title::text&#39;).get()            link = item.css(&#39;::attr(href)&#39;).get()            print(&quot;\033[1;31m[%s]: %s\033[0m\n&quot; % (name, link))            yield Request(url=link, headers=headers, callback=self.parse_one)        next_page = response.css(&#39;ol&gt;li.next&#39;).css(&#39;a::attr(href)&#39;).get()        if next_page:            print(&quot;%s&quot; % next_page)            yield Request(next_page, callback=self.parse_rank)    def parse_one(self, response):        for src in response.css(&#39;div#post[role=main] p img::attr(src)&#39;).getall():            print(&quot;\033[1;32m%s\n\033[0m&quot; % src)            item = HaosuItem()            item[&#39;src&#39;] = src            yield item</code></pre><blockquote><p>所有具备解析功能的函数都应该返回 Item 或 Requests</p></blockquote><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>在 <code>item.py</code> 中定义数据模型</p><pre><code>class HaosuItem(scrapy.Item):    # define the fields for your item here like:    src = scrapy.Field()    pass</code></pre><p>数据填充并返回 <code>item</code> 见上述函数 <code>parse_one</code></p><h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>Scrapy 提供了一个 item pipeline 用于下载</p><pre><code class="python">from scrapy.pipelines.images import ImagesPipelineimport scrapyclass HaosuPipeline(ImagesPipeline):    def get_media_requests(self, item, info):        yield scrapy.Request(item[&#39;src&#39;])</code></pre><p>从 <code>item</code> 中获取下载地址并下载，修改 <code>setting.py</code> 开启管道</p><pre><code>ITEM_PIPELINES = {    &#39;haosu.pipelines.HaosuPipeline&#39;: 5,}IMAGES_STORE = &#39;image&#39;</code></pre><h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><h3 id="内置工具"><a href="#内置工具" class="headerlink" title="内置工具"></a>内置工具</h3><pre><code class="shell">$ scrapy crawl spider -o data.json$ scrapy crawl spider -o data.csv$ scrapy crawl spider -o data.xml$ scrapy crawl spider -s FEED_URI=&#39;/home/user/folder/mydata.csv&#39; -s FEED_FORMAT=csv</code></pre><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><pre><code class="python">from scrapy.exporters import CsvItemExporterclass CsvPipeline (object):    def __init__ (self):        self.file = open (&#39;databases.csv&#39;, &#39;wb&#39;)        self.exporter = CsvItemExporter(self.file)        self.exporter.start_exporting()    def close_spider (self, spider):        self.exporter.finish_exporting()        self.file.close()    def process_item (self, item, spider):        print(&quot;%s&quot; % item.__class__)        self.exporter.export_item(item)        return item</code></pre><p>在 <code>settings.py</code> 中启动 <code>pipeline</code></p><pre><code>ITEM_PIPELINES = {    &#39;satellites.pipelines.SatellitesPipeline&#39;: 300,    &#39;satellites.pipelines.CsvPipeline&#39;: 500,}</code></pre><h2 id="classmethod-使用"><a href="#classmethod-使用" class="headerlink" title="classmethod 使用"></a>classmethod 使用</h2><p>使用 <code>classmethod</code> 创建不同的数据库</p><pre><code class="python">def __init__(self, mysql_dbname):    # create db    sql = &quot;CREATE DATABASE if not exists &quot; + mysql_dbname    self.cursor = self.connect.cursor()    self.cursor.execute(sql)@classmethoddef from_crawler(cls, crawler):    settings = crawler.settings    mysql_dbname = settings.get(&#39;MYSQL_DBNAME&#39;)    print(&quot;%s&quot; % mysql_dbname)    return cls(mysql_dbname)</code></pre><h2 id="pymysql-数据存储"><a href="#pymysql-数据存储" class="headerlink" title="pymysql 数据存储"></a>pymysql 数据存储</h2><ul><li><a href="https://pymysql.readthedocs.io/en/latest/user/index.html" target="_blank" rel="noopener">User Guide</a></li><li><a href="https://pymysql.readthedocs.io/en/latest/modules/index.html" target="_blank" rel="noopener">API Reference</a></li><li><a href="https://juejin.im/post/5c7e524af265da2d914db18f" target="_blank" rel="noopener">SQL 语法速成手册</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384" target="_blank" rel="noopener">SQL教程</a></li></ul><pre><code class="python">import pymysqlself.connect = pymysql.connect(    host=settings.MYSQL_HOST,    user=settings.MYSQL_USER,    passwd=settings.MYSQL_PASSWD,    charset=&#39;utf8&#39;,    use_unicode=True)sql = &quot;CREATE DATABASE if not exists &quot; + mysql_dbnameself.cursor = self.connect.cursor()self.cursor.execute(sql)self.cursor.execute(&quot;USE %s;&quot; % mysql_dbname)# create satellite tablesql = &quot;&quot;&quot;CREATE TABLE if not exists satellites(    id bigint(20) NOT NULL AUTO_INCREMENT,    position varchar(20),    area varchar(30),    band varchar(10),    name varchar(100),    time varchar(20),    PRIMARY KEY (id)    ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;&quot;&quot;&quot;self.cursor.execute(sql)</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="shell">$ scrapy crawl demo</code></pre><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="网页返回乱码"><a href="#网页返回乱码" class="headerlink" title="网页返回乱码"></a>网页返回乱码</h3><p><code>DEFAULT_REQUEST_HEADERS</code> 设置 <code>Accept-Encoding</code> 为 <code>gzip,deflate</code> 导致网页返回乱码</p><p>这个配置表示接受压缩后的数据，需要自己解压缩</p><h3 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h3><pre><code>ROBOTSTXT_OBEY = False</code></pre><h2 id="Scrapy-体系结构"><a href="#Scrapy-体系结构" class="headerlink" title="Scrapy 体系结构"></a>Scrapy 体系结构</h2><ul><li><a href="https://docs.scrapy.org/en/latest/topics/architecture.html" target="_blank" rel="noopener">Architecture overview</a></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://juejin.im/post/5cfc6f716fb9a07ea7130308" target="_blank" rel="noopener">Scrapy简明教程</a></li><li><a href="https://docs.scrapy.org/en/latest/index.html" target="_blank" rel="noopener">Scrapy 2.0 documentation</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;a href=&quot;https://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scrapy&lt;/a&gt; 爬虫框架编写爬虫&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Python/Spider/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="spider" scheme="http://yoursite.com/tags/spider/"/>
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 搜索技巧</title>
    <link href="http://yoursite.com/2020/03/25/searching-on-github/"/>
    <id>http://yoursite.com/2020/03/25/searching-on-github/</id>
    <published>2020-03-25T12:01:05.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 搜索技巧，用于准确搜索到相关资源</p><ul><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-on-github" target="_blank" rel="noopener">Searching on GitHub</a><ul><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories" target="_blank" rel="noopener">Searching for repositories</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/finding-files-on-github" target="_blank" rel="noopener">Finding files on GitHub</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-topics" target="_blank" rel="noopener">Searching topics</a></li><li><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-code" target="_blank" rel="noopener">Searching code</a></li><li>…</li></ul></li><li><a href="https://github.com/trending" target="_blank" rel="noopener">GitHub Trending</a></li><li><a href="https://github.com/topics" target="_blank" rel="noopener">GitHub Topics</a></li><li><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">GitHub中文排行榜</a></li><li><a href="https://www.jianshu.com/p/7321caea2a08" target="_blank" rel="noopener">Github 搜索技巧</a></li><li><a href="https://sspai.com/post/46061" target="_blank" rel="noopener">掌握 3 个搜索技巧，在 GitHub 上快速找到实用软件资源</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub 搜索技巧，用于准确搜索到相关资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.github.com/en/github/searching-for-information-on-github/searching-on-github&quot; 
      
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/categories/Tools/GitHub/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="searching" scheme="http://yoursite.com/tags/searching/"/>
    
  </entry>
  
  <entry>
    <title>ARM stack backtrace的实现</title>
    <link href="http://yoursite.com/2020/03/17/arm-stack-backtrace/"/>
    <id>http://yoursite.com/2020/03/17/arm-stack-backtrace/</id>
    <published>2020-03-17T06:09:46.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 arm 体系下如何实现 stack backtrace</p><a id="more"></a><h2 id="APCS"><a href="#APCS" class="headerlink" title="APCS"></a>APCS</h2><p>APCS (ARM Procedure Call Standard)，ARM 过程调用标准规范了 arm 寄存器的使用、过程调用时出栈和入栈的约定。如下图示意：</p><p><img src="/images/linux/apcs_t.png" alt=""></p><p>函数的栈帧由 <code>fp</code> 和 <code>sp</code> 标记边界。如果编译器遵循APCS，形成结构化的函数调用栈，就可以解析当前栈(callee)结构，从而得到调用栈(caller)的结构，这样就输出了整个回溯栈。</p><p>编译器选项 <code>-g</code> 生成栈帧信息 <code>.debug_frame</code></p><pre><code class="shell">$ readelf -S output/out.elfThere are 18 section headers, starting at offset 0x1bb0fd0:节头：  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .text             PROGBITS        90000000 001000 6c132c 04  AX  0   0 1024  [ 2] .devtab           PROGBITS        906c132c 6c232c 000c8c 00  WA  0   0  8  [ 3] .bss              NOBITS          906c1fb8 6c2fb8 16a568 00  WA  0   0  8  [ 4] .debug_abbrev     PROGBITS        00000000 6c2fb8 0b82a7 00      0   0  1  [ 5] .debug_info       PROGBITS        00000000 77b25f a37035 00      0   0  1  [ 6] .debug_line       PROGBITS        00000000 11b2294 3bb5fc 00      0   0  1  [ 7] .debug_pubnames   PROGBITS        00000000 156d890 04911e 00      0   0  1  [ 8] .debug_pubtypes   PROGBITS        00000000 15b69ae 166807 00      0   0  1  [ 9] .debug_aranges    PROGBITS        00000000 171d1b5 018900 00      0   0  1  [10] .debug_str        PROGBITS        00000000 1735ab5 0c4732 01  MS  0   0  1  [11] .comment          PROGBITS        00000000 17fa1e7 0000cf 01  MS  0   0  1  [12] .debug_frame      PROGBITS        00000000 17fa2b8 08c8b0 00      0   0  4  [13] .debug_ranges     PROGBITS        00000000 1886b68 056380 00      0   0  1  [14] .debug_loc        PROGBITS        00000000 18dcee8 2d402b 00      0   0  1  [15] .shstrtab         STRTAB          00000000 1bb0f13 0000bd 00      0   0  1  [16] .symtab           SYMTAB          00000000 1bb12a0 071130 10     17 14593  4  [17] .strtab           STRTAB          00000000 1c223d0 086411 00      0   0  1</code></pre><p>内核编译选项</p><pre><code class="makefile">ifeq ($(CONFIG_FRAME_POINTER),y)KBUILD_CFLAGS   +=-fno-omit-frame-pointer -mapcs -mno-sched-prologendif</code></pre><h2 id="unwind"><a href="#unwind" class="headerlink" title="unwind"></a>unwind</h2><p>APCS的缺陷是，维护栈框的指令过多，栈消耗大，占用的寄存器也过多，比如每次调用都必须将 <code>r11,r12,lr,pc</code> 入栈。使用unwind就能避免这些问题，生产指令的效率要有用的多。它的原理是记录每个函数的入栈指令(一般比APCS的入栈要少的多)到特殊的段 <code>.ARM.unwind_idx</code> <code>.ARM.unwind_tab</code>。</p><pre><code class="shell">$ readelf -S vmlinuxThere are 33 section headers, starting at offset 0xa33ba8:节头：  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .head.text        PROGBITS        c0008000 008000 00026c 00  AX  0   0  4  [ 2] .text             PROGBITS        c0100000 010000 55e3dc 00  AX  0   0 64  [ 3] .fixup            PROGBITS        c065e3dc 56e3dc 00001c 00  AX  0   0  4  [ 4] .rodata           PROGBITS        c0700000 570000 105fc8 00  WA  0   0 4096  [ 5] __bug_table       PROGBITS        c0805fc8 675fc8 0057a8 00   A  0   0  4  [ 6] __ksymtab         PROGBITS        c080b770 67b770 006e28 00   A  0   0  4  [ 7] __ksymtab_gpl     PROGBITS        c0812598 682598 005d10 00   A  0   0  4  [ 8] __ksymtab_strings PROGBITS        c08182a8 6882a8 01e235 00   A  0   0  1  [ 9] __param           PROGBITS        c08364e0 6a64e0 000d34 00   A  0   0  4  [10] __modver          PROGBITS        c0837214 6a7214 000dec 00   A  0   0  4  [11] __ex_table        PROGBITS        c0838000 6a8000 001038 00   A  0   0  8  [12] .ARM.unwind_idx   ARM_EXIDX       c0839038 6a9038 0273d8 00  AL 17   0  4  [13] .ARM.unwind_tab   PROGBITS        c0860410 6d0410 003630 00   A  0   0  4  [14] .notes            NOTE            c0863a40 6d3a40 000024 00  AX  0   0  4  [15] .vectors          PROGBITS        ffff0000 6e0000 000020 00  AX  0   0  4  [16] .stubs            PROGBITS        ffff1000 6e1000 0002ac 00  AX  0   0 32  [17] .init.text        PROGBITS        c09002e0 6f02e0 0440d0 00  AX  0   0 32  [18] .exit.text        PROGBITS        c09443b0 7343b0 000ee4 00  AX  0   0  4  [19] .init.arch.info   PROGBITS        c0945294 735294 0000d0 00   A  0   0  4  [20] .init.tagtable    PROGBITS        c0945364 735364 000048 00   A  0   0  4  [21] .init.smpalt      PROGBITS        c09453ac 7353ac 00bd10 00   A  0   0  4  [22] .init.pv_table    PROGBITS        c09510bc 7410bc 00064c 00   A  0   0  1  [23] .init.data        PROGBITS        c0952000 742000 00a194 00  WA  0   0 4096  [24] .data..percpu     PROGBITS        c095d000 74d000 0067cc 00  WA  0   0 64  [25] .data             PROGBITS        c0a00000 760000 0609ac 00  WA  0   0 64  [26] .data..page_align PROGBITS        c0a61000 7c1000 001000 00  WA  0   0 4096  [27] .bss              NOBITS          c0a62000 7c2000 03260c 00  WA  0   0 64  [28] .comment          PROGBITS        00000000 7c2000 00004e 01  MS  0   0  1  [29] .ARM.attributes   ARM_ATTRIBUTES  00000000 7c204e 00002f 00      0   0  1  [30] .symtab           SYMTAB          00000000 7c2080 167560 10     31 77680  4  [31] .strtab           STRTAB          00000000 9295e0 10a46c 00      0   0  1  [32] .shstrtab         STRTAB          00000000 a33a4c 00015a 00      0   0  1$ objdump -D vmlinuc04ee72c &lt;__skb_recv_datagram&gt;:c04ee72c:       e3110040        tst     r1, #64 ; 0x40c04ee730:       e92d43f0        push    {r4, r5, r6, r7, r8, r9, lr}c04ee734:       e1a09003        mov     r9, r3c04ee738:       05903144        ldreq   r3, [r0, #324]  ; 0x144c04ee73c:       e24dd014        sub     sp, sp, #20$ readelf -u .ARM.unwind_idx vmlinux0xc04ee72c &lt;__skb_recv_datagram&gt;: 0x8004adb0  Compact model index: 0  0x04      vsp = vsp + 20  0xad      pop {r4, r5, r6, r7, r8, r9, r14}  0xb0      finish</code></pre><p>输出了函数的地址和对应的编码。接下输出的是编码对应的出栈伪指令，这些伪指令正好是函数栈操作的逆过程，用于回溯。</p><p>内核编译选项</p><pre><code class="makefile">ifeq ($(CONFIG_ARM_UNWIND),y)CFLAGS_ABI  +=-funwind-tablesendif</code></pre><h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>APCS会产生更多的代码指令，对性能有影响，使用unwind的方式会生成额外的段，但不影响性能。</p><p>文件 <code>arch/arm/kernel/traps.c</code></p><pre><code class="c">#ifdef CONFIG_ARM_UNWINDstatic inline void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk){    unwind_backtrace(regs, tsk);}#elsestatic void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk){    unsigned int fp, mode;    int ok = 1;    printk(&quot;Backtrace: &quot;);    if (!tsk)        tsk = current;    if (regs) {        fp = frame_pointer(regs);        mode = processor_mode(regs);    } else if (tsk != current) {        fp = thread_saved_fp(tsk);        mode = 0x10;    } else {        asm(&quot;mov %0, fp&quot; : &quot;=r&quot; (fp) : : &quot;cc&quot;);        mode = 0x10;    }    if (!fp) {        pr_cont(&quot;no frame pointer&quot;);        ok = 0;    } else if (verify_stack(fp)) {        pr_cont(&quot;invalid frame pointer 0x%08x&quot;, fp);        ok = 0;    } else if (fp &lt; (unsigned long)end_of_stack(tsk))        pr_cont(&quot;frame pointer underflow&quot;);    pr_cont(&quot;\n&quot;);    if (ok)        c_backtrace(fp, mode);}#endif</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/itismine/article/details/4752489" target="_blank" rel="noopener">APCS，ARM 过程调用标准(ARM Procedure Call Standard) </a></li><li><a href="https://www.linuxidc.com/Linux/2013-03/81247.htm" target="_blank" rel="noopener">ARM FP寄存器及frame pointer介绍</a></li><li><a href="https://www.alivepea.me/prog/how-backtrace-work/" target="_blank" rel="noopener">Stack backtrace 的实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 arm 体系下如何实现 stack backtrace&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="backtrace" scheme="http://yoursite.com/tags/backtrace/"/>
    
      <category term="unwind" scheme="http://yoursite.com/tags/unwind/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核符号表的生成和查找</title>
    <link href="http://yoursite.com/2020/03/11/linux-kernel-all-syms/"/>
    <id>http://yoursite.com/2020/03/11/linux-kernel-all-syms/</id>
    <published>2020-03-11T03:12:09.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p><code>printk</code> 可以根据地址打印函数名/符号名，记录内核符号表生成及使用过程</p><a id="more"></a><h2 id="System-map"><a href="#System-map" class="headerlink" title="System.map"></a>System.map</h2><p>System.map 文件是编译内核时生成的，它记录了内核中的符号列表，以及符号在内存中的虚拟地址，由脚本 <code>scripts/mksysmap</code> 生成</p><h2 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h2><p>内核必须打开 <code>CONFIG_KALLSYMS</code> 编译选项，和 System.map 的区别是<strong>它同时包含了内核模块的符号列表</strong>，是在内核启动后生成的，位于文件系统的 /proc 目录下，实现代码见 <code>kernel/kallsyms.c</code></p><h2 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h2><p><strong>System.map 和内核启动后的 /proc/kallsyms 文件中的符号表只是给我们看的，内核不会使用它们</strong>，而是在编译内核时，向 vmlinux 嵌入了一个符号表</p><p>内核符号表如何嵌入内核查看文件 <code>scripts/link-vmlinux.sh</code></p><h3 id="内核符号表结构"><a href="#内核符号表结构" class="headerlink" title="内核符号表结构"></a>内核符号表结构</h3><p>由工具 <code>scripts/kallsyms</code> 生成，工具源码在同目录，用法如下</p><pre><code>nm -n vmlinux | scripts/kallsyms [--all-symbols] &gt; symbols.S</code></pre><p>使用 nm 工具获得符号表之后进行整理得到汇编文件，包括 6 个全局变量</p><ul><li><code>kallsyms_addresses</code> 数组，存放所有符号的地址列表，按地址升序排列</li><li><code>kallsyms_num_syms</code> 符号的数量</li><li><code>kallsyms_names</code> 数组，存放所有符号的名称，和 <code>kallsyms_addresses</code> 一一对应</li><li><code>kallsyms_markers</code> 存储索引用于加速搜索</li><li><code>kallsyms_token_table</code> 数组，存储压缩字符串</li><li><code>kallsyms_token_index</code> 记录每个 token 首字符在 <code>kallsyms_token_table</code> 中的偏移</li></ul><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><pre><code>c0008000 T _textc0008000 T stextc000808c t __create_page_tables</code></pre><p>计算符号 <code>c000808c t __create_page_tables</code> 偏移为 <code>0x8c</code>，从 <code>kallsyms_addresses</code> 中得到索引为 <code>2</code></p><pre><code>kallsyms_addresses:     PTR _text + 0     PTR _text + 0     PTR _text + 0x8ckallsyms_names:    .byte 0x04, 0x9b, 0xef, 0x78, 0x74    .byte 0x05, 0x54, 0x5f, 0xef, 0x78, 0x74    .byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73kallsyms_markers:    PTR 0    PTR 2917    PTR 5993</code></pre><p>根据 <code>2 &gt;&gt; 8</code> 计算出在 <code>kallsyms_markers</code> 第一组 <code>PTR 0</code>，指出起始字符的偏移在 <code>kallsyms_names[0]</code>，同时根据 <code>2 &amp;&amp; 0xFF</code> 找到具体位置</p><p><code>.byte 0x0a, 0xff, 0xe1, 0xf5, 0x8b, 0xa7, 0x18, 0xfd, 0x62, 0xd2, 0x73</code> 为压缩字符，需要根据 <code>kallsyms_token_table</code> 解析</p><ul><li>0x0a 长度</li><li>0xff <code>t_</code></li><li>0xe1 <code>_c</code></li><li>0xf5 <code>re</code></li><li>0x8b <code>ate_</code></li><li>0xa7 <code>pa</code></li><li>0x18 <code>get_</code></li><li>0xfd <code>ta</code></li><li>0x62 <code>b</code></li><li>0xd2 <code>le</code></li><li>0x73 <code>s</code></li></ul><p><code>t__create_page_tables</code> 其中 <code>t</code> 为符号类型，去除之后为 <code>__create_page_tables</code></p><h3 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h3><p>内核文件参照 <code>kernel/kallsyms.c</code> 提供接口用于内核符号表查找</p><ul><li><code>get_symbol_pos</code> 根据地址查找索引及偏移</li><li><code>module_address_lookup</code> 内核模块符号查找</li><li><code>get_symbol_offset</code> 根据 <code>kallsyms_markers</code> 获取偏移</li><li><code>kallsyms_expand_symbol</code> 获取符号名</li><li><code>kallsyms_get_symbol_type</code> 获取符号类型</li></ul><p>例如函数 <code>kallsyms_lookup</code></p><pre><code class="c">if (is_ksym_addr(addr)) {    unsigned long pos;    pos = get_symbol_pos(addr, symbolsize, offset);    /* Grab name */    kallsyms_expand_symbol(get_symbol_offset(pos),                   namebuf, KSYM_NAME_LEN);    if (modname)        *modname = NULL;    return namebuf;}/* See if it&#39;s in a module. */return module_address_lookup(addr, symbolsize, offset, modname,                 namebuf);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;printk&lt;/code&gt; 可以根据地址打印函数名/符号名，记录内核符号表生成及使用过程&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="kallsyms" scheme="http://yoursite.com/tags/kallsyms/"/>
    
  </entry>
  
  <entry>
    <title>USB 通信设备类与 USB Dongle 拨号</title>
    <link href="http://yoursite.com/2020/03/11/usb-3g-and-usb-cdc/"/>
    <id>http://yoursite.com/2020/03/11/usb-3g-and-usb-cdc/</id>
    <published>2020-03-11T01:40:47.000Z</published>
    <updated>2020-08-11T03:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<ul><li>USB 通信设备类</li><li>USB Dongle 拨号</li></ul><a id="more"></a><h2 id="Defined-Class-Codes"><a href="#Defined-Class-Codes" class="headerlink" title="Defined Class Codes"></a>Defined Class Codes</h2><p><a href="https://www.usb.org/defined-class-codes" target="_blank" rel="noopener">Defined Class Codes</a></p><p>例如：</p><ul><li><code>02h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass02h" target="_blank" rel="noopener">Communications and CDC Control</a></li><li><code>08h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass08h" target="_blank" rel="noopener">Mass Storage</a></li><li><code>09h</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass09h" target="_blank" rel="noopener">Hub</a></li><li><code>0Ah</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClass0Ah" target="_blank" rel="noopener">CDC-Data</a></li><li><code>EFh</code> <a href="https://www.usb.org/defined-class-codes#anchor_BaseClassEFh" target="_blank" rel="noopener">Miscellaneous</a></li></ul><p>Linux4.9 <code>include/uapi/linux/usb/ch9.h</code> 可以看到各个定义值</p><h2 id="Communications-Class-Subclass-Codes"><a href="#Communications-Class-Subclass-Codes" class="headerlink" title="Communications Class Subclass Codes"></a>Communications Class Subclass Codes</h2><p>USB 的 CDC 类是 USB 通信设备类（Communication Device Class）的简称。CDC 类是 USB 组织定义的一类专门给各种通信设备（电信通信设备和中速网络通信设备）使用的 USB 子类。</p><p>具体列表见文档 Universal Serial Bus Class Definitions for Communications Devices 4.3章节：</p><ul><li><code>00h</code> RESERVED</li><li><code>01h</code> Direct Line Control Model [USBPSTN1.2]</li><li><code>02h</code> Abstract Control Model [USBPSTN1.2]</li><li><code>03h</code> Telephone Control Model [USBPSTN1.2]</li><li><code>04h</code> Multi-Channel Control Model [USBISDN1.2]</li><li><code>05h</code> CAPI Control Model [USBISDN1.2]</li><li><code>06h</code> Ethernet Networking Control Model [USBECM1.2]</li><li><code>07h</code> ATM Networking Control Model [USBATM1.2]</li><li><code>08h</code> Wireless Handset Control Model [USBWMC1.1]</li><li><code>09h</code> Device Management [USBWMC1.1]</li><li><code>0Ah</code> Mobile Direct Line Model [USBWMC1.1]</li><li><code>0Bh</code> OBEX [USBWMC1.1]</li><li><code>0Ch</code> Ethernet Emulation Model [USBEEM1.0]</li><li><code>0Dh</code> Network Control Model [USBNCM1.0]</li><li><code>0Eh</code> Mobile Broadband Interface Model [USBMBIM1.0]</li><li><code>0Dh-7Fh</code> RESERVED (future use)</li><li><code>80-FEh</code> RESERVED (vendor specific)</li></ul><h2 id="Linux4-9-内核实现"><a href="#Linux4-9-内核实现" class="headerlink" title="Linux4.9 内核实现"></a>Linux4.9 内核实现</h2><p>构造 USB 设备宏定义</p><pre><code class="c">/** * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces * @cl: bInterfaceClass value * @sc: bInterfaceSubClass value * @pr: bInterfaceProtocol value * * This macro is used to create a struct usb_device_id that matches a * specific class of interfaces. */#define USB_INTERFACE_INFO(cl, sc, pr) \    .match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \    .bInterfaceClass = (cl), \    .bInterfaceSubClass = (sc), \    .bInterfaceProtocol = (pr)</code></pre><p>例如：</p><pre><code class="c">/* Telit LE922A6 in MBIM composition */{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x1041, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),  .driver_info = (unsigned long)&amp;cdc_mbim_info_avoid_altsetting_toggle,},{    USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_EEM,            USB_CDC_PROTO_EEM),    .driver_info = (unsigned long) &amp;eem_info,},/* Telit LE910 V2 */{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x0036,    USB_CLASS_COMM,    USB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),  .driver_info = (unsigned long)&amp;wwan_noarp_info,},</code></pre><p>内核文件</p><pre><code class="shell">$ find -name &quot;cdc_*&quot;./include/linux/usb/cdc_ncm.h./drivers/net/usb/cdc_mbim.c./drivers/net/usb/cdc_ncm.c./drivers/net/usb/cdc_ether.c./drivers/net/usb/cdc_eem.c./drivers/net/usb/cdc_ether.o./drivers/net/usb/cdc_subset.c./Documentation/networking/cdc_mbim.txt</code></pre><h2 id="Rndis"><a href="#Rndis" class="headerlink" title="Rndis"></a>Rndis</h2><p>在文件 <code>drivers/net/usb/rndis_host.c</code> 中发现如下代码</p><pre><code class="c">static const struct usb_device_id   products [] = {{    /* 2Wire HomePortal 1000SW */    USB_DEVICE_AND_INTERFACE_INFO(0x1630, 0x0042,                      USB_CLASS_COMM, 2 /* ACM */, 0x0ff),    .driver_info = (unsigned long) &amp;rndis_poll_status_info,}, {    /* RNDIS is MSFT&#39;s un-official variant of CDC ACM */    USB_INTERFACE_INFO(USB_CLASS_COMM, 2 /* ACM */, 0x0ff),    .driver_info = (unsigned long) &amp;rndis_info,}, {    /* &quot;ActiveSync&quot; is an undocumented variant of RNDIS, used in WM5 */    USB_INTERFACE_INFO(USB_CLASS_MISC, 1, 1),    .driver_info = (unsigned long) &amp;rndis_poll_status_info,}, {    /* RNDIS for tethering */    USB_INTERFACE_INFO(USB_CLASS_WIRELESS_CONTROLLER, 1, 3),    .driver_info = (unsigned long) &amp;rndis_info,},    { },        // END};MODULE_DEVICE_TABLE(usb, products);</code></pre><blockquote><p>RNDIS是一个以太网端口 （ Ethernet port ）。最开始是微软控制的，用以取代 CDC Ethernet 的协议。Linux 支持它仅仅是因为微软不支持 CDC以太网标准。</p></blockquote><h2 id="USB-Dongle-拨号"><a href="#USB-Dongle-拨号" class="headerlink" title="USB Dongle 拨号"></a>USB Dongle 拨号</h2><blockquote><p>Many modern (and most LTE) usb modems provide <strong>qmi, mbim, ncm, rndis</strong> protocol for connection instead of legacy <strong>ppp</strong> protocol, they are faster and better, overall recommended. For more information:</p></blockquote><ul><li>qmi and mbim, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ltedongle" target="_blank" rel="noopener">How To Use LTE modem in QMI mode for WAN connection</a></li><li>ncm, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ethernetoverusb_ncm" target="_blank" rel="noopener">How To Use LTE modem in NCM mode for WAN connection</a></li><li>rndis, see <a href="https://openwrt.org/docs/guide-user/network/wan/wwan/ethernetoverusb_rndis" target="_blank" rel="noopener">How To Use LTE modem in RNDIS mode for WAN connection</a></li></ul><h2 id="内核设备列表"><a href="#内核设备列表" class="headerlink" title="内核设备列表"></a>内核设备列表</h2><p>USB 设备需要关心 <code>ProductID</code> 和 <code>VendorID</code>，用于表示某一种具体的设备，例如文件 <code>unusual_devs.h</code> 列举了非常规设备列表，表示这些设备需要特殊处理</p><pre><code class="c">/* * Reported by fangxiaozhi &lt;huananhu@huawei.com&gt; * This brings the HUAWEI data card devices into multi-port mode */UNUSUAL_DEV(  0x12d1, 0x1001, 0x0000, 0x0000,        &quot;HUAWEI MOBILE&quot;,        &quot;Mass Storage&quot;,        USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,        0),UNUSUAL_DEV(  0x12d1, 0x1003, 0x0000, 0x0000,        &quot;HUAWEI MOBILE&quot;,        &quot;Mass Storage&quot;,        USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,        0),</code></pre><h2 id="Add-New-USB-Dongle"><a href="#Add-New-USB-Dongle" class="headerlink" title="Add New USB Dongle"></a>Add New USB Dongle</h2><p>在内核中增加普通 USB Dongle 设备，修改 <code>drivers/usb/serial/option.c</code> 中的数组 <code>option_ids</code></p><pre><code class="c">{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1C0B, 0xff, 0xff, 0xff) },{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1C05, 0xff, 0xff, 0xff) },</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/kangear/article/details/37605811" target="_blank" rel="noopener">USB中CDC-ECM的了解和配置</a></li><li><a href="https://wenku.baidu.com/view/fd16907e011ca300a6c3903e.html" target="_blank" rel="noopener">RNDIS,ECM及MBIM报文简述</a></li><li><a href="https://openwrt.org/docs/guide-user/network/wan/wwan/3gdongle" target="_blank" rel="noopener">Use 3g/UMTS USB Dongle for WAN connection</a></li><li><a href="https://stackoverflow.com/questions/20299434/whats-different-in-usb-class-when-the-devices-are-modem" target="_blank" rel="noopener">What’s different in USB class when the devices are modem?</a></li><li><a href="https://www.iteye.com/blog/javatome-1205027" target="_blank" rel="noopener">Linux那些事儿之我是U盘(18)</a></li><li><a href="https://blog.csdn.net/cfy_phonex/article/details/22684005" target="_blank" rel="noopener">Android f_rndis 分析笔记</a></li><li><a href="https://wenku.baidu.com/view/a1e2c42d4b73f242336c5fa0.html" target="_blank" rel="noopener">RNDIS原理分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;USB 通信设备类&lt;/li&gt;
&lt;li&gt;USB Dongle 拨号&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="USB" scheme="http://yoursite.com/categories/Linux/USB/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="rndis" scheme="http://yoursite.com/tags/rndis/"/>
    
      <category term="usb" scheme="http://yoursite.com/tags/usb/"/>
    
      <category term="3g" scheme="http://yoursite.com/tags/3g/"/>
    
      <category term="ppp" scheme="http://yoursite.com/tags/ppp/"/>
    
      <category term="usb-cdc" scheme="http://yoursite.com/tags/usb-cdc/"/>
    
      <category term="ecm" scheme="http://yoursite.com/tags/ecm/"/>
    
      <category term="mbim" scheme="http://yoursite.com/tags/mbim/"/>
    
  </entry>
  
</feed>
