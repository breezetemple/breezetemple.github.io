<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT日记</title>
  
  <subtitle>Life is Now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-11T02:35:26.216Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Breeze.Temple</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核栈溢出检测</title>
    <link href="http://yoursite.com/2020/03/09/linux-kernel-stack/"/>
    <id>http://yoursite.com/2020/03/09/linux-kernel-stack/</id>
    <published>2020-03-09T02:22:33.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>监测内核栈使用情况，分析 crash 问题</p><a id="more"></a><p><code>thread_info</code> 位于内核栈底部，一旦溢出会破坏相关信息，有时会报错，但更多的是不直接报错，而是各种奇怪的panic</p><p><img src="/images/linux/kstack-smash.png" alt="kernel stack"></p><h2 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h2><p>开启 <code>debugfs</code> 使用如下方法监控内核栈的大小和深度</p><pre><code># mount -t debugfs nodev /sys/kernel/debug# echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled# cat /sys/kernel/debug/tracing/stack_max_size# cat /sys/kernel/debug/tracing/stack_trace</code></pre><h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><h3 id="CONFIG-DEBUG-STACK-USAGE"><a href="#CONFIG-DEBUG-STACK-USAGE" class="headerlink" title="CONFIG_DEBUG_STACK_USAGE"></a>CONFIG_DEBUG_STACK_USAGE</h3><pre><code>Symbol: DEBUG_STACK_USAGE [=y]Type  : booleanPrompt: Stack utilization instrumentation  Location:    -&gt; Kernel hacking(1)   -&gt; Memory Debugging  Defined at lib/Kconfig.debug:562  Depends on: DEBUG_KERNEL [=y] &amp;&amp; !IA64</code></pre><p>用于跟踪内核栈的溢出错误，一个内核栈溢出错误的明显的现象是产生 oops 错误却没有列出系统的调用栈信息。该选项将使内核进行栈溢出检查，并使内核进行栈使用的统计</p><h3 id="DEBUG-STACK-OVERFLOW"><a href="#DEBUG-STACK-OVERFLOW" class="headerlink" title="DEBUG_STACK_OVERFLOW"></a>DEBUG_STACK_OVERFLOW</h3><p>内核未提供 arm 配置选项，可以参照 <a href="https://www.alivepea.me/kernel/kernel-overflow/" target="_blank" rel="noopener">patch 检测内核的堆栈溢出</a></p><h3 id="CONFIG-STACK-TRACER"><a href="#CONFIG-STACK-TRACER" class="headerlink" title="CONFIG_STACK_TRACER"></a>CONFIG_STACK_TRACER</h3><pre><code>Symbol: STACK_TRACER [=n]   Type  : boolean   Prompt: Trace max stack     Location:       -&gt; Kernel hacking         -&gt; Tracers (FTRACE [=y])     Defined at kernel/trace/Kconfig:381     Depends on: TRACING_SUPPORT [=y] &amp;&amp; FTRACE [=y] &amp;&amp; HAVE_FUNCTION_TRACER [=y]     Selects: FUNCTION_TRACER [=n] &amp;&amp; STACKTRACE [=y] &amp;&amp; KALLSYMS [=y]</code></pre><p>参照文档 <code>Documentation/trace/ftrace.txt</code> 使用如下</p><pre><code># echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled# cat stack_max_size2928# cat stack_trace       Depth    Size   Location    (18 entries)       -----    ----   -------- 0)     2928     224   update_sd_lb_stats+0xbc/0x4ac 1)     2704     160   find_busiest_group+0x31/0x1f1 2)     2544     256   load_balance+0xd9/0x662 3)     2288      80   idle_balance+0xbb/0x130 4)     2208     128   __schedule+0x26e/0x5b9 5)     2080      16   schedule+0x64/0x66 6)     2064     128   schedule_timeout+0x34/0xe0 7)     1936     112   wait_for_common+0x97/0xf1 8)     1824      16   wait_for_completion+0x1d/0x1f 9)     1808     128   flush_work+0xfe/0x11910)     1680      16   tty_flush_to_ldisc+0x1e/0x2011)     1664      48   input_available_p+0x1d/0x5c12)     1616      48   n_tty_poll+0x6d/0x13413)     1568      64   tty_poll+0x64/0x7f14)     1504     880   do_select+0x31e/0x51115)      624     400   core_sys_select+0x177/0x21616)      224      96   sys_select+0x91/0xb917)      128     128   system_call_fastpath+0x16/0x1b</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监测内核栈使用情况，分析 crash 问题&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="debugfs" scheme="http://yoursite.com/tags/debugfs/"/>
    
      <category term="crash" scheme="http://yoursite.com/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>打印用户态段错误信息</title>
    <link href="http://yoursite.com/2020/03/05/linux-user-debug/"/>
    <id>http://yoursite.com/2020/03/05/linux-user-debug/</id>
    <published>2020-03-05T02:01:09.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>user_debug</code> 打印由用户态引起的 oops 信息</p><a id="more"></a><p><a href="https://www.cnblogs.com/lifexy/p/8045191.html" target="_blank" rel="noopener">Linux应用调试-修改内核来打印用户态的oops</a></p><ul><li>Linux 4.9</li><li>arm arch</li></ul><h2 id="Linux-内核错误处理"><a href="#Linux-内核错误处理" class="headerlink" title="Linux 内核错误处理"></a>Linux 内核错误处理</h2><p>文件 <code>arch/arm/mm/fsr-2level.c</code></p><pre><code class="c">{ do_bad,       SIGSEGV, 0,     &quot;vector exception&quot;         },{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },{ do_bad,       SIGKILL, 0,     &quot;terminal exception&quot;           },{ do_bad,       SIGBUS,  BUS_ADRALN,    &quot;alignment exception&quot;          },{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },{ do_translation_fault, SIGSEGV, SEGV_MAPERR,   &quot;section translation fault&quot;    },{ do_bad,       SIGBUS,  0,     &quot;external abort on linefetch&quot;      },{ do_page_fault,    SIGSEGV, SEGV_MAPERR,   &quot;page translation fault&quot;       },{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;section domain fault&quot;         },{ do_bad,       SIGBUS,  0,     &quot;external abort on non-linefetch&quot;  },{ do_bad,       SIGSEGV, SEGV_ACCERR,   &quot;page domain fault&quot;        },{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },{ do_sect_fault,    SIGSEGV, SEGV_ACCERR,   &quot;section permission fault&quot;     },{ do_bad,       SIGBUS,  0,     &quot;external abort on translation&quot;    },{ do_page_fault,    SIGSEGV, SEGV_ACCERR,   &quot;page permission fault&quot;        },</code></pre><ul><li><code>do_translation_fault</code> 调用 <code>do_bad_area</code></li><li><code>do_page_fault</code> 调用 <code>__do_user_fault</code> 或 <code>__do_kernel_fault</code></li><li><code>do_sect_fault</code> 调用 <code>do_bad_area</code></li></ul><pre><code class="c">/*                                                                               * Oops.  The kernel tried to access some page that wasn&#39;t present.              */                                                                             static void                                                                     __do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,             struct pt_regs *regs)                                                 {                                                                                   /*                                                                               * Are we prepared to handle this kernel fault?                                  */                                                                             if (fixup_exception(regs))                                                          return;                                                                     /*                                                                               * No handler, we&#39;ll have to terminate things with extreme prejudice.            */                                                                             bust_spinlocks(1);                                                              pr_alert(&quot;Unable to handle kernel %s at virtual address %08lx\n&quot;,                    (addr &lt; PAGE_SIZE) ? &quot;NULL pointer dereference&quot; :                               &quot;paging request&quot;, addr);                                                   show_pte(mm, addr);                                                             die(&quot;Oops&quot;, regs, fsr);                                                         bust_spinlocks(0);                                                              do_exit(SIGKILL);                                                           }/* * Something tried to access memory that isn&#39;t in our memory map.. * User mode accesses just cause a SIGSEGV */static void__do_user_fault(struct task_struct *tsk, unsigned long addr,        unsigned int fsr, unsigned int sig, int code,        struct pt_regs *regs){    struct siginfo si;#ifdef CONFIG_DEBUG_USER    if (((user_debug &amp; UDBG_SEGV) &amp;&amp; (sig == SIGSEGV)) ||        ((user_debug &amp; UDBG_BUS)  &amp;&amp; (sig == SIGBUS))) {        printk(KERN_DEBUG &quot;%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\n&quot;,               tsk-&gt;comm, sig, addr, fsr);        show_pte(tsk-&gt;mm, addr);        show_regs(regs);    }#endif    tsk-&gt;thread.address = addr;    tsk-&gt;thread.error_code = fsr;    tsk-&gt;thread.trap_no = 14;    si.si_signo = sig;    si.si_errno = 0;    si.si_code = code;    si.si_addr = (void __user *)addr;    force_sig_info(sig, &amp;si, tsk);}void do_bad_area(unsigned long addr, unsigned int fsr, struct pt_regs *regs){    struct task_struct *tsk = current;    struct mm_struct *mm = tsk-&gt;active_mm;    /*     * If we are in kernel mode at this point, we     * have no context to handle this fault with.     */    if (user_mode(regs))        __do_user_fault(tsk, addr, fsr, SIGSEGV, SEGV_MAPERR, regs);    else        __do_kernel_fault(mm, addr, fsr, regs);}</code></pre><p>可以看出 <code>__do_kernel_fault</code> 为内核态 oops 输出，<code>__do_user_fault</code> 为用户态输出，同时需要满足</p><ol><li>定义 <code>CONFIG_DEBUG_USER</code></li><li>设置 <code>user_debug</code></li></ol><h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><ul><li><code>Kernel hacking</code> -&gt; <code>Verbose user fault messages</code></li><li><code>user_debug</code> 见文档 <code>kernel-parameters.txt</code>，在 cmdline 中增加 <code>user_debug=31</code><pre><code class="txt">  user_debug= [KNL,ARM]          Format: &lt;int&gt;          See arch/arm/Kconfig.debug help text.              1 - undefined instruction events              2 - system calls              4 - invalid data aborts              8 - SIGSEGV faults              16 - SIGBUS faults          Example: user_debug=31</code></pre><pre><code class="c">unsigned int user_debug;static int __init user_debug_setup(char *str){  get_option(&amp;str, &amp;user_debug);  return 1;}__setup(&quot;user_debug=&quot;, user_debug_setup);</code></pre></li></ul><p>修改之后测试会输出调试信息，但不包括栈信息</p><h2 id="打印应用栈数据"><a href="#打印应用栈数据" class="headerlink" title="打印应用栈数据"></a>打印应用栈数据</h2><p>参考 <code>__do_kernel_fault</code> 中打印栈信息函数</p><pre><code class="c">if (!user_mode(regs) || in_interrupt()) {    dump_mem(KERN_EMERG, &quot;Stack: &quot;, regs-&gt;ARM_sp,         THREAD_SIZE + (unsigned long)task_stack_page(tsk));    dump_backtrace(regs, tsk);    dump_instr(KERN_EMERG, regs);}</code></pre><p>通过sp寄存器里存的栈地址，每打印一个栈地址里的32位数据, 栈地址便加4</p><p>在 <code>__do_user_fault</code> 中修改如下</p><pre><code class="c">unsigned long ret;unsigned long val;int i = 0;printk(&quot;Stack: \n&quot;);while(i &lt; 1024){    if(copy_from_user(&amp;val, (const void __user *)(regs-&gt;ARM_sp + i*4), 4)){        break;    }    i++;    printk(&quot;%08x &quot;, val);    if(i%8 == 0)        printk(&quot;\n&quot;);}printk(&quot;\n end of stack \n&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;user_debug&lt;/code&gt; 打印由用户态引起的 oops 信息&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Debug" scheme="http://yoursite.com/categories/Linux/Debug/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="oops" scheme="http://yoursite.com/tags/oops/"/>
    
  </entry>
  
  <entry>
    <title>gcc 编译选项 -fomit-frame-pointer</title>
    <link href="http://yoursite.com/2020/02/26/gcc-options-fomit-frame-pointer/"/>
    <id>http://yoursite.com/2020/02/26/gcc-options-fomit-frame-pointer/</id>
    <published>2020-02-26T05:34:12.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>编译选项 <code>-fomit-frame-pointer</code> 与 <code>-fno-omit-frame-pointer</code> 对汇编及调试影响</p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>栈是向下生长的。所谓向下生长是指从 内存高地址 -&gt; 低地址 的路径延伸</li><li>有两个重要的指针用于维护栈信息<ul><li>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。  由于栈的地址大小是从上到下从大到小，所以ESP指在栈的最底端</li><li>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。指在栈的最顶端</li></ul></li></ul><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>手册中对 <code>-fomit-frame-pointer</code> 描述如下</p><blockquote><p>Don’t keep the frame pointer in a register for functions that don’t need one.  This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions.  It also makes debugging impossible on some machines.<br>Enabled at levels -O, -O2, -O3, -Os.</p></blockquote><p>当使用 <code>-O0</code> 时不会开启上述选项，编译器会在栈空间中保存额外信息用于调试，即 <code>frame pointer</code></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="c">int add(int a, int b){    return a + b ;}</code></pre><p>汇编对比如下</p><pre><code class="shell">$ gcc -fno-omit-frame-pointer test.c$ csky-elf-objdump -dS a.out00008934 &lt;add&gt;:    8934:    2470          subi    r0, r0, 8    8936:    9800          st    r8, (r0, 0)    8938:    2470          subi    r0, r0, 8    893a:    1208          mov    r8, r0    893c:    9208          st    r2, (r8, 0)    893e:    9318          st    r3, (r8, 4)    8940:    8608          ld    r6, (r8, 0)    8942:    8718          ld    r7, (r8, 4)    8944:    1c67          addu    r7, r7, r6    8946:    1272          mov    r2, r7    8948:    1280          mov    r0, r8    894a:    2070          addi    r0, r0, 8    894c:    8640          ld    r6, (r0, 16)    894e:    8800          ld    r8, (r0, 0)    8950:    2070          addi    r0, r0, 8    8952:    00cf          jmp    r15$ gcc -fomit-frame-pointer test.c$ objdump -dS a.out00008934 &lt;add&gt;:    8934:    2470          subi    r0, r0, 8    8936:    9200          st    r2, (r0, 0)    8938:    9310          st    r3, (r0, 4)    893a:    8600          ld    r6, (r0, 0)    893c:    8710          ld    r7, (r0, 4)    893e:    1c67          addu    r7, r7, r6    8940:    1272          mov    r2, r7    8942:    2070          addi    r0, r0, 8    8944:    8640          ld    r6, (r0, 16)    8946:    00cf          jmp    r15</code></pre><p>可以看到在栈上多开辟一些空间用于存储 <code>frame pointer</code></p><p>不开启优化时更能反映出压栈及出栈的操作，在这个过程中不会有 <code>fp</code> 操作</p><pre><code class="disass">00008934 &lt;add&gt;:    # 开辟栈空间 8B    8934:    2470          subi    r0, r0, 8    # 第一个参数 r2 入栈    8936:    9200          st    r2, (r0, 0)    # 第二个参数 r3 入栈    8938:    9310          st    r3, (r0, 4)    # 加载并执行子程序 a + b    893a:    8600          ld    r6, (r0, 0)    893c:    8710          ld    r7, (r0, 4)    893e:    1c67          addu    r7, r7, r6    # 赋值给 r2 作为函数返回值    8940:    1272          mov    r2, r7    # 释放栈    8942:    2070          addi    r0, r0, 8    8944:    8640          ld    r6, (r0, 16)    # 返回调用函数栈    8946:    00cf          jmp    r15</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/HedpatCzw/article/details/50380128" target="_blank" rel="noopener">关于-fno-omit-frame-pointer与-fomit-frame-pointer</a></li><li><a href="https://jijing.site/riscv/20190428_function_call.html" target="_blank" rel="noopener">C函数调用和汇编代码分析</a></li><li><a href="http://blog.sina.com.cn/s/blog_a558c25a0101l9yd.html" target="_blank" rel="noopener">Linux下Call Stack追溯的实现机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译选项 &lt;code&gt;-fomit-frame-pointer&lt;/code&gt; 与 &lt;code&gt;-fno-omit-frame-pointer&lt;/code&gt; 对汇编及调试影响&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
      <category term="BackTrace" scheme="http://yoursite.com/categories/C/BackTrace/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
      <category term="bt" scheme="http://yoursite.com/tags/bt/"/>
    
      <category term="stack frame" scheme="http://yoursite.com/tags/stack-frame/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 发布 Hexo Blog</title>
    <link href="http://yoursite.com/2020/01/19/github-actions-ci-hexo/"/>
    <id>http://yoursite.com/2020/01/19/github-actions-ci-hexo/</id>
    <published>2020-01-19T09:16:07.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用 Travis CI 实现了自动生成并发布 Hexo 博客，现在切换到 GitHub Actions</p><a id="more"></a><h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><ul><li>源码仓库，私有</li><li>发布仓库，xxx.github.io</li></ul><p>有两种方式可以用于 GitHub Actions 发布 Blog</p><ul><li>ssh-key，分别提交 key 到两个仓库，参考 <a href="https://juejin.im/post/5da03d5e6fb9a04e046bc3a2" target="_blank" rel="noopener">用 GitHub Actions 自动化发布Hexo网站到 GitHub Pages</a></li><li>token，参考 <a href="https://www.jianshu.com/p/7940fe40885d" target="_blank" rel="noopener">Hexo 使用 Github Actions 自动更新</a></li></ul><h2 id="source仓库"><a href="#source仓库" class="headerlink" title="source仓库"></a>source仓库</h2><p>打开仓库设置，在 <code>Secrets</code> 选项中，点击 <code>Add a new secret</code>，新建 <code>GH_TOKEN</code></p><p>添加 <code>Github Actions</code> 文件</p><pre><code class="yaml">name: Hexo Auto-Deployon: [push]jobs:  build:    name: Hexo Auto-Deploy by GitHub Actions    runs-on: ubuntu-latest    steps:    - name: 1. git checkout...      uses: actions/checkout@v1    - name: 2. setup nodejs...      uses: actions/setup-node@v1    - name: 3. install hexo...      run: |        npm install hexo-cli -g        npm install    - name: 4. hexo generate public files...      run: |        hexo clean        hexo g      - name: 5. deploy &#39;public files&#39; to &#39;xxx.github.io&#39; repo...      env:        GH_REF: https://shenbo:${{ secrets.GH_TOKEN }}@github.com/shenbo/shenbo.github.io.git      run: |        git config --global user.name &quot;shenbo&quot;        git config --global user.email &quot;shenbo@hotmail.com&quot;        git clone ${GH_REF} hexo-public        cp -rf public/* hexo-public/                cd hexo-public        git add .        git commit -am &quot;Deployed by GitHub Actions ...&quot;        git push origin master</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前使用 Travis CI 实现了自动生成并发布 Hexo 博客，现在切换到 GitHub Actions&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Tools/Hexo/"/>
    
      <category term="CI" scheme="http://yoursite.com/categories/Tools/CI/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="ci" scheme="http://yoursite.com/tags/ci/"/>
    
      <category term="GitHub Actions" scheme="http://yoursite.com/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>32/64系统支撑库导致 Bear 编译失败</title>
    <link href="http://yoursite.com/2020/01/10/bear-cmake-error/"/>
    <id>http://yoursite.com/2020/01/10/bear-cmake-error/</id>
    <published>2020-01-10T03:27:38.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Bear 生成 <code>compile_commands.json</code> 时需要编译 32位库，记录错误及解决过程</p><a id="more"></a><h2 id="Bear"><a href="#Bear" class="headerlink" title="Bear"></a>Bear</h2><p>编译命令及错误</p><pre><code class="shell">$ cmake .. -DCMAKE_C_COMPILER_ARG1=&quot;-m32&quot;; VERBOSE=1 make all    Linking C executable cmTC_8b292    /usr/local/bin/cmake -E cmake_link_script CMakeFiles/cmTC_8b292.dir/link.txt --verbose=1    /usr/bin/cc -m32      -rdynamic CMakeFiles/cmTC_8b292.dir/testCCompiler.c.o  -o cmTC_8b292    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc    /usr/bin/ld: 找不到 -lgcc    /usr/bin/ld: 当搜索用于 /usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a 时跳过不兼容的 -lgcc    /usr/bin/ld: 找不到 -lgcc</code></pre><p>可以看到原因是找不到 <code>libgcc.a</code></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>系统为 <code>ubuntu18.04</code>，可以找到 <code>/usr/lib/gcc/x86_64-linux-gnu/7/libgcc.a</code>，需要安装32位支持库</p><pre><code class="shell">$ sudo apt-cache search libgcclibgcc1 - GCC 支持库lib32gcc-7-dev - GCC support library (32 bit development files)$ sudo apt install lib32gcc-7-dev$ fd libgcc.agcc/x86_64-linux-gnu/7/32/libgcc.agcc/x86_64-linux-gnu/7/libgcc.a</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Bear 生成 &lt;code&gt;compile_commands.json&lt;/code&gt; 时需要编译 32位库，记录错误及解决过程&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Make" scheme="http://yoursite.com/categories/Tools/Make/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
      <category term="cmake" scheme="http://yoursite.com/tags/cmake/"/>
    
      <category term="make" scheme="http://yoursite.com/tags/make/"/>
    
      <category term="bear" scheme="http://yoursite.com/tags/bear/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 BRE ERE PCRE 区别</title>
    <link href="http://yoursite.com/2019/12/27/regular-expression/"/>
    <id>http://yoursite.com/2019/12/27/regular-expression/</id>
    <published>2019-12-27T06:35:30.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>了解正则表达式标准，各个之间存在一些差异</p><ul><li>BRE (Basic Regular Expressions)</li><li>ERE (Extended Regular Expressions)</li><li>PCRE (Perl Compatible Regular Expressions)</li></ul><a id="more"></a><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><table class="table table-bordered table-striped">  <thead>    <tr><th>What</th><th>Syntax</th><th>Comments/gotchas</th></tr>  </thead>  <tbody id="programs-languages" class="subgroup">    <tr><th colspan="3">Programming languages</th></tr>    <tr><td><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a></td><td>PCRE</td><td>PCRE is actually a separate implementation from Perl's, with <a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions#Differences_from_Perl" target="_blank" rel="noopener">slight differences</a></td></tr>    <tr><td><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code> standard lib</a></td><td>Python's own syntax (Perl-inspired)</td><td></td></tr>    <tr><td><a href="http://ruby-doc.org/core-2.2.0/Regexp.html" target="_blank" rel="noopener">Ruby</a></td><td>Ruby's own syntax (Perl-inspired)</td><td></td></tr>    <tr><td><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">Java's java.util.regex</a></td><td>Almost PCRE</td><td></td></tr>    <tr><td><a href="http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="noopener">Boost.Regex</a></td><td>PCRE</td><td></td></tr>  </tbody>  <tbody id="programs-editors" class="subgroup">    <tr><th colspan="3">Text editors</th></tr>    <tr><td><a href="http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html" target="_blank" rel="noopener">Eclipse</a></td><td>PCRE</td><td></td></tr>    <tr><td>Emacs</td><td>?</td><td></td></tr>    <tr><td>Netbeans</td><td>PCRE</td><td></td></tr>    <tr><td>Notepad++</td><td>PCRE (Boost.Regex)</td><td></td></tr>    <tr><td>PyCharm</td><td>PCRE</td><td>Perl-inspired</td></tr>    <tr><td>Sublime Text</td><td>?</td><td></td></tr>    <tr><td>UltraEdit</td><td>PCRE</td><td></td></tr>    <tr><td>ViM</td><td>ViM</td><td></td></tr>  </tbody>  <tbody id="programs-cmdline" class="subgroup">    <tr><th colspan="3">Command-line tools</th></tr>    <tr><td>awk</td><td>ERE</td><td>might depend on the implementation</td></tr>    <tr><td>grep</td><td>BRE, <code>egrep</code> for ERE, <code>grep -P</code> for PCRE (optional)</td><td></td></tr>    <tr><td>less</td><td>ERE</td><td>usually; man page says "regular expression library supplied by your system"</td></tr>    <tr><td>screen</td><td>plain text</td><td></td></tr>    <tr><td>sed</td><td>BRE, <code>-E</code> switches to ERE</td><td></td></tr>  </tbody></table><h2 id="语法差异"><a href="#语法差异" class="headerlink" title="语法差异"></a>语法差异</h2><table class="table table-bordered table-striped">  <thead>    <tr><th>What</th><th><a href="http://perldoc.perl.org/perlre.html" target="_blank" rel="noopener">Perl</a>/PCRE</th><th><a href="https://docs.python.org/library/re.html" target="_blank" rel="noopener">Python's <code>re</code></a></th><th>POSIX (BRE)</th><th>POSIX extended (ERE)</th><th>ViM</th></tr>  </thead>  <tbody id="syntax-basics" class="subgroup">    <tr><th colspan="6">Basics</th></tr>    <tr><td>Custom character class</td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td><td><code>[...]</code></td></tr>    <tr><td>Negated custom character class</td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td><td><code>[^...]</code></td></tr>    <tr><td>\ special in class?</td><td>yes</td><td>yes</td><td>no, <code>]</code> escaped if comes first</td><td>no, <code>]</code> escaped if comes first</td><td>yes</td></tr>    <tr><td>Ranges</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td><code>[a-z]</code>, <code>-</code> escaped if first or last</td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td><td></td><td><code>[a-z]</code>, <code>-</code> escaped if comes last</td></tr>    <tr><td>Alternation</td><td><code>|</code></td><td><code>|</code></td><td><code>\|</code></td><td><code>|</code></td><td><code>\|</code> <code>\&amp;</code> (low precedence)</td></tr>    <tr><td>Escaped character</td><td><code>\033</code> <code>\x1B</code> <code>\x{1234}</code> <code>\N{name}</code> <code>\N{U+263D}</code></td><td><code>\x12</code></td><td class="na"></td><td class="na"></td><td><code>\%d123</code> <code>\%x2A</code> <code>\%u1234</code> <code>\%U1234ABCD</code></td></tr>  </tbody>  <tbody id="syntax-characters" class="subgroup">    <tr><th colspan="6">Character classes</th></tr>    <tr><td>Any character (except newline)</td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td><td><code>.</code></td></tr>    <tr><td>Any character (including newline)</td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\_.</code></td></tr>    <tr><td>Match a "word" character (alphanumeric plus <code>_</code>)</td><td><code>\w</code> <code>[[:word:]]</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td><td><code>\w</code></td></tr>    <tr><td>Case</td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td class="na"></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>[[:upper:]]</code> / <code>[[:lower:]]</code></td><td><code>\u</code> <code>[[:upper:]]</code> / <code>\l</code> <code>[[:lower:]]</code></td></tr>    <tr><td>Match a non-"word" character</td><td><code>\W</code></td><td><code>\W</code></td><td class="na"></td><td class="na"></td><td><code>\W</code></td></tr>    <tr><td>Match a whitespace character (except newline)</td><td class="na"></td><td class="na"></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code> <code>[[:space:]]</code></td></tr>    <tr><td>Whitespace including newline</td><td><code>\s</code> <code>[[:space:]]</code></td><td><code>\s</code></td><td class="na"></td><td class="na"></td><td><code>\_s</code></td></tr>    <tr><td>Match a non-whitespace character</td><td><code>\S</code></td><td><code>\S</code></td><td><code>[^[:space:]]</code></td><td><code>[^[:space:]]</code></td><td><code>\S</code> <code>[^[:space:]]</code></td></tr>    <tr><td>Match a digit character</td><td><code>\d</code> <code>[[:digit:]]</code></td><td><code>\d</code></td><td><code>[[:digit:]]</code></td><td><code>[[:digit:]]</code></td><td><code>\d</code> <code>[[:digit:]]</code></td></tr>    <tr><td>Match a non-digit character</td><td><code>\D</code></td><td><code>\D</code></td><td><code>[^[:digit:]]</code></td><td><code>[^[:digit:]]</code></td><td><code>\D</code> <code>[^[:digit:]]</code></td></tr>    <tr><td>Any hexadecimal digit</td><td><code>[[:xdigit:]]</code></td><td class="na"></td><td><code>[[:xdigit:]]</code></td><td><code>[[:xdigit:]]</code></td><td><code>\x</code> <code>[[:xdigit:]]</code></td></tr>    <tr><td>Any octal digit</td><td></td><td class="na"></td><td></td><td></td><td><code>\o</code></td></tr>    <tr><td>Any graphical character excluding "word" characters</td><td><code>[[:punct:]]</code></td><td class="na"></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td><td><code>[[:punct:]]</code></td></tr>    <tr><td>Any alphabetical character</td><td><code>[[:alpha:]]</code></td><td class="na"></td><td><code>[[:alpha:]]</code></td><td><code>[[:alpha:]]</code></td><td><code>\a</code> <code>[[:alpha:]]</code></td></tr>    <tr><td>Non-alphabetical character</td><td></td><td class="na"></td><td><code>[^[:alpha:]]</code></td><td><code>[^[:alpha:]]</code></td><td><code>\A</code> <code>[^[:alpha:]]</code></td></tr>    <tr><td>Any alphanumerical character</td><td><code>[[:alnum:]]</code></td><td class="na"></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td><td><code>[[:alnum:]]</code></td></tr>    <tr><td>ASCII</td><td><code>[[:ascii:]]</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>Character equivalents (e = é = è) (as per locale)</td><td></td><td class="na"></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td><td><code>[[=e=]]</code></td></tr>  </tbody>  <tbody id="syntax-assert" class="subgroup">    <tr><th colspan="6">Zero-width assertions</th></tr>    <tr><td>Word boundary</td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\b</code></td><td><code>\&lt;</code> / <code>\&gt;</code></td></tr>    <tr><td>Anywhere but word boundary</td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td><code>\B</code></td><td class="na"></td></tr>    <tr><td>Beginning of line/string</td><td><code>^</code> / <code>\A</code></td><td><code>^</code> / <code>\A</code></td><td><code>^</code></td><td><code>^</code></td><td><code>^</code> (beginning of pattern ) <code>\_^</code></td></tr>    <tr><td>End of line/string</td><td><code>$</code> / <code>\Z</code></td><td><code>$</code> / <code>\Z</code></td><td><code>$</code></td><td><code>$</code></td><td><code>$</code> (end of pattern) <code>\_$</code></td></tr>  </tbody>  <tbody id="syntax-groups" class="subgroup">    <tr><th colspan="6">Captures and groups</th></tr>    <tr><td>Capturing group</td><td><code>(...)</code> <code>(?&lt;name&gt;...)</code></td><td><code>(...)</code> <code>(?P&lt;name&gt;...)</code></td><td><code>\(...\)</code></td><td><code>(...)</code></td><td><code>\(...\)</code></td></tr>    <tr><td>Non-capturing group</td><td><code>(?:...)</code></td><td><code>(?:...)</code></td><td class="na"></td><td class="na"></td><td><code>\%(...\)</code></td></tr>    <tr><td>Backreference to a specific group.</td><td><code>\1</code> <code>\g1</code> <code>\g{-1}</code></td><td><code>\1</code></td><td><code>\1</code></td><td><code>\1</code> non-official</td><td><code>\1</code></td></tr>    <tr><td>Named backreference</td><td><code>\g{name}</code> <code>\k&lt;name&gt;</code></td><td><code>(?P=name)</code></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>  </tbody>  <tbody id="syntax-lookaround" class="subgroup">    <tr><th colspan="6">Look-around</th></tr>    <tr><td>Positive look-ahead</td><td><code>(?=...)</code></td><td><code>(?=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@=</code></td></tr>    <tr><td>Negative look-ahead</td><td><code>(?!...)</code></td><td><code>(?!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@!</code></td></tr>    <tr><td>Positive look-behind</td><td><code>(?&lt;=...)</code></td><td><code>(?&lt;=...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;=</code></td></tr>    <tr><td>Negative look-behind</td><td><code>(?&lt;!...)</code></td><td><code>(?&lt;!...)</code></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&lt;!</code></td></tr>  </tbody>  <tbody id="syntax-multiplicity" class="subgroup">    <tr><th colspan="6">Multiplicity</th></tr>    <tr><td>0 or 1</td><td><code>?</code></td><td><code>?</code></td><td><code>\?</code></td><td><code>?</code></td><td><code>\?</code></td></tr>    <tr><td>0 or more</td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td></tr>    <tr><td>1 or more</td><td><code>+</code></td><td><code>+</code></td><td><code>\+</code></td><td><code>+</code></td><td><code>\+</code></td></tr>    <tr><td>Specific number</td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n\}</code> <code>\{n,m\}</code> <code>\{n,\}</code></td><td><code>{n}</code> <code>{n,m}</code> <code>{n,}</code></td><td><code>\{n}</code> <code>\{n,m}</code> <code>\{n,}</code></td></tr>    <tr><td>0 or 1, non-greedy</td><td><code>??</code></td><td><code>??</code></td><td class="na"></td><td class="na"></td><td></td></tr>    <tr><td>0 or more, non-greedy</td><td><code>*?</code></td><td><code>*?</code></td><td class="na"></td><td class="na"></td><td><code>\{-}</code></td></tr>    <tr><td>1 or more, non-greedy</td><td><code>+?</code></td><td><code>+?</code></td><td class="na"></td><td class="na"></td><td></td></tr>    <tr><td>Specific number, non-greedy</td><td><code>{n,m}?</code> <code>{n,}?</code></td><td><code>{n,m}?</code> <code>{n,}?</code></td><td class="na"></td><td class="na"></td><td><code>\{-n,m}</code> <code>\{-n,}</code></td></tr>    <tr><td>0 or 1, don't give back on backtrack</td><td><code>?+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>0 or more, don't give back on backtrack</td><td><code>*+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>1 or more, don't give back on backtrack</td><td><code>++</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>    <tr><td>Specific number, don't give back on backtrack</td><td><code>{n,m}+</code> <code>{n,}+</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td class="na"></td></tr>  </tbody>  <tbody id="syntax-other" class="subgroup">    <tr><th colspan="6">Other</th></tr>    <tr><td>Independent non-backtracking pattern</td><td><code>(?&gt;...)</code></td><td class="na"></td><td class="na"></td><td class="na"></td><td><code>\(...\)\@&gt;</code></td></tr>    <tr><td>Make case-sensitive/insensitive</td><td><code>(?i)</code> / <code>(?-i)</code></td><td><code>(?i)</code> / <code>(?-i)</code></td><td class="na"></td><td class="na"></td><td><code>\c</code> / <code>\C</code></td></tr>  </tbody></table><p>BRE ERE 需要注意 <code>()</code> <code>{}</code> 的区别，另外都不支持 <code>\d\D</code></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://liujiacai.net/blog/2014/12/07/regexp-favors/" target="_blank" rel="noopener">正则表达式“派别”简述</a></li><li><a href="https://en.wikipedia.org/wiki/Regular_expression#Character_classes" target="_blank" rel="noopener">Regular expression</a></li><li><a href="https://blog.csdn.net/yufenghyc/article/details/51078107" target="_blank" rel="noopener">grep中使用”\d”匹配数字不成功的原因</a></li><li><a href="https://remram44.github.io/regex-cheatsheet/regex.html" target="_blank" rel="noopener">Regex cheatsheet</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解正则表达式标准，各个之间存在一些差异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BRE (Basic Regular Expressions)&lt;/li&gt;
&lt;li&gt;ERE (Extended Regular Expressions)&lt;/li&gt;
&lt;li&gt;PCRE (Perl Compatible Regular Expressions)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="RE" scheme="http://yoursite.com/categories/Tools/RE/"/>
    
    
      <category term="grep" scheme="http://yoursite.com/tags/grep/"/>
    
      <category term="sed" scheme="http://yoursite.com/tags/sed/"/>
    
      <category term="awk" scheme="http://yoursite.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Doxygen 注释语法</title>
    <link href="http://yoursite.com/2019/12/27/doxygen-syntax/"/>
    <id>http://yoursite.com/2019/12/27/doxygen-syntax/</id>
    <published>2019-12-27T02:20:07.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Doxygen 来生成文档需要遵从的注释语法</p><a id="more"></a><h2 id="开源工程"><a href="#开源工程" class="headerlink" title="开源工程"></a>开源工程</h2><p>可以搜索参考用法</p><ul><li><a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></li><li><a href="https://github.com/LiamBindle/MQTT-C.git" target="_blank" rel="noopener">MQTT</a></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释块<pre><code>/*** comment text here*/int x = 0;</code></pre></li><li>行尾注释<pre><code>int x = 0; ///&lt; comment text here</code></pre></li><li>单行注释<pre><code>/// comment text hereint x = 0;</code></pre></li></ul><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>注释块中可以使用一些特殊的标记，比如 <code>brief</code> 标记，官方称为 <code>Special Commands</code></p><ul><li><a href="http://www.doxygen.nl/manual/commands.html" target="_blank" rel="noopener">Special Commands</a></li><li><a href="https://www.cnblogs.com/benhuan/p/3302114.html" target="_blank" rel="noopener">翻译</a></li></ul><p>例如</p><ul><li><code>\struct &lt;name&gt; [&lt;header-file&gt;] [&lt;header-name&gt;]</code></li><li><code>\typedef (typedef declaration)</code></li><li><code>\brief { brief description }</code></li></ul><p>标记可以有两种书写方式 <code>\param</code> 或者 <code>@param</code>，每个命令有一个或多个参数，每个参数都有明确的范围：</p><ul><li><code>&lt;&gt;</code> 参数是一个单独单词</li><li><code>()</code> 参数一直到命令所在的结束</li><li><code>[]</code> 参数是可选的</li><li><code>{}</code> 参数一直延伸到本段结束。一个段落的结束以一个空行来标识，或者是一个段落标记</li></ul><h2 id="常用标记"><a href="#常用标记" class="headerlink" title="常用标记"></a>常用标记</h2><ul><li><code>\brief { brief description }</code> 可以省略</li><li><code>\param &#39;[&#39;dir&#39;]&#39; &lt;parameter-name&gt; { parameter description }</code><pre><code>/*** @param[out] dest The memory area to copy to.* @param[in]  src  The memory area to copy from.* @param[in]  n    The number of bytes to copy*/void memcpy(void *dest, const void *src, size_t n);</code></pre></li><li><code>\return { description of the return value }</code> 返回说明</li><li><code>\retval &lt;return value&gt; { description }</code> 返回值</li><li><code>\ref &lt;name&gt; [&quot;(text)&quot;]</code> 引用<pre><code>/*** @return 程序执行成功与否*     @retval 0 程序执行成功*     @retval 1 程序执行失败* @note 这里只是一个简单的例子*/int main(int argc, char* argv[])</code></pre></li><li><code>\note { text }</code> 标注需要特别注意的地方</li><li><code>\deprecated { description }</code></li><li><code>\warning { warning message }</code> 接口容易出错的地方</li><li><code>\sa { references }</code> <code>\see { references }</code></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Example <a href="https://github.com/FFmpeg/FFmpeg.git" target="_blank" rel="noopener">FFMPEG</a></p><pre><code>*** Initialize the AVCodecContext to use the given AVCodec. Prior to using this* function the context has to be allocated with avcodec_alloc_context3().** The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),* avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for* retrieving a codec.** @warning This function is not thread safe!** @note Always call this function before using decoding routines (such as* @ref avcodec_receive_frame()).** @code* avcodec_register_all();* av_dict_set(&amp;opts, &quot;b&quot;, &quot;2.5M&quot;, 0);* codec = avcodec_find_decoder(AV_CODEC_ID_H264);* if (!codec)*     exit(1);** context = avcodec_alloc_context3(codec);** if (avcodec_open2(context, codec, opts) &lt; 0)*     exit(1);* @endcode** @param avctx The context to initialize.* @param codec The codec to open this context for. If a non-NULL codec has been*              previously passed to avcodec_alloc_context3() or*              for this context, then this parameter MUST be either NULL or*              equal to the previously passed codec.* @param options A dictionary filled with AVCodecContext and codec-private options.*                On return this object will be filled with options that were not found.** @return zero on success, a negative value on error* @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),*      av_dict_set(), av_opt_find().*/</code></pre><p>注释 <code>struct</code></p><pre><code>/** * @struct AC3HeaderInfo * Coded AC-3 header values up to the lfeon element, plus derived values. */typedef struct AC3HeaderInfo {    /** @name Coded elements     * @{     */    uint16_t sync_word;    uint16_t crc1;    uint8_t sr_code;    uint8_t bitstream_id;    uint8_t bitstream_mode;    uint8_t channel_mode;    uint8_t lfe_on;    uint8_t frame_type;    int substreamid;                        ///&lt; substream identification    int center_mix_level;                   ///&lt; Center mix level index    int surround_mix_level;                 ///&lt; Surround mix level index    uint16_t channel_map;    int num_blocks;                         ///&lt; number of audio blocks    int dolby_surround_mode;    /** @} */    /** @name Derived values     * @{     */    uint8_t sr_shift;    uint16_t sample_rate;    uint32_t bit_rate;    uint8_t channels;    uint16_t frame_size;    uint64_t channel_layout;    /** @} */} AC3HeaderInfo;/** * @brief Example class的简易说明 * * 本范例说明Example class。 * 这是一个极为简单的范例。 * */class Example {    private:        int var1 ; ///&lt; 这是一个private的变数    public:        int var2 ; ///&lt; 这是一个public的变数成员。        int var3 ; ///&lt; 这是另一个public的变数成员。        void ExFunc1(void);        int ExFunc2(int a, char b);        char *ExFunc3(char *c) ;};</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="http://blog.guorongfei.com/2016/11/20/doxygen-usage/" target="_blank" rel="noopener">使用 Doxygen 生成文档注释</a></li><li><a href="http://www.doxygen.nl/manual/index.html" target="_blank" rel="noopener">Doxygen Manual</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Doxygen 来生成文档需要遵从的注释语法&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Doxygen" scheme="http://yoursite.com/categories/Tools/Doxygen/"/>
    
    
      <category term="doxygen" scheme="http://yoursite.com/tags/doxygen/"/>
    
  </entry>
  
  <entry>
    <title>使用 LSP 搭建代码补全环境</title>
    <link href="http://yoursite.com/2019/12/25/vim-lsp/"/>
    <id>http://yoursite.com/2019/12/25/vim-lsp/</id>
    <published>2019-12-25T02:07:51.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>Language Server Protocol (LSP) 用于架接编辑器与具体语言，实现各种功能。</p><a id="more"></a><h2 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h2><p><a href="https://zhuanlan.zhihu.com/p/37290578" target="_blank" rel="noopener">Vim 8 中 C/C++ 符号索引：LSP 篇</a></p><p>LSP 是一套通信协议，遵从 LSP 规范的客户端（各种编辑器/IDE）可以通过众多 LSP 服务端按协议标准进行通信，由客户端完成用户界面相关的事情，由服务端提编程语言相关的：补全，定义引用查找，诊断，帮助文档，重构等服务。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">coc.nvim</a><br><a href="https://segmentfault.com/a/1190000017785227" target="_blank" rel="noopener">Vim的新一代补全插件：coc.nvim</a></p><p>使用 <code>vim-plug</code> 安装</p><pre><code class="vim">&quot; Use release branch (Recommend)Plug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>执行 <code>:CocConfig</code> 生成配置文件 <code>~/.vim/coc-settings.json</code></p><p>例如</p><pre><code>&quot;diagnostic.enable&quot;:        Set to false to disable diagnostic display,  default: true</code></pre><p>在 <code>coc-settings.json</code> 中添加</p><pre><code class="json">&quot;diagnostic.enable&quot;: false,</code></pre><h2 id="安装内置插件"><a href="#安装内置插件" class="headerlink" title="安装内置插件"></a>安装内置插件</h2><p><a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions" target="_blank" rel="noopener">内置插件支持列表</a><br><a href="https://github.com/fannheyward/coc-marketplace" target="_blank" rel="noopener">coc-marketplace</a><br><a href="https://www.npmjs.com/search?q=keywords%3Acoc.nvim" target="_blank" rel="noopener">coc.nvim on npm</a></p><p>例如：</p><ul><li>coc-json for <code>json</code>.</li><li>coc-tsserver for <code>javascript</code> and <code>typescript</code>.</li><li>coc-html for <code>html</code>, <code>handlebars</code> and <code>razor</code>.</li><li>coc-css for <code>css</code>, <code>scss</code> and <code>less</code>.</li><li>coc-ember for ember projects.</li><li>coc-vetur for <code>vue</code>, use vetur.</li><li>coc-phpls for <code>php</code>, use intelephense-docs.</li><li>coc-java for <code>java</code>, use eclipse.jdt.ls.</li></ul><p>使用 <code>:CocInstall coc-xxx</code> 安装，位于 <code>/.config/coc/extensions/node_modules</code>，配置文件 <code>coc-settings.json</code></p><p>例如 <code>coc-python</code> 需要忽略特定错误，查看 <a href="https://github.com/neoclide/coc-python" target="_blank" rel="noopener">配置</a> 添加如下内容</p><pre><code class="json">&quot;python.linting.flake8Args&quot;: [&quot;--ignore=E501&quot;]</code></pre><h2 id="安装-LSP"><a href="#安装-LSP" class="headerlink" title="安装 LSP"></a>安装 LSP</h2><p><a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers" target="_blank" rel="noopener">Language servers</a></p><p>支持多种 LSP，例如：</p><ul><li>Python</li><li>C/C++</li><li>Lua</li></ul><p>选择 <a href="https://github.com/MaskRay/ccls" target="_blank" rel="noopener">ccls</a> 作为 C LSP</p><p>编译安装如下</p><pre><code class="shell">$ git clone --depth=1 --recursive https://github.com/MaskRay/ccls$ wget -c http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz$ tar xf clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz$ cd ccls$ cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=$PWD/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04$ cmake --build Release</code></pre><p>在 <code>coc-settings.json</code> 中添加配置</p><pre><code class="json">&quot;ccls&quot;: {                                                                     &quot;command&quot;: &quot;~/.vim/ccls/ccls/Release/ccls&quot;,                    &quot;filetypes&quot;: [&quot;c&quot;, &quot;cpp&quot;, &quot;objc&quot;, &quot;objcpp&quot;],                              &quot;rootPatterns&quot;: [&quot;.ccls&quot;, &quot;compile_commands.json&quot;, &quot;.vim/&quot;, &quot;.git/&quot;, &quot;.hg/&quot;],      &quot;initializationOptions&quot;: {                                                    &quot;cache&quot;: {                                                                    &quot;directory&quot;: &quot;/tmp/ccls&quot;                                              }                                                                     }                                                                     }</code></pre><p><code>ccls</code> 运行依赖于 <code>compile_commands.json</code>，使用 <code>Bear</code> 生成此文件</p><pre><code class="shell">$ Bear make</code></pre><h2 id="vimrc-配置"><a href="#vimrc-配置" class="headerlink" title=".vimrc 配置"></a>.vimrc 配置</h2><p><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">Example vim configuration</a><br><a href="https://github.com/MaskRay/ccls/wiki/coc.nvim" target="_blank" rel="noopener">ccls coc.nvim配置</a></p><pre><code class="vim">nmap &lt;silent&gt; &lt;M-j&gt; &lt;Plug&gt;(coc-definition)nmap &lt;silent&gt; &lt;C-,&gt; &lt;Plug&gt;(coc-references)nn &lt;silent&gt; K :call CocActionAsync(&#39;doHover&#39;)&lt;cr&gt;&quot; basesnn &lt;silent&gt; xb :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;)&lt;cr&gt;&quot; bases of up to 3 levelsnn &lt;silent&gt; xB :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;levels&#39;:3})&lt;cr&gt;&quot; derivednn &lt;silent&gt; xd :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;derived&#39;:v:true})&lt;cr&gt;&quot; derived of up to 3 levelsnn &lt;silent&gt; xD :call CocLocations(&#39;ccls&#39;,&#39;$ccls/inheritance&#39;,{&#39;derived&#39;:v:true,&#39;levels&#39;:3})&lt;cr&gt;&quot; callernn &lt;silent&gt; xc :call CocLocations(&#39;ccls&#39;,&#39;$ccls/call&#39;)&lt;cr&gt;&quot; calleenn &lt;silent&gt; xC :call CocLocations(&#39;ccls&#39;,&#39;$ccls/call&#39;,{&#39;callee&#39;:v:true})&lt;cr&gt;&quot; $ccls/member&quot; member variables / variables in a namespacenn &lt;silent&gt; xm :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;)&lt;cr&gt;&quot; member functions / functions in a namespacenn &lt;silent&gt; xf :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;,{&#39;kind&#39;:3})&lt;cr&gt;&quot; nested classes / types in a namespacenn &lt;silent&gt; xs :call CocLocations(&#39;ccls&#39;,&#39;$ccls/member&#39;,{&#39;kind&#39;:2})&lt;cr&gt;nmap &lt;silent&gt; xt &lt;Plug&gt;(coc-type-definition)&lt;cr&gt;nn &lt;silent&gt; xv :call CocLocations(&#39;ccls&#39;,&#39;$ccls/vars&#39;)&lt;cr&gt;nn &lt;silent&gt; xV :call CocLocations(&#39;ccls&#39;,&#39;$ccls/vars&#39;,{&#39;kind&#39;:1})&lt;cr&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Language Server Protocol (LSP) 用于架接编辑器与具体语言，实现各种功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Editor" scheme="http://yoursite.com/categories/Tools/Editor/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
      <category term="lsp" scheme="http://yoursite.com/tags/lsp/"/>
    
      <category term="completion" scheme="http://yoursite.com/tags/completion/"/>
    
  </entry>
  
  <entry>
    <title>指定运行时动态库位置</title>
    <link href="http://yoursite.com/2019/12/19/gcc-run-path/"/>
    <id>http://yoursite.com/2019/12/19/gcc-run-path/</id>
    <published>2019-12-19T08:39:27.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>指定运行时动态库路径</p><ul><li>gcc参数指定 <code>-Wl,-rpath=${LD_PATH}</code></li><li>设置环境变量 <code>export LD_LIBRARY_PATH=${LD_PATH}</code></li><li>配置文件 <code>/etc/ld.so.conf</code></li></ul><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>编译 <code>mosquitto</code> 得到几个可执行文件，运行时出现错误</p><pre><code class="shell">$ ./mosquitto_sub --help./mosquitto_sub: error while loading shared libraries: libmosquitto.so.1: cannot open shared object file: No such file or directory$ ldd mosquitto_sub    linux-vdso.so.1 (0x00007fffe178b000)    libmosquitto.so.1 =&gt; not found    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc8c9ca5000)    /lib64/ld-linux-x86-64.so.2 (0x00007fc8ca2a3000)</code></pre><p>找不到 <code>libmosquitto.so.1</code>， 需要指定路径</p><h2 id="GCC参数"><a href="#GCC参数" class="headerlink" title="GCC参数"></a>GCC参数</h2><pre><code class="shell">-Wl,-rpath=${LD_PATH}</code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre><code class="shell">$ export LD_LIBRARY_PATH=../lib$ ldd mosquitto_sub    linux-vdso.so.1 (0x00007ffd3410b000)    libmosquitto.so.1 =&gt; ../lib/libmosquitto.so.1 (0x00007f4ecc2d5000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4ecbee4000)    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f4ecbcdc000)    libssl.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007f4ecba74000)    libcrypto.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007f4ecb631000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f4ecb412000)    /lib64/ld-linux-x86-64.so.2 (0x00007f4ecc6fb000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4ecb20e000)</code></pre><p>只在当前 shell 有效</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>修改 <code>/etc/ld.so.conf</code> 文件以添加私有路径</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指定运行时动态库路径&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc参数指定 &lt;code&gt;-Wl,-rpath=${LD_PATH}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置环境变量 &lt;code&gt;export LD_LIBRARY_PATH=${LD_PATH}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置文件 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Linker" scheme="http://yoursite.com/categories/C/Linker/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
    
      <category term="shared" scheme="http://yoursite.com/tags/shared/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 静态模板使用</title>
    <link href="http://yoursite.com/2019/12/18/makefile-static-pattern-rule/"/>
    <id>http://yoursite.com/2019/12/18/makefile-static-pattern-rule/</id>
    <published>2019-12-18T09:28:15.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>Makefile 静态模板的使用</p><pre><code class="makefile">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;    &lt;commands&gt;</code></pre><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code class="shell">$ tree -L 2.├── dirA│   ├── dirA_1.c│   ├── dirA_2.c│   └── include├── makefile├── output│   └── objects└── dirB    ├── include    └── dirB.c</code></pre><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><pre><code class="makefile">SRC = $(shell find . -iname &quot;*.c&quot;)SRC = $(wildcard dirA/*.c) \      $(wildcard dirB/*.c)</code></pre><p>Makefile 规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数 <code>wildcard</code></p><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><pre><code class="makefile">OBJ = $(SRC:.c=.o)OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))</code></pre><ul><li><code>OBJ = $(SRC:.c=.o)</code> 这个表示 <code>.obj</code> 与 <code>.c</code> 位于同一个目录下</li><li><code>OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))</code> <code>.obj</code> 统一放到 <code>$(objects_dir)</code> 目录下</li></ul><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><pre><code class="makefile">SUBDIR = dirASUBDIR += dirBCFLAGS += $(patsubst %, -I%, $(SUBDIR))</code></pre><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="静态模板"><a href="#静态模板" class="headerlink" title="静态模板"></a>静态模板</h3><pre><code class="makefile">SRC = $(wildcard dirA/*.c) \      $(wildcard dirB/*.c)OBJ = $(SRC:.c=.o)$(TARGET): $(OBJ)    @echo &quot;Generating new lib\033[1;31m: $@\033[0m&quot;    @$(AR) -rcs $@ $^$(OBJ): %.o: %.c    @echo &quot;compiling \033[032m[$(CC)]\033[0m&quot;: $&lt;    @$(CC) -c $(CFLAGS) $&lt; -o $@</code></pre><h3 id="obj-文件制定路径"><a href="#obj-文件制定路径" class="headerlink" title="obj 文件制定路径"></a>obj 文件制定路径</h3><pre><code class="makefile">SRC = $(wildcard dirA/*.c) \      $(wildcard dirB/*.c)OBJ = $(addprefix $(objects_dir)/, $(SRC:.c=.o))$(TARGET): $(OBJ)    @echo &quot;Generating new lib\033[1;31m: $@\033[0m&quot;    @$(AR) -rcs $@ $^$(objects_dir)/%.o: %.c dirmake    @echo &quot;compiling \033[032m[$(CC)]\033[0m&quot;: $&lt;    @$(CC) -c $(CFLAGS) $&lt; -o $@</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://seisman.github.io/how-to-write-makefile/rules.html#id8" target="_blank" rel="noopener">静态模式</a></li><li><a href="https://seisman.github.io/how-to-write-makefile/rules.html#id3" target="_blank" rel="noopener">规则的语法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Makefile 静态模板的使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;&amp;lt;targets ...&amp;gt; : &amp;lt;target-pattern&amp;gt; : &amp;lt;prereq-patterns ...&amp;gt;
    &amp;lt;commands&amp;gt;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Make" scheme="http://yoursite.com/categories/Tools/Make/"/>
    
      <category term="Makefile" scheme="http://yoursite.com/categories/C/Makefile/"/>
    
    
      <category term="makefile" scheme="http://yoursite.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>Linker 及 ld 脚本分析</title>
    <link href="http://yoursite.com/2019/12/11/linker-and-lds-file/"/>
    <id>http://yoursite.com/2019/12/11/linker-and-lds-file/</id>
    <published>2019-12-11T06:41:04.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>链接器工作过程及链接脚本文件 <code>.lds</code> 分析</p><a id="more"></a><h2 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h2><p>链接器将多目标文件生成最终可执行文件，示意图如下</p><p><img src="/images/gnu/linker.png" alt="Linker Role"></p><p>在链接过程中执行如下操作</p><ol><li>Symbol Resolution - 符号解析<ul><li>多文件声明与调用</li><li>调用替换为具体函数入口</li></ul></li><li>Relocation - 重定位<ul><li>相同段合并，例如 <code>.text</code></li><li>Section Placement, 各段在内存中的位置</li></ul></li></ol><p>详细解释见 <a href="https://www.bravegnu.org/gnu-eprog/linker.html" target="_blank" rel="noopener">Linker</a></p><h2 id="Linker-Script-File"><a href="#Linker-Script-File" class="headerlink" title="Linker Script File"></a>Linker Script File</h2><p>控制链接器行为的脚本文件，一般后缀为 <code>.lds</code>。如果不指定，存在默认脚本，使用 <code>ld --verbose</code> 查看</p><p><a href="https://www.bravegnu.org/gnu-eprog/lds.html" target="_blank" rel="noopener">Linker Script File</a></p><pre><code class="lds">SECTIONS { ❶        . = 0x00000000; ❷        .text : { ❸                abc.o (.text);                def.o (.text);        }}</code></pre><ol><li><code>SECTIONS</code> 脚本各段组成及位置</li><li><code>.</code> 定位器符号</li><li><code>.text</code> 由 <code>abc.o</code> 和 <code>def.o</code> 中的 <code>.text</code> 组成</li></ol><h2 id="LMA-vs-VMA"><a href="#LMA-vs-VMA" class="headerlink" title="LMA vs VMA"></a>LMA vs VMA</h2><ul><li><code>LMA</code> (load memory address 加载内存地址或进程地址空间地址）</li><li><code>VMA</code> (virtual memory address 虚拟内存地址或程序地址空间地址）</li></ul><blockquote><p>VMA 是执行输出文件时 section 所在的地址，而 LMA 是加载输出文件时 section 所在的地址。一般而言，某 section 的 VMA == LMA. 但在嵌入式系统中，经常存在加载地址和执行地址不同的情况：比如将输出文件加载到开发板的 flash 中（由 LMA 指定）, 而在运行时将位于 flash 中的输出文件复制到 SDRAM 中（由 VMA 指定）。</p></blockquote><h2 id="SECTIONS-命令"><a href="#SECTIONS-命令" class="headerlink" title="SECTIONS 命令"></a>SECTIONS 命令</h2><p><code>SECTIONS</code> 命令告诉 ld 如何把输入文件的 sections 映射到输出文件的各个 section: 如何将输入 section 合为输出 section; 如何把输出 section 放入 VMA 和 LMA</p><pre><code>SECTIONS{    SECTIONS-COMMAND    SECTIONS-COMMAND    ...}</code></pre><p>SECTION-COMMAND 有四种：</p><ol><li>ENTRY 命令</li><li>符号赋值语句</li><li>一个输出 section 的描述 (output section description)</li><li>一个 section 叠加描述 (overlay description)</li></ol><h3 id="ENTRY-命令"><a href="#ENTRY-命令" class="headerlink" title="ENTRY 命令"></a>ENTRY 命令</h3><p>将符号 <code>SYMBOL</code> 的值设置成入口地址</p><pre><code>ENTRY(SYMBOL)</code></pre><h3 id="符号赋值"><a href="#符号赋值" class="headerlink" title="符号赋值"></a>符号赋值</h3><ul><li>对符号的赋值只对全局变量起作用</li><li>赋值语句包含 4 个语法元素：符号名、操作符、表达式、分号；一个也不能少</li><li><code>.</code> 是一个特殊的符号，它是定位器，一个位置指针，指向程序地址空间内的某位置。该符号只能在 SECTIONS 命令内使用</li></ul><h3 id="叠加描述"><a href="#叠加描述" class="headerlink" title="叠加描述"></a>叠加描述</h3><p>覆盖图描述使两个或多个不同的 section 占用同一块程序地址空间。覆盖图管理代码负责将 section 的拷入和拷出。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>格式如下</p><pre><code>SECTION-NAME [ADDRESS] [(TYPE)] : [AT(LMA)]{    OUTPUT-SECTION-COMMAND    OUTPUT-SECTION-COMMAND    …} [&gt;REGION] [AT&gt;LMA_REGION] [:PHDR HDR ...] [=FILLEXP]</code></pre><ul><li><code>ALIGN</code> 地址对齐</li><li>文件通配符</li><li><code>.</code> 定位符</li><li><code>KEEP</code></li><li><code>AT</code> 修改 LMA</li><li><code>&gt;REGION</code> 修改 VMA</li></ul><h2 id="MEMORY-命令"><a href="#MEMORY-命令" class="headerlink" title="MEMORY 命令"></a>MEMORY 命令</h2><p>在默认情形下，连接器可以为 section 在程序地址空间内分配任意位置的存储区域。并通过输出 section 描述的 <code>&gt;REGION</code> 属性显示地将该输出 section 限定于在程序地址空间内的某块存储区域，当存储区域大小不能满足要求时，连接器会报告该错误。</p><pre><code>MEMORY{    NAME1 [(ATTR)] : ORIGIN = ORIGIN1, LENGTH = LEN2    NAME2 [(ATTR)] : ORIGIN = ORIGIN2, LENGTH = LEN2    ...}</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code class="lds">MEMORY{    sram  :   ORIGIN = 0x00100000,    LENGTH = 0x8000    ddram :   ORIGIN = 0x80000000,    LENGTH = 0x100000}ENTRY(ResetEntry)SECTIONS {    . = ALIGN(4);    .text :    {        sram/*(.text*)        sram/*(.data*)        sram/*(.rodata*)        *(.reset_patch)        *(.sram_text)        *(.sram)    } &gt; sram    . = ALIGN(0x8000);    .data :    {        *(.text*)        . = ALIGN(4);        *(.data*)        *(.rodata*)        . = ALIGN(16);    } &gt; ddram    . = ALIGN(4);    .bss :    {        . = ALIGN(4);        __bss_start__ = .;        *(.bss*)        *(COMMON)        . = ALIGN(4);        __bss_end__ = .;    } &gt; ddram}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://www.cnblogs.com/li-hao/p/4107964.html" target="_blank" rel="noopener">Linux 下的 lds 链接脚本详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接器工作过程及链接脚本文件 &lt;code&gt;.lds&lt;/code&gt; 分析&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Linker" scheme="http://yoursite.com/categories/C/Linker/"/>
    
    
      <category term="ld" scheme="http://yoursite.com/tags/ld/"/>
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="lds" scheme="http://yoursite.com/tags/lds/"/>
    
      <category term="linker" scheme="http://yoursite.com/tags/linker/"/>
    
  </entry>
  
  <entry>
    <title>objdump 解析目标文件各个段</title>
    <link href="http://yoursite.com/2019/12/10/nm-code-segment/"/>
    <id>http://yoursite.com/2019/12/10/nm-code-segment/</id>
    <published>2019-12-10T05:32:47.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>目标文件 <code>.o</code> 中 <code>text</code>、 <code>bss</code>、 <code>data</code> 和 <code>rodata</code> 区别和联系</p><a id="more"></a><p>目标文件只是ELF文件的<strong>可重定位文件(Relocatable file)</strong>，常用分析ELF文件工具如下</p><ol><li>objdump</li><li>readelf</li><li>nm</li></ol><h2 id="text"><a href="#text" class="headerlink" title=".text"></a>.text</h2><p>代码段，也有可能包含一些只读的常数变量，例如字符串常量等。只读。</p><h2 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h2><p>没有初始化的和初始化为0的全局变量和静态变量，并不给该段的数据分配空间，只是记录数据所需空间的大小，运行时在栈上分配。</p><h2 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h2><p>已初始化非0全局变量和静态变量，需要分配空间用于存储数据。</p><h2 id="rodata"><a href="#rodata" class="headerlink" title=".rodata"></a>.rodata</h2><p><code>ro</code> 表示为只读数据段，存放C中的字符串和常量，优化后会只存储一份。常量并不一定在此段，有可能存放在代码段。</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><pre><code class="c">static int x1 = 0;static int x2 = 1234;int main(){    return 0;}</code></pre><p>使用 <code>objdump -x -s -d a.out</code> 查找如下</p><pre><code>00000000006bb330 l     O .bss   0000000000000004 x100000000006b90f0 l     O .data  0000000000000004 x2.Contents of section .data: 6b90e0 00000000 00000000 00000000 00000000  ................ 6b90f0 34120000 00000000 00080000 00000000  4...............</code></pre><p><code>x1</code> 放入 <code>.bss</code> 段；<code>x2</code> 放入 <code>.data</code> 段。</p><h2 id="nm-vs-objdump"><a href="#nm-vs-objdump" class="headerlink" title="nm vs objdump"></a>nm vs objdump</h2><p><code>nm</code> 与 <code>objdump</code> 标志不统一，需要注意区分</p><h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h3><a href="/2015/04/05/nm-symbols/" title="nm symbols 类型及程序组成">nm symbols 类型及程序组成</a><p>查看详细信息 <code>man nm</code></p><h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>查看详细信息 <code>man objdump</code></p><ul><li><code>l</code> local</li><li><code>g</code> global</li><li><code>u</code> unique global</li><li><code>!</code> both global and local</li><li><code>w</code> weak</li><li><code>C</code> The symbol denotes a constructor</li><li><code>W</code> warning</li><li><code>I</code> The symbol is an indirect reference to another symbol</li><li><code>i</code> a function to be evaluated during reloc processing</li><li><code>d</code> a debugging symbol</li><li><code>D</code> a dynamic symbol</li><li><code>F</code> function</li><li><code>f</code> file</li><li><code>O</code> object</li></ul><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><pre><code class="shell">$ tree.├── a.out├── one.c   // extern unsigned long start_time;├── two.c   // unsigned long start_time = 0;└── main.c  // start_time = _get_time();$ nm one.o | grep start_time00000004 C start_time$ nm two.o | grep start_time00000000 B start_time$ nm main.o | grep start_time00000004 C start_time$ nm a.out | grep start_time97d6c6c4 B start_time$ objdump -x -s a.out | grep start_time97d6c6c4 g     O .bss    00000004 start_time 0640 0e000067 5f737461 72745f74 696d6500  ...start_time. 1ae0 675f7374 6172745f 74696d65 00df0e00  start_time....$ objdump -x -s one.o | grep start_time00000004       O *COM*    00000004 start_time00000ef5 ADDR32   start_time0000003c ADDR32   start_time$ objdump -x -s main.o | grep start_time00000004       O *COM*    00000004 start_time00000262 ADDR32   start_time000000e4 ADDR32   start_time$ objdump -x -s two.o | grep start_time 32 .bss.start_time 00000004  00000000  00000000  000015c8  2**200000000 l    d  .bss.start_time    00000000 .bss.start_time00000000 g     O .bss.start_time    00000004 start_time000006d7 ADDR32   .bss.start_time</code></pre><p>注意变量 <code>start_time</code> 在各个文件中的标志</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.51cto.com/12810168/2321531" target="_blank" rel="noopener">程序的结构体系（十）</a></li><li><a href="https://www.jianshu.com/p/863b279c941e" target="_blank" rel="noopener">使用readelf和objdump解析目标文件</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目标文件 &lt;code&gt;.o&lt;/code&gt; 中 &lt;code&gt;text&lt;/code&gt;、 &lt;code&gt;bss&lt;/code&gt;、 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;rodata&lt;/code&gt; 区别和联系&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Linker" scheme="http://yoursite.com/categories/C/Linker/"/>
    
    
      <category term="ld" scheme="http://yoursite.com/tags/ld/"/>
    
      <category term="nm" scheme="http://yoursite.com/tags/nm/"/>
    
      <category term="objdump" scheme="http://yoursite.com/tags/objdump/"/>
    
      <category term="readelf" scheme="http://yoursite.com/tags/readelf/"/>
    
  </entry>
  
  <entry>
    <title>抓取 JS 动态生成网页数据</title>
    <link href="http://yoursite.com/2019/12/06/python-requests-dynamic-webpages/"/>
    <id>http://yoursite.com/2019/12/06/python-requests-dynamic-webpages/</id>
    <published>2019-12-06T02:43:27.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>静态网页使用 <code>bs4</code> + <code>requests</code> 进行抓取<br>动态网页数据不在 HTML 中，需要分析之后设计程序</p><a id="more"></a><blockquote><p>转载 <a href="https://www.jianshu.com/p/9de3be54abc1" target="_blank" rel="noopener">网络数据抓取-JS动态生成数据-Python-requests爬虫</a></p></blockquote><h2 id="理解页面"><a href="#理解页面" class="headerlink" title="理解页面"></a>理解页面</h2><p><img src="/images/spider/4324074-6bc9881ca058cf06.webp" alt="动态填充数据页面流程"></p><blockquote><p>能够动态请求数据和填充数据的代码就是 Html 网页内运行的 JavaScript 脚本代码，它们可以做各种事情，尤其善于玩弄数据。</p></blockquote><h2 id="理解数据请求Request"><a href="#理解数据请求Request" class="headerlink" title="理解数据请求Request"></a>理解数据请求Request</h2><p>使用 <code>chrome</code> 开发者工具分析 <code>Network</code></p><h2 id="发送数据请求"><a href="#发送数据请求" class="headerlink" title="发送数据请求"></a>发送数据请求</h2><p>复制请求地址</p><pre><code class="python">requests.get(url, headers=User_Agents[0], timeout=50)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态网页使用 &lt;code&gt;bs4&lt;/code&gt; + &lt;code&gt;requests&lt;/code&gt; 进行抓取&lt;br&gt;动态网页数据不在 HTML 中，需要分析之后设计程序&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Python/Spider/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="bs4" scheme="http://yoursite.com/tags/bs4/"/>
    
      <category term="requests" scheme="http://yoursite.com/tags/requests/"/>
    
      <category term="spider" scheme="http://yoursite.com/tags/spider/"/>
    
  </entry>
  
  <entry>
    <title>提高 github 下载速度</title>
    <link href="http://yoursite.com/2019/12/03/improve-github-download-speed/"/>
    <id>http://yoursite.com/2019/12/03/improve-github-download-speed/</id>
    <published>2019-12-03T02:52:05.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>修改 <code>hosts</code> 提高 github 下载速度</p><a id="more"></a><h2 id="提供速度"><a href="#提供速度" class="headerlink" title="提供速度"></a>提供速度</h2><p>在 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 使用 IP Lookup 查询下面三个域名地址</p><ul><li>140.82.113.4 github.com</li><li>199.232.5.194 github.global.ssl.fastly.net</li><li>140.82.113.10 codeload.github.com</li></ul><p>将上述信息添加到 <code>/etc/hosts</code> 中并重启网络服务</p><pre><code class="shell">$ sudo /etc/init.d/networking restart</code></pre><h2 id="减少下载量"><a href="#减少下载量" class="headerlink" title="减少下载量"></a>减少下载量</h2><pre><code class="shell">$ git clone repo_url --depth=1</code></pre><p>只下载最新版本，而不是带有全部历史版本的仓库</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改 &lt;code&gt;hosts&lt;/code&gt; 提高 github 下载速度&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/categories/Tools/GitHub/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hosts" scheme="http://yoursite.com/tags/hosts/"/>
    
  </entry>
  
  <entry>
    <title>Docker 网桥 172.17 导致本地无法访问</title>
    <link href="http://yoursite.com/2019/11/26/docker-destination-host-unreachable/"/>
    <id>http://yoursite.com/2019/11/26/docker-destination-host-unreachable/</id>
    <published>2019-11-26T05:34:02.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 安装几个容器后导致本地无法访问，记录解决过程</p><a id="more"></a><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>本地网站无法访问，显示<code>Destination Host Unreachable</code>错误</p><pre><code class="shell">$ ping xxx.comPING xxx.com (172.18.0.10) 56(84) bytes of data.From (172.18.0.1) icmp_seq=1 Destination Host UnreachableFrom (172.18.0.1) icmp_seq=2 Destination Host UnreachableFrom (172.18.0.1) icmp_seq=3 Destination Host Unreachable$ route内核 IP 路由表目标            网关            子网掩码        标志  跃点   引用  使用 接口default         _gateway        0.0.0.0         UG    100    0        0 enp0s25link-local      0.0.0.0         255.255.0.0     U     1000   0        0 enp0s25172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-cfc9270b15f3172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-f5c5f0da48a2192.168.110.0   0.0.0.0         255.255.254.0   U     100    0        0 enp0s25$ ifconfigbr-cfc9270b15f3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255        inet6 fe80::42:1aff:fec6:7043  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 02:42:1a:c6:70:43  txqueuelen 0  (以太网)        RX packets 14  bytes 9546 (9.5 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 797  bytes 91465 (91.4 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:13:03:9a:6c  txqueuelen 0  (以太网)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.110.55  netmask 255.255.254.0  broadcast 192.168.111.255        inet6 fe80::3615:4135:d778:298  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 54:ee:75:40:ea:67  txqueuelen 1000  (以太网)        RX packets 407891  bytes 60596095 (60.5 MB)        RX errors 0  dropped 15691  overruns 0  frame 0        TX packets 31293  bytes 3769383 (3.7 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0        device interrupt 20  memory 0xf1600000-f1620000  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (本地环回)        RX packets 33484889  bytes 2454937345 (2.4 GB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 33484889  bytes 2454937345 (2.4 GB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>问题在于 br-cfc9270b15f3</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h3><pre><code class="shell">$ docker stop $(docker ps -aq)$ docker rm $(docker ps -aq)</code></pre><h3 id="删除network"><a href="#删除network" class="headerlink" title="删除network"></a>删除network</h3><pre><code class="shell">$ docker network prune$ ifconfigdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:13:03:9a:6c  txqueuelen 0  (以太网)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.110.55  netmask 255.255.254.0  broadcast 192.168.111.255        inet6 fe80::3615:4135:d778:298  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 54:ee:75:40:ea:67  txqueuelen 1000  (以太网)        RX packets 419408  bytes 72317482 (72.3 MB)        RX errors 0  dropped 15691  overruns 0  frame 0        TX packets 39576  bytes 4970401 (4.9 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0        device interrupt 20  memory 0xf1600000-f1620000  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (本地环回)        RX packets 34240204  bytes 2501217904 (2.5 GB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 34240204  bytes 2501217904 (2.5 GB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="修改-docker-网段"><a href="#修改-docker-网段" class="headerlink" title="修改 docker 网段"></a>修改 docker 网段</h3><pre><code class="shell">$ sudo service docker stop$ sudo ifconfig docker0 down$ sudo vim /etc/docker/daemon.json$ sudo service docker restart$ ifconfigdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 175.168.0.1  netmask 255.255.0.0  broadcast 175.168.255.255        ether 02:42:13:03:9a:6c  txqueuelen 0  (以太网)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>在 <code>daemon.json</code> 添加 <code>&quot;bip&quot;: &quot;175.168.0.1/16&quot;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 安装几个容器后导致本地无法访问，记录解决过程&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Linux/Docker/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
      <category term="hosts" scheme="http://yoursite.com/tags/hosts/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>git 覆盖分支</title>
    <link href="http://yoursite.com/2019/11/25/git-push-force/"/>
    <id>http://yoursite.com/2019/11/25/git-push-force/</id>
    <published>2019-11-25T04:54:30.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>git push -f</code> 用一个分支覆盖另一个分支</p><a id="more"></a><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><ol><li>同步 develop 分支<pre><code class="shell">$ git checkout develop$ git pull</code></pre></li><li>如果是 gerrit 控制权限，需要允许 <code>git push -f</code></li></ol><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><pre><code class="shell">$ git push origin develop:master -f</code></pre><p>将本地 develop 分支推送到远程 master 分支</p><h2 id="II"><a href="#II" class="headerlink" title="II"></a>II</h2><pre><code class="shell">$ git checkout master$ git reset –hard develop</code></pre><p>将本地 master 分支重置成 develop 分支</p><pre><code class="shell">$ git push origin master –force</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;git push -f&lt;/code&gt; 用一个分支覆盖另一个分支&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/Tools/Git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="git push" scheme="http://yoursite.com/tags/git-push/"/>
    
  </entry>
  
  <entry>
    <title>RSA 数字签名与加解密</title>
    <link href="http://yoursite.com/2019/11/25/rsa-encrypt-and-signature/"/>
    <id>http://yoursite.com/2019/11/25/rsa-encrypt-and-signature/</id>
    <published>2019-11-25T02:47:05.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<ul><li>非对称加密算法 RSA 生成一对密钥：公钥和私钥。公钥和私钥都可以用来加解密，取决于应用场景</li><li>加密是公钥加密、私钥解密，用于保证数据安全</li><li>签名是私钥加密、公钥解密，用于验证身份</li></ul><a id="more"></a><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>将明文转换为密文，用于保护敏感数据</p><p><img src="/images/ssl/OpenPGPEncrypt.jpg" alt="Encrypting"></p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名有助于确保以下各项：</p><ol><li>数据完整性–消息未更改其原始形式。</li><li>消息身份验证（来源证明）–消息实际上来自声称的发件人。</li></ol><p><img src="/images/ssl/OpenPGPSign.jpg" alt="Signing"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/liwei16611/article/details/83686674" target="_blank" rel="noopener">加密与安全：图解非对称加密算法 RSA 数字签名与数字证书</a></li><li><a href="https://blog.csdn.net/sfdev/article/details/2174305" target="_blank" rel="noopener">RSA 数字签名与加密、解密间的关系</a></li><li><a href="http://blogs.mdaemon.com/index.php/2018/05/29/encrypting-vs-signing-with-openpgp-whats-the-difference-2/" target="_blank" rel="noopener">Encrypting vs. Signing with OpenPGP. What’s the Difference?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;非对称加密算法 RSA 生成一对密钥：公钥和私钥。公钥和私钥都可以用来加解密，取决于应用场景&lt;/li&gt;
&lt;li&gt;加密是公钥加密、私钥解密，用于保证数据安全&lt;/li&gt;
&lt;li&gt;签名是私钥加密、公钥解密，用于验证身份&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Security" scheme="http://yoursite.com/categories/Security/"/>
    
    
      <category term="encrypt" scheme="http://yoursite.com/tags/encrypt/"/>
    
      <category term="rsa" scheme="http://yoursite.com/tags/rsa/"/>
    
      <category term="signature" scheme="http://yoursite.com/tags/signature/"/>
    
      <category term="CA" scheme="http://yoursite.com/tags/CA/"/>
    
  </entry>
  
  <entry>
    <title>markdown-with-mathjax</title>
    <link href="http://yoursite.com/2019/11/05/markdown-with-mathjax/"/>
    <id>http://yoursite.com/2019/11/05/markdown-with-mathjax/</id>
    <published>2019-11-05T08:39:30.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><a href="https://juejin.im/post/5a6721bd518825733201c4a2" target="_blank" rel="noopener">MarkDown 插入数学公式实验大集合</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a6721bd518825733201c4a2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MarkDown 插入数学公式实验大集合&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>openssl 密钥生成与解析</title>
    <link href="http://yoursite.com/2019/11/05/openssl-rsa-key/"/>
    <id>http://yoursite.com/2019/11/05/openssl-rsa-key/</id>
    <published>2019-11-05T07:27:18.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>使用 openssl 生成解析 rsa 公私钥</p><a id="more"></a><h2 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA 算法原理（一）</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA 算法原理（二）</a></p><p>从中可以得出如下信息：</p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><table><thead><tr><th align="center">-</th><th align="center">公式</th></tr></thead><tbody><tr><td align="center">公钥 KU</td><td align="center">n：质数 p 和质数 q 的乘积（p 和 q 必须保密）<br>e：与 (p-1)×(q-1) 互质</td></tr><tr><td align="center">私钥 KR</td><td align="center">n：同公钥 n<br> d: \(e^{-1}(mod(p-1)(q-1))\)</td></tr><tr><td align="center">加密</td><td align="center">\(c=m^emodn\)</td></tr><tr><td align="center">解密</td><td align="center">\(m=c^dmodn\)</td></tr></tbody></table><p><strong>n 和 e 封装成公钥，n 和 d 封装成私钥。公钥和私钥的数据都采用 <code>ASN.1</code> 格式表达</strong></p><blockquote><p>实际应用中，e 常常选择 65537</p></blockquote><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>使用 openssl 来生成公钥、私钥</p><h3 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h3><pre><code class="shell">$ openssl genrsa -out privkey.pem 2048</code></pre><h3 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h3><pre><code class="shell">$ openssl rsa -in privkey.pem -pubout -out pubkey.pem</code></pre><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><pre><code class="shell">$ openssl req -new -key privkey.pem -out ca.csr</code></pre><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><a href="https://www.jianshu.com/p/78886e480bef" target="_blank" rel="noopener">openssl 密钥生成和解析</a></p><h3 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h3><p>openssl 的数据编码规则是基于 ans.1<br>openssl 有多种形式的密钥，openssl 提供 PEM 和 DER 两种编码方式对这些密钥进行编码，并提供相关指令可以使用户在这两种格式之间进行转换。</p><h4 id="DER"><a href="#DER" class="headerlink" title="DER"></a>DER</h4><p>DER 就是密钥的二进制表述格式。</p><h4 id="PEM"><a href="#PEM" class="headerlink" title="PEM"></a>PEM</h4><p>PEM 格式就是对 DER 编码转码为 base64 字符格式。通过 base64 解码可以还原 DER 格式。</p><h3 id="PEM-格式"><a href="#PEM-格式" class="headerlink" title="PEM 格式"></a>PEM 格式</h3><h4 id="公钥-1"><a href="#公钥-1" class="headerlink" title="公钥"></a>公钥</h4><pre><code>RSAPublicKey ::= SEQUENCE {    modulus           INTEGER,  -- n    publicExponent    INTEGER   -- e}</code></pre><ul><li>modulus 是 RSA 的合数模 n</li><li>publicExponent 是 RSA 公开幂 e</li></ul><p>命令分析公钥如下</p><pre><code class="shell">$ cat pubkey.pem-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA04VqFIaa59Aba74p+fuLLa4I1KoZJ+40yeg3QFFagCNpqI+Krf+5qZBNuhWrBRtp0LN9IOftfDr/nC+I+04GCXMX+4ZrPfkWRWkDZr2RC7WqC+/E2Fgx7DBSWqXx1dPog3q3j1eeO8PL/FGA2q6C9Yy9PW5a/E/YG4ngMOGCvIc1dR2eJkqz6hBOWZB3+GnrV7VoVZZE2hNP3SXsqGZYFXRntKhuBc1FWMIwSN9tTWC6EhR550HqZx9jogTVDvwVn5yXSNhJ/K1fg7vkQVRaNMNuz1EX2VT00XJ1U4qd+q7p4PR1N+vDIAHUMABW8HkM0HKlYS+hl/LnZTvRCUcRXwIDAQAB-----END PUBLIC KEY-----$ openssl rsa -pubin -in pubkey.pem -text -nooutRSA Public-Key: (2048 bit)Modulus:    00:d3:85:6a:14:86:9a:e7:d0:1b:6b:be:29:f9:fb:    ...Exponent: 65537 (0x10001)$ openssl asn1parse -i -in pubkey.pem    0:d=0  hl=4 l= 290 cons: SEQUENCE    4:d=1  hl=2 l=  13 cons:  SEQUENCE    6:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption   17:d=2  hl=2 l=   0 prim:   NULL   19:d=1  hl=4 l= 271 prim:  BIT STRING</code></pre><h4 id="私钥-1"><a href="#私钥-1" class="headerlink" title="私钥"></a>私钥</h4><pre><code>RSAPrivateKey ::= SEQUENCE {  version           Version,  modulus           INTEGER,  -- n  publicExponent    INTEGER,  -- e  privateExponent   INTEGER,  -- d  prime1            INTEGER,  -- p  prime2            INTEGER,  -- q  exponent1         INTEGER,  -- d mod (p-1)  exponent2         INTEGER,  -- d mod (q-1)  coefficient       INTEGER,  -- (inverse of q) mod p  otherPrimeInfos   OtherPrimeInfos OPTIONAL}</code></pre><ul><li>modulus 是 RSA 合数模 n</li><li>publicExponent 是 RSA 的公开幂 e</li><li>privateExponent 是 RSA 的私有幂 d</li><li>prime1 是 n 的素数因子 p</li><li>prime2 是 n 的素数因子 q</li><li>exponent1 等于 \(d mod (p−1)\)</li><li>exponent2 等于 \(d mod (q−1)\)</li><li>coefficient 是 CRT 系数 \((q–1) mod p\)</li></ul><p>分析私钥如下</p><pre><code class="shell">$ cat privkey.pem-----BEGIN RSA PRIVATE KEY-----MIIEowIBAAKCAQEA04VqFIaa59Aba74p+fuLLa4I1KoZJ+40yeg3QFFagCNpqI+K...-----END RSA PRIVATE KEY-----$ openssl rsa -in privkey.pem -text -nooutRSA Private-Key: (2048 bit, 2 primes)modulus:    00:d3:85:6a:14:86:9a:e7:d0:1b:6b:be:29:f9:fb:    ...publicExponent: 65537 (0x10001)privateExponent:    3f:84:70:b6:79:35:4b:27:53:14:a7:a6:33:4b:36:    ...prime1:    00:f9:d6:97:89:e0:a6:78:e4:c9:f8:70:ed:aa:6c:    ...prime2:    00:d8:bc:e6:2b:25:83:48:98:d6:84:fb:90:ef:f4:    ...exponent1:    00:f7:f8:64:aa:05:9e:55:49:87:a9:1d:b4:d6:bc:    ...exponent2:    46:e7:85:65:18:20:9a:df:65:4e:9b:fe:0e:82:26:    ...coefficient:    2c:be:89:1e:ad:1b:c7:1f:f1:72:1e:ae:6e:a8:c6:    ...$ openssl asn1parse -i -in privkey.pem    0:d=0  hl=4 l=1187 cons: SEQUENCE    4:d=1  hl=2 l=   1 prim:  INTEGER           :00    7:d=1  hl=4 l= 257 prim:  INTEGER           :D3856A14869AE7D01B6BBE29F9FB8B2DAE08D4AA1927EE34C9E83740515A802369A88F8AADFFB9A9904DBA15AB051B69D0B37D20E7ED7C3AFF9C2F88FB4E06097317FB866B3DF91645690366BD910BB5AA0BEFC4D85831EC30525AA5F1D5D3E8837AB78F579E3BC3CBFC5180DAAE82F58CBD3D6E5AFC4FD81B89E030E182BC8735751D9E264AB3EA104E599077F869EB57B568559644DA134FDD25ECA86658157467B4A86E05CD4558C23048DF6D4D60BA121479E741EA671F63A204D50EFC159F9C9748D849FCAD5F83BBE441545A34C36ECF5117D954F4D17275538A9DFAAEE9E0F47537EBC32001D4300056F0790CD072A5612FA197F2E7653BD10947115F  268:d=1  hl=2 l=   3 prim:  INTEGER           :010001  273:d=1  hl=4 l= 256 prim:  INTEGER           :3F8470B679354B275314A7A6334B36202182C559CEF40EB40B6D9029E0442CF6756408B6BC496E975C9DFAA34717E1838508612AE07A9033A74E5F77E2FF2B10EB5EE849152B270169167FCEFA5DF406396A1C3620415BBC714649B24B4CCAB5A7C5D21959564ADC210543F44DB6D9DCA2C6B10BD286B1F35351B3E0F9D72885658C1B59062CDE9F71746BBC51AEAB3BF4A72093D61E186A2D241DFB6EF25F21A0F243A557E03F84BFDB67626B2C9E27E44E7865E50AF5937AA4F316D54D7D53B2666628AAF808E70775998B863D5764312E52FAD7796206312803BF685463F91662669C2D4F2B0D75F8AF5591D010C6B29B314EB3C0E0BC47410C3EBC7CF101  533:d=1  hl=3 l= 129 prim:  INTEGER           :F9D69789E0A678E4C9F870EDAA6C1C1AA9BEE312C19E6B53129FF4F23D9CBCCCEED5DDCF6311E23A1D58741F47C6F065CF2F7A84D0FB989AD87C37B241C69AC5AA3E3E382DF603B774C6AD5CD4F0AAA40F90CCDDD69A758845213AAA0A67745E22C4FF2C703B9E0A4C6F8A73E0A3A848A20C667C8F226BAFEC8004B92CB6851B  665:d=1  hl=3 l= 129 prim:  INTEGER           :D8BCE62B25834898D684FB90EFF468BBDE358413EA0FF9420A44F4A05636113DB2AEEAEFFECEFBA11807674612AAD21945C157EC60FB7672FC7DEC402695255AFE2FD2D55566DCAAC6FBE6231B8504765DE073F852772706BB2B7E6A7D0AA84607459F8D9EBF3AC63086B6037F626D667A8CE82EA7C96ABCD721BC4C9CEEDD0D  797:d=1  hl=3 l= 129 prim:  INTEGER           :F7F864AA059E554987A91DB4D6BCBCDC3DF4677E9B4BF86C188548E21202FA6550FC564E5B9F4971B2E4B344C4C210A28C142CBF9C88CB7B8D392532B9143D53C95843FB10AB281F33396AA243FBA6F2753C9C09E6D1A1AC22290C07EF91A52F35C55F1BA53D96EBD3D7B58CB3BEDBED5361896B41C9C126784ECBE15B1EC157  929:d=1  hl=3 l= 128 prim:  INTEGER           :46E7856518209ADF654E9BFE0E8226C14F30B2C4D10DE8BD721E9CE8D74B58D8965C22FFE09C56359D66CEA25DF90442C04F40345485EF7A2EA00369F93551C332E4F254585C0E54D0441845E3FAE03AD8FB54F5280552FF20BC59DEFC894003A8DD5E153699D8E07D7F948C106062E9E3ADB5478E1C968EB0D2988777CFAD01 1060:d=1  hl=3 l= 128 prim:  INTEGER           :2CBE891EAD1BC71FF1721EAE6EA8C6091AD8C117029A9142FC4F82F04BED3855EAC22D77ACC401095AE46D6964A5CAC596513BD71554DAE296614AF352CB198C25F0213C062C93A980DAA351583C5BF354E9A39B9FE0B4EC38FFA3C8324D33062AF21FA73AAFF1CDFE6056150C724F46C689F33D132C2AB4CE6F6B79A5A9AFD8</code></pre><ul><li><code>0</code> 表示节点在整个文件中的偏移长度</li><li><code>d=0</code> 表示节点深度</li><li><code>hl=3</code> 表示节点头字节长度</li><li><code>l=135</code> 表示节点数据字节长度</li><li><code>cons</code> 表示该节点为结构节点，表示包含子节点或者子结构数据</li><li><code>prim</code> 表示该节点为原始节点，包含数据</li><li><code>SEQUENCE</code>、 <code>OCTET STRING</code> 等都是 ASN.1 中定义的数据类型</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 openssl 生成解析 rsa 公私钥&lt;/p&gt;
    
    </summary>
    
      <category term="Security" scheme="http://yoursite.com/categories/Security/"/>
    
    
      <category term="openssl" scheme="http://yoursite.com/tags/openssl/"/>
    
      <category term="rsa" scheme="http://yoursite.com/tags/rsa/"/>
    
  </entry>
  
  <entry>
    <title>Docker 镜像存储原理 UnionFS</title>
    <link href="http://yoursite.com/2019/10/31/docker-unionfs-aufs-vs-overlay2/"/>
    <id>http://yoursite.com/2019/10/31/docker-unionfs-aufs-vs-overlay2/</id>
    <published>2019-10-31T08:30:41.000Z</published>
    <updated>2020-03-11T02:35:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 使用 <code>UnionFS</code> 以支持存储，常用的有如下文件系统</p><ul><li><a href="https://zh.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">aufs</a></li><li><a href="https://zh.wikipedia.org/wiki/OverlayFS" target="_blank" rel="noopener">overlay2</a></li></ul><a id="more"></a><h2 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h2><p>基于 <code>ubuntu 14.04</code> 分析 <code>AUFS</code></p><p><a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="noopener">DOCKER基础技术：AUFS</a></p><h2 id="overlay2"><a href="#overlay2" class="headerlink" title="overlay2"></a>overlay2</h2><p><a href="https://www.linuxidc.com/Linux/2017-03/141579.htm" target="_blank" rel="noopener">Docker存储驱动之OverlayFS简介</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>官方资料</p><ul><li><a href="https://docs.docker.com/storage/storagedriver/aufs-driver/" target="_blank" rel="noopener">Use the AUFS storage driver</a></li><li><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">Use the OverlayFS storage driver</a></li><li><a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">About storage drivers</a></li></ul><p>如下信息</p><ul><li>内核 <code>4.0</code> 以上第一选择 <code>overlay2</code></li><li>不支持 <code>overlay2</code>，首选 <code>aufs</code></li><li><code>overlay2</code> 已合并到内核，不需要进行任何额外的配置</li><li><code>aufs</code> 未合并进内核，需要安装额外的包以支持</li></ul><p>使用命令 <code>docker info</code> 检查存储驱动</p><pre><code class="shell">$ docker infoClient: Debug Mode: falseServer: Containers: 4  Running: 0  Paused: 0  Stopped: 4 Images: 7 Server Version: 19.03.4 Storage Driver: overlay2  Backing Filesystem: extfs  Supports d_type: true  Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 使用 &lt;code&gt;UnionFS&lt;/code&gt; 以支持存储，常用的有如下文件系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Aufs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aufs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/OverlayFS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;overlay2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Linux/Docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="unionfs" scheme="http://yoursite.com/tags/unionfs/"/>
    
      <category term="aufs" scheme="http://yoursite.com/tags/aufs/"/>
    
      <category term="overlay2" scheme="http://yoursite.com/tags/overlay2/"/>
    
  </entry>
  
</feed>
