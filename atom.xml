<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-10-12T02:40:42.978Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Breeze.Temple</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>嵌入式内对齐及相关位运算</title>
    <link href="http://yoursite.com/2021/07/28/memory-alignment/"/>
    <id>http://yoursite.com/2021/07/28/memory-alignment/</id>
    <published>2021-07-28T02:48:49.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>嵌入式内存对齐及位运算解析</p><a id="more"></a><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p><a href="https://murphypei.github.io/blog/2020/04/memory-align" target="_blank" rel="noopener">浅谈内存对齐</a><br><a href="https://blog.csdn.net/vector03/article/details/40977679?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control" target="_blank" rel="noopener">位运算</a><br><a href="https://embeddedartistry.com/blog/2017/02/22/generating-aligned-memory/" target="_blank" rel="noopener">Generating Aligned Memory</a></p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><code>gcc</code> 修饰 <code>__attribute__((aligned(32)))</code></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>各种内存分配算法保证，为了保证内存对齐，<code>malloc</code>时需要申请比所要求的内存大的容量，这样可以<strong>向下</strong>寻找一个保证是对齐大小的整倍数的内存地址</p><p>如果 <code>n</code> 为以2为底的m (m &gt; 0, m = 1, 2, 3, …)次幂指数,当以 <code>n</code> 为对齐边界时,称 <code>n – 1</code> 为该对齐边界的对齐掩码(align mask).</p><pre><code class="c">#define is_align(A, n) ((A) &amp; ((n) - 1) == 0)</code></pre><p>对齐方式：</p><ul><li>上对齐 align up / round up</li><li>下对齐 align down / round down</li></ul><pre><code class="c">#define align_down(A, n) ((A) &amp; ~((n) - 1)) # 舍弃对齐低位#define align_up(A, n) (((A) + ((n) - 1)) &amp; !((n) - 1)) # + (n) - 1 跳到下个区间，然后 align down 对齐 </code></pre><p>计算内存对齐偏移量：</p><pre><code class="c">#define align_offset(A, n) (((A) &amp; ((n) - 1) == 0) ? 0 : \   ((n) - (A) &amp; ((n) - 1)) &amp; ((n) - 1)) </code></pre><p><strong>DLMalloc</strong></p><pre><code class="c">/* The bit mask value corresponding to MALLOC_ALIGNMENT */#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)/* True if address a has acceptable alignment */#define is_aligned(A)       (((size_t)((A)) &amp; (CHUNK_ALIGN_MASK)) == 0)/* the number of bytes to offset an address to align it */#define align_offset(A)\ ((((size_t)(A) &amp; CHUNK_ALIGN_MASK) == 0)? 0 :\  ((MALLOC_ALIGNMENT - ((size_t)(A) &amp; CHUNK_ALIGN_MASK)) &amp; CHUNK_ALIGN_MASK))</code></pre><p>最后一步 <code>&amp; CHUNK_ALIGN_MASK</code> 是多余的</p><p><strong>TLSF</strong></p><pre><code class="c">#define BLOCK_ALIGN (sizeof(void *) * 2)#define MEM_ALIGN         ((BLOCK_ALIGN) - 1)#define ROUNDUP_SIZE(_r)          (((_r) + MEM_ALIGN) &amp; ~MEM_ALIGN)#define ROUNDDOWN_SIZE(_r)        ((_r) &amp; ~MEM_ALIGN)size = (size &lt; MIN_BLOCK_SIZE) ? MIN_BLOCK_SIZE : ROUNDUP_SIZE(size);</code></pre><blockquote><p>malloc内存对齐实现</p></blockquote><ul><li>计算申请内存大小：ori_size + 控制块 + alignment</li><li>申请内存</li><li>align down获取内存对齐首地址</li></ul><h2 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h2><h3 id="不存在-pragma-pack"><a href="#不存在-pragma-pack" class="headerlink" title="不存在 #pragma pack"></a>不存在 <code>#pragma pack</code></h3><ol><li>第一个成员的首地址为0</li><li>每个成员的首地址是自身大小的整数倍</li><li>结构体的总大小，为其成员中所含最大类型的整数倍</li></ol><pre><code class="c">struct test{  char a;   //1 + p1  short b;  //2  char c;   //1 + p1};struct test{  char a;   //1 + p3  int  b;   //4  short c;  //2 + p2};</code></pre><h3 id="存在-pragma-pack"><a href="#存在-pragma-pack" class="headerlink" title="存在 #pragma pack"></a>存在 <code>#pragma pack</code></h3><blockquote><p>按照这个宏声明的和实际数据类型中最大值较小的那个来决定</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嵌入式内存对齐及位运算解析&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="Memory" scheme="http://yoursite.com/categories/C/Memory/"/>
    
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="memory" scheme="http://yoursite.com/tags/memory/"/>
    
      <category term="tlsf" scheme="http://yoursite.com/tags/tlsf/"/>
    
      <category term="align" scheme="http://yoursite.com/tags/align/"/>
    
      <category term="dlmalloc" scheme="http://yoursite.com/tags/dlmalloc/"/>
    
  </entry>
  
  <entry>
    <title>Linux Debugging Tools</title>
    <link href="http://yoursite.com/2021/07/22/linux-debugging-tools/"/>
    <id>http://yoursite.com/2021/07/22/linux-debugging-tools/</id>
    <published>2021-07-22T02:10:29.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 调试工具</p><a id="more"></a><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><pre><code class="c">#ifdef UNIT_TESTING#define TRACE(flag, format) if(global_debug &amp; flag) printf format#else#define TRACE(flag, format)#endif</code></pre><p>需要重新编译以及影响执行时间</p><h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><blockquote><p>Monitor User Application and Kernel.</p></blockquote><pre><code class="shell">$ strace -c find /etc -name xorg.conf</code></pre><h2 id="Performance-Analysis"><a href="#Performance-Analysis" class="headerlink" title="Performance Analysis"></a>Performance Analysis</h2><blockquote><p>gprof</p></blockquote><ul><li>compile option <code>-gp</code></li><li>make<pre><code class="makefile">$(CC) $(LDFLAGS) -pg -o $@ $(OBJS)</code></pre></li><li>Profile<pre><code class="shell">gprof &lt;options&gt; &lt;exec file&gt; gmon.out</code></pre></li></ul><h2 id="GDB-GNU-DeBugger"><a href="#GDB-GNU-DeBugger" class="headerlink" title="GDB - GNU DeBugger"></a>GDB - GNU DeBugger</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://slideplayer.com/slide/6201415/" target="_blank" rel="noopener">Section 9: Linux Debugging Tools</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 调试工具&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>优化 c 程序可执行文件大小</title>
    <link href="http://yoursite.com/2021/07/13/how-to-make-smaller-c-binaries/"/>
    <id>http://yoursite.com/2021/07/13/how-to-make-smaller-c-binaries/</id>
    <published>2021-07-13T07:31:03.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>优化 elf 大小的各种方式</p><a id="more"></a><h2 id="编译优化等级"><a href="#编译优化等级" class="headerlink" title="编译优化等级"></a>编译优化等级</h2><ul><li><code>-O0</code> 默认</li><li><code>-O1</code></li><li><code>-O2</code></li><li><code>-O3</code></li><li><code>-Ofast</code></li><li><code>Os</code></li></ul><p>应该使用 <code>-Os</code> 来保证编译的 elf 最小，禁用了类似 <code>inline</code> 之类的编译优化选项，同时对性能敏感的代码使用 <code>#pragma</code> 来保证</p><pre><code class="c">#pragma GCC push_options#pragma GCC optimize (&quot;O2&quot;)/* * Code that needs optimizing O2 */#pragma GCC pop_options</code></pre><h2 id="Linker-Garbage-Collection"><a href="#Linker-Garbage-Collection" class="headerlink" title="Linker Garbage Collection"></a>Linker Garbage Collection</h2><p>将不使用的 <code>function</code>、<code>data</code> 从 elf 中删除</p><pre><code class="makefile">CFLAGS += -ffunction-sections -fdata-sectionsLDFLAGS += -Wl,--gc-sections</code></pre><p><strong>需要避免某些符号被优化掉，例如中断向量，使用 KEEP</strong></p><pre><code class="ld">    .text :    {        KEEP(*(.vectors .vectors.*))            [...]    } &gt; rom</code></pre><h2 id="strip-elf"><a href="#strip-elf" class="headerlink" title="strip elf"></a>strip elf</h2><p>去除非必要段</p><pre><code class="shell">$ objcopy -S -g out.elf$ strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag</code></pre><ul><li>Remove all symbol and relocation information</li><li>Remove all debugging symbols &amp; sections</li><li>Remove all symbols not needed by relocations</li></ul><h2 id="m32"><a href="#m32" class="headerlink" title="-m32"></a><code>-m32</code></h2><p>Use <code>-m32</code> to compile a 32-bit binary. 32-bit binaries are smaller than 64-bit binaries because pointers are shorter.</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><ul><li><code>-fno-stack-protector</code></li><li><code>-fomit-frame-pointer</code></li><li><code>-fno-math-errno</code>, and don’t check the errno after calling math functions.</li><li>Try <code>-fno-unroll-loops</code>, sometimes it makes the file smaller.</li><li><code>-fmerge-all-constants</code></li><li><code>-fno-ident</code>, this will prevent the generation of the .ident assembler directive, which adds an identification of the compiler to the binary.</li><li><code>-mfpmath=387</code> <code>-mfancy-math-387</code> to make floating point computations shorter.</li><li>If you don’t need double precision, but float preecision is enough, use -fshort-double -fsingle-precision-constant .</li><li>If you don’t need IEEE-conformat floating point calculations, use -ffast-math .</li><li>Use -Wl,-z,norelro for linking, which is equivalent to ld -z norelro .</li><li>Use -Wl,–hash-style=gnu for linking, which is equivalent to ld –hash-style=gnu . You may also try =sysv instead of =gnu, sometimes it’s smaller by a couple of bytes. The goal here is to avoid =both, which is the default on some systems.</li><li>Use -Wl,–build-id=none for linking, which is equivalent to ld –build-id=none .</li><li>Get more flags from the Os list in diet.c of diet libc, for about 15 architectures.</li><li>Don’t use these flags: -pie, -fpie, -fPIE, -fpic, -fPIC. Some of these are useful in shared libraries, so enable them only when compiling shared libraries.</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul><li>use <code>-fno-exceptions</code> if your code doesn’t use exceptions.</li><li>use <code>-fno-rtti</code> if your code doesn’t use RTTI (run-time type identification) or dynamic_cast.</li><li>use <code>-fvtable-gc</code> to let the linker know about and remove unused virtual method tables.</li></ul><h2 id="i386"><a href="#i386" class="headerlink" title="i386"></a>i386</h2><ul><li>use -mpreferred-stack-boundary=2 .</li><li>use -falign-functions=1 -falign-jumps=1 -falign-loops=1 .</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://ptspts.blogspot.com/2013/12/how-to-make-smaller-c-and-c-binaries.html" target="_blank" rel="noopener"><strong>How to make smaller C and C++ binaries</strong></a></li><li><a href="https://interrupt.memfault.com/blog/code-size-optimization-gcc-flags" target="_blank" rel="noopener">Code Size Optimization: GCC Compiler Flags</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;优化 elf 大小的各种方式&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="elf" scheme="http://yoursite.com/tags/elf/"/>
    
  </entry>
  
  <entry>
    <title>eCos3.0-dlmalloc</title>
    <link href="http://yoursite.com/2021/07/13/eCos3-0-dlmalloc/"/>
    <id>http://yoursite.com/2021/07/13/eCos3-0-dlmalloc/</id>
    <published>2021-07-13T06:51:57.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="http://gee.cs.oswego.edu/dl/" target="_blank" rel="noopener">Doug Lea’s Home Page</a></li><li><a href="http://www.cppblog.com/yangfan/articles/117132.html" target="_blank" rel="noopener">dlmalloc-2.6.6源码分析(一)</a></li><li><a href="http://www.cppblog.com/yangfan/archive/2014/03/07/117351.html#206094" target="_blank" rel="noopener">dlmalloc-2.6.6源码分析(二)</a></li><li><a href="https://blog.csdn.net/vector03/article/details/40977679?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control" target="_blank" rel="noopener">dlmalloc 2.8.6 源码详解(1)</a></li><li><a href="https://blog.csdn.net/txx_683/article/details/53456661?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">dlmalloc 2.8.6 源码详解—(2)分箱(bins)</a></li><li><a href="https://blog.csdn.net/vector03/article/details/41008671?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-11.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-11.control" target="_blank" rel="noopener">dlmalloc 2.8.6 源码详解(3)</a></li><li><a href="http://www.malloc.de/papers/malloc-slides.html" target="_blank" rel="noopener">Dynamic memory allocator implementations in Linux system libraries</a></li><li><a href="http://www.gii.upv.es/tlsf/" target="_blank" rel="noopener">TLSF: Memory allocator real time embedded systems</a></li><li><a href="https://blog.csdn.net/tyst08/article/details/105881951" target="_blank" rel="noopener">靠谱：保证实时的动态内存分配</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;


&lt;h2 id=&quot;Ref&quot;&gt;&lt;a href=&quot;#Ref&quot; class=&quot;headerlink&quot; title=&quot;Ref&quot;&gt;&lt;/a&gt;Ref&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://gee.cs.oswego.edu/dl/&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ubuntu 20.04 GitBook 升级</title>
    <link href="http://yoursite.com/2021/07/12/ubuntu-20-04-gitbook-update/"/>
    <id>http://yoursite.com/2021/07/12/ubuntu-20-04-gitbook-update/</id>
    <published>2021-07-12T02:49:21.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p><code>ubuntu 20.04</code> 下 <code>GitBook</code> 运行出现错误</p><pre><code class="shell">$ gitbook serveLive reload server started on port: 35729Press CTRL+C to quit .../usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287      if (cb) cb.apply(this, arguments)                 ^TypeError: cb.apply is not a function    at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18    at FSReqCallback.oncomplete (fs.js:184:5)</code></pre><a id="more"></a><p>本质原因部分包版本不匹配，需要重新安装 <code>GitBook</code></p><ul><li><p>卸载现有版本</p><pre><code class="shell">$ gitbook lsGitBook Versions Installed:  * 3.2.3    2.6.9</code></pre></li></ul><p>Run “gitbook update” to update to the latest version.</p><p>$ gitbook uninstall 2.6.9<br>GitBook 2.6.9 has been uninstalled.</p><p>$ gitbook uninstall 3.2.3<br>GitBook 3.2.3 has been uninstalled.</p><pre><code>- Install```shell$ gitbook ls-remote$ gitbook fecth 3.2.3Installing GitBook 3.2.3/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287      if (cb) cb.apply(this, arguments)                 ^TypeError: cb.apply is not a function    at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18    at FSReqCallback.oncomplete (fs.js:184:5)</code></pre><ul><li>update <code>graceful-fs</code><pre><code class="shell">$ cd /home/&lt;USER_NAME&gt;/.nvm/versions/node/v14.17.1/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/$ sudo npm install graceful-fs@4.2.0 --save</code></pre></li><li>Reinstall<pre><code class="shell">$ gitbook fecth 3.2.3</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ubuntu 20.04&lt;/code&gt; 下 &lt;code&gt;GitBook&lt;/code&gt; 运行出现错误&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ gitbook serve
Live reload server started on port: 35729
Press CTRL+C to quit ...

/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287
      if (cb) cb.apply(this, arguments)
                 ^

TypeError: cb.apply is not a function
    at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18
    at FSReqCallback.oncomplete (fs.js:184:5)&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://yoursite.com/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
      <category term="gitbook" scheme="http://yoursite.com/tags/gitbook/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu20.04 ssl 导致 svn update失败</title>
    <link href="http://yoursite.com/2021/06/07/ubuntu-20-04-svn-update-error/"/>
    <id>http://yoursite.com/2021/06/07/ubuntu-20-04-svn-update-error/</id>
    <published>2021-06-07T05:57:57.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>升级 <code>ubuntu 20.04</code> 后 <code>svn update</code> 失败</p><pre><code>svn: E170013: Unable to connect to a repository at URL &#39;https://svn.xxx.comsvn: E120171: Error running context: An error occurred during SSL communication</code></pre><a id="more"></a><p>使用 <code>curl -v</code> 检查如下</p><pre><code class="shell">curl -v https://svn.xxx.com*   Trying 192.168.0.254:443...* TCP_NODELAY set* Connected to svn.xxx.com (192.168.0.254) port 443 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:*   CAfile: /etc/ssl/certs/ca-certificates.crt  CApath: /etc/ssl/certs* TLSv1.3 (OUT), TLS handshake, Client hello (1):* TLSv1.3 (IN), TLS handshake, Server hello (2):* TLSv1.2 (IN), TLS handshake, Certificate (11):* TLSv1.2 (OUT), TLS alert, bad certificate (554):* SSL certificate problem: EE certificate key too weak* Closing connection 0curl: (60) SSL certificate problem: EE certificate key too weakMore details here: https://curl.haxx.se/docs/sslcerts.html</code></pre><p><a href="https://www.cnblogs.com/milton/p/12831113.html" target="_blank" rel="noopener">Ubuntu 20.04 出现 SSL_connect: error:1425F102 .. unsupported protocol问题的解决</a></p><p><code>ubuntu 20.04</code> 将 <code>TLS</code> 最低版本设置为 <code>1.2</code>，从而导致认证失败<br>修改<code>/etc/ssl/openssl.cnf</code>，在 <code>oid_section = new_oids</code>下增加</p><pre><code>openssl_conf = default_conf[default_conf]ssl_conf = ssl_sect[ssl_sect]system_default = system_default_sect[system_default_sect]MinProtocol = TLSv1.1CipherString = DEFAULT@SECLEVEL=1</code></pre><p>重新测试如下</p><pre><code class="shell">$ curl -v https://svn.xxx.com*   Trying 192.168.0.254:443...* TCP_NODELAY set* Connected to svn.xxx.com (192.168.0.254) port 443 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:*   CAfile: /etc/ssl/certs/ca-certificates.crt  CApath: /etc/ssl/certs* TLSv1.3 (OUT), TLS handshake, Client hello (1):* TLSv1.3 (IN), TLS handshake, Server hello (2):* TLSv1.2 (IN), TLS handshake, Certificate (11):* TLSv1.2 (OUT), TLS alert, unknown CA (560):* SSL certificate problem: self signed certificate* Closing connection 0curl: (60) SSL certificate problem: self signed certificateMore details here: https://curl.haxx.se/docs/sslcerts.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级 &lt;code&gt;ubuntu 20.04&lt;/code&gt; 后 &lt;code&gt;svn update&lt;/code&gt; 失败&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;svn: E170013: Unable to connect to a repository at URL &amp;#39;https://svn.xxx.com
svn: E120171: Error running context: An error occurred during SSL communication&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://yoursite.com/categories/ubuntu/"/>
    
    
      <category term="ssl" scheme="http://yoursite.com/tags/ssl/"/>
    
      <category term="svn" scheme="http://yoursite.com/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>DVB PSI/SI 组成</title>
    <link href="http://yoursite.com/2021/06/03/dvb-psi-si/"/>
    <id>http://yoursite.com/2021/06/03/dvb-psi-si/</id>
    <published>2021-06-03T06:44:29.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>DVB PSI 基础知识</p><a id="more"></a><h2 id="PSI-SI关键词"><a href="#PSI-SI关键词" class="headerlink" title="PSI/SI关键词"></a>PSI/SI关键词</h2><table><thead><tr><th align="center">序号</th><th align="center">关键字</th><th align="center">全拼</th><th align="center">翻译</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">PSI</td><td align="center">Program Specific Information</td><td align="center">节目引导信息</td><td align="left">对单一码流的描述</td></tr><tr><td align="center">2</td><td align="center">SI</td><td align="center">Service Information</td><td align="center">业务信息</td><td align="left">对系统中所有码流的描述，包含了PSI（PSI+9张表）</td></tr><tr><td align="center">3</td><td align="center">TS包</td><td align="center">Transport Packet</td><td align="center">传输包</td><td align="left">数字视音频、图文数据打包成TS包</td></tr><tr><td align="center">4</td><td align="center">TS</td><td align="center">Transport Stream</td><td align="center">传输流（TS流）</td><td align="left">一个频道（多个节目及业务）的TS包复用后称TS流</td></tr><tr><td align="center">5</td><td align="center">PAT</td><td align="center">Program Association Table</td><td align="center">节目关联表</td><td align="left">将节目号码和节目映射表PID相关联，获取数据的开始</td></tr><tr><td align="center">6</td><td align="center">PMT</td><td align="center">Program Map Table</td><td align="center">节目映射表</td><td align="left">指定一个或多个节目的PID</td></tr><tr><td align="center">7</td><td align="center">CAT</td><td align="center">Conditional Access Table</td><td align="center">条件接收表</td><td align="left">将一个或多个专用EMM流分别与唯一的PID相关联</td></tr><tr><td align="center">8</td><td align="center">NIT</td><td align="center">Network Information Table</td><td align="center">网络信息表</td><td align="left">描述整个网络，如多少TS流、频点和调制方式等信息</td></tr><tr><td align="center">9</td><td align="center">SDT</td><td align="center">Service Description Table</td><td align="center"><strong>业务</strong>描述表</td><td align="left">包含业务数据（如业务名称、起始时间、持续时间等）</td></tr><tr><td align="center">10</td><td align="center">BAT</td><td align="center">Bouquet Association Table</td><td align="center">业务群关联表</td><td align="left">给出业务群的名称及其业务列表等信息</td></tr><tr><td align="center">11</td><td align="center">EIT</td><td align="center">Event Information Table</td><td align="center"><strong>事件</strong>信息表</td><td align="left">包含事件或节目相关数据，是生成EPG的主要表</td></tr><tr><td align="center">12</td><td align="center">RST</td><td align="center">Running Status Table</td><td align="center">运行状态表</td><td align="left">给出事件的状态（运行/非运行）</td></tr><tr><td align="center">13</td><td align="center">TDT</td><td align="center">Time&amp;Date Table</td><td align="center">时间和日期表</td><td align="left">给出当前事件和日期相关信息，更新频繁</td></tr><tr><td align="center">14</td><td align="center">TOT</td><td align="center">Time Offset Table</td><td align="center">时间偏移表</td><td align="left">给出了当前时间日期与本地时间偏移的信息</td></tr><tr><td align="center">15</td><td align="center">ST</td><td align="center">Stuffing Table</td><td align="center">填充表</td><td align="left">用于使现有的段无效，如在一个传输系统的边界</td></tr><tr><td align="center">16</td><td align="center">SIT</td><td align="center">Stuffing Information Table</td><td align="center">选择信息表</td><td align="left">仅用于码流片段中，如记录的一段码流，包含描述该码流片段业务信息段的地方</td></tr><tr><td align="center">17</td><td align="center">DIT</td><td align="center">Discontinuity Information Table</td><td align="center">间断信息表</td><td align="left">仅用于码流片段，如记录的一段码流中，它将插入到码流片段业务信息间断的地方</td></tr></tbody></table><blockquote><ul><li><code>PAT</code>,<code>PMT</code>,<code>CAT</code>,<code>NIT</code>为<strong>PSI信息</strong>,由<strong>MPEG2标准</strong>定义,NIT是由<strong>SI标准</strong>规定</li><li><code>SDT</code>,<code>BAT</code>,<code>EIT</code>,<code>RST</code>,<code>TDT</code>,<code>TOT</code>,<code>ST</code>,<code>SIT</code>,<code>DIT</code>为<strong>SI信息</strong></li></ul></blockquote><h2 id="业务-Service-与事件-Event"><a href="#业务-Service-与事件-Event" class="headerlink" title="业务(Service)与事件(Event)"></a>业务(Service)与事件(Event)</h2><p><code>业务</code>就是指“频道”，<code>事件</code>就是“节目”.</p><blockquote><p>举个例子：CCTV1是一个频道，也就是我们所说的“业务（Service）”；《新闻联播》是一个节目，也就是我们所说的“事件(Event)”。</p></blockquote><h2 id="SI信息的构成"><a href="#SI信息的构成" class="headerlink" title="SI信息的构成"></a>SI信息的构成</h2><blockquote><p>SI信息内容是按照 <code>network(网络)</code> -&gt; <code>transport strem（传输流）</code> -&gt; <code>service（业务）</code> -&gt; <code>event（事件）</code>的分层顺序描述</p></blockquote><p><img src="/images/dvb/psisi.png" alt=""></p><p>为了能有效地从众多的数据包中组织起SI信息，而使用了很多的标识。有Network_id(网络标识)、 Original_network_id(原始网络标识)、Transport_stream_id(传输流标识)、Service id(业务标识)、eventid_id(事件标识)、Bouquet_id(业务群组标识)。</p><ul><li>一个网络信息由network_id来定位。</li><li>一个TS由network_id、Original_network_id、Transport_stream_id来定位，标明这个流在那个网络播发，它原属那个网络，并给它加上标识。</li><li>一个业务由network_id、Original_network_id、Transport_stream_id、service_id来定位，标明这个业务在那个网络播发，它原属那个网络和那个流，并给它加上标识。这体现在SDT表中。</li><li>一个事件由network_id、Original_network_id、Transport_stream_id、service_id、event_id来定位，标明这个事件在那个网络播发，它原属那个网络和那个流及那个业务，并给它加上标识。这体现在EIT表中。</li></ul><h3 id="SI和SI信息的各种表的PID"><a href="#SI和SI信息的各种表的PID" class="headerlink" title="SI和SI信息的各种表的PID"></a>SI和SI信息的各种表的PID</h3><table><thead><tr><th align="center">Table</th><th align="center">PID</th></tr></thead><tbody><tr><td align="center">PAT</td><td align="center">0x0000</td></tr><tr><td align="center">CAT</td><td align="center">0x0001</td></tr><tr><td align="center">TSDT</td><td align="center">0x0002</td></tr><tr><td align="center">NIT,ST</td><td align="center">0x0010</td></tr><tr><td align="center">SDT,BAT,ST</td><td align="center">0x0011</td></tr><tr><td align="center">EIT,ST</td><td align="center">0x0012</td></tr><tr><td align="center">RST,ST</td><td align="center">0x0013</td></tr><tr><td align="center">TDT,TOT,ST</td><td align="center">0x0014</td></tr><tr><td align="center">DIT</td><td align="center">0x001E</td></tr><tr><td align="center">SIT</td><td align="center">0x001F</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DVB PSI 基础知识&lt;/p&gt;
    
    </summary>
    
      <category term="DVB" scheme="http://yoursite.com/categories/DVB/"/>
    
    
      <category term="dvb" scheme="http://yoursite.com/tags/dvb/"/>
    
      <category term="psi" scheme="http://yoursite.com/tags/psi/"/>
    
      <category term="si" scheme="http://yoursite.com/tags/si/"/>
    
  </entry>
  
  <entry>
    <title>强制删除未完全安装包</title>
    <link href="http://yoursite.com/2021/04/20/how-to-force-uninstall-package/"/>
    <id>http://yoursite.com/2021/04/20/how-to-force-uninstall-package/</id>
    <published>2021-04-20T02:56:30.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p><code>ubuntu 20.04</code> 安装 <code>touchpad-indicator.deb</code> 因为依赖问题导致安装失败，卸载时出现如下问题</p><pre><code class="shell">$ sudo apt remove touchpad-indicator/usr/sbin/deluser: The user `backup&#39; is not a member of group `input&#39;.dpkg: error processing package touchpad-indicator (--remove): installed touchpad-indicator package post-removal script subprocess returned error exit status 6$ sudo dpkg -l &quot;touchpad-indicator&quot;rH xxx xxx</code></pre><p><code>touchpad-indicator</code> 的 BUG，需要将 <code>backup</code> 加入 <code>input</code> 组，但是卸载时会将用户删除，不可行</p><p>强制卸载如下：</p><pre><code class="shell">$ sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_old/$ sudo mkdir /var/lib/dpkg/info/$ sudo apt-get update</code></pre><p>进一步可以清除 <code>info_old</code> 中 <code>touchpad-indicator.*</code> 并将 <code>info_old</code> 还原</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ubuntu 20.04&lt;/code&gt; 安装 &lt;code&gt;touchpad-indicator.deb&lt;/code&gt; 因为依赖问题导致安装失败，卸载时出现如下问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ sudo apt remove touchpad-indicator
/usr/sbin/deluser: The user `backup&amp;#39; is not a member of group `input&amp;#39;.
dpkg: error processing package touchpad-indicator (--remove):
 installed touchpad-indicator package post-removal script subprocess returned error exit status 6

$ sudo dpkg -l &amp;quot;touchpad-indicator&amp;quot;
rH xxx xxx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;touchpad-indicator&lt;/code&gt; 的 BUG，需要将 &lt;code&gt;backup&lt;/code&gt; 加入 &lt;code&gt;input&lt;/code&gt; 组，但是卸载时会将用户删除，不可行&lt;/p&gt;
&lt;p&gt;强制卸载如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_old/
$ sudo mkdir /var/lib/dpkg/info/
$ sudo apt-get update&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进一步可以清除 &lt;code&gt;info_old&lt;/code&gt; 中 &lt;code&gt;touchpad-indicator.*&lt;/code&gt; 并将 &lt;code&gt;info_old&lt;/code&gt; 还原&lt;/p&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://yoursite.com/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
      <category term="apt" scheme="http://yoursite.com/tags/apt/"/>
    
      <category term="dpkg" scheme="http://yoursite.com/tags/dpkg/"/>
    
  </entry>
  
  <entry>
    <title>jenkins-shell-echo-off</title>
    <link href="http://yoursite.com/2021/04/19/jenkins-shell-echo-off/"/>
    <id>http://yoursite.com/2021/04/19/jenkins-shell-echo-off/</id>
    <published>2021-04-19T02:24:11.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>Problem:</p><pre><code class="shell"># jenkins shell08:06:57 + export KEYPWD=secretPwd08:06:57 + KEYPWD=secretPwd</code></pre><p>原因：</p><blockquote><p>By default, Jenkins launches Execute Shell script with set -x. This causes all commands to be echoed</p></blockquote><pre><code class="shell">$ man bash    -x        Print commands and their arguments as they are executed.</code></pre><p>解决方案：</p><pre><code class="shell">#!/bin/bash +x</code></pre><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# jenkins shell
08:06:57 + export KEYPWD=secretPwd
08:06:57 + KEYPWD=secretPwd&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, Jenkins launches Execute Shell script with set -x. This causes all commands to be echoed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ man bash
    -x        Print commands and their arguments as they are executed.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;#!/bin/bash +x&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
      <category term="CI" scheme="http://yoursite.com/categories/Tools/CI/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="jenkins" scheme="http://yoursite.com/tags/jenkins/"/>
    
      <category term="ci" scheme="http://yoursite.com/tags/ci/"/>
    
  </entry>
  
  <entry>
    <title>tcp 性能优化</title>
    <link href="http://yoursite.com/2021/03/30/tcp-optimization/"/>
    <id>http://yoursite.com/2021/03/30/tcp-optimization/</id>
    <published>2021-03-30T02:32:42.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Packet Size ,Window Size and Socket Buffer In TCP</li><li>Nagel and Delayed Ack</li><li>SO_SNDBUF and SO_RCVBUF</li><li>TCP Window FULL</li><li>TCP Window ZERO</li><li>sack</li><li>BDP(bandwidth-delay product) and RTT(round trip time)</li><li>重传超时时间(RTO)</li><li>Interactive Data Flow and Bulk Data Flow</li><li>RWND and CWND</li></ul><a id="more"></a><h2 id="TCP-Window-Size"><a href="#TCP-Window-Size" class="headerlink" title="TCP Window Size"></a>TCP Window Size</h2><ul><li><code>SO_SNDBUF</code> send buffer size at the sender</li><li><code>SO_RCVBUF</code> receive buffer size at the receiver</li></ul><p>用于 TCP 握手中 TCP Window Size，影响吞吐</p><ul><li><strong>使用 wireshark tcp 时序图分析问题</strong></li><li><strong>接收窗口的大小对性能的影响，RTT 越大影响越明显</strong></li></ul><p>BDP = RTT * (Bandwidth / 8)</p><h2 id="TCP-QUICKACK"><a href="#TCP-QUICKACK" class="headerlink" title="TCP_QUICKACK"></a><code>TCP_QUICKACK</code></h2><pre><code class="shell">$ man 7 tcpTCP_QUICKACK (since Linux 2.4.4)              Enable  quickack mode if set or disable quickack mode if cleared.  In quickack mode, acks are sent immediately, rather than delayed if              needed in accordance to normal TCP operation.  This flag is not permanent, it only enables a switch to or from quickack mode.   Subse‐              quent  operation  of  the TCP protocol will once again enter/leave quickack mode depending on internal protocol processing and factors              such as delayed ack timeouts occurring and data transfer.  This option should not be used in code intended to be portable.</code></pre><p><code>TCP_QUICKACK</code> 不是永久的，需要在每次调用 recv 后重新设置</p><h2 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h2><ul><li>RWND</li><li>CWND：Congestion Window，拥塞窗口，负责控制单位时间内，数据发送端的报文发送量。TCP 协议规定，一个 RTT（Round-Trip Time，往返时延，大家常说的 ping 值）时间内，数据发送端只能发送 CWND 个数据包（注意不是字节数）。TCP 协议利用 CWND/RTT 来控制速度。这个值是根据丢包动态计算出来的</li><li>SS：Slow Start，慢启动阶段。TCP 刚开始传输的时候，速度是慢慢涨起来的，除非遇到丢包，否则速度会一直指数性增长（标准 TCP 协议的拥塞控制算法，例如 cubic 就是如此。很多其它拥塞控制算法或其它厂商可能修改过慢启动增长特性，未必符合指数特性）</li><li>CA：Congestion Avoid，拥塞避免阶段。当 TCP 数据发送方感知到有丢包后，会降低 CWND，此时速度会下降，CWND 再次增长时，不再像 SS 那样指数增，而是线性增（同理，标准 TCP 协议的拥塞控制算法，例如 cubic 是这样，很多其它拥塞控制算法或其它厂商可能修改过慢启动增长特性，未必符合这个特性）</li><li>ssthresh：Slow Start Threshold，慢启动阈值。当数据发送方感知到丢包时，会记录此时的 CWND，并计算合理的 ssthresh 值（ssthresh &lt;= 丢包时的 CWND），当 CWND 重新由小至大增长，直到 sshtresh 时，不再 SS 而是 CA。但因为数据确认超时（数据发送端始终收不到对端的接收确认报文），发送端会骤降 CWND 到最初始的状态</li><li>tcp_wmem 对应send buffer，也就是滑动窗口大小</li></ul><p><img src="/images/socket/cwnd.png" alt=""></p><p><img src="/images/socket/cwnd.jpg" alt=""></p><p>上图一旦发生丢包，cwnd降到1 ssthresh降到cwnd/2,一夜回到解放前，太保守了，实际大多情况下都是公网带宽还有空余但是链路过长，非带宽不够丢包概率增大，对此没必要这么保守（tcp诞生的背景主要针对局域网、双绞线来设计，偏保守）。RTT越大的网络环境（长肥管道）这个问题越是严重，表现就是传输速度抖动非常厉害</p><ul><li>超时重传：ssthresh降到cwnd/2 cwnd降到1</li><li>快速重传：CWND降低到一半并降低ssthresh</li></ul><h2 id="Socket-Options"><a href="#Socket-Options" class="headerlink" title="Socket Options"></a>Socket Options</h2><pre><code class="c">#include &lt;sys/socket.h&gt;int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);int setsockopt(int sockfd, int level, int optname, const void *optval socklen_t optlen);/* Both return: 0 if OK,–1 on error */</code></pre><p>参数列表</p><table class="table table-striped table-hover"><thead><tr><th><em>level</em></th><th><em>optname</em></th><th><code>get</code></th><th><code>set</code></th><th>Description</th><th>Flag</th><th>Datatype</th></tr></thead><tbody><tr><td><code>SOL_SOCKET</code></td><td><code>SO_BROADCAST</code></td><td>x</td><td>x</td><td>Permit sending of broadcast datagrams</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>SO_DEBUG</code></td><td>x</td><td>x</td><td>Enable debug tracing</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>SO_DONTROUTE</code></td><td>x</td><td>x</td><td>Bypass routing table lookup</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>SO_ERROR</code></td><td>x</td><td></td><td>Get pending error and clear</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>SO_KEEPALIVE</code></td><td>x</td><td>x</td><td>Periodically test if connection still alive</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>SO_LINGER</code></td><td>x</td><td>x</td><td>Linger on close if data to send</td><td></td><td><code>linger{}</code></td></tr><tr><td></td><td><code>SO_OOBINLINE</code></td><td>x</td><td>x</td><td>Leave received out-of-band data inline</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>SO_RCVBUF</code></td><td>x</td><td>x</td><td>Receive buffer size</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>SO_SNDBUF</code></td><td>x</td><td>x</td><td>Send buffer size</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>SO_RCVLOWAT</code></td><td>x</td><td>x</td><td>Receive buffer low-water mark</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>SO_SNDLOWAT</code></td><td>x</td><td>x</td><td>Send buffer low-water mark</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>SO_RCVTIMEO</code></td><td>x</td><td>x</td><td>Receive timeout</td><td></td><td><code>timeval{}</code></td></tr><tr><td></td><td><code>SO_SNDTIMEO</code></td><td>x</td><td>x</td><td>Send timeout</td><td></td><td><code>timeval{}</code></td></tr><tr><td></td><td><code>SO_REUSEADDR</code></td><td>x</td><td>x</td><td>Allow local address reuse</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>SO_REUSEPORT</code></td><td>x</td><td>x</td><td>Allow local port reuse</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>SO_TYPE</code></td><td>x</td><td></td><td>Get socket type</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>SO_USELOOPBACK</code></td><td>x</td><td>x</td><td>Routing socket gets copy of what it sends</td><td>x</td><td><code>int</code></td></tr><tr><td><code>IPPROTO_IP</code></td><td><code>IP_HDRINCL</code></td><td>x</td><td>x</td><td>IP header included with data</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IP_OPTIONS</code></td><td>x</td><td>x</td><td>IP header options</td><td></td><td>(see text)</td></tr><tr><td></td><td><code>IP_RECVDSTADDR</code></td><td>x</td><td>x</td><td>Return destination IP address</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IP_RECVIF</code></td><td>x</td><td>x</td><td>Return destination IP address</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IP_TOS</code></td><td>x</td><td>x</td><td>Type-of-service and precedence</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>IP_TTL</code></td><td>x</td><td>x</td><td>TTL</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>IP_MULTICAST_IF</code></td><td>x</td><td>x</td><td>Specify outgoing interface</td><td></td><td><code>in_addr{}</code></td></tr><tr><td></td><td><code>IP_MULTICAST_TTL</code></td><td>x</td><td>x</td><td>Specify outgoing TTL</td><td></td><td><code>u_char</code></td></tr><tr><td></td><td><code>IP_MULTICAST_LOOP</code></td><td>x</td><td>x</td><td>Specify loopback</td><td></td><td><code>u_char</code></td></tr><tr><td></td><td><code>IP_{ADD,DROP}_MEMBERSHIP</code></td><td></td><td>x</td><td>Join or leave multicast group</td><td></td><td><code>ip_mreq{}</code></td></tr><tr><td></td><td><code>IP_{BLOCK,UNBLOCK}_SOURCE</code></td><td></td><td>x</td><td>Block or unblock multicast source</td><td></td><td><code>ip_mreq_source{}</code></td></tr><tr><td></td><td><code>IP_{ADD,DROP}_SOURCE_MEMBERSHIP</code></td><td></td><td>x</td><td>Join or leave source-specific multicast</td><td></td><td><code>ip_mreq_source{}</code></td></tr><tr><td><code>IPPROTO_ICMPV6</code></td><td><code>ICMP6_FILTER</code></td><td>x</td><td>x</td><td>Specify ICMPv6 message types to pass</td><td></td><td><code>icmp6_filter{}</code></td></tr><tr><td><code>IPPROTO_IPV6</code></td><td><code>IPV6_CHECKSUM</code></td><td>x</td><td>x</td><td>Offset of checksum field for raw sockets</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_DONTFRAG</code></td><td>x</td><td>x</td><td>Drop instead of fragment large packets</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_NEXTHOP</code></td><td>x</td><td>x</td><td>Specify next-hop address</td><td></td><td><code>sockaddr_in6{}</code></td></tr><tr><td></td><td><code>IPV6_PATHMTU</code></td><td>x</td><td></td><td>Retrieve current path MTU</td><td></td><td><code>ip6_mtuinfo{}</code></td></tr><tr><td></td><td><code>IPV6_RECVDSTOPTS</code></td><td>x</td><td></td><td>Receive destination options</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_RECVHOPLIMIT</code></td><td>x</td><td>x</td><td>Receive unicast hop limit</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_RECVHOPOPTS</code></td><td>x</td><td>x</td><td>Receive hop-by-hop options</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_RECVPATHMTU</code></td><td>x</td><td>x</td><td>Receive path MTU</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_RECVPKTINFO</code></td><td>x</td><td>x</td><td>Receive packet information</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_RECVRTHDR</code></td><td>x</td><td>x</td><td>Receive source route</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_RECVTCLASS</code></td><td>x</td><td>x</td><td>Receive traffic class</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_UNICAT_HOPS</code></td><td>x</td><td>x</td><td>Default unicast hop limit</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_USE_MIN_MTU</code></td><td>x</td><td>x</td><td>Use minimum MTU</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_V6ONLY</code></td><td>x</td><td>x</td><td>Disable v4 compatibility</td><td>x</td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_XXX</code></td><td>x</td><td>x</td><td>Sticky ancillary data</td><td></td><td>(see text)</td></tr><tr><td></td><td><code>IPV6_MULTICAST_IF</code></td><td>x</td><td>x</td><td>Specify outgoing interface</td><td></td><td><code>u_int</code></td></tr><tr><td></td><td><code>IPV6_MULTICAST_HOPS</code></td><td>x</td><td>x</td><td>Specify outgoing hop limit</td><td></td><td><code>int</code></td></tr><tr><td></td><td><code>IPV6_MULTICAST_LOOP</code></td><td>x</td><td>x</td><td>Specify loopback</td><td>x</td><td><code>u_int</code></td></tr><tr><td></td><td><code>IPV6_JOIN_GROUP</code></td><td></td><td>x</td><td>Join multicast group</td><td></td><td><code>ipv6_mreq{}</code></td></tr><tr><td></td><td><code>IPV6_LEAVE_GROUP</code></td><td></td><td>x</td><td>Leave multicast group</td><td></td><td><code>ipv6_mreq{}</code></td></tr><tr><td><code>IPPROTO_IP</code> or <code>IPPROTO_IPV6</code></td><td><code>MCAST_JOIN_GROUP</code></td><td></td><td>x</td><td>Join multicast group</td><td></td><td><code>group_req{}</code></td></tr><tr><td></td><td><code>MCAST_LEAVE_GROUP</code></td><td></td><td>x</td><td>Leave multicast group</td><td></td><td><code>group_source_req{}</code></td></tr><tr><td></td><td><code>MCAST_BLOCK_SOURCE</code></td><td></td><td>x</td><td>Block multicast source</td><td></td><td><code>group_source_req{}</code></td></tr><tr><td></td><td><code>MCAST_UNBLOCK_SOURCE</code></td><td></td><td>x</td><td>Unblock multicast source</td><td></td><td><code>group_source_req{}</code></td></tr><tr><td></td><td><code>MCAST_JOIN_SOURCE_GROUP</code></td><td></td><td>x</td><td>Join source-specific multicast</td><td></td><td><code>group_source_req{}</code></td></tr><tr><td></td><td><code>MCAST_LEAVE_SOURCE_GROUP</code></td><td></td><td>x</td><td>Leave source-specific multicast</td><td></td><td><code>group_source_req{}</code></td></tr></tbody></table><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1383232" target="_blank" rel="noopener">长肥管道传输之痛与解决之道</a><blockquote><p>BDP RTT BBR</p></blockquote></li><li><a href="https://zhuanlan.zhihu.com/p/53169705" target="_blank" rel="noopener">我们来说一说TCP神奇的40ms</a><blockquote><p>Nagel算法 Delayed Ack机制</p></blockquote></li><li><a href="https://cloud.tencent.com/developer/article/1004356" target="_blank" rel="noopener">Linux下TCP延迟确认(Delayed Ack)机制导致的时延问题分析</a><blockquote><p><code>TCP_QUICKACK</code> Nagle算法 Delayed Ack机制 <code>/proc/sys/net/ipv4/tcpdelackmin</code></p></blockquote></li><li><a href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener"><strong>TCP性能和发送接收窗口、Buffer的关系</strong></a><blockquote><p><code>SO_SNDBUF</code> <code>SO_RCVBUF</code> <code>TCP Window Full</code> <code>TCP分析优化</code></p></blockquote></li><li><a href="https://zhuanlan.zhihu.com/p/80043707" target="_blank" rel="noopener"><strong>TCP传输慢问题分析</strong></a><blockquote><p><code>RWND</code> <code>CWND</code> <code>SACK</code> <code>TCP Window Full</code> <code>TCP zero window</code></p></blockquote></li><li><a href="https://notes.shichao.io/unp/ch7/" target="_blank" rel="noopener">Chapter 7. Socket Options</a><blockquote><p>setsockopt</p></blockquote></li><li><a href="https://plantegg.github.io/2021/01/15/TCP%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">TCP传输速度案例分析</a><blockquote><p>RTT SendBuffer RecvBuffer之间的影响 <code>window scaling factor</code> <code>Delayed Ack机制</code></p></blockquote></li><li><a href="https://plantegg.github.io/2018/06/14/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%9C%80%E7%BB%8F%E5%85%B8%E7%9A%84TCP%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">就是要你懂TCP–TCP性能问题</a><blockquote><p>Nagel算法 Delayed Ack机制</p></blockquote></li><li><a href="https://ksmeow.moe/tcp-bbr/" target="_blank" rel="noopener">BBR（瓶颈带宽和往返传播时间）拥塞控制算法</a><blockquote><p><code>CWND</code> <code>BBR</code></p></blockquote></li><li><a href="https://cloud.tencent.com/developer/article/1629739" target="_blank" rel="noopener">30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制</a></li><li><a href="https://gitbook.cn/gitchat/activity/5ede2afa28b89774245e2c0f" target="_blank" rel="noopener">提升 TCP 性能的参数，你知道几个？</a><blockquote><p>三次握手的性能提升 四次挥手的性能提升 数据传输的性能提升</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Packet Size ,Window Size and Socket Buffer In TCP&lt;/li&gt;
&lt;li&gt;Nagel and Delayed Ack&lt;/li&gt;
&lt;li&gt;SO_SNDBUF and SO_RCVBUF&lt;/li&gt;
&lt;li&gt;TCP Window FULL&lt;/li&gt;
&lt;li&gt;TCP Window ZERO&lt;/li&gt;
&lt;li&gt;sack&lt;/li&gt;
&lt;li&gt;BDP(bandwidth-delay product) and RTT(round trip time)&lt;/li&gt;
&lt;li&gt;重传超时时间(RTO)&lt;/li&gt;
&lt;li&gt;Interactive Data Flow and Bulk Data Flow&lt;/li&gt;
&lt;li&gt;RWND and CWND&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Socket" scheme="http://yoursite.com/categories/Linux/Socket/"/>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
      <category term="TCP" scheme="http://yoursite.com/categories/Network/TCP/"/>
    
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
      <category term="setsockopt" scheme="http://yoursite.com/tags/setsockopt/"/>
    
      <category term="SO_RCVBUF" scheme="http://yoursite.com/tags/SO-RCVBUF/"/>
    
      <category term="Nagel" scheme="http://yoursite.com/tags/Nagel/"/>
    
      <category term="Delayed Ack" scheme="http://yoursite.com/tags/Delayed-Ack/"/>
    
      <category term="TCP Window Size" scheme="http://yoursite.com/tags/TCP-Window-Size/"/>
    
  </entry>
  
  <entry>
    <title>tcp 选项 SO_REUSEADDR</title>
    <link href="http://yoursite.com/2021/03/29/tcp-option-SO-REUSEADDR/"/>
    <id>http://yoursite.com/2021/03/29/tcp-option-SO-REUSEADDR/</id>
    <published>2021-03-29T06:51:29.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p><code>SO_REUSEADDR</code> 用于调整解决地址复用问题</p><a id="more"></a><p>在 <code>bind()</code> 前设置 <code>SO_REUSEADDR</code>，用于将 <code>TIME_WAIT</code> 重复绑定使用</p><pre><code class="c">int yes = 1;if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) == -1) {    perror(&quot;server: socket&quot;);    continue;}if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1) {    perror(&quot;setsockopt&quot;);    exit(1);}if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {    close(sockfd);    perror(&quot;server: bind&quot;);    continue;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/pmt123456/article/details/55259728" target="_blank" rel="noopener">SO_REUSEADDR 套接字选项作用</a></li><li><a href="https://zhuanlan.zhihu.com/p/31329253" target="_blank" rel="noopener">从SO_REUSEADDR选项说起</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt; 用于调整解决地址复用问题&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Socket" scheme="http://yoursite.com/categories/Linux/Socket/"/>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
      <category term="TCP" scheme="http://yoursite.com/categories/Network/TCP/"/>
    
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
      <category term="setsockopt" scheme="http://yoursite.com/tags/setsockopt/"/>
    
      <category term="linger" scheme="http://yoursite.com/tags/linger/"/>
    
  </entry>
  
  <entry>
    <title>ssh 升级导致 git clone 失败</title>
    <link href="http://yoursite.com/2021/03/18/ssh-unable-to-negotiate/"/>
    <id>http://yoursite.com/2021/03/18/ssh-unable-to-negotiate/</id>
    <published>2021-03-18T06:23:28.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>错误信息</p><pre><code>Unable to negotiate with 192.168.110.254 port 29418: no matching key exchange method found. Their offer: diffie-hellman-group14-sha1,diffie-hellman-group1-sha1</code></pre><a id="more"></a><p><a href="https://unix.stackexchange.com/questions/402746/ssh-unable-to-negotiate-no-matching-key-exchange-method-found" target="_blank" rel="noopener">ssh unable to negotiate - no matching key exchange method found</a><br><a href="https://mycyberuniverse.com/error/no-matching-key-exchange-method-found-openssh7.html" target="_blank" rel="noopener">How to fix: No matching key exchange method found by OpenSSH 7.0</a></p><p>新老版本兼容性问题，需要增加对老旧算法支持</p><ul><li><code>~/.ssh/config</code><pre><code class="config">Host somehost.example.org  KexAlgorithms +diffie-hellman-group1-sha1</code></pre></li><li><code>/etc/ssh/ssh_config</code><pre><code class="config">Host somehost.example.org  KexAlgorithms +diffie-hellman-group1-sha1</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Unable to negotiate with 192.168.110.254 port 29418: no matching key exchange method found. Their offer: diffie-hellman-group14-sha1,diffie-hellman-group1-sha1&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://yoursite.com/categories/ubuntu/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>fork safety 以及多线程环境下注意事项</title>
    <link href="http://yoursite.com/2021/01/15/fork-safe/"/>
    <id>http://yoursite.com/2021/01/15/fork-safe/</id>
    <published>2021-01-15T02:07:57.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>多线程下进程安全及 fork 使用注意事项</p><blockquote><p>非进程安全容易导致死锁<br>未考虑 fork 时文件的处理 <code>fcntl(fd, F_SETFD, FD_CLOEXEC)</code></p></blockquote><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>Reentrant Function 可重入函数</li><li>Thread-Safe Function 线程安全函数</li><li>signal-safety - async-signal-safe functions 异步信号安全函数</li></ul><h2 id="fork-amp-fork-safety-amp-signal-safety"><a href="#fork-amp-fork-safety-amp-signal-safety" class="headerlink" title="fork &amp; fork safety &amp; signal-safety"></a>fork &amp; fork safety &amp; signal-safety</h2><pre><code class="shell">$ man fork    Note the following further points:    *  The child process is created with a single thread—the one that called fork().  The entire virtual address space of the  parent  is  repli‐        cated  in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of pthread_atfork(3) may be        helpful for dealing with problems that this can cause.    *  After a fork() in a multithreaded program, the child can safely call only async-signal-safe functions (see  signal-safety(7))  until  such        time as it calls execve(2).</code></pre><ul><li><strong>只复制了父进程中当前线程到子进程</strong>，如果父进程是多线程，那个其他线程在子进程中消失</li><li>子进程得到父进程拷贝，包括互斥锁、条件变量…，这会导致死锁，是问题的根源</li><li><strong>互斥锁，就是多线程fork大部分问题的关键部分</strong></li><li>可以使用 <code>pthread_atfork</code> 处理部分问题，例外如<strong>库函数不受控制</strong>，还需要考虑锁的顺序，在大型程序中无实用价值</li><li><code>fork</code> 后，在执行 <code>execve</code> 前，只能调用 <code>async-signal-safe functions</code>，其他函数都有风险</li></ul><p>死锁模型如下：<br><img src="/images/linux/fork-deadlock.png" alt=""></p><ul><li>T1 持有锁</li><li>T2 <code>fork</code> 后，子进程中只存在 T2 线程，获取不到锁导致死锁</li><li><code>pthread_atfork</code> 只能解决简单模型</li><li><code>fork</code> 之后，<code>execve</code> 之前，只能调用 <code>async-signal-safe functions</code></li><li><code>libc</code> 中很多函数都使用锁，而且不是 <code>async-signal-safe functions</code>，例如 <code>malloc/free</code></li><li><code>fork</code> 之后，<code>execve</code>之前，使用内存分配函数存在风险</li><li><code>execve</code> 后会重置所有进程状态，之前线程获取的锁会直接被销毁</li></ul><p>查看 <code>async-signal-safe functions</code> 列表：</p><pre><code class="shell">$ man signal-safety</code></pre><h2 id="uclibc-amp-glibc"><a href="#uclibc-amp-glibc" class="headerlink" title="uclibc &amp; glibc"></a>uclibc &amp; glibc</h2><ul><li><a href="https://wiki.strongswan.org/issues/990" target="_blank" rel="noopener">unsafe use of malloc after fork</a></li><li><code>glibc</code> 中 <code>malloc</code> 不存在问题<blockquote><p>malloc/malloc.c (malloc_atfork, free_atfork): Remove<br>Remove malloc hooks from fork handler.  They are no longer needed because malloc runs right before fork, and no malloc calls from other fork handlers are not possible anymore.</p></blockquote></li><li><code>uclibc</code> 中 <code>malloc</code> 存在问题</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><code>fork</code> 后立即调用 <code>execve</code>，两者之间只允许调用 <code>async-signal-safe functions</code></li><li>在程序启动其他线程前 <code>fork</code> 子进程，需要考虑 <code>C++</code> 静态构造函数</li><li>在多线程中避免使用 <code>fork</code>，使用 <code>pthread_create</code> 代替</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="http://timd.cn/fork-safety-and-thread-safety/" target="_blank" rel="noopener">fork-safe和thread-safe简介</a></li><li><a href="https://blog.kghost.info/2013/04/27/fork-multi-thread/" target="_blank" rel="noopener">多线程程序中使用 Fork/Exec</a></li><li><a href="https://www.cnblogs.com/liyuan989/p/4279210.html" target="_blank" rel="noopener">谨慎使用多线程中的fork</a></li><li><a href="https://www.evanjones.ca/fork-is-dangerous.html" target="_blank" rel="noopener">fork() without exec() is dangerous in large programs</a></li><li><a href="https://my.oschina.net/lowkey2046/blog/672450" target="_blank" rel="noopener">多线程程序里不准使用fork</a></li><li><a href="https://docs.oracle.com/cd/E19253-01/819-7051/6n919hpaq/index.html" target="_blank" rel="noopener">进程创建中的 fork 问题</a></li><li><a href="https://www.infoq.cn/article/bygiwi-fxhtnvsoheunw" target="_blank" rel="noopener">是时候淘汰对操作系统的 fork() 调用了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程下进程安全及 fork 使用注意事项&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非进程安全容易导致死锁&lt;br&gt;未考虑 fork 时文件的处理 &lt;code&gt;fcntl(fd, F_SETFD, FD_CLOEXEC)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Fork" scheme="http://yoursite.com/categories/Linux/Fork/"/>
    
    
      <category term="malloc" scheme="http://yoursite.com/tags/malloc/"/>
    
      <category term="fork" scheme="http://yoursite.com/tags/fork/"/>
    
      <category term="multithread" scheme="http://yoursite.com/tags/multithread/"/>
    
      <category term="fork safety" scheme="http://yoursite.com/tags/fork-safety/"/>
    
  </entry>
  
  <entry>
    <title>python 数据库</title>
    <link href="http://yoursite.com/2021/01/11/python-database/"/>
    <id>http://yoursite.com/2021/01/11/python-database/</id>
    <published>2021-01-11T11:46:28.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关系数据库和非关系数据库</li><li>python 数据库介绍</li></ul><a id="more"></a><h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><ul><li>关系数据库<ul><li>是指采用了关系模型来组织数据的数据库，常见的 MySQL 就是典型的关系数据库</li></ul></li><li>非关系数据库<ul><li>NoSQL，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。MongoDb 就是典型的 NoSQL 型数据库</li></ul></li></ul><h2 id="Python操作数据库"><a href="#Python操作数据库" class="headerlink" title="Python操作数据库"></a>Python操作数据库</h2><p>使用 <code>DB-API</code> 对接各种数据库</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;关系数据库和非关系数据库&lt;/li&gt;
&lt;li&gt;python 数据库介绍&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Database" scheme="http://yoursite.com/categories/Python/Database/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MMU 下虚拟地址向物理地址的转换</title>
    <link href="http://yoursite.com/2021/01/08/va-mmu-tlb-page-pa/"/>
    <id>http://yoursite.com/2021/01/08/va-mmu-tlb-page-pa/</id>
    <published>2021-01-08T08:18:40.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<ul><li>MMU 概念</li><li>虚拟地址转换为物理地址</li><li>Cache 概念</li></ul><a id="more"></a><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>VA 虚拟地址</li><li>PA 物理地址</li><li>MMU 内存管理单元，是<strong>硬件设备</strong>，用于完成地址映射</li><li>TLB 是 MMU 的一部分，是一块高速缓存，用于缓存页表，提高页表查询速度</li><li>页表 是内存管理系统中的数据结构，保存 VA 到 PA 的映射，位于主内存中，相对于 CPU，属于慢速设备</li><li>Cache 是<strong>硬件设备</strong>，为了解决处理器与慢速 DRAM（慢速 DRAM 即内存）设备之间巨大的速度差异</li><li>cacheline，cache 分成多个组，每个组分成多个行，linesize 是 cache 的基本单位，从主存向 cache 迁移数据都是按照 cacheline 为单位替换</li><li>page 页，一般为 4k</li></ul><p>page 是 os 的概念，而 cache 是 cpu 的概念。虚拟地址和物理地址以 page 为单位进行操作的，由两部分组成：page 地址和 page 内地址</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟地址 VA 到物理地址 PA 以页 page 为单位。通常 page 的大小为 4K。物理页面称为 page frame。<br>虚拟地址到物理地址是一个查表的过程，但可能不只一个表，是一个多级的表。虚拟地址本身分为几个部分，page 地址和 page 内地址，page 地址分为多级用于查表。这个过程称为 Translation Table Walk，由硬件完成。上述所指的表，是保存在内存上的。</p><p><img src="/images/mmu/mmu-cpu.png" alt=""></p><p>MMU 包括 TLB 和 Translation Table Walk，TLB（Translation Lookaside Buffer）是一块高速缓存，缓存最近查找过的 VA 对应的页表项。如果 TLB 中有需要查表的 VA，就不用 Translation Table Walk 了，Translation Table Walk 较慢要从内存上读表。</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache 设计：</p><ul><li>组相联</li><li>全相联</li><li>直接映射</li></ul><p>Cache 写回内存模式：</p><ul><li>Write Back</li><li>Write Through</li></ul><h2 id="VA2PA"><a href="#VA2PA" class="headerlink" title="VA2PA"></a>VA2PA</h2><p><img src="/images/mmu/va2pa.png" alt=""></p><ul><li>TLB采用组相联</li><li>页表采用两级页表</li><li>cache采用组相联，仅考虑L1 d-cache，不考虑L1 i-cache、L2 cache和L3 cache</li><li>未考虑页表缺页</li><li>简化了cache未命中情况</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.cnblogs.com/pengdonglin137/p/3362274.html" target="_blank" rel="noopener">虚拟内存，MMU/TLB，PAGE，Cache 之间关系</a></li><li><a href="https://www.polarxiong.com/archives/%E5%9B%BE%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BF%BB%E8%AF%91%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96-TLB-%E9%A1%B5%E8%A1%A8-cache.html" target="_blank" rel="noopener">图解虚拟地址到物理地址的翻译以及数据的获取（TLB，页表，cache）</a></li><li><a href="https://www.jianshu.com/p/f301857a559a" target="_blank" rel="noopener">计算机内存管理</a></li><li><a href="https://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-MMU.html" target="_blank" rel="noopener">CPU体系架构-MMU</a></li><li><a href="https://pianshen.com/article/5813880269/" target="_blank" rel="noopener">MMU和cache详解（TLB机制）</a></li><li><a href="https://zhuanlan.zhihu.com/p/37749443" target="_blank" rel="noopener">计算机缓存Cache以及Cache Line详解</a></li><li><a href="https://www.cnblogs.com/alantu2018/p/9000777.html" target="_blank" rel="noopener">TLB的作用及工作原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;MMU 概念&lt;/li&gt;
&lt;li&gt;虚拟地址转换为物理地址&lt;/li&gt;
&lt;li&gt;Cache 概念&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="MM" scheme="http://yoursite.com/categories/Linux/MM/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="cache" scheme="http://yoursite.com/tags/cache/"/>
    
      <category term="tlb" scheme="http://yoursite.com/tags/tlb/"/>
    
      <category term="page" scheme="http://yoursite.com/tags/page/"/>
    
  </entry>
  
  <entry>
    <title>Linux 缺页异常</title>
    <link href="http://yoursite.com/2021/01/06/linux-page-fault/"/>
    <id>http://yoursite.com/2021/01/06/linux-page-fault/</id>
    <published>2021-01-06T07:01:32.000Z</published>
    <updated>2022-10-12T02:40:42.978Z</updated>
    
    <content type="html"><![CDATA[<p>缺页中断以及页面调度算法</p><a id="more"></a><p>##</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/sunsky303/p/9214223.html" target="_blank" rel="noopener">深入理解【缺页中断】及FIFO、LRU、OPT这三种置换算法</a><br><a href="https://lrita.github.io/2019/03/07/linux-page-fault/" target="_blank" rel="noopener">Linux Page Fault(缺页异常)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缺页中断以及页面调度算法&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="MM" scheme="http://yoursite.com/categories/Linux/MM/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="page fault" scheme="http://yoursite.com/tags/page-fault/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存性能分析</title>
    <link href="http://yoursite.com/2021/01/06/linux-memory-performance-analysis/"/>
    <id>http://yoursite.com/2021/01/06/linux-memory-performance-analysis/</id>
    <published>2021-01-06T05:23:25.000Z</published>
    <updated>2022-10-12T02:40:42.974Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Linux 内存性能分析相关工具及参数解析</p><a id="more"></a><h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>Linux 使用虚拟内存来管理分配内存空间，为了支持虚拟内存管理，需要</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81" target="_blank" rel="noopener">分页</a></li><li><a href="https://dpatrickx.github.io/wiki/os/page/" target="_blank" rel="noopener">页面置换算法</a></li></ul><p>页面调度有不同的算法：</p><ul><li>局部页面置换算法<blockquote><p>分配给一个进程的物理页面数目确定，置换选择范围仅限于当前进程占用的物理页面</p></blockquote><ul><li>最优算法</li><li>先进先出算法 FIFO</li><li>最近最久未使用算法 LRU</li><li>时钟算法、最不常用算法 (LRU的近似)</li></ul></li><li>全局页面置换算法<blockquote><p>置换页面的选择范围是所有可换出的物理页面</p></blockquote><ul><li>工作集算法</li><li>缺页率算法</li></ul></li></ul><p>当出现大量页缺失时会造成 <a href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81#%E7%B3%BB%E7%B5%B1%E9%A1%9B%E7%B0%B8" target="_blank" rel="noopener">系统颠簸</a>，<strong>系统效能会急剧下降</strong></p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>读取 <code>/proc/meminfo</code> 文件中信息，显示内存相关信息</p><pre><code class="shell">$ free             total       used       free     shared    buffers     cachedMem:         63444      38012      25432          4       4780      12312-/+ buffers/cache:      20920      42524Swap:            0          0          0</code></pre><p>内存使用常见问题：</p><ul><li>free 内存少<br>  和 Linux 内存使用设计有关，会尽量提高内存使用率，经常会把磁盘上的内容缓存到内存，用来加速。当内存不足时会释放缓存部分，让给真正需要的程序使用</li><li>buffer / cached<ul><li>buffer 缓存的是磁盘文件的元数据，例如文件属性、目录结构等</li><li>cached 缓存的是真正的文件内容</li></ul></li><li><strong>判断内存真正不足</strong><ul><li>持续的内存换入换出</li><li>较多的主缺页中断<blockquote><p>次缺页中断，是在内存中可以找到目标页<br>主缺页中断，是在内存中找不到，需要到磁盘中找</p></blockquote></li></ul></li></ul><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>显示进程，内存，分页，IO，中断，CPU活动的信息</p><pre><code class="shell">$ vmstat 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 1  0      0 1108572   2356 1506880    0    0    92    13  148  654  3  1 95  1  0</code></pre><ul><li>Procs（进程）：<ul><li>r: 运行队列中进程数量</li><li>b: 等待IO的进程数量</li></ul></li><li>Memory（内存）：<ul><li>swpd: 使用虚拟内存大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器</li><li>free: 可用内存大小</li><li>buff: 用作缓冲的内存大小</li><li>cache: 用作缓存的内存大小</li></ul></li><li>Swap：<ul><li>si: 每秒从磁盘写到虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉</li><li>so: 每秒写入磁盘的虚拟内存大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉</li></ul></li><li>IO：<ul><li>bi: 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte</li><li>bo: 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整</li></ul></li><li>系统：<ul><li>in: 每秒中断数，包括时钟中断</li><li>cs: 每秒上下文切换数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的</li></ul></li><li>CPU（以百分比表示）：<ul><li>us: 用户进程执行时间,us的值比较高时，说明用户进程消耗的CPU时间多，如果长期大于50%，需要考虑优化程序</li><li>sy: 系统进程执行时间,sy的值比较高时，就说明内核消耗的CPU时间多；如果us+sy超过80%，就说明CPU的资源存在不足</li><li>id: 空闲时间(包括IO等待时间)</li><li>wa: 等待IO时间,wa值越高，说明IO等待越严重。如果wa值超过20%，说明IO等待严重</li></ul></li></ul><h3 id="重点关注指标"><a href="#重点关注指标" class="headerlink" title="重点关注指标"></a><strong>重点关注指标</strong></h3><ul><li>r 运行的进程比较多，系统繁忙</li><li>bo 磁盘写的数据量大</li><li>us 持续大于50，服务器高峰可以接受</li><li>wa IO等待，持续大于30，说明IO等待严重</li><li>id 持续小于50，服务器高峰可以接受</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://www.jianshu.com/p/41504e93103c" target="_blank" rel="noopener">Linux性能分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 Linux 内存性能分析相关工具及参数解析&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="MM" scheme="http://yoursite.com/categories/Linux/MM/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="top" scheme="http://yoursite.com/tags/top/"/>
    
      <category term="mm" scheme="http://yoursite.com/tags/mm/"/>
    
      <category term="free" scheme="http://yoursite.com/tags/free/"/>
    
      <category term="meminfo" scheme="http://yoursite.com/tags/meminfo/"/>
    
      <category term="vmstat" scheme="http://yoursite.com/tags/vmstat/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel vm pagecache 配置优化项</title>
    <link href="http://yoursite.com/2020/12/28/linux-kernel-sysctl-vm-pagecache/"/>
    <id>http://yoursite.com/2020/12/28/linux-kernel-sysctl-vm-pagecache/</id>
    <published>2020-12-28T04:58:24.000Z</published>
    <updated>2022-10-12T02:40:42.974Z</updated>
    
    <content type="html"><![CDATA[<p>通过配置优化文件读写性能</p><a id="more"></a><h2 id="dirty-background-bytes-amp-dirty-background-ratio"><a href="#dirty-background-bytes-amp-dirty-background-ratio" class="headerlink" title="dirty_background_bytes &amp; dirty_background_ratio"></a>dirty_background_bytes &amp; dirty_background_ratio</h2><ol><li>当系统脏页的比例超过 <code>dirty_background_ratio</code> 或者所占内存数量超过 <code>dirty_background_bytes</code> 设定的阈值时，启动相关内核线程 <code>pdflush/flush/kdmflush</code> 开始将脏页写入磁盘。</li><li>如果该值过大，同时又有进程大量未使用 <code>DIRECT_IO</code> 写磁盘时，会使 pagecache 占用对应比例的系统内存</li><li>两个参数是相对的，只能指定其中一个。当其中一个参数文件被写入时，会立即开始计算脏页限制，并且会将另一个参数的值清零</li><li>是内存可以填充脏数据的百分比</li></ol><pre><code class="shell"># 字节vm.dirty_background_bytes = 0# 百分比vm.dirty_background_ratio = 10</code></pre><h2 id="dirty-bytes-amp-dirty-ratio"><a href="#dirty-bytes-amp-dirty-ratio" class="headerlink" title="dirty_bytes &amp; dirty_ratio"></a>dirty_bytes &amp; dirty_ratio</h2><ol><li>当系统脏页达到系统内存 <code>dirty_bytes</code> / <code>dirty_ratio</code> 阈值时，系统就会阻塞新的写请求，直到脏页被回写到磁盘</li><li>此值过低时，遇到写入突增时，会造成短时间内 pagecache 脏页快速上升，造成写请求耗时增加</li><li>当该值太高时，会造成内核 flush 脏页时，超过内核限制的 120s 导致进程挂起或中断</li><li>两个参数是相对的，只能指定其中一个。当其中一个参数文件被写入时，会立即开始计算脏页限制，并且会将另一个参数的值清零</li><li>是可以用脏数据填充的绝对最大系统内存量</li><li>是保证内存中不会存在过量脏数据的保护机制</li></ol><pre><code class="shell">vm.dirty_bytes = 0vm.dirty_ratio = 20</code></pre><h2 id="dirty-expire-centisecs"><a href="#dirty-expire-centisecs" class="headerlink" title="dirty_expire_centisecs"></a>dirty_expire_centisecs</h2><ol><li>指定脏数据能存活的时间。在这里它的值是 30 秒。当 <code>pdflush/flush/kdmflush</code> 在运行的时候，他们会检查是否有数据超过这个时限，如果有则会把它异步地写到磁盘中</li><li>当该值太小时，会造成 IO 提高过多</li></ol><pre><code class="shell"># 1/100svm.dirty_expire_centisecs = 3000</code></pre><h2 id="dirty-writeback-centisecs"><a href="#dirty-writeback-centisecs" class="headerlink" title="dirty_writeback_centisecs"></a>dirty_writeback_centisecs</h2><ol><li>指定多长时间 <code>pdflush/flush/kdmflush</code> 这些进程会唤醒一次，然后检查是否有缓存需要清理</li><li>如果设置为 0，则禁止周期性地唤醒回写线程</li></ol><pre><code class="shell"># 1/100svm.dirty_writeback_centisecs = 100</code></pre><h2 id="vfs-cache-pressure"><a href="#vfs-cache-pressure" class="headerlink" title="vfs_cache_pressure"></a>vfs_cache_pressure</h2><h2 id="drop-caches"><a href="#drop-caches" class="headerlink" title="drop_caches"></a>drop_caches</h2><h2 id="查看相关信息"><a href="#查看相关信息" class="headerlink" title="查看相关信息"></a>查看相关信息</h2><ul><li>sysctl<pre><code class="shell">$ sysctl -a | grep dirtyvm.dirty_background_bytes = 0vm.dirty_background_ratio = 10vm.dirty_bytes = 0vm.dirty_expire_centisecs = 3000vm.dirty_ratio = 20vm.dirty_writeback_centisecs = 500vm.dirtytime_expire_seconds = 43200</code></pre></li><li>vmstat<pre><code class="shell">$ cat /proc/vmstat | egrep &quot;dirty|writeback&quot;nr_dirty 103nr_writeback 0nr_writeback_temp 0nr_dirty_threshold 83638nr_dirty_background_threshold 41768</code></pre></li></ul><h2 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h2><h3 id="减少缓存"><a href="#减少缓存" class="headerlink" title="减少缓存"></a>减少缓存</h3><p>快速的磁盘子系统，减少数据丢失风险</p><pre><code class="shell">vm.dirty_background_ratio = 5vm.dirty_ratio = 10</code></pre><h3 id="增加缓存"><a href="#增加缓存" class="headerlink" title="增加缓存"></a>增加缓存</h3><p>数据不是关键的，可丢失，允许存在更多的脏页</p><pre><code class="shell">vm.dirty_background_ratio = 50vm.dirty_ratio = 80</code></pre><h3 id="增减都用"><a href="#增减都用" class="headerlink" title="增减都用"></a>增减都用</h3><p>应对突发数据高峰，允许大量 IO 存储在缓存中，后台慢慢异步刷新</p><pre><code class="shell">vm.dirty_background_ratio = 5vm.dirty_ratio = 80</code></pre><p>系统后台进程在脏数据达到 5% 时就开始异步清理，但在 80% 之前系统不会强制同步写磁盘</p><h2 id="IO-调度"><a href="#IO-调度" class="headerlink" title="IO 调度"></a>IO 调度</h2><p><a href="https://www.cnblogs.com/276815076/p/5687814.html" target="_blank" rel="noopener">linux I/O优化 磁盘读写参数设置</a></p><ul><li><code>/sys/block/sdX/queue/scheduler</code></li><li><code>/sys/block/sdX/queue/nr_requests</code></li><li><code>/sys/block/sdX/queue/read_ahead_kb</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过配置优化文件读写性能&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="MM" scheme="http://yoursite.com/categories/Linux/MM/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="proc" scheme="http://yoursite.com/tags/proc/"/>
    
      <category term="sysctl" scheme="http://yoursite.com/tags/sysctl/"/>
    
      <category term="pagecache" scheme="http://yoursite.com/tags/pagecache/"/>
    
  </entry>
  
  <entry>
    <title>802.11 帧结构及协议分析</title>
    <link href="http://yoursite.com/2020/12/24/802-11-wlan-packets-and-protocols/"/>
    <id>http://yoursite.com/2020/12/24/802-11-wlan-packets-and-protocols/</id>
    <published>2020-12-24T06:39:41.000Z</published>
    <updated>2022-10-12T02:40:42.974Z</updated>
    
    <content type="html"><![CDATA[<p>802.11 WLAN 数据结构及协议</p><a id="more"></a><h2 id="802-11-WLAN"><a href="#802-11-WLAN" class="headerlink" title="802.11 WLAN"></a>802.11 WLAN</h2><p><img src="/images/wifi/osi_network_model.gif" alt="OSI Network Model"></p><p>从上面的结构图中可以看出，802.11 帧携带 MAC Header</p><p><img src="/images/wifi/802.11_packets.gif" alt="OSI Network Model"></p><p>802.11 物理层 PHY 是介质访问控制层 MAC 与无线介质之间的接口，它传输和接收共享无线介质上的数据帧。802.11 将 PHY 进一步划分为两个组成元件：</p><ol><li>PLCP(Physical Layer ConvergenceProcedure)：物理层收敛程序，负责将MAC帧对映到传输介质</li><li>PMD(Physical Medium Dependent)：实际搭配介质，负责传送这些帧</li></ol><p>MSDU（MAC层业务数据单元。这是最原始的待发数据信息）经过封装变成MPDU（MAC层协议数据单元），MPDU传到PLCP子层变成PSDU（PLCP子层业务数据单元），PSUD经过封装变成PPDU（PLCP子层协议数据单元）</p><p><img src="/images/wifi/80211-packet.gif" alt="802.11 packet structure"></p><p><strong>硬件前导码不会被捕获</strong></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://www.cnblogs.com/shangdawei/p/3496736.html" target="_blank" rel="noopener">TCP/IP协议栈与数据报封装</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;802.11 WLAN 数据结构及协议&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="802.11" scheme="http://yoursite.com/categories/Linux/802-11/"/>
    
    
      <category term="802.11" scheme="http://yoursite.com/tags/802-11/"/>
    
      <category term="SNAP" scheme="http://yoursite.com/tags/SNAP/"/>
    
      <category term="LLC" scheme="http://yoursite.com/tags/LLC/"/>
    
      <category term="MAC" scheme="http://yoursite.com/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>编辑工具链头文件和库的搜索路径</title>
    <link href="http://yoursite.com/2020/12/01/how-to-get-search-dirs-for-toolchain/"/>
    <id>http://yoursite.com/2020/12/01/how-to-get-search-dirs-for-toolchain/</id>
    <published>2020-12-01T05:12:29.000Z</published>
    <updated>2022-10-12T02:40:42.974Z</updated>
    
    <content type="html"><![CDATA[<p>获取编译工具链默认头文件和库的搜索路径</p><a id="more"></a><ul><li>I<pre><code class="shell">$ echo &#39;main(){}&#39; | gcc -E -v -</code></pre></li><li>II<pre><code class="shell">$ gcc -print-search-dirs</code></pre></li><li>III 查看 specs<pre><code class="shell">$ gcc -v</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;获取编译工具链默认头文件和库的搜索路径&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="GCC" scheme="http://yoursite.com/categories/C/GCC/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
  </entry>
  
</feed>
